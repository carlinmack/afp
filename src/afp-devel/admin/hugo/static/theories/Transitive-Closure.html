<div id="Transitive_Closure_Impl">
<div class="head">
<h1>Theory Transitive_Closure_Impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Executable Transitive Closures of Finite Relations
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
                 René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹A Generic Work-List Algorithm›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Transitive_Closure_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Let <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> be some finite relation. We start to present a standard work-list algorithm to
  compute all elements that are reachable from some initial set by at most <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>-steps. Then, we obtain algorithms for the (reflexive) transitive closure from a given starting
  set by exploiting the fact that for finite relations we have to iterate at most <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"card <span class="free"><span class="free">R</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  times. The presented algorithms are generic in the sense that the underlying data structure can
  freely be chosen, you just have to provide certain operations like union, membership, etc.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Bounded Reachability›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide an algorithm <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>relpow_impl›</span></span></span></span> that computes all states that are reachable from an
  initial set of states <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by at most <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> steps. The algorithm also stores a set of
  states that have already been visited <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">have</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and then show, do not have to be expanded a
  second time. The algorithm is parametric in the underlying data structure, it just requires
  operations for union and membership as well as a function to compute the successors of a list.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span>
  <span class="entity">relpow_impl</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">relpow_impl</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="free"><span class="bound"><span class="entity">new</span></span></span> <span class="free"><span class="bound"><span class="entity">have</span></span></span> <span class="main">0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">new</span></span></span> <span class="free"><span class="bound"><span class="entity">have</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">relpow_impl</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="free"><span class="bound"><span class="entity">new</span></span></span> <span class="free"><span class="bound"><span class="entity">have</span></span></span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">new</span></span></span> <span class="main">=</span> <span class="main">[]</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">have</span></span></span>
    <span class="keyword1">else</span>
      <span class="keyword1">let</span>
        <span class="bound">maybe</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">new</span></span></span><span class="main">;</span>
        <span class="bound">have'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">new</span></span></span> <span class="free"><span class="bound"><span class="entity">have</span></span></span><span class="main">;</span>
        <span class="bound">new'</span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="bound">n</span> <span class="bound">have'</span><span class="main">)</span> <span class="bound">maybe</span>
      <span class="keyword1">in</span> <span class="free">relpow_impl</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="bound">new'</span> <span class="bound">have'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We need to know that the provided operations behave correctly.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> set_access <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">un</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">set_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">memb</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'b</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="main">(</span><span class="free">un</span> <span class="free">as</span> <span class="free">bs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">as</span> <span class="main">∪</span> <span class="free">set_of</span> <span class="free">bs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> memb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">memb</span> <span class="free">a</span> <span class="free">bs</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">∈</span> <span class="free">set_of</span> <span class="free">bs</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="free">empty</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> set_access_succ <span class="main">=</span> set_access <span class="quoted"><span class="free">un</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">un</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span>  <span class="free">rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> succ<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">succ</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">relpow_i</span> <span class="main">≡</span> relpow_impl <span class="free">succ</span> <span class="free">un</span> <span class="free">memb</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  What follows is the main technical result of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> relpow_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> algorithm: what it computes
  for arbitrary values of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">new</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">have</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1" id="Transitive_Closure_Impl-relpow_impl_main"><span class="command">lemma</span></span> relpow_impl_main<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="main">(</span>relpow_i <span class="free">new</span> <span class="free">have</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> 
    <span class="main">{</span><span class="bound">b</span> <span class="main">|</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">new</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">rel</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="free">set_of</span> <span class="free">have</span><span class="main">}</span><span class="main">)</span> <span class="main">^^</span> <span class="bound">m</span><span class="main">}</span> <span class="main">∪</span>
    <span class="free">set_of</span> <span class="free">have</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="free">new</span> <span class="free">have</span> <span class="free">n</span> <span class="main">=</span> <span class="var">?r</span> <span class="free">new</span> <span class="free">have</span> <span class="free">n</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"<span class="free">have</span>"</span></span> <span class="quoted"><span class="free">new</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span> <span class="skolem">hhave</span> <span class="skolem">nnew</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">nnew</span> <span class="main">=</span> <span class="main">[]</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?have</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="skolem">hhave</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?new</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"set <span class="skolem">nnew</span>"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted">"<span class="skolem"><span class="skolem">have</span></span>"</span> <span class="skolem"><span class="skolem">new</span></span> <span class="keyword2"><span class="keyword">where</span></span> hav<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">have</span> <span class="main">=</span> <span class="var">?have</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">new</span> <span class="main">=</span> <span class="var">?new</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?reln</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">m</span><span class="main">.</span> <span class="main">(</span><span class="free">rel</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="skolem">new</span> <span class="main">∧</span> <span class="bound">b</span> <span class="main">∉</span> <span class="skolem">have</span><span class="main">}</span><span class="main">)</span> <span class="main">^^</span>  <span class="bound">m</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rel</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">m</span><span class="main">.</span> <span class="main">(</span><span class="free">rel</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="skolem">have</span><span class="main">}</span><span class="main">)</span> <span class="main">^^</span>  <span class="bound">m</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> idl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="skolem">nnew</span> <span class="skolem">hhave</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> 
      <span class="main">{</span><span class="bound">uu</span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">aa</span><span class="main">∈</span> <span class="skolem">new</span><span class="main">.</span> <span class="main">(</span><span class="bound">aa</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">new</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">∉</span> <span class="skolem">have</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">m</span></span> <span class="main">≤</span> <span class="skolem">n</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">uu</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?reln</span> <span class="bound">m</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span>
      <span class="main">(</span><span class="skolem">new</span> <span class="main">∪</span> <span class="skolem">have</span><span class="main">)</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?l1</span> <span class="main">∪</span> <span class="main">(</span><span class="var">?l2</span> <span class="main">∪</span> <span class="var">?l3</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hav new False Let_def Suc<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memb un succ<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?l1</span> <span class="main">∪</span> <span class="main">(</span><span class="var">?l2</span> <span class="main">∪</span> <span class="var">?l3</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> idr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="skolem">nnew</span> <span class="skolem">hhave</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="skolem">new</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">≤</span> Suc <span class="skolem">n</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="bound">m</span><span class="main">}</span> <span class="main">∪</span> <span class="skolem">have</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="main">(</span><span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hav new<span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span>      
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">new</span> <span class="main">∨</span> <span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">have</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">have</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">new</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r1</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> CollectI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">0</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> b<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> b <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?l1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a2</span></span> <span class="skolem"><span class="skolem">a1</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> a2n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a2</span> <span class="main">∉</span> <span class="skolem">new</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> a2h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a2</span> <span class="main">∉</span> <span class="skolem">have</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a1</span> <span class="main">∈</span> <span class="skolem">new</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> a1a2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a1</span><span class="main">,</span><span class="skolem">a2</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> a2b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a2</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?reln</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r1</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> CollectI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"Suc <span class="skolem"><span class="skolem"><span class="skolem">m</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> a1<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> relpow_Suc_I2<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> a1a2<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a2h<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> a2b<span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a2</span></span> <span class="quoted"><span class="skolem">b</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>     
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> 
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="skolem">have</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> b <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">new</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> seq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> <span class="skolem">new</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="skolem">m</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> a  ab <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="keyword2"><span class="keyword">where</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">m</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> <span class="skolem">new</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> least<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> <span class="skolem">new</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> l<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> LeastI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> lm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Least_le<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> seq<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> m <span class="keyword1"><span class="command">have</span></span> ln<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> Suc <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> least <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> <span class="skolem">new</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> ab <span class="main">[</span><span class="operator">unfolded</span> relpow_fun_conv<span class="main">]</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> fa<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">0</span> <span class="main">=</span> <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">l</span>"</span></span>
          <span class="keyword2"><span class="keyword">and</span></span> steps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">l</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
          <span class="keyword3"><span class="command">assume</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span>
          <span class="keyword1"><span class="command">have</span></span> main<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">new</span>"</span></span> 
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">new</span>"</span></span>
            <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="main">+</span> <span class="bound">j</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">have</span></span> seq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="main">(</span><span class="skolem">l</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">unfolding</span></span> relpow_fun_conv
            <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var">?f</span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI allI impI<span class="main">)</span>
              <span class="keyword1"><span class="command">from</span></span> i <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">l</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span>
                <span class="keyword1"><span class="command">unfolding</span></span> fb <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">next</span></span>
              <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
              <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">l</span> <span class="main">-</span> Suc <span class="skolem">i</span>"</span></span>
              <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> small<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">+</span> <span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?f</span> <span class="skolem">j</span><span class="main">,</span> <span class="var">?f</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">b</span> <span class="main">∉</span> <span class="skolem">have</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> steps <span class="main">[</span><span class="operator">OF</span> small<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">from</span></span> i <span class="keyword1"><span class="command">have</span></span> small<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">-</span> Suc <span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> seq new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> <span class="skolem">new</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?rel</span> <span class="main">(</span><span class="skolem">l</span> <span class="main">-</span> Suc <span class="skolem">i</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> not_less_Least <span class="main">[</span><span class="operator">OF</span> small <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> l<span class="main"><span class="main">]</span></span><span class="main">]</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> l <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">f</span> <span class="skolem">i</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?reln</span> <span class="main">1</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> steps <span class="main">[</span><span class="operator">OF</span> i<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> steps <span class="main">=</span> this
        <span class="keyword1"><span class="command">have</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?reln</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> relpow_fun_conv
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> fa fb steps<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?l1</span> <span class="main">∪</span> <span class="var">?l2</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> 0
          <span class="keyword1"><span class="command">with</span></span> ab a <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">ll</span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> relpow_Suc_D2 <span class="main">[</span><span class="operator">OF</span> ab <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> Suc<span class="main"><span class="main">]</span></span><span class="main">]</span> a ln Suc 
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> idl idr <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> un<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  From the previous lemma we can directly derive that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> relpow_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> works correctly if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">have</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is initially set to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>empty›</span></span></span></span>
›</span></span>
<span class="keyword1" id="Transitive_Closure_Impl-relpow_impl"><span class="command">lemma</span></span> relpow_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="main">(</span>relpow_i <span class="free">new</span> <span class="free">empty</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span> <span class="main">|</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">new</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">rel</span> <span class="main">^^</span> <span class="bound">m</span><span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rel</span> <span class="main">∩</span> <span class="main">{</span><span class="main">(</span><span class="bound">a</span> <span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> True<span class="main">}</span> <span class="main">=</span> <span class="free">rel</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> relpow_impl_main empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> id<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reflexive Transitive Closure and Transitive closure›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> relpow_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> it is now easy to obtain algorithms for the reflexive transitive
  closure and the transitive closure by restricting the number of steps to the size of the finite
  relation. Note that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> relpow_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> will abort the computation as soon as no new states are
  detected. Hence, there is no penalty in using this large bound.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">rtrancl_impl</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rtrancl_impl</span> <span class="free"><span class="bound"><span class="entity">gen_succ</span></span></span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="free"><span class="bound"><span class="entity">emp</span></span></span> <span class="free"><span class="bound"><span class="entity">rel</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">succ</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">gen_succ</span></span></span> <span class="free"><span class="bound"><span class="entity">rel</span></span></span><span class="main">;</span>
      <span class="bound">n</span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">rel</span></span></span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">as</span><span class="main">.</span> relpow_impl <span class="bound">succ</span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="bound">as</span> <span class="free"><span class="bound"><span class="entity">emp</span></span></span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">trancl_impl</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span> <span class="main">⇒</span>
      <span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trancl_impl</span> <span class="free"><span class="bound"><span class="entity">gen_succ</span></span></span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="free"><span class="bound"><span class="entity">emp</span></span></span> <span class="free"><span class="bound"><span class="entity">rel</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">succ</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">gen_succ</span></span></span> <span class="free"><span class="bound"><span class="entity">rel</span></span></span><span class="main">;</span>
      <span class="bound">n</span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">rel</span></span></span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">as</span><span class="main">.</span> relpow_impl <span class="bound">succ</span> <span class="free"><span class="bound"><span class="entity">un</span></span></span> <span class="free"><span class="bound"><span class="entity">memb</span></span></span> <span class="main">(</span><span class="bound">succ</span> <span class="bound">as</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">emp</span></span></span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The soundness of both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> rtrancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> trancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> follows from the soundness of
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> relpow_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> and the fact that for finite relations, we can limit the number of steps to
  explore all elements in the reflexive transitive closure.
›</span></span>

<span class="keyword1" id="Transitive_Closure_Impl-rtrancl_finite_relpow"><span class="command">lemma</span></span> rtrancl_finite_relpow<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">rel</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound"><span class="bound">n</span></span> <span class="main">≤</span> length <span class="free">rel</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rtrancl_power <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span>
  <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> rtrancl_power<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span> <span class="main">^^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="keyword2"><span class="keyword">where</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span> <span class="main">^^</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> LeastI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ab<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> relpow_fun_conv<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">0</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="skolem">l</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> steps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">l</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?hits</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="skolem">l</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> steps <span class="keyword1"><span class="command">have</span></span> subset<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="var">?hits</span> <span class="main">⊆</span> snd <span class="main">`</span> set <span class="free">rel</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> length <span class="free">rel</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"distinct <span class="var">?hits</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> length <span class="var">?hits</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> card <span class="main">(</span>set <span class="var">?hits</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> distinct_card <span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> card <span class="main">(</span>snd <span class="main">`</span> set <span class="free">rel</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> card_mono <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subset<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> card <span class="main">(</span>set <span class="main">(</span>map snd <span class="free">rel</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> length <span class="main">(</span>map snd <span class="free">rel</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> card_length<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span>  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> distinct_conv_nth<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?i</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"min <span class="skolem">i</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?j</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"max <span class="skolem">i</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?i</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?j</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="var">?i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="var">?j</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?i</span> <span class="main">&lt;</span> <span class="var">?j</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> i j ij fij <span class="keyword1"><span class="command">unfolding</span></span> min_def max_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> i j fij ij <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">≤</span> <span class="skolem">i</span> <span class="keyword1">then</span> <span class="skolem">f</span> <span class="bound">n</span> <span class="keyword1">else</span> <span class="skolem">f</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> abl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span> <span class="main">^^</span> <span class="var">?l</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> relpow_fun_conv
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var">?g</span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI impI allI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?g</span> <span class="var">?l</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> b <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> j ij <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
      <span class="keyword3"><span class="command">assume</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> <span class="var">?l</span>"</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?g</span> <span class="skolem">k</span><span class="main">,</span> <span class="var">?g</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> <span class="skolem">i</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> i <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> steps <span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> ik<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> ij fij steps <span class="main">[</span><span class="operator">OF</span> i<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> ik <span class="keyword1"><span class="command">have</span></span> ik<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> small<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> k <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> steps<span class="main">[</span><span class="operator">OF</span> small<span class="main">]</span> ik <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> ij i <span class="keyword1"><span class="command">have</span></span> ll<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">&lt;</span> <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> <span class="var">?l</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> l
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Least_le<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> abl <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> l<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> ll <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> ab <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">locale</span></span> set_access_gen <span class="main">=</span> set_access <span class="quoted"><span class="free">un</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">un</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">gen_succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> gen_succ<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">gen_succ</span> <span class="free">rel</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">rel</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">rtrancl_i</span> <span class="main">≡</span> rtrancl_impl <span class="free">gen_succ</span> <span class="free">un</span> <span class="free">memb</span> <span class="free">empty</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">trancl_i</span> <span class="main">≡</span> trancl_impl <span class="free">gen_succ</span> <span class="free">un</span> <span class="free">memb</span> <span class="free">empty</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_Impl-rtrancl_impl"><span class="command">lemma</span></span> rtrancl_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="main">(</span>rtrancl_i <span class="free">rel</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">rel</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> set_access_succ <span class="quoted"><span class="free">set_of</span></span> <span class="quoted"><span class="free">memb</span></span> <span class="quoted"><span class="free">empty</span></span> <span class="quoted"><span class="free">un</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_succ</span> <span class="free">rel</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">rel</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> gen_succ<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> rtrancl_impl_def Let_def relpow_impl
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_finite_relpow<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Transitive_Closure_Impl-trancl_impl"><span class="command">lemma</span></span> trancl_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">set_of</span> <span class="main">(</span>trancl_i <span class="free">rel</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">rel</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> set_access_succ <span class="quoted"><span class="free">set_of</span></span> <span class="quoted"><span class="free">memb</span></span> <span class="quoted"><span class="free">empty</span></span> <span class="quoted"><span class="free">un</span></span> <span class="quoted"><span class="quoted">"<span class="free">gen_succ</span> <span class="free">rel</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">rel</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> gen_succ<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> trancl_impl_def Let_def relpow_impl trancl_unfold_left relcomp_unfold rtrancl_finite_relpow succ <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Transitive_Closure_List_Impl">
<div class="head">
<h1>Theory Transitive_Closure_List_Impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Executable Transitive Closures of Finite Relations
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
                 René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Closure Computation using Lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Transitive_Closure_List_Impl
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Transitive_Closure_Impl.html">Transitive_Closure_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide two algorithms for the computation of the reflexive transitive closure which internally
  work on lists. The first one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rtrancl_list_impl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) computes the closure on demand for a
  given set of initial states. The second one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">memo_list_rtrancl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) precomputes the closure
  for each individual state, stores the result, and then only does a look-up.
  
  For the transitive closure there are the corresponding algorithms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">trancl_list_impl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">memo_list_trancl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Computing Closures from Sets On-The-Fly›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The algorithms are based on the generic algorithms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> rtrancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> trancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  instantiated by list operations. Here, after computing the successors in a straightforward way,
  we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> remdups<span class="antiquote"><span class="antiquote">}</span></span></span></span> to not have duplicates in the results. Moreover, also in the union
  operation we filter to those elements that have not yet been seen. The use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> filter<span class="antiquote"><span class="antiquote">}</span></span></span></span> in
  the union operation is preferred over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> remdups<span class="antiquote"><span class="antiquote">}</span></span></span></span> since by construction the latter set will
  not contain duplicates.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rtrancl_list_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rtrancl_list_impl</span> <span class="main">=</span> rtrancl_impl
    <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span> <span class="bound">as</span><span class="main">.</span> remdups <span class="main">(</span>map snd <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="bound">as</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="bound">ys</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">@</span> <span class="bound">ys</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">)</span>
    <span class="main">[]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">trancl_list_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trancl_list_impl</span> <span class="main">=</span> trancl_impl
    <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span> <span class="bound">as</span><span class="main">.</span> remdups <span class="main">(</span>map snd <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="bound">as</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">xs</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> set <span class="bound">ys</span><span class="main">)</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">@</span> <span class="bound">ys</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set <span class="bound">xs</span><span class="main">)</span>
    <span class="main">[]</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_List_Impl-rtrancl_list_impl"><span class="command">lemma</span></span> rtrancl_list_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>rtrancl_list_impl <span class="free">r</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rtrancl_list_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> set_access_gen.rtrancl_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword1" id="Transitive_Closure_List_Impl-trancl_list_impl"><span class="command">lemma</span></span> trancl_list_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>trancl_list_impl <span class="free">r</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> trancl_list_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> set_access_gen.trancl_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precomputing Closures for Single States›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Storing all relevant entries is done by mapping all left-hand sides of the relation to their
  closure. To avoid redundant entries, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> remdups<span class="antiquote"><span class="antiquote">}</span></span></span></span> is used.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">memo_list_rtrancl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">memo_list_rtrancl</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">tr</span> <span class="main">=</span> rtrancl_list_impl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
      <span class="bound">rm</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">tr</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>remdups <span class="main">∘</span> map fst<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="keyword1">case</span> map_of <span class="bound">rm</span> <span class="bound">a</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span>
      <span class="main">|</span> Some <span class="bound">as</span> <span class="main">⇒</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_List_Impl-memo_list_rtrancl"><span class="command">lemma</span></span> memo_list_rtrancl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>memo_list_rtrancl <span class="free">r</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> rtrancl_list_impl <span class="free">r</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>remdups <span class="main">∘</span> map fst<span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"map_of <span class="var">?rm</span> <span class="free">a</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None
    <span class="keyword1"><span class="command">have</span></span> one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> memo_list_rtrancl_def Let_def None
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> None <span class="main">[</span><span class="operator">unfolded</span> map_of_eq_None_iff<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> rtrancl_power relpow_fun_conv<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">0</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∧</span> <span class="skolem">f</span> <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> steps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">n</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> ab steps <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">as</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">as</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main">^*</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> map_of_SomeD <span class="main">[</span><span class="operator">OF</span> Some<span class="main">]</span>
        rtrancl_list_impl <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> memo_list_rtrancl_def Let_def Some <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">memo_list_trancl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">memo_list_trancl</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">tr</span> <span class="main">=</span> trancl_list_impl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
      <span class="bound">rm</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">tr</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>remdups <span class="main">∘</span> map fst<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="keyword1">case</span> map_of <span class="bound">rm</span> <span class="bound">a</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> <span class="main">[]</span>
      <span class="main">|</span> Some <span class="bound">as</span> <span class="main">⇒</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_List_Impl-memo_list_trancl"><span class="command">lemma</span></span> memo_list_trancl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>memo_list_trancl <span class="free">r</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> trancl_list_impl <span class="free">r</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>remdups <span class="main">∘</span> map fst<span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"map_of <span class="var">?rm</span> <span class="free">a</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None
    <span class="keyword1"><span class="command">have</span></span> one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> memo_list_trancl_def Let_def None
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> None <span class="main">[</span><span class="operator">unfolded</span> map_of_eq_None_iff<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> trancl_unfold_left<span class="main">]</span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">as</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">as</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> map_of_SomeD <span class="main">[</span><span class="operator">OF</span> Some<span class="main">]</span>
        trancl_list_impl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> memo_list_trancl_def Let_def Some <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="RBT_Map_Set_Extension">
<div class="head">
<h1>Theory RBT_Map_Set_Extension</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Executable Transitive Closures of Finite Relations
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
                 René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Accessing Values via Keys›</span></span>

<span class="keyword1"><span class="command">theory</span></span> RBT_Map_Set_Extension
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../Collections/RBTMapImpl.html">Collections.RBTMapImpl</a> 
  <a href="../Collections/RBTSetImpl.html">Collections.RBTSetImpl</a>
  <a href="../Matrix/Utility.html">Matrix.Utility</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide two extensions of the red black tree implementation.

  The first extension provides two convenience methods on sets which are represented by red black
  trees: a check on subsets and the big union operator. 

  The second extension is to provide two operations <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">elem_list_to_rm</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">rm_set_lookup</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which can be used to index a set of values via keys. More precisely, given a list
  of values of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'v</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and a key function of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'v</span></span> <span class="main"><span class="main">=&gt;</span></span> <span class="tfree"><span class="tfree">'k</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">elem_list_to_rm</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> will generate a map of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'k</span></span> <span class="main"><span class="main">=&gt;</span></span> <span class="tfree"><span class="tfree">'v</span></span> set"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Then with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">rs_set_lookup</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> we can efficiently access all values which match a given key.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Subset and Union›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For the subset operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">r</span></span> <span class="main"><span class="main">⊆</span></span> <span class="free"><span class="free">s</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> we provide two implementations. The first one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">rs_subset</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) traverses over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and then performs membership tests <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∈ s›</span></span></span></span>. Its
  complexity is ${\cal O}(|r| \cdot log (|s|))$. The second one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">rs_subset_list</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) generates
  sorted lists for both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and then linearly checks the subset condition. Its
  complexity is ${\cal O}(|r| + |s|)$.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As union operator we use the standard fold function. Note that the order of the union is important
  so that new sets are added to the big union.
›</span></span>

<span class="comment1">(* perhaps there is a smarter way to use two iterates at the same time, however,
  when writing this theory this feature was not detected in the RBTSetImpl theory *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rs_subset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">)</span> rs <span class="main">⇒</span> <span class="tfree">'a</span> rs <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rs_subset</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> rs.iteratei
    <span class="free"><span class="bound"><span class="entity">as</span></span></span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">maybe</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">maybe</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="keyword1">if</span> rs.memb <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="bound">a</span><span class="main">)</span>
    None"</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-rs_subset"><span class="command">lemma</span></span> rs_subset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs_subset <span class="free">as</span> <span class="free">bs</span> <span class="main">=</span> None <span class="main">⟷</span> rs.α <span class="free">as</span> <span class="main">⊆</span> rs.α <span class="free">bs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?abort</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">maybe</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">maybe</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?I</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">aas</span> <span class="bound">maybe</span><span class="main">.</span> <span class="bound">maybe</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> rs.α <span class="free">as</span> <span class="main">-</span> <span class="bound">aas</span> <span class="main">⟶</span> <span class="bound">a</span> <span class="main">∈</span> rs.α <span class="free">bs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?it</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rs_subset <span class="free">as</span> <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?I</span> <span class="main">{}</span> <span class="var">?it</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound"><span class="bound">it</span></span> <span class="main">⊆</span> rs.α <span class="free">as</span><span class="main">.</span> <span class="bound">it</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">¬</span> <span class="var">?abort</span> <span class="var">?it</span> <span class="main">∧</span> <span class="var">?I</span> <span class="bound">it</span> <span class="var">?it</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rs_subset_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rs.iteratei_rule_P <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?I</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rs_subset_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">)</span> rs <span class="main">⇒</span> <span class="tfree">'a</span> rs <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rs_subset_list</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span> <span class="free"><span class="bound"><span class="entity">bs</span></span></span> <span class="main">=</span> sorted_list_subset <span class="main">(</span>rs.to_sorted_list <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">(</span>rs.to_sorted_list <span class="free"><span class="bound"><span class="entity">bs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-rs_subset_list"><span class="command">lemma</span></span> rs_subset_list <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs_subset_list <span class="free">as</span> <span class="free">bs</span> <span class="main">=</span> None <span class="main">⟷</span> rs.α <span class="free">as</span> <span class="main">⊆</span> rs.α <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rs_subset_list_def
    sorted_list_subset<span class="main">[</span><span class="operator">OF</span> rs.to_sorted_list_correct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> rs.invar<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">as</span></span><span class="main"><span class="main">]</span></span>
    rs.to_sorted_list_correct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> rs.invar<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="free">bs</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.to_sorted_list_correct<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rs_Union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span> <span class="main">::</span> linorder<span class="main">)</span> rs list <span class="main">⇒</span> <span class="tfree">'q</span> rs"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rs_Union</span> <span class="main">=</span> foldl rs.union <span class="main">(</span>rs.empty <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-rs_Union"><span class="command">lemma</span></span> rs_Union <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>rs_Union <span class="free">qs</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span> <span class="main">(</span>rs.α <span class="main">`</span> set <span class="free">qs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">start</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>foldl rs.union <span class="skolem">start</span> <span class="free">qs</span><span class="main">)</span> <span class="main">=</span> rs.α <span class="skolem">start</span> <span class="main">∪</span> <span class="main">⋃</span> <span class="main">(</span>rs.α <span class="main">`</span> set <span class="free">qs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">qs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">start</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"rs.empty <span class="main">()</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> rs_Union_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Grouping Values via Keys›</span></span>
 
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The functions to produce the index (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">elem_list_to_rm</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) and the lookup function (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">rm_set_lookup</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) are straight-forward, however it requires some tedious reasoning that they perform
  as they should.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">elem_list_to_rm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">::</span> linorder<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'d</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'k</span><span class="main">,</span> <span class="tfree">'d</span> list<span class="main">)</span> rm"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">elem_list_to_rm</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="main">[]</span> <span class="main">=</span> rm.empty <span class="main">()</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">elem_list_to_rm</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">rm</span> <span class="main">=</span> <span class="free">elem_list_to_rm</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">ds</span></span></span><span class="main">;</span>
      <span class="bound">k</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">key</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="keyword1">case</span> rm.α <span class="bound">rm</span> <span class="bound">k</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> rm.update_dj <span class="bound">k</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">]</span> <span class="bound">rm</span>
      <span class="main">|</span> Some <span class="bound">data</span> <span class="main">⇒</span> rm.update <span class="bound">k</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">#</span> <span class="bound">data</span><span class="main">)</span> <span class="bound">rm</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rm_set_lookup</span> <span class="free"><span class="bound"><span class="entity">rm</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">case</span> rm.α <span class="free"><span class="bound"><span class="entity">rm</span></span></span> <span class="bound">a</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span> <span class="main">|</span> Some <span class="bound">rules</span> <span class="main">⇒</span> <span class="bound">rules</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-rm_to_list_empty"><span class="command">lemma</span></span> rm_to_list_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rm.to_list <span class="main">(</span>rm.empty <span class="main">()</span><span class="main">)</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>rm.to_list <span class="main">(</span>rm.empty <span class="main">()</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Map.empty"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rm.correct<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> map_of_empty_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> map_of <span class="bound">l</span> <span class="main">=</span> Map.empty <span class="main">⟷</span> <span class="bound">l</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">l</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">locale</span></span> rm_set <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">rm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">::</span> linorder<span class="main">,</span> <span class="tfree">'d</span> list<span class="main">)</span> rm"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">key</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> <span class="main">⇒</span> <span class="tfree">'k</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">data</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'d</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rm_set_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">k</span><span class="main">.</span> set <span class="main">(</span>rm_set_lookup <span class="free">rm</span> <span class="bound">k</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">d</span></span> <span class="main">∈</span> <span class="free">data</span><span class="main">.</span> <span class="free">key</span> <span class="bound">d</span> <span class="main">=</span> <span class="bound">k</span><span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-data_lookup"><span class="command">lemma</span></span> data_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">data</span> <span class="main">=</span> <span class="main">⋃</span> <span class="main">{</span>set <span class="main">(</span>rm_set_lookup <span class="free">rm</span> <span class="bound">k</span><span class="main">)</span> <span class="main">|</span> <span class="bound">k</span><span class="main">.</span> True<span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?R</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
    <span class="keyword3"><span class="command">assume</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="free">data</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="main">{</span><span class="bound"><span class="bound">d'</span></span> <span class="main">∈</span> <span class="free">data</span><span class="main">.</span> <span class="free">key</span> <span class="bound">d'</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> UnionI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ d<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> CollectI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> rm_set_lookup<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> rm_set_lookup<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">∈</span> <span class="free">data</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="RBT_Map_Set_Extension-finite_data"><span class="command">lemma</span></span> finite_data<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="free">data</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> data_lookup
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span>set <span class="main">(</span>rm_set_lookup <span class="free">rm</span> <span class="bound">k</span><span class="main">)</span> <span class="main">|</span> <span class="bound">k</span><span class="main">.</span> True<span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?L</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rmset</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rm.α <span class="free">rm</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?rmset</span> <span class="main">`</span> Map.dom <span class="var">?rmset</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?N</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span> <span class="bound">e</span><span class="main">.</span> set <span class="main">(</span><span class="keyword1">case</span> <span class="bound">e</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span> <span class="main">|</span> Some <span class="bound">ds</span> <span class="main">⇒</span> <span class="bound">ds</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="var">?M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?K</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?N</span> <span class="main">∪</span> <span class="main">{</span><span class="main">{}</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> rm.finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">rm</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="var">?K</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ fin<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ds</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ds</span> <span class="main">∈</span> <span class="var">?L</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> rm_set_lookup_def<span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">fn</span></span> <span class="keyword2"><span class="keyword">where</span></span> ds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ds</span> <span class="main">=</span> set <span class="main">(</span><span class="keyword1">case</span> rm.α <span class="free">rm</span> <span class="skolem">fn</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span>
          <span class="main">|</span> Some <span class="bound">ds</span> <span class="main">⇒</span> <span class="bound">ds</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ds</span> <span class="main">∈</span> <span class="var">?K</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.α <span class="free">rm</span> <span class="skolem">fn</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> None
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ds <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">rules</span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> Some <span class="keyword1"><span class="command">have</span></span> fn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">fn</span> <span class="main">∈</span> Map.dom <span class="var">?rmset</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ds</span> <span class="main">∈</span> <span class="var">?N</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> ds
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> fn<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rm_set_lookup_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> elem_list_to_rm<span class="main">:</span> rm_set <span class="quoted"><span class="quoted">"elem_list_to_rm <span class="free">key</span> <span class="free">ds</span>"</span></span> <span class="quoted"><span class="free">key</span></span> <span class="quoted"><span class="quoted">"set <span class="free">ds</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>rm_set_lookup <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="free">ds</span><span class="main">)</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">d</span></span> <span class="main">∈</span> set <span class="free">ds</span><span class="main">.</span> <span class="free">key</span> <span class="bound">d</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ds</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">k</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> rm_set_lookup_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rm.correct<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">d</span> <span class="skolem">ds</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?el</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"elem_list_to_rm <span class="free">key</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">k</span> <span class="bound">ds</span><span class="main">.</span> set <span class="main">(</span>rm_set_lookup <span class="main">(</span><span class="var">?el</span> <span class="bound">ds</span><span class="main">)</span> <span class="bound">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">k</span> <span class="bound">ds</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">d</span></span> <span class="main">∈</span> set <span class="bound">ds</span><span class="main">.</span> <span class="free">key</span> <span class="bound">d</span> <span class="main">=</span> <span class="bound">k</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> Cons <span class="keyword1"><span class="command">have</span></span> ind<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">k</span><span class="main">.</span> <span class="var">?l</span> <span class="bound">k</span> <span class="skolem">ds</span> <span class="main">=</span> <span class="var">?r</span> <span class="bound">k</span> <span class="skolem">ds</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> <span class="var">?r</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">(</span><span class="free">key</span> <span class="skolem">d</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None
      <span class="keyword1"><span class="command">from</span></span> None ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">da</span></span> <span class="main">∈</span> set <span class="skolem">ds</span><span class="main">.</span> <span class="free">key</span> <span class="bound">da</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> rm_set_lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> None <span class="keyword1"><span class="command">have</span></span> el<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?el</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> rm.update_dj <span class="main">(</span><span class="free">key</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">[</span><span class="skolem">d</span><span class="main">]</span> <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> None <span class="keyword1"><span class="command">have</span></span> ndom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span> <span class="main">∉</span> Map.dom <span class="main">(</span>rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> <span class="var">?r</span> <span class="skolem">k</span> <span class="skolem">ds</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">da</span><span class="main">.</span> <span class="free">key</span> <span class="bound">da</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">d</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">da</span> <span class="main">.</span> <span class="free">key</span> <span class="bound">da</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">∧</span> <span class="bound">da</span> <span class="main">=</span> <span class="skolem">d</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> r <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> ndom <span class="keyword1"><span class="command">have</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> 
        set <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>rm.α <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">(</span><span class="free">key</span> <span class="skolem">d</span> <span class="main">↦</span> <span class="main">[</span><span class="skolem">d</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="skolem">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span>
        <span class="main">|</span> Some <span class="bound">rules</span> <span class="main">⇒</span> <span class="bound">rules</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?l</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> el rm_set_lookup_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rm.correct<span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">da</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r2</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span> <span class="main">=</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> da k <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> ind<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rm_set_lookup_def<span class="main">]</span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">das</span></span> <span class="keyword2"><span class="keyword">where</span></span> rm<span class="main">:</span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span> <span class="main">=</span> Some <span class="skolem">das</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">da</span> <span class="main">≠</span> <span class="free">key</span> <span class="skolem">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">unfolded</span> rm_set_lookup_def<span class="main">]</span> rm da k <span class="keyword1"><span class="command">have</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span> <span class="main">≠</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> rm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rm.α <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">(</span><span class="free">key</span> <span class="skolem">d</span> <span class="main">↦</span> <span class="main">[</span><span class="skolem">d</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="skolem">k</span> <span class="main">=</span> Some <span class="skolem">das</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> rm<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> k <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> rm <span class="keyword1"><span class="command">using</span></span> da <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> 
      <span class="keyword1"><span class="command">moreover</span></span> 
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">da</span>
        <span class="keyword3"><span class="command">assume</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rm.α <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">key</span> <span class="skolem">d</span> <span class="main">↦</span> <span class="main">[</span><span class="skolem">d</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> l <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">das</span></span> <span class="keyword2"><span class="keyword">where</span></span> rm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rm</span> <span class="main">=</span> Some <span class="skolem">das</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">with</span></span> rm da <span class="keyword1"><span class="command">have</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> rm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span> <span class="main">=</span> Some <span class="skolem">das</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">unfolded</span> rm_set_lookup_def this<span class="main">]</span> da False
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> l r <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">das</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> Some ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> das<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">da</span></span> <span class="main">∈</span> set <span class="skolem">ds</span><span class="main">.</span> <span class="free">key</span> <span class="bound">da</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">das</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> rm_set_lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> Some <span class="keyword1"><span class="command">have</span></span> el<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?el</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> rm.update <span class="main">(</span><span class="free">key</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">das</span><span class="main">)</span> <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> Some <span class="keyword1"><span class="command">have</span></span> dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span> <span class="main">∈</span> Map.dom <span class="main">(</span>rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> dom <span class="keyword1"><span class="command">have</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> 
        set <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>rm.α <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">(</span><span class="free">key</span> <span class="skolem">d</span> <span class="main">↦</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">das</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">[]</span>
        <span class="main">|</span> Some <span class="bound">rules</span> <span class="main">⇒</span> <span class="bound">rules</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?l</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> el rm_set_lookup_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rm.correct<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="skolem">k</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">ds</span><span class="main">)</span> <span class="main">=</span> <span class="var">?r</span> <span class="skolem">k</span> <span class="skolem">ds</span> <span class="main">∪</span> <span class="main">{</span><span class="bound">da</span><span class="main">.</span> <span class="free">key</span> <span class="bound">da</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">∧</span> <span class="bound">da</span> <span class="main">=</span> <span class="skolem">d</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span><span class="main">)</span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">da</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r2</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">d</span> <span class="main">=</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> da k <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> ind<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rm_set_lookup_def<span class="main">]</span>
          <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">das'</span></span> <span class="keyword2"><span class="keyword">where</span></span> rm<span class="main">:</span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span> <span class="main">=</span> Some <span class="skolem">das'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">unfolded</span> rm_set_lookup_def rm<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> das'<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">das'</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">d</span></span> <span class="main">∈</span> set <span class="skolem">ds</span><span class="main">.</span> <span class="free">key</span> <span class="bound">d</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> True
            <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> das' das da <span class="keyword1"><span class="command">unfolding</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> False
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> das' da rm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> 
      <span class="keyword1"><span class="command">moreover</span></span> 
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">da</span>
        <span class="keyword3"><span class="command">assume</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?l</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rm.α <span class="main">(</span>elem_list_to_rm <span class="free">key</span> <span class="skolem">ds</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">key</span> <span class="skolem">d</span> <span class="main">↦</span> <span class="skolem">d</span> <span class="main">#</span> <span class="skolem">das</span><span class="main">)</span><span class="main">)</span> <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> l <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">das'</span></span> <span class="keyword2"><span class="keyword">where</span></span> rm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rm</span> <span class="main">=</span> Some <span class="skolem">das'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das'</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> <span class="free">key</span> <span class="skolem">d</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True
          <span class="keyword1"><span class="command">with</span></span> rm da das <span class="keyword1"><span class="command">have</span></span> da<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">d</span> <span class="main">#</span> <span class="skolem">das</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">=</span> <span class="skolem">d</span> <span class="main">∨</span> <span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">key</span> <span class="skolem">da</span> <span class="main">=</span> <span class="skolem">k</span>"</span></span> 
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">da</span> <span class="main">∈</span> set <span class="skolem">das</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> das True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">from</span></span> da k <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> das <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword1"><span class="command">with</span></span> rm <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rm.α <span class="main">(</span><span class="var">?el</span> <span class="skolem">ds</span><span class="main">)</span> <span class="skolem">k</span> <span class="main">=</span> Some <span class="skolem">das'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> ind<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">,</span> <span class="operator">unfolded</span> rm_set_lookup_def this<span class="main">]</span> da False
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r1</span> <span class="main">∪</span> <span class="var">?r2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> l r <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Transitive_Closure_RBT_Impl">
<div class="head">
<h1>Theory Transitive_Closure_RBT_Impl</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Executable Transitive Closures of Finite Relations
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
                 René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Closure Computation via Red Black Trees›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Transitive_Closure_RBT_Impl
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Transitive_Closure_Impl.html">Transitive_Closure_Impl</a>
  <a href="RBT_Map_Set_Extension.html">RBT_Map_Set_Extension</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide two algorithms to compute the reflexive transitive closure which internally work on red
  black trees. Therefore, the carrier has to be linear ordered. The first one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
  <span class="quoted"><span class="free"><span class="quoted"><span class="free">rtrancl_rbt_impl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) computes the closure on demand for a given set of initial states. The second
  one (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">memo_rbt_rtrancl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) precomputes the closure for each individual state, stores the
  results, and then only does a look-up.
  
  For the transitive closure there are the corresponding algorithms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">trancl_rbt_impl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">memo_rbt_trancl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Computing Closures from Sets On-The-Fly›</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The algorithms are based on the generic algorithms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> rtrancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> trancl_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  using red black trees. To compute the successors efficiently, all successors of a state are
  collected and stored in a red black tree map by using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> elem_list_to_rm<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Then, to lift the
  successor relation for single states to lists of states, all results are united using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
  rs_Union<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The rest is standard.
›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> set_access <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">as</span> <span class="bound">bs</span><span class="main">.</span> rs.union <span class="bound">bs</span> <span class="main">(</span>rs.from_list <span class="bound">as</span><span class="main">)</span>"</span></span> <span class="quoted">rs.α</span> <span class="quoted">rs.memb</span> <span class="quoted"><span class="quoted">"rs.empty <span class="main">()</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">rm_succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rm_succ</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">rm</span> <span class="main">=</span> elem_list_to_rm fst <span class="bound">r</span> <span class="keyword1">in</span>
    <span class="main">(</span><span class="main">λ</span> <span class="bound">as</span><span class="main">.</span> rs.to_list <span class="main">(</span>rs_Union <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> rs.from_list <span class="main">(</span>map snd <span class="main">(</span>rm_set_lookup <span class="bound">rm</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rtrancl_rbt_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> rs"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rtrancl_rbt_impl</span> <span class="main">=</span> rtrancl_impl rm_succ
    <span class="main">(</span><span class="main">λ</span> <span class="bound">as</span> <span class="bound">bs</span><span class="main">.</span> rs.union <span class="bound">bs</span> <span class="main">(</span>rs.from_list <span class="bound">as</span><span class="main">)</span><span class="main">)</span> rs.memb <span class="main">(</span>rs.empty <span class="main">()</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">trancl_rbt_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> rs"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">trancl_rbt_impl</span> <span class="main">=</span> trancl_impl rm_succ
    <span class="main">(</span><span class="main">λ</span> <span class="bound">as</span> <span class="bound">bs</span><span class="main">.</span> rs.union <span class="bound">bs</span> <span class="main">(</span>rs.from_list <span class="bound">as</span><span class="main">)</span><span class="main">)</span> rs.memb <span class="main">(</span>rs.empty <span class="main">()</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Transitive_Closure_RBT_Impl-rtrancl_rbt_impl"><span class="command">lemma</span></span> rtrancl_rbt_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>rtrancl_rbt_impl <span class="free">r</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rtrancl_rbt_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> set_access_gen.rtrancl_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> Let_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct elem_list_to_rm.rm_set_lookup<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>

<span class="keyword1" id="Transitive_Closure_RBT_Impl-trancl_rbt_impl"><span class="command">lemma</span></span> trancl_rbt_impl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>trancl_rbt_impl <span class="free">r</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> set <span class="free">as</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> trancl_rbt_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> set_access_gen.trancl_impl<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> Let_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct elem_list_to_rm.rm_set_lookup<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Precomputing Closures for Single States›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Storing all relevant entries is done by mapping all left-hand sides of the relation to their
  closure. Since we assume a linear order on the carrier, for the lookup we can use maps that are
  implemented as red black trees.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">memo_rbt_rtrancl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> rs<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">memo_rbt_rtrancl</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span> 
      <span class="bound">tr</span> <span class="main">=</span> rtrancl_rbt_impl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
      <span class="bound">rm</span> <span class="main">=</span> rm.to_map <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">tr</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>rs.to_list <span class="main">∘</span> rs.from_list <span class="main">∘</span> map fst<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="keyword1">case</span> rm.lookup <span class="bound">a</span> <span class="bound">rm</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> rs.from_list <span class="main">[</span><span class="bound">a</span><span class="main">]</span> 
      <span class="main">|</span> Some <span class="bound">as</span> <span class="main">⇒</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_RBT_Impl-memo_rbt_rtrancl"><span class="command">lemma</span></span> memo_rbt_rtrancl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>memo_rbt_rtrancl <span class="free">r</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rm.to_map
    <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> rtrancl_rbt_impl <span class="free">r</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>rs.to_list <span class="main">∘</span> rs.from_list <span class="main">∘</span> map fst<span class="main">)</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.lookup <span class="free">a</span> <span class="var">?rm</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None
    <span class="keyword1"><span class="command">have</span></span> one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> memo_rbt_rtrancl_def Let_def None
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> None <span class="main">[</span><span class="operator">unfolded</span> rm.lookup_correct <span class="main"><span class="main">[</span></span><span class="operator">OF</span> rm.invar<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span> rm.correct map_of_eq_None_iff<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> rtrancl_power relpow_fun_conv<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        ab<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">0</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∧</span> <span class="skolem">f</span> <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> steps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="skolem">n</span> <span class="main">⟹</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">,</span> <span class="skolem">f</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> ab steps <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="free">a</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">as</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"rs.α <span class="skolem">as</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> map_of_SomeD <span class="main">[</span><span class="operator">OF</span> Some <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rm.lookup_correct <span class="main"><span class="main">[</span></span><span class="operator">OF</span> rm.invar<span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span> rm.correct<span class="main"><span class="main">]</span></span><span class="main">]</span>
        rtrancl_rbt_impl <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> memo_rbt_rtrancl_def Let_def Some <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">memo_rbt_trancl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> rs<span class="main">)</span>"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">memo_rbt_trancl</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">tr</span> <span class="main">=</span> trancl_rbt_impl <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
      <span class="bound">rm</span> <span class="main">=</span> rm.to_map <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">tr</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>rs.to_list <span class="main">∘</span> rs.from_list <span class="main">∘</span> map fst<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span>
      <span class="main">(</span><span class="keyword1">case</span> rm.lookup <span class="bound">a</span> <span class="bound">rm</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> rs.empty <span class="main">()</span>
      <span class="main">|</span> Some <span class="bound">as</span> <span class="main">⇒</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Transitive_Closure_RBT_Impl-memo_rbt_trancl"><span class="command">lemma</span></span> memo_rbt_trancl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"rs.α <span class="main">(</span>memo_rbt_trancl <span class="free">r</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="var">?r</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"rm.to_map
    <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> trancl_rbt_impl <span class="free">r</span> <span class="main">[</span><span class="bound">a</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>rs.to_list <span class="main">∘</span> rs.from_list <span class="main">∘</span> map fst<span class="main">)</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"rm.lookup <span class="free">a</span> <span class="var">?rm</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> None
    <span class="keyword1"><span class="command">have</span></span> one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?l</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> memo_rbt_trancl_def Let_def None
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> None <span class="main">[</span><span class="operator">unfolded</span> rm.lookup_correct <span class="main"><span class="main">[</span></span><span class="operator">OF</span> rm.invar<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span> rm.correct map_of_eq_None_iff<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rs.correct<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">b</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">∈</span> <span class="var">?r</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">unfolded</span> trancl_unfold_left<span class="main">]</span> a <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">as</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">have</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"rs.α <span class="skolem">as</span> <span class="main">=</span> <span class="main">{</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">r</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> map_of_SomeD <span class="main">[</span><span class="operator">OF</span> Some <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> rm.lookup_correct <span class="main"><span class="main">[</span></span><span class="operator">OF</span> rm.invar<span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span> rm.correct<span class="main"><span class="main">]</span></span><span class="main">]</span>
        trancl_rbt_impl <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> memo_rbt_trancl_def Let_def Some <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Finite_Transitive_Closure_Simprocs">
<div class="head">
<h1>Theory Finite_Transitive_Closure_Simprocs</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Executable Transitive Closures of Finite Relations
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
                 René Thiemann       &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel and René Thiemann
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Computing Images of Finite Transitive Closures›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Finite_Transitive_Closure_Simprocs
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Transitive_Closure_List_Impl.html">Transitive_Closure_List_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Finite_Transitive_Closure_Simprocs-rtrancl_Image_eq"><span class="command">lemma</span></span> rtrancl_Image_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> set <span class="free">r'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> set <span class="free">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">x</span> <span class="main">=</span> set <span class="main">(</span>rtrancl_list_impl <span class="free">r'</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_list_impl<span class="main">)</span>

<span class="keyword1" id="Finite_Transitive_Closure_Simprocs-trancl_Image_eq"><span class="command">lemma</span></span> trancl_Image_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> set <span class="free">r'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> set <span class="free">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="free">x</span> <span class="main">=</span> set <span class="main">(</span>trancl_list_impl <span class="free">r'</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> trancl_list_impl<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Simproc for Computing the Images of Finite Transitive Closures›</span></span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">FINITE_TRANCL_IMAGE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> trancl_simproc <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> rtrancl_simproc <span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm option
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Finite_Trancl_Image</span> <span class="main">:</span> <span class="entity">FINITE_TRANCL_IMAGE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eval_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv</span> <span class="main">=</span> <span class="entity">Code_Runtime.dynamic_holds_conv</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span> CONVERSION <span class="main">(</span>Conv.params_conv <span class="inner_numeral">~1</span> <span class="main">(</span>K <span class="main">(</span>Conv.concl_conv <span class="inner_numeral">~1</span> <span class="entity">conv</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span> THEN' resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">TrueI</span><span class="main">]</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rtrancl</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> rtrancl_list_impl<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_trancl</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> trancl_list_impl<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_rtrancl_Image</span>
      <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Image<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> rtrancl<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">r</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">r</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_rtrancl_Image</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_trancl_Image</span>
      <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Image<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> $ <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> trancl<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">r</span><span class="main">)</span> $ <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">r</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_trancl_Image</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> Match

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_simproc</span> <span class="entity">dest</span> <span class="entity">mk_const</span> <span class="entity">eq_thm</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">r</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span> |&gt; <span class="entity">dest</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="comment1">(*make sure that the relation as well as the given domain are finite sets*)</span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>try <span class="entity">HOLogic.dest_set</span> <span class="entity">r</span><span class="main">,</span> try <span class="entity">HOLogic.dest_set</span> <span class="entity">x</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">(</span>SOME <span class="entity">xs</span><span class="main">,</span> SOME <span class="entity">ys</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(*types*)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">setT</span> <span class="main">=</span> <span class="entity">T</span> |&gt; dest_funT |&gt; snd |&gt; dest_funT |&gt; fst<span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eltT</span> <span class="main">=</span> <span class="entity">setT</span> |&gt; <span class="entity">HOLogic.dest_setT</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prodT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_prodT</span> <span class="main">(</span><span class="entity">eltT</span><span class="main">,</span> <span class="entity">eltT</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prod_listT</span> <span class="main">=</span> <span class="entity">HOLogic.listT</span> <span class="entity">prodT</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">listT</span> <span class="main">=</span> <span class="entity">HOLogic.listT</span> <span class="entity">eltT</span><span class="main">;</span>

          <span class="comment1">(*terms*)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> List.set<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">listT</span> --&gt; <span class="entity">setT</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">const</span> <span class="main">=</span> <span class="entity">mk_const</span> <span class="main">(</span><span class="entity">prod_listT</span> --&gt; <span class="entity">listT</span> --&gt; <span class="entity">listT</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r'</span> <span class="main">=</span> <span class="entity">HOLogic.mk_list</span> <span class="entity">prodT</span> <span class="entity">xs</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x'</span> <span class="main">=</span> <span class="entity">HOLogic.mk_list</span> <span class="entity">eltT</span> <span class="entity">ys</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">set</span> $ <span class="main">(</span><span class="entity">const</span> $ <span class="entity">r'</span> $ <span class="entity">x'</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> <span class="entity">Value_Command.value</span> <span class="entity">ctxt</span> <span class="entity">t'</span><span class="main">;</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eval</span> <span class="main">=</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_eq</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">;</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">maybe_rule</span> <span class="main">=</span>
            try <span class="main">(</span>Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">eval</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">eval_tac</span> <span class="entity">context</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">maybe_rule</span> <span class="keyword2"><span class="keyword">of</span></span>
            SOME <span class="entity">rule</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conv</span> <span class="main">=</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> |&gt; <span class="entity">HOLogic.mk_eq</span> |&gt; <span class="entity">HOLogic.mk_Trueprop</span><span class="main">;</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_thm'</span> <span class="main">=</span> Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">conv</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
                resolve_tac <span class="entity">ctxt'</span> <span class="main">[</span><span class="entity">eq_thm</span><span class="main">]</span> <span class="inner_numeral">1</span> THEN REPEAT <span class="main">(</span><span class="entity">simp_tac</span> <span class="entity">ctxt'</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              SOME <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.trans<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">eq_thm'</span><span class="main">,</span> <span class="entity">rule</span><span class="main">]</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_reflection<span class="antiquote">}</span></span></span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="main">|</span> NONE <span class="main">=&gt;</span> NONE<span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rtrancl_simproc</span> <span class="main">=</span> <span class="entity">gen_simproc</span> <span class="entity">dest_rtrancl_Image</span> <span class="entity">mk_rtrancl</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rtrancl_Image_eq<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">trancl_simproc</span> <span class="main">=</span> <span class="entity">gen_simproc</span> <span class="entity">dest_trancl_Image</span> <span class="entity">mk_trancl</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trancl_Image_eq<span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">simproc_setup</span></span> rtrancl_Image <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">x</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹K <span class="entity">Finite_Trancl_Image.rtrancl_simproc</span>›</span>
<span class="keyword1"><span class="command">simproc_setup</span></span> trancl_Image  <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="free">x</span>"</span></span><span class="main">)</span> <span class="main">=</span> <span class="quoted">‹K <span class="entity">Finite_Trancl_Image.trancl_simproc</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Example›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The images of (reflexive) transitive closures are computed by evaluation.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">,</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">4</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">5</span><span class="main">)</span><span class="main">}</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">5</span><span class="main">}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">,</span> <span class="numeral">2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">4</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">5</span><span class="main">)</span><span class="main">}</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">``</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">5</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Evaluation does not allow for free variables and thus fails in their presence.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">}</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div>