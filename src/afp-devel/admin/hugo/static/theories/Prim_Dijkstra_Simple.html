<div id="Common">
<div class="head">
<h1>Theory Common</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Commonly used Lemmas›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Common
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Extended_Nat.html">HOL-Library.Extended_Nat</a>"</span> 
  <span class="quoted">"<a href="../../HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">coercion_enabled</span> <span class="main"><span class="main">=</span></span> <span class="quasi_keyword">false</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Miscellaneous›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> split_sym_rel<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sym <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">E</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main">∩</span><span class="free">E</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> <span class="free">E</span> <span class="main">∪</span> <span class="free">E</span><span class="main">¯</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> rel"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> WO<span class="main">:</span> <span class="quoted"><span class="quoted">"well_order_on UNIV <span class="skolem">R</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Zorn.well_order_on <span class="keyword1"><span class="command">..</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">∩</span> <span class="skolem">R</span>"</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹irrefl <span class="free">G</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∉</span><span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> irrefl_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?E</span> <span class="main">∩</span> <span class="var">?E</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> WO 
    <span class="keyword1"><span class="command">unfolding</span></span> well_order_on_def linear_order_on_def 
      partial_order_on_def antisym_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 
  <span class="keyword1"><span class="command">moreover</span></span>  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> <span class="var">?E</span> <span class="main">∪</span> <span class="var">?E</span><span class="main">¯</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹sym <span class="free">G</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> WO <span class="keyword1"><span class="command">unfolding</span></span> well_order_on_def linear_order_on_def total_on_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>  
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> least_antimono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">≠</span><span class="main">{}</span> <span class="main">⟹</span> <span class="free">X</span><span class="main">⊆</span><span class="free">Y</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">y</span><span class="main">::</span><span class="main">_</span><span class="main">::</span>wellorder<span class="main">.</span> <span class="bound">y</span><span class="main">∈</span><span class="free">Y</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> LeastI_ex Least_le equals0I rev_subsetD<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> distinct_map_snd_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map snd <span class="free">l</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a'</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">a</span><span class="main">=</span><span class="free">a'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_map inj_onD prod.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> prod.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> map_add_apply<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">++</span> <span class="free">m<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">m<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">k</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">m<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">k</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> Some <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_add_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> map_eq_append_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="free">ys<span class="hidden">⇩</span><sub>2</sub></span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> map <span class="free">f</span> <span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> map <span class="free">f</span> <span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="free">ys<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"take <span class="main">(</span>length <span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">xs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"drop <span class="main">(</span>length <span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">xs</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> sym<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> append_eq_conv_conj take_map drop_map<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> prod_case_const<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"case_prod <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">c</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> card2_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="free">e</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">u</span><span class="main">≠</span><span class="bound">v</span> <span class="main">∧</span> <span class="free">e</span><span class="main">=</span><span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eval_nat_numeral card_Suc_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> in_ranE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> ran <span class="free">m</span>"</span></span>  
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> Inf_in<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>linorder<span class="main">,</span>complete_lattice<span class="main">}</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">≠</span><span class="main">{}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf <span class="free">A</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inf <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">a</span><span class="main">≤</span><span class="skolem">b</span> <span class="keyword1">then</span> <span class="skolem">a</span> <span class="keyword1">else</span> <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> inf_absorb2 le_iff_inf linear<span class="main">)</span>
  
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">F</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">F</span><span class="main">=</span><span class="main">{}</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">F</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> insert.IH <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Inf <span class="skolem">F</span> <span class="main">∈</span> <span class="skolem">F</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> le_less_linear<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="quoted">"Inf <span class="skolem">F</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> INF_of_enat_infty_iff1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> enat <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="free">A</span><span class="main">=</span><span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">=</span><span class="main">{}</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> top_enat_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">safe</span> <span class="main">(</span><span class="operator">metis</span> INF_top_conv<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> enat.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> top_enat_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> INF_of_enat_infty_iff2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> enat <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span><span class="main">=</span><span class="main">{}</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> INF_of_enat_infty_iff1<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> INF_of_enat_infty_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> INF_of_enat_infty_iff1 INF_of_enat_infty_iff2
    
<span class="keyword1"><span class="command">lemma</span></span> INF_of_enat_nat_conv1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> enat <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> enat <span class="free">d</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">d</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>enat<span class="main">`</span><span class="free">f</span><span class="main">`</span><span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">=</span><span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> top_enat_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> False  
    <span class="keyword1"><span class="command">note</span></span> * <span class="main">=</span> Inf_in<span class="main">[</span><span class="operator">OF</span> F<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> False Inf_in assms enat.inject enat_ord_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> finite_imageI imageE image_is_empty le_INF_iff order_refl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> INF_greatest INF_lower antisym enat_ord_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>      
      
<span class="keyword1"><span class="command">lemma</span></span> INF_of_enat_nat_conv2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">d</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> enat <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">d</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> INF_of_enat_nat_conv1<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1"><span class="command">lemmas</span></span> INF_of_enat_nat_conv <span class="main">=</span> INF_of_enat_nat_conv1 INF_of_enat_nat_conv2
  
<span class="keyword1"><span class="command">lemma</span></span> finite_inf_linorder_ne_ex<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span><span class="main">::</span><span class="main">{</span>complete_lattice<span class="main">,</span>linorder<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Inf_in finite_imageI imageE image_is_empty<span class="main">)</span>
  
  

<span class="keyword1"><span class="command">lemma</span></span> finite_linorder_eq_INF_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> 
  <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">INF</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">S</span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> <span class="free">a</span><span class="main">=</span>top <span class="keyword1">else</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">a</span><span class="main">=</span><span class="free">f</span> <span class="bound">x</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span><span class="main">::</span><span class="main">{</span>complete_lattice<span class="main">,</span>linorder<span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> INF_greatest INF_lower  
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_inf_linorder_ne_ex antisym<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> sym_inv_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="free">E</span> <span class="main">⟹</span> <span class="free">E</span><span class="main">¯</span> <span class="main">=</span> <span class="free">E</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> sym_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

<span class="keyword1"><span class="command">lemma</span></span> insert_inv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="free">e</span> <span class="free">E</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> insert <span class="main">(</span>prod.swap <span class="free">e</span><span class="main">)</span> <span class="main">(</span><span class="free">E</span><span class="main">¯</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> inter_compl_eq_diff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∩</span> <span class="main">-</span> <span class="free">s</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="free">s</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> inter_same_diff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">∩</span><span class="main">(</span><span class="free">A</span><span class="main">-</span><span class="free">S</span><span class="main">)</span> <span class="main">=</span> <span class="free">A</span><span class="main">-</span><span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> minus_inv_sym_aux<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">b</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">a</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> <span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">a</span><span class="main">)</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The-Default›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">the_default</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">the_default</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> None <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">the_default</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> the_default_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"the_default <span class="free">d</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">d</span> <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>enat›</span></span></span></span> by Option›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our maps are functions to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nat option›</span></span></span></span>,which are interpreted as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>enat›</span></span></span></span>,
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span> being <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∞›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">enat_of_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option <span class="main">⇒</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">enat_of_option</span> None <span class="main">=</span> <span class="main">∞</span>"</span></span> 
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">enat_of_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> enat <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_inj<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> enat_of_option <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> enat <span class="free">n</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">=</span> enat_of_option <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">=</span> enat_of_option <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_le_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"enat_of_option <span class="free">m</span> <span class="main">≤</span> enat_of_option <span class="free">n</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">m</span><span class="main">,</span><span class="free">n</span><span class="main">)</span> <span class="keyword1">of</span> 
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span>None<span class="main">)</span> <span class="main">⇒</span> True
  <span class="main">|</span> <span class="main">(</span>Some <span class="bound">a</span><span class="main">,</span> Some <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">≤</span><span class="bound">b</span>
  <span class="main">|</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> False
<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Foldr-Refine›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> foldr_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">I</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free">α</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span> <span class="bound">x</span> <span class="main">(</span><span class="free">α</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">(</span>foldr <span class="free">f</span> <span class="free">l</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free">α</span> <span class="main">(</span>foldr <span class="free">f</span> <span class="free">l</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> foldr <span class="free">f'</span> <span class="free">l</span> <span class="main">(</span><span class="free">α</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">auto</span>
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Chapter_Prim">
<div class="head">
<h1>Theory Chapter_Prim</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Prim's Minimum Spanning Tree Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Prim's algorithm~\cite{Prim57} is a classical algorithm to find a minimum spanning 
  tree of an undirected graph. In this section we describe our formalization 
  of Prim's algorithm, roughly following the presentation of Cormen et al.~\cite{Cormen-Leiserson-Rivest}.
  
  Our approach features stepwise refinement. We start by a generic MST algorithm (Section~\ref{sec:generic_mst}) 
  that covers both Prim's and Kruskal's algorithms. It maintains a subgraph <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> of an MST.
  Initially, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> contains no edges and only the root node. In each iteration, the algorithm adds a new edge to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span>,
  maintaining the property that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> is a subgraph of an MST. 
  In a next refinement step, we only add edges that are adjacent to the current <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span>, thus 
  maintaining the invariant that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span> is always a tree (Section~\ref{sec:prim_algo}). 
  Next, we show how to use a priority queue to efficiently determine a next edge to be 
  added (Section~\ref{sec:using_pq}), and implement 
  the necessary update of the priority queue using a foreach-loop (Section~\ref{sec:using_foreach}).
  Finally we parameterize our algorithm over ADTs for graphs, maps, and priority queues 
  (Section~\ref{sec:prim_data_structs}), instantiate these with actual data structures (Section~\ref{sec:prim_inst_ds}), and extract
  executable ML code (Section~\ref{sec:prim_exec}).
  
  The advantage of this stepwise refinement approach is that the proof obligations of 
  each step are mostly independent from the other steps. This modularization greatly helps
  to keep the proof manageable. Moreover, the steps also correspond to a natural split 
  of the ideas behind Prim's algorithm: The same structuring is also done in the presentation 
  of Cormen et al.~\cite{Cormen-Leiserson-Rivest}, though not as detailed as ours.
›</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Chapter_Prim
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Undirected_Graph">
<div class="head">
<h1>Theory Undirected_Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span>  <span class="quoted"><span class="plain_text">‹Undirected Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Undirected_Graph
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Common.html">Common</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nodes and Edges›</span></span>  

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'v</span> ugraph 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span><span class="bound">V</span><span class="main">::</span><span class="tfree">'v</span> set <span class="main">,</span> <span class="bound">E</span><span class="main">)</span><span class="main">.</span> <span class="bound">E</span> <span class="main">⊆</span> <span class="bound">V</span><span class="main">×</span><span class="bound">V</span> <span class="main">∧</span> finite <span class="bound">V</span> <span class="main">∧</span> sym <span class="bound">E</span> <span class="main">∧</span> irrefl <span class="bound">E</span> <span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sym_def irrefl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_ugraph

<span class="keyword1"><span class="command">lift_definition</span></span> nodes_internal <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph <span class="main">⇒</span> <span class="tfree">'v</span> set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">fst</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> edges_internal <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">snd</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> graph_internal <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'v</span> ugraph"</span></span> 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">V</span> <span class="bound">E</span><span class="main">.</span> <span class="keyword1">if</span> finite <span class="bound">V</span> <span class="main">∧</span> finite <span class="bound">E</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">V</span><span class="main">∪</span>fst<span class="main">`</span><span class="bound">E</span><span class="main">∪</span>snd<span class="main">`</span><span class="bound">E</span><span class="main">,</span> <span class="main">(</span><span class="bound">E</span><span class="main">∪</span><span class="bound">E</span><span class="main">¯</span><span class="main">)</span><span class="main">-</span>Id<span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sym_def irrefl_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>     

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nodes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph <span class="main">⇒</span> <span class="tfree">'v</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nodes</span> <span class="main">=</span> nodes_internal"</span></span> 
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">edges</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">=</span> edges_internal"</span></span> 
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="tfree">'v</span> ugraph"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph</span> <span class="main">=</span> graph_internal"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> edges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">⊆</span> nodes <span class="free">g</span> <span class="main">×</span> nodes <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> nodes_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nodes <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> edges_irrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"irrefl <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span>"</span></span>      
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> nodes_graph<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>finite <span class="free">V</span><span class="main">;</span> finite <span class="free">E</span><span class="main">⟧</span> <span class="main">⟹</span> nodes <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="free">V</span><span class="main">∪</span>fst<span class="main">`</span><span class="free">E</span><span class="main">∪</span>snd<span class="main">`</span><span class="free">E</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_graph<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>finite <span class="free">V</span><span class="main">;</span> finite <span class="free">E</span><span class="main">⟧</span> <span class="main">⟹</span> edges <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">E</span><span class="main">∪</span><span class="free">E</span><span class="main">¯</span><span class="main">)</span><span class="main">-</span>Id"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemmas</span></span> graph_accs <span class="main">=</span> nodes_graph edges_graph  
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_edges_graph_presentation<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>finite <span class="free">V</span><span class="main">;</span> finite <span class="free">E</span><span class="main">⟧</span> 
    <span class="main">⟹</span> nodes <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="free">V</span> <span class="main">∪</span> fst<span class="main">`</span><span class="free">E</span> <span class="main">∪</span> snd<span class="main">`</span><span class="free">E</span> <span class="main">∧</span> edges <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="free">E</span><span class="main">∪</span><span class="free">E</span><span class="main">¯</span> <span class="main">-</span> Id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> graph_accs<span class="main">)</span>
      
<span class="keyword1"><span class="command">lemma</span></span> graph_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">(</span>nodes <span class="free">g</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def graph_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command">unfolding</span></span> sym_def irrefl_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> edges_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_subset finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  
<span class="keyword1"><span class="command">lemma</span></span> graph_cases<span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">type</span></span></span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">V</span> <span class="free">E</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">=</span> graph <span class="free">V</span> <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">V</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main">⊆</span><span class="free">V</span><span class="main">×</span><span class="free">V</span>"</span></span> <span class="quoted"><span class="quoted">"sym <span class="free">E</span>"</span></span> <span class="quoted"><span class="quoted">"irrefl <span class="free">E</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"nodes <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> edges_subset edges_sym edges_irrefl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>     

<span class="keyword1"><span class="command">lemma</span></span> graph_eq_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">=</span><span class="free">g'</span> <span class="main">⟷</span> nodes <span class="free">g</span> <span class="main">=</span> nodes <span class="free">g'</span> <span class="main">∧</span> edges <span class="free">g</span> <span class="main">=</span> edges <span class="free">g'</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> edges_def nodes_def graph_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

  
  
<span class="keyword1"><span class="command">lemma</span></span> edges_sym'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> edges_sym 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> symD<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_irrefl'<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>edges <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> edges_irrefl irrefl_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_irreflI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  
<span class="keyword1"><span class="command">lemma</span></span> edgesT_diff_sng_inv_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">¯</span> <span class="main">=</span> edges <span class="free">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_sym' <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  
<span class="keyword1"><span class="command">lemma</span></span> nodesI<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms edges_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> split_edges_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">E</span><span class="main">.</span> <span class="bound">E</span><span class="main">∩</span><span class="bound">E</span><span class="main">¯</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> edges <span class="free">g</span> <span class="main">=</span> <span class="bound">E</span> <span class="main">∪</span> <span class="bound">E</span><span class="main">¯</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> split_sym_rel<span class="main">[</span><span class="operator">OF</span> edges_sym edges_irrefl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connectedness Relation›</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> rtrancl_edges_sym'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_sym symD sym_rtrancl<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> trancl_edges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">⊆</span> nodes <span class="free">g</span> <span class="main">×</span> nodes <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_subset trancl_subset_Sigma<span class="main">)</span>
      
<span class="keyword1"><span class="command">lemma</span></span> find_crossing_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">V</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">u'</span> <span class="free">v'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main">∩</span><span class="free">V</span><span class="main">×</span><span class="main">-</span><span class="free">V</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Constructing Graphs›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_empty</span> <span class="main">≡</span> graph <span class="main">{}</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ins_node</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> graph <span class="main">(</span>insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ins_edge</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> graph <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">(</span>insert <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_join</span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span> graph <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> nodes <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∪</span> edges <span class="free"><span class="bound"><span class="entity">g<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">restrict_nodes</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">≡</span> graph <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">restrict_edges</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">≡</span> graph <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∩</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">∪</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">¯</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nodes_edges_consistent</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">≡</span> finite <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">∧</span> irrefl <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">∧</span> sym <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">V</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nodes_edges_consistent <span class="free">V</span> <span class="free">E</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> nodes_graph'<span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="free">V</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> edges_graph'<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph <span class="free">V</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="free">E</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">E</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> nodes_edges_consistent_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> finite_SigmaI rev_finite_subset<span class="main">)</span> 

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nodes_edges_consistent_def nodes_graph edges_graph irrefl_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword1"><span class="command">lemma</span></span> nec_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes_edges_consistent <span class="main">{}</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nodes_edges_consistent_def irrefl_def sym_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> graph_empty_accs<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nodes graph_empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"edges graph_empty <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_empty_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> graph_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"graph <span class="main">{}</span> <span class="main">{}</span> <span class="main">=</span> graph_empty"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> graph_empty_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">lemma</span></span> nodes_empty_iff_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"nodes <span class="free">G</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">G</span><span class="main">=</span>graph <span class="main">{}</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">=</span> nodes <span class="free">G</span> <span class="main">⟷</span> <span class="free">G</span><span class="main">=</span>graph_empty"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_subset
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_eq_iff<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_ins_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>ins_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">v</span> <span class="main">(</span>nodes <span class="free">g</span><span class="main">)</span>"</span></span>         
  <span class="keyword2"><span class="keyword">and</span></span> edges_ins_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>ins_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> edges <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ins_node_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs edges_sym'<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_ins_edge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>ins_edge <span class="free">e</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>fst <span class="free">e</span><span class="main">,</span> snd <span class="free">e</span><span class="main">}</span> <span class="main">∪</span> nodes <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> edges_ins_edge<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"edges <span class="main">(</span>ins_edge <span class="free">e</span> <span class="free">g</span><span class="main">)</span> 
      <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> fst <span class="free">e</span> <span class="main">=</span> snd <span class="free">e</span> <span class="keyword1">then</span> edges <span class="free">g</span> <span class="keyword1">else</span> <span class="main">{</span><span class="free">e</span><span class="main">,</span>prod.swap <span class="free">e</span><span class="main">}</span><span class="main">∪</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ins_edge_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹<span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_ins_edge'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span> <span class="main">⟹</span> edges <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> edges <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> edges_ins_edge_ss<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">⊆</span> edges <span class="main">(</span>ins_edge <span class="free">e</span> <span class="free">g</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_join<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>  
  <span class="keyword2"><span class="keyword">and</span></span> edges_join<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_join_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nodes_restrict_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>restrict_nodes <span class="free">g</span> <span class="free">V</span><span class="main">)</span> <span class="main">=</span> nodes <span class="free">g</span> <span class="main">∩</span> <span class="free">V</span>"</span></span>  
  <span class="keyword2"><span class="keyword">and</span></span> edges_restrict_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict_nodes <span class="free">g</span> <span class="free">V</span><span class="main">)</span> <span class="main">=</span> edges <span class="free">g</span> <span class="main">∩</span> <span class="free">V</span><span class="main">×</span><span class="free">V</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> restrict_nodes_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_restrict_edges<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> nodes <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> edges_restrict_edges<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="main">=</span> edges <span class="free">g</span> <span class="main">∩</span> <span class="main">(</span><span class="free">E</span><span class="main">∪</span><span class="free">E</span><span class="main">¯</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> restrict_edges_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> unrestricte_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> unrestrictn_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>restrict_nodes <span class="free">g</span> <span class="free">V</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> unrestrict_nodes<span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="main">⊆</span> nodes <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>  
    
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">path</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>  
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">=</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">∈</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∧</span> <span class="free">path</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span>"</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> path_emptyI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="main">[]</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
<span class="keyword1"><span class="command">lemma</span></span> path_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">w</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> path <span class="free">g</span> <span class="free">u</span> <span class="free">p1</span> <span class="bound">v</span> <span class="main">∧</span> path <span class="free">g</span> <span class="bound">v</span> <span class="free">p2</span> <span class="free">w</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> path_transs1<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">w</span>"</span></span>  
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">w</span>"</span></span>
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p1</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">v</span> <span class="free">p2</span> <span class="free">w</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> path_graph_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path graph_empty <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">=</span><span class="free">u</span> <span class="main">∧</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">revp</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> rev <span class="main">(</span>map prod.swap <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> revp_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"revp <span class="free">p</span> <span class="main">=</span> rev <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> path_rev<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span>revp <span class="free">p</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟷</span> path <span class="free">g</span> <span class="free">v</span> <span class="free">p</span> <span class="free">u</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> path_rev_sym<span class="main">[</span><span class="operator">sym</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">v</span> <span class="free">p</span> <span class="free">u</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span>revp <span class="free">p</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 

<span class="keyword1"><span class="command">lemma</span></span> path_transs2<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">w</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">w</span>"</span></span>  
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="free">w</span>"</span></span>
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p1</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">w</span> <span class="free">p2</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span>revp <span class="free">p2</span><span class="main">)</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>

  
<span class="keyword1"><span class="command">lemma</span></span> path_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> set <span class="free">p</span> <span class="main">⊆</span> edges <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> path_graph_cong<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>path <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span><span class="main">;</span> set <span class="free">p</span> <span class="main">⊆</span> edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⟹</span> set <span class="free">p</span> <span class="main">⊆</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">⟧</span> <span class="main">⟹</span> path <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> path_edges<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
  
                
<span class="keyword1"><span class="command">lemma</span></span> path_endpoints<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nodesI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nodesI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">⊆</span> edges <span class="free">g'</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g'</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> path_edges path_graph_cong subset_trans<span class="main">)</span>

  
  
<span class="keyword1"><span class="command">lemmas</span></span> unrestricte_path <span class="main">=</span> path_mono<span class="main">[</span><span class="operator">OF</span> unrestricte_edges<span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> unrestrictn_path <span class="main">=</span> path_mono<span class="main">[</span><span class="operator">OF</span> unrestrictn_edges<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> unrestrict_path_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> unrestrict_path_nodes<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_nodes <span class="free">g</span> <span class="free">E</span><span class="main">)</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>
  
      
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Paths and Connectedness›</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> rtrancl_edges_iff_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> path <span class="free">g</span> <span class="free">u</span> <span class="bound">p</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_transs1<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> rtrancl_edges_pathE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_edges_iff_path<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> path_rtrancl_edgesD<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_edges_iff_path<span class="main">)</span>  
      
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Simple Paths›</span></span>  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">uedge</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">}</span>"</span></span>   
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">simple</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> distinct <span class="main">(</span>map uedge <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>  


<span class="keyword1"><span class="command">lemma</span></span> in_uedge_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>uedge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span><span class="free">u</span> <span class="main">∨</span> <span class="free">x</span><span class="main">=</span><span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> uedge_eq_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> uedge <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">d</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">b</span><span class="main">=</span><span class="free">d</span> <span class="main">∨</span> <span class="free">a</span><span class="main">=</span><span class="free">d</span> <span class="main">∧</span> <span class="free">b</span><span class="main">=</span><span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def doubleton_eq_iff<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> uedge_degen<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> uedge_in_set_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> uedge <span class="main">`</span> <span class="free">S</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span> <span class="main">∨</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def doubleton_eq_iff<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> uedge_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> uedge <span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      
<span class="keyword1"><span class="command">lemma</span></span> simple_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"simple <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_cons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> uedge <span class="free">e</span> <span class="main">∉</span> uedge <span class="main">`</span> set <span class="free">p</span> <span class="main">∧</span> simple <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> simple_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="free">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="free">p<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> 
  <span class="main">⟷</span> simple <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> simple <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> uedge <span class="main">`</span> set <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> uedge <span class="main">`</span> set <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_def<span class="main">)</span>

  
<span class="keyword1"><span class="command">lemma</span></span> simplify_pathD<span class="main">:</span>
  <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p'</span><span class="main">.</span> path <span class="free">g</span> <span class="free">u</span> <span class="bound">p'</span> <span class="free">v</span> <span class="main">∧</span> simple <span class="bound">p'</span> <span class="main">∧</span> set <span class="bound">p'</span> <span class="main">⊆</span> set <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> length_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> A<span class="main">:</span> <span class="main">(</span>1 <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> A.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>simple <span class="skolem">p</span>"</span></span>  
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span>"</span></span>
                <span class="main">|</span> <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simple_def map_eq_append_conv uedge_eq_iff 
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> not_distinct_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="skolem">p'</span> <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p'</span> <span class="main">⊆</span> set <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 1
      <span class="keyword1"><span class="command">from</span></span> A.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span><span class="main">)</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> that<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 2
      <span class="keyword1"><span class="command">from</span></span> A.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span><span class="main">)</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> that<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> A.IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>  
    
<span class="keyword1"><span class="command">lemma</span></span> simplify_pathE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> 
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p'</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">p'</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">p'</span> <span class="main">⊆</span> set <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> simplify_pathD<span class="main">)</span>
   

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Splitting Paths›</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> find_crossing_edge_on_path<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">u'</span> <span class="free">v'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">u'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> find_crossing_edges_on_path<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span><span class="main">.</span> <span class="free">P</span> <span class="bound">u</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span>"</span></span>
        <span class="main">|</span> <span class="free">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">v<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">u<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">p<span class="hidden">⇩</span><sub>3</sub></span> 
          <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="free">v<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="free">p<span class="hidden">⇩</span><sub>2</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">,</span><span class="free">v<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="free">p<span class="hidden">⇩</span><sub>3</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">u<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">v<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">u<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span><span class="main">.</span> <span class="free">P</span> <span class="bound">u</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">with</span></span> P <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="free">u</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="bound">v<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span><span class="main">.</span> <span class="free">P</span> <span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="main">¬</span><span class="free">P</span> <span class="bound">v<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="skolem"><span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> PRED1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>3</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span><span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>3</sub></span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>3</sub></span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> find_crossing_edge_on_path<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">P</span></span><span class="main">,</span> <span class="operator">OF</span> this <span class="quoted"><span class="quoted">‹<span class="main">¬</span><span class="free">P</span> <span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">P</span> <span class="free">v</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="skolem"><span class="skolem">v<span class="hidden">⇩</span><sub>2</sub></span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">,</span><span class="skolem">v<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">∈</span>set <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>3</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">v<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="free">thesis</span></span> <span class="keyword1"><span class="command">using</span></span> PRED1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>      
  
<span class="keyword1"><span class="command">lemma</span></span> find_crossing_edge_rtrancl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">u'</span> <span class="free">v'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="free">u'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">v'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> converse_rtrancl_induct<span class="main">)</span>
  

<span class="keyword1"><span class="command">lemma</span></span> path_change<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">y</span> <span class="free">p1</span> <span class="free">p2</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∉</span> <span class="free">S</span>"</span></span>
    <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">u</span> <span class="free">p1</span> <span class="free">x</span>"</span></span> 
    <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">y</span> <span class="free">p2</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> find_crossing_edge_on_path<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∉</span><span class="free">S</span>"</span></span><span class="main">]</span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∉</span><span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
  
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
  
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="skolem">p1</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">y</span> <span class="skolem">p2</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹simple <span class="free">p</span>›</span></span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∉</span>set <span class="main">(</span>map uedge <span class="skolem">p1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∉</span>set <span class="main">(</span>map uedge <span class="skolem">p2</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?g'</span> <span class="free">u</span> <span class="skolem">p1</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?g'</span> <span class="skolem">y</span> <span class="skolem">p2</span> <span class="free">v</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> path_graph_cong<span class="main">[</span><span class="operator">OF</span> P1<span class="main">,</span> <span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?g'</span></span></span><span class="main">]</span> path_graph_cong<span class="main">[</span><span class="operator">OF</span> P2<span class="main">,</span> <span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?g'</span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_in_set_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
      




<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Cycles›</span></span>      
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cycle_free</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">∄</span><span class="bound">p</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> simple <span class="bound">p</span> <span class="main">∧</span> path <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">u</span> <span class="bound">p</span> <span class="bound">u</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cycle_free_alt_in_nodes<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span> <span class="main">≡</span> <span class="main">∄</span><span class="bound">p</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> <span class="bound">u</span><span class="main">∈</span>nodes <span class="free">g</span> <span class="main">∧</span> simple <span class="bound">p</span> <span class="main">∧</span> path <span class="free">g</span> <span class="bound">u</span> <span class="bound">p</span> <span class="bound">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cycle_free_def path_endpoints<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cycle_freeI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">u</span><span class="main">.</span> <span class="main">⟦</span> path <span class="free">g</span> <span class="bound">u</span> <span class="bound">p</span> <span class="bound">u</span><span class="main">;</span> <span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">;</span> simple <span class="bound">p</span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> cycle_freeD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">p</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  
<span class="keyword1"><span class="command">lemma</span></span> cycle_free_antimono<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">⊆</span> edges <span class="free">g'</span> <span class="main">⟹</span> cycle_free <span class="free">g'</span> <span class="main">⟹</span> cycle_free <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> cycle_free_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cycle_free graph_empty"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> cycle_free_no_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> cycle_free <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cycle_freeI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> simple_path_cycle_free_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CF<span class="main">:</span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="free">u</span> <span class="free">p'</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="free">p'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> P 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="free">p'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> cycle_freeD<span class="main">[</span><span class="operator">OF</span> CF<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">e</span> <span class="skolem">p</span><span class="main">)</span>
  
  <span class="keyword1"><span class="command">note</span></span> CF <span class="main">=</span> cycle_freeD<span class="main">[</span><span class="operator">OF</span> CF<span class="main">]</span>
  
  <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> P'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_in_set_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    SP1<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
  <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u''</span></span> <span class="skolem"><span class="skolem">p''</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">p''</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> P''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u''</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p''</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Cons.prems<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> CF list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_in_set_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    SP2<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
    
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u''</span><span class="main">=</span><span class="skolem">u'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u''</span><span class="main">≠</span><span class="skolem">u'</span>"</span></span>
    
    <span class="keyword1"><span class="command">have</span></span> AUX1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> 
      <span class="keyword1"><span class="command">with</span></span> SP1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> CF <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>  
    
    <span class="keyword1"><span class="command">have</span></span> AUX2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> 
      
      <span class="keyword1"><span class="command">with</span></span> SP1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
        <span class="comment1">(* TODO: Do more explicit, like other AUXes*)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Cons.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Cons.prems<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> Un_iff 
        AUX1 <span class="quoted"><span class="quoted">‹<span class="skolem">e</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">u'</span><span class="main">)</span>›</span></span> insert_iff list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> 
        path.elims<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> path.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> prod.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> set_append simple_cons<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> CF <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>  
    
    <span class="keyword1"><span class="command">have</span></span> AUX3<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> 
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp'</span></span> <span class="skolem"><span class="skolem">sp''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="skolem">sp'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">sp''</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> SP2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> CF <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>    
    
    <span class="keyword1"><span class="command">have</span></span> AUX4<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> 
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp'</span></span> <span class="skolem"><span class="skolem">sp''</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="skolem">sp'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">@</span><span class="skolem">sp''</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> SP2 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> CF <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>    
    
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>revp <span class="skolem">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>set <span class="skolem">p</span><span class="main">)</span><span class="main">¯</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">from</span></span> SP1 SP2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u'</span> <span class="main">(</span><span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span>revp <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="skolem">u''</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">sp</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      SP<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u'</span> <span class="skolem">sp</span> <span class="skolem">u''</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">sp</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">sp</span> <span class="main">⊆</span> set <span class="skolem">sp<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> set <span class="main">(</span>revp <span class="skolem">sp<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> simplify_pathE<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u''</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>›</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u''</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym' <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> SP SP1 SP2 AUX1 AUX2 AUX3 AUX4 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">#</span><span class="skolem">sp</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u''</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 3 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> CF <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
  <span class="keyword1"><span class="command">qed</span></span>    

  <span class="keyword1"><span class="command">with</span></span> Cons.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">u'</span></span> <span class="quoted"><span class="skolem">p''</span></span><span class="main">]</span> Cons.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
<span class="keyword1"><span class="command">qed</span></span>    
  
              
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Characterization by Removing Edge›</span></span>      



<span class="keyword1"><span class="command">lemma</span></span> cycle_free_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">∈</span>edges <span class="free">g</span><span class="main">.</span> <span class="bound">e</span><span class="main">∉</span><span class="main">(</span>edges <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="bound">e</span><span class="main">,</span>prod.swap <span class="bound">e</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> edges_restrict_edges<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> u v <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> edges_restrict_edges<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rg</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="var">?rg</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="var">?rg</span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_edges_iff_path <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> simplify_pathE<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> unrestricte_path<span class="main">)</span> 
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">g</span>›</span></span> <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">u</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">u</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> path_edges<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> set <span class="main">(</span>map uedge <span class="skolem">p</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_eq_iff edges_restrict_edges<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹simple <span class="skolem">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple <span class="main">(</span><span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_eq_iff uedge_in_set_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹cycle_free <span class="free">g</span>›</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cycle_free_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword2"><span class="keyword">for</span></span> p u <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹path <span class="free">g</span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">u</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">#</span><span class="skolem">p'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">u</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹simple <span class="skolem">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p'</span>"</span></span> <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∉</span> set <span class="main">(</span>map uedge <span class="skolem">p'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_in_set_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹path <span class="free">g</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">u</span>›</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">g</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">u</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?rg</span> <span class="main">_</span> <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> path_graph_cong<span class="main">)</span> <span class="operator">auto</span>
      
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="var">?rg</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> path_rev rtrancl_edges_iff_path<span class="main">)</span>  
    <span class="keyword1"><span class="command">with</span></span> prems<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> cycle_free_altI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟧</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_alt <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span><span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> cycle_free_altD<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span><span class="main">(</span>edges <span class="free">g</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> cycle_free_alt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  


<span class="keyword1"><span class="command">lemma</span></span> remove_redundant_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">g</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⊆</span> <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Diff_subset rtrancl_mono<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⊆</span> <span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">then</span></span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
      <span class="keyword3"><span class="command">case</span></span> base
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">b</span> <span class="skolem">c</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">c</span><span class="main">)</span><span class="main">∈</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True

        <span class="keyword1"><span class="command">have</span></span> SYME<span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span><span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sym_rtrancl<span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> edges_sym<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sym_def<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> step.IH assms <span class="keyword1"><span class="command">have</span></span> 
          IH'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> symD<span class="main">)</span>
        
        <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms step.IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms IH' <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> symD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SYME<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> DiffI rtrancl.rtrancl_into_rtrancl step.IH step.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> 
        
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
  
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connected Graphs›</span></span>  
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">connected</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">connected</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">×</span> nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">⊆</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> connectedI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">u</span><span class="main">∈</span>nodes <span class="free">g</span><span class="main">;</span> <span class="bound">v</span><span class="main">∈</span>nodes <span class="free">g</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> connectedD<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">?</span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> connected_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected graph_empty"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Component Containing Node›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reachable_nodes</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">component_of</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> 
  <span class="main">≡</span> ins_node <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>restrict_nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span>reachable_nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_nodes_refl<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> reachable_nodes_step<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">``</span> reachable_nodes <span class="free">g</span> <span class="free">r</span> <span class="main">⊆</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_nodes_steps<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> reachable_nodes <span class="free">g</span> <span class="free">r</span> <span class="main">⊆</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_nodes_step'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">g</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> ImageI assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reachable_nodes_step rev_subsetD<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> component_of_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> reachable_nodes_steps'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> reachable_nodes_steps assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> converse_rtrancl_into_rtrancl reachable_nodes_step'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
   
<span class="keyword1"><span class="command">lemma</span></span> reachable_not_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∉</span>nodes <span class="free">g</span> <span class="main">⟹</span> reachable_nodes <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> converse_rtranclE <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nodesI<span class="main">)</span>
   
  
<span class="keyword1"><span class="command">lemma</span></span> nodes_of_component<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> component_of_def reachable_nodes_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rtranclE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> component_connected<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> connectedI<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> reachable_nodes <span class="free">g</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">r</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rtrancl_edges_sym'<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> reachable_nodes_steps'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> component_edges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span> <span class="main">⊆</span> edges <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> component_of_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> component_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> 
  path <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span> <span class="main">⟷</span> path <span class="free">g</span> <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> component_edges_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>     
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> reachable_nodes_step'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> component_cycle_free<span class="main">:</span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g</span> <span class="main">⟹</span> cycle_free <span class="main">(</span>component_of <span class="free">g</span> <span class="free">r</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> component_edges_subset cycle_free_antimono<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> component_of_connected_graph<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>connected <span class="free">g</span><span class="main">;</span> <span class="free">r</span><span class="main">∈</span>nodes <span class="free">g</span><span class="main">⟧</span> <span class="main">⟹</span> component_of <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> graph_eq_iff 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Image_singleton_iff nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reachable_nodes_def rtranclE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> connectedD reachable_nodes_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> component_of_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> connectedD reachable_nodes_def reachable_nodes_step'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> component_of_not_node<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∉</span>nodes <span class="free">g</span> <span class="main">⟹</span> component_of <span class="free">g</span> <span class="free">r</span> <span class="main">=</span> graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_eq_iff component_of_def reachable_not_node graph_accs<span class="main">)</span>

      
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Trees›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tree</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> connected <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∧</span> cycle_free <span class="free"><span class="bound"><span class="entity">g</span></span></span> "</span></span>    

<span class="keyword1"><span class="command">lemma</span></span> tree_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree graph_empty"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> component_of_tree<span class="main">:</span> <span class="quoted"><span class="quoted">"tree <span class="free">T</span> <span class="main">⟹</span> tree <span class="main">(</span>component_of <span class="free">T</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> tree_def <span class="keyword1"><span class="command">using</span></span> component_connected component_cycle_free <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Joining and Splitting Trees on Single Edge›</span></span>
      
<span class="keyword1"><span class="command">lemma</span></span> join_connected<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CONN<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IN_NODES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"connected <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"connected <span class="var">?g'</span>"</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="var">?g'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>nodes <span class="var">?g'</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> ESS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⊆</span> <span class="main">(</span>edges <span class="var">?g'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⊆</span> <span class="main">(</span>edges <span class="var">?g'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> edges_ins_edge_ss
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rtrancl_mono<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> UV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="var">?g'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_ins_edge r_into_rtrancl<span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="var">?g'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹connected <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>›</span></span> ESS<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹connected <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>›</span></span> ESS<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> connectedD<span class="main">[</span><span class="operator">OF</span> CONN<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> connectedD<span class="main">[</span><span class="operator">OF</span> CONN<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> ESS
      <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> UV IN_NODES contra_subsetD rtrancl_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> connectedD<span class="main">[</span><span class="operator">OF</span> CONN<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> connectedD<span class="main">[</span><span class="operator">OF</span> CONN<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> ESS
      <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> UV IN_NODES contra_subsetD rtrancl_edges_sym' rtrancl_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A IN_NODES <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    
<span class="keyword1"><span class="command">qed</span></span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> join_cycle_free<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> CYCF<span class="main">:</span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IN_NODES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="var">?g'</span>"</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> cycle_freeI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p</span> <span class="skolem">a</span>
  <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="var">?g'</span> <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> path_endpoints<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main"><span class="main">(</span></span></span>1<span class="main"><span class="main"><span class="main">,</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> IN_NODES 
    <span class="keyword1"><span class="command">have</span></span> A_NODE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∪</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> N1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p</span> <span class="main">⊆</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">×</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> 
      <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> find_crossing_edges_on_path<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> N1 N1<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">v<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹simple <span class="skolem">p</span>›</span></span> P
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> path_edges<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">v</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge uedge_in_set_eq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> DJ IntI IN_NODES empty_iff<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DJ IntI empty_iff nodesI uedge_eq_iff<span class="main">)</span>
        
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p</span> <span class="main">⊆</span> edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> DJ edges_subset path_edges<span class="main">[</span><span class="operator">OF</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> IN_NODES
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_graph_cong<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> cycle_freeD<span class="main">[</span><span class="operator">OF</span> CYCF<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> P<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> N2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p</span> <span class="main">⊆</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">×</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> 
      <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> find_crossing_edges_on_path<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> N2 N2<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">v<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">v<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">p<span class="hidden">⇩</span><sub>3</sub></span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹simple <span class="skolem">p</span>›</span></span> P
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> path_edges<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">v</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge uedge_in_set_eq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> DJ IntI IN_NODES empty_iff<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DJ IntI empty_iff nodesI uedge_eq_iff<span class="main">)</span>
        
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">p</span> <span class="main">⊆</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> DJ edges_subset path_edges<span class="main">[</span><span class="operator">OF</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> IN_NODES
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_ins_edge <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> P<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_graph_cong<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> cycle_freeD<span class="main">[</span><span class="operator">OF</span> CYCF<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> P<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1"><span class="command">lemma</span></span> join_trees<span class="main">:</span>     
  <span class="keyword2"><span class="keyword">assumes</span></span> TREE<span class="main">:</span> <span class="quoted"><span class="quoted">"tree <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"tree <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> DJ<span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IN_NODES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms join_cycle_free join_connected <span class="keyword1"><span class="command">unfolding</span></span> tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span> 
  
  
<span class="keyword1"><span class="command">lemma</span></span> split_tree<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tree <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">E'</span> <span class="main">≡</span> <span class="main">(</span>edges <span class="free">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">T1</span> <span class="free">T2</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"tree <span class="free">T1</span>"</span></span> <span class="quoted"><span class="quoted">"tree <span class="free">T2</span>"</span></span> 
    <span class="quoted"><span class="quoted">"nodes <span class="free">T1</span> <span class="main">∩</span> nodes <span class="free">T2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"nodes <span class="free">T</span> <span class="main">=</span> nodes <span class="free">T1</span> <span class="main">∪</span> nodes <span class="free">T2</span>"</span></span>
    <span class="quoted"><span class="quoted">"edges <span class="free">T1</span> <span class="main">∪</span> edges <span class="free">T2</span> <span class="main">=</span> <span class="free">E'</span>"</span></span>
    <span class="quoted"><span class="quoted">"nodes <span class="free">T1</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"nodes <span class="free">T2</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>nodes <span class="free">T1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈</span>nodes <span class="free">T2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="comment1">(* TODO: Use component_of here! *)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">N1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N1</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">N2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N2</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">}</span>"</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">T1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">T1</span> <span class="main">=</span> restrict_nodes <span class="free">T</span> <span class="skolem">N1</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">T2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">T2</span> <span class="main">=</span> restrict_nodes <span class="free">T</span> <span class="skolem">N2</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> SYME<span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sym_rtrancl<span class="main">)</span> 
    <span class="keyword1"><span class="command">using</span></span> edges_sym<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">T</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sym_def E'_def<span class="main">)</span>
  

  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="free">T</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹cycle_free <span class="free">T</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="skolem">T1</span>"</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="skolem">T2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> T1_def T2_def
    <span class="keyword1"><span class="command">using</span></span> cycle_free_antimono unrestrictn_edges <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">T</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> XYN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>nodes <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈</span>nodes <span class="free">T</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> edges_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> XYN <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T1</span> <span class="main">=</span> <span class="skolem">N1</span>"</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T2</span> <span class="main">=</span> <span class="skolem">N2</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> T1_def T2_def N1_def N2_def <span class="keyword1"><span class="command">unfolding</span></span> E'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹<span class="operator">clarsimp</span>›</span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffD1 nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rtrancl.simps<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span><span class="skolem">N1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈</span><span class="skolem">N2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N1_def N2_def<span class="main">)</span>   
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">N1</span> <span class="main">∩</span> <span class="skolem">N2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">N1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">N2</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N1_def N2_def symD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SYME<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> cycle_free_altD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹cycle_free <span class="free">T</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">T</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> 
      <span class="keyword1"><span class="command">unfolding</span></span> E'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> rtrancl_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  
  <span class="keyword1"><span class="command">have</span></span> N1C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E'</span><span class="main">``</span><span class="skolem">N1</span> <span class="main">⊆</span> <span class="skolem">N1</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> N1_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl.rtrancl_into_rtrancl<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> N2C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E'</span><span class="main">``</span><span class="skolem">N2</span> <span class="main">⊆</span> <span class="skolem">N2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> N2_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl.rtrancl_into_rtrancl<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> XE1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="skolem">T1</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">N1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> that <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span><span class="main">∈</span><span class="skolem">N1</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> T1_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> N1C <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span><span class="main">∈</span><span class="skolem">N1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span> step.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>Restr <span class="main">(</span>edges <span class="free">T</span><span class="main">)</span> <span class="skolem">N1</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> E'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> step.IH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span><span class="main">∈</span><span class="skolem">N1</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> converse_rtrancl_into_rtrancl edges_restrict_nodes<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    
  
  <span class="keyword1"><span class="command">have</span></span> XE2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>edges <span class="skolem">T2</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">N2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> that <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N2_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">y</span><span class="main">∈</span><span class="skolem">N2</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> T2_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> converse_rtrancl_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">y</span> <span class="skolem">z</span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> N2C <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span><span class="main">∈</span><span class="skolem">N2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> step.hyps<span class="main">(</span>1<span class="main">)</span> step.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>Restr <span class="main">(</span>edges <span class="free">T</span><span class="main">)</span> <span class="skolem">N2</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> E'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> step.IH<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">z</span><span class="main">∈</span><span class="skolem">N2</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> converse_rtrancl_into_rtrancl edges_restrict_nodes<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>    
  
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="skolem">T1</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> XE1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> rtrancl_edges_sym' rtrancl_trans<span class="main">)</span>      
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="skolem">T2</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> XE2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> rtrancl_edges_sym' rtrancl_trans<span class="main">)</span>      
   
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">N1</span> <span class="main">∪</span> <span class="skolem">N2</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>nodes <span class="free">T</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> connectedD<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹connected <span class="free">T</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span><span class="main">∈</span>nodes <span class="free">T</span>›</span></span> that <span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">T</span> <span class="free">x</span> <span class="skolem">p</span> <span class="skolem">u</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rtrancl_edges_iff_path <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> simplify_pathE<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span> <span class="main">∧</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> P<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">T</span> <span class="free">E'</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">p</span> <span class="skolem">u</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> E'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule_tac</span> path_graph_cong<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> path_rtrancl_edgesD<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> N1_def E'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span> <span class="main">∧</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∉</span>set <span class="skolem">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> P <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        <span class="quoted"><span class="quoted">"uedge <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∉</span>set <span class="main">(</span>map uedge <span class="skolem">p'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">T</span> <span class="free">y</span> <span class="skolem">p'</span> <span class="skolem">u</span> <span class="main">∨</span> path <span class="free">T</span> <span class="free">x</span> <span class="skolem">p'</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp uedge_commute<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="free">T</span> <span class="free">E'</span><span class="main">)</span> <span class="free">y</span> <span class="skolem">p'</span> <span class="skolem">u</span> <span class="main">∨</span> path <span class="main">(</span>restrict_edges <span class="free">T</span> <span class="free">E'</span><span class="main">)</span> <span class="free">x</span> <span class="skolem">p'</span> <span class="skolem">u</span>"</span></span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_in_set_eq E'_def<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> ComplD DiffI Int_iff UnCI edges_restrict_edges insertE 
                path_graph_cong subset_Compl_singleton subset_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> N1_def N2_def E'_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_rtrancl_edgesD<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nodes <span class="free">T</span> <span class="main">=</span> <span class="skolem">N1</span> <span class="main">∪</span> <span class="skolem">N2</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> N1_def N2_def <span class="keyword1"><span class="command">using</span></span> XYN
    <span class="keyword1"><span class="command">unfolding</span></span> E'_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffD1 nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rtrancl.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffD1 nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rtrancl.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">⊆</span> <span class="free">E'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> T1_def T2_def E'_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">N1</span> <span class="main">∩</span> <span class="skolem">N2</span> <span class="main">=</span> <span class="main">{}</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="skolem">N1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">∈</span> <span class="skolem">N2</span>›</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">⊇</span> <span class="free">E'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> ED1 <span class="main">=</span> nodesI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">T</span></span></span></span><span class="main">,</span> <span class="operator">unfolded</span> <span class="quoted"><span class="quoted"><span class="quoted">‹nodes <span class="free"><span class="free">T</span></span> <span class="main"><span class="main">=</span></span> <span class="skolem"><span class="skolem">N1</span></span><span class="main"><span class="main">∪</span></span><span class="skolem"><span class="skolem">N2</span></span>›</span></span></span><span class="main">]</span>  
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">E'</span> <span class="main">⊆</span> edges <span class="free">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> E'_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">⊇</span> <span class="free">E'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> T1_def T2_def
      <span class="keyword1"><span class="command">using</span></span> ED1 N1C N2C <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> 
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">=</span> <span class="free">E'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>  
          
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem">T1</span></span> <span class="quoted"><span class="skolem">T2</span></span><span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> tree_def<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Spanning Trees›</span></span>    
                                    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_spanning_tree</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> 
  <span class="main">≡</span> tree <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">∧</span> nodes <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">=</span> nodes <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">∧</span> edges <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⊆</span> edges <span class="free"><span class="bound"><span class="entity">G</span></span></span>"</span></span>    
  
<span class="comment1">(* TODO: Move *)</span>
<span class="keyword1"><span class="command">lemma</span></span> connected_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="main">(</span>ins_node <span class="free">u</span> graph_empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> connected_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> path_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>ins_node <span class="free">u</span> graph_empty<span class="main">)</span> <span class="free">v</span> <span class="free">p</span> <span class="free">w</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">=</span><span class="free">w</span> <span class="main">∧</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> tree_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree <span class="main">(</span>ins_node <span class="free">u</span> graph_empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cycle_free_no_edges tree_def<span class="main">)</span>

<span class="comment1">(* TODO: Move *)</span>
<span class="keyword1"><span class="command">lemma</span></span> tree_add_edge_in_out<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tree <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="free">T</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>nodes <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">T</span> <span class="main">=</span> ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_join <span class="free">T</span> <span class="main">(</span>ins_node <span class="free">v</span> graph_empty<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> join_trees<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Remove edges on cycles until the graph is cycle free›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> ex_spanning_tree<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"connected <span class="free">g</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">t</span><span class="main">.</span> is_spanning_tree <span class="free">g</span> <span class="bound">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> edges_finite<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> psubset
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"cycle_free <span class="skolem">g</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True 
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹connected <span class="skolem">g</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_spanning_tree_def tree_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
          EDGE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="skolem">g</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> RED<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges <span class="skolem">g</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> cycle_free_altI <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹connected <span class="skolem">g</span>›</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="main">(</span>restrict_edges <span class="skolem">g</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"connected <span class="var">?g'</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> connected_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_redundant_edge<span class="main"><span class="main">[</span></span><span class="operator">OF</span> RED<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="var">?g'</span> <span class="main">⊂</span> edges <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> EDGE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree <span class="var">?g'</span> <span class="skolem">t</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> psubset.hyps<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?g'</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree <span class="skolem">g</span> <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_spanning_tree_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Weighted Undirected Graphs›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weight</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> set <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> ugraph <span class="main">⇒</span> nat"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">weight</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span>uedge <span class="bound">e</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span>

  
<span class="keyword1"><span class="command">lemma</span></span> weight_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>uedge<span class="main">`</span>edges <span class="free">g</span><span class="main">.</span> <span class="free">w</span> <span class="bound">e</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> split_edges_sym<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">E</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">=</span> <span class="skolem">E</span> <span class="main">∪</span> <span class="skolem">E</span><span class="main">¯</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">E</span><span class="main">∩</span><span class="skolem">E</span><span class="main">¯</span><span class="main">=</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">E</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> edges_finite finite_Un<span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="skolem">E</span><span class="main">¯</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">E</span><span class="main">¯</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span>uedge <span class="bound">e</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">E</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span>uedge <span class="bound">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> sum.reindex_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> l<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">prod.swap</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> A<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">E</span><span class="main">¯</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="skolem">E</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def insert_commute<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on uedge <span class="skolem">E</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">E</span><span class="main">∩</span><span class="skolem">E</span><span class="main">¯</span><span class="main">=</span><span class="main">_</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def inj_on_def doubleton_eq_iff<span class="main">)</span>
        
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span><span class="skolem">E</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span>uedge <span class="bound">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> weight_def <span class="quoted"><span class="quoted">‹edges <span class="free">g</span> <span class="main">=</span> <span class="main">_</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">E</span><span class="main">∩</span><span class="skolem">E</span><span class="main">¯</span><span class="main">=</span><span class="main">{}</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.union_disjoint<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">e</span><span class="main">∈</span>uedge<span class="main">`</span><span class="skolem">E</span><span class="main">.</span> <span class="free">w</span> <span class="bound">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> sum.reindex<span class="main">[</span><span class="operator">of</span> <span class="quoted">uedge</span> <span class="quoted"><span class="skolem">E</span></span> <span class="quoted"><span class="free">w</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"uedge<span class="main">`</span><span class="skolem">E</span> <span class="main">=</span> uedge<span class="main">`</span><span class="main">(</span>edges <span class="free">g</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹edges <span class="free">g</span> <span class="main">=</span> <span class="main">_</span>›</span></span> uedge_def <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">E</span><span class="main">∩</span><span class="skolem">E</span><span class="main">¯</span><span class="main">=</span><span class="main">{}</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> weight_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> graph_empty <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> weight_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> weight_ins_edge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>edges <span class="free">g</span><span class="main">⟧</span> 
  <span class="main">⟹</span> weight <span class="free">w</span> <span class="main">(</span>ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span> <span class="main">+</span> weight <span class="free">w</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> weight_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sum.insert<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym' <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def insert_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> uedge_img_disj_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"uedge<span class="main">`</span>edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> uedge<span class="main">`</span>edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_eq_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> weight_join<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∩</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="main">{}</span> 
  <span class="main">⟹</span> weight <span class="free">w</span> <span class="main">(</span>graph_join <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> weight <span class="free">w</span> <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> weight <span class="free">w</span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> weight_alt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.union_disjoint image_Un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> weight_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> edges <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟹</span> weight <span class="free">w</span> <span class="free">g<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> weight <span class="free">w</span> <span class="free">g<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> weight_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> weight_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">⊆</span> edges <span class="free">g'</span> <span class="main">⟹</span> weight <span class="free">w</span> <span class="free">g</span> <span class="main">≤</span> weight <span class="free">w</span> <span class="free">g'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> weight_alt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum_mono2<span class="main">)</span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> weight_ge_edge<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="free">T</span> <span class="main">≥</span> <span class="free">w</span> <span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> weight_alt
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> member_le_sum<span class="main">)</span>
  
  
          
<span class="keyword1"><span class="command">lemma</span></span> weight_del_edge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">T</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="main">(</span>restrict_edges <span class="free">T</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> weight <span class="free">w</span> <span class="free">T</span> <span class="main">-</span> <span class="free">w</span> <span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">E</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">E</span> <span class="main">=</span> uedge <span class="main">`</span> edges <span class="free">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uedge <span class="main">`</span> <span class="main">(</span>edges <span class="free">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">E</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> E_def uedge_def doubleton_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">`</span> edges <span class="free">T</span> <span class="main">=</span> insert <span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span> <span class="skolem">E</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span><span class="main">∉</span><span class="skolem">E</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> E_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>        

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> weight_alt
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> E_def <span class="quoted"><span class="quoted">‹uedge <span class="main">`</span> edges <span class="free">T</span> <span class="main">=</span> insert <span class="main">{</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">}</span> <span class="skolem">E</span>›</span></span> insertI1 sum_diff1_nat<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    
  
        
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Minimum Spanning Trees›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_MST</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span> is_spanning_tree <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">t'</span><span class="main">.</span> is_spanning_tree <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">t'</span> <span class="main">⟶</span> weight <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≤</span> weight <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="bound">t'</span><span class="main">)</span>"</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> exists_MST<span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">g</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">t</span><span class="main">.</span> is_MST <span class="free">w</span> <span class="free">g</span> <span class="bound">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ex_has_least_nat<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"is_spanning_tree <span class="free">g</span>"</span></span><span class="main">]</span> ex_spanning_tree 
  <span class="keyword1"><span class="command">unfolding</span></span> is_MST_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Undirected_Graph_Specs">
<div class="head">
<h1>Theory Undirected_Graph_Specs</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract Graph Datatype›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Undirected_Graph_Specs
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Undirected_Graph.html">Undirected_Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Weighted Graph›</span></span>

<span class="keyword1"><span class="command">locale</span></span> adt_wgraph <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">αw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">αg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'v</span> ugraph"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">adj</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span>nat<span class="main">)</span> list"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'g</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'g</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adj_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> 
    <span class="main">⟹</span> set <span class="main">(</span><span class="free">adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span> <span class="main">∧</span> <span class="free">αw</span> <span class="free">g</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">empty</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">αg</span> <span class="free">empty</span> <span class="main">=</span> graph_empty"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">αw</span> <span class="free">empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> add_edge_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">invar</span> <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>edges <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">invar</span> <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>edges <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="free">αg</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">invar</span> <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>edges <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="free">αw</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">αw</span> <span class="free">g</span><span class="main">)</span><span class="main">(</span><span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span><span class="main">:=</span><span class="free">d</span><span class="main">)</span>"</span></span>
  
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> wgraph_specs <span class="main">=</span> adj_correct empty_correct add_edge_correct

<span class="keyword1"><span class="command">lemma</span></span> empty_spec_presentation<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">empty</span> <span class="main">∧</span> <span class="free">αg</span> <span class="free">empty</span> <span class="main">=</span> graph <span class="main">{}</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">αw</span> <span class="free">empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wgraph_specs<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> add_edge_spec_presentation<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">invar</span> <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>edges <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span>
    <span class="free">invar</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span>
  <span class="main">∧</span> <span class="free">αg</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="free">αg</span> <span class="free">g</span><span class="main">)</span>
  <span class="main">∧</span> <span class="free">αw</span> <span class="main">(</span><span class="free">add_edge</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">αw</span> <span class="free">g</span><span class="main">)</span><span class="main">(</span><span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span><span class="main">:=</span><span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wgraph_specs<span class="main">)</span>
    
<span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic From-List Algorithm›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_graph_repr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_graph_repr</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">.</span> <span class="bound">u</span><span class="main">≠</span><span class="bound">v</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">graph_from_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'v</span> ugraph"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_from_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> foldr ins_edge <span class="free"><span class="bound"><span class="entity">l</span></span></span> graph_empty"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> graph_from_list_foldl<span class="main">:</span> <span class="quoted"><span class="quoted">"graph_from_list <span class="free">l</span> <span class="main">=</span> fold ins_edge <span class="free">l</span> graph_empty"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> graph_from_list_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> foldr_fold<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> fun_cong<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff graph_eq_iff edges_ins_edge<span class="main">)</span>

  
<span class="keyword1"><span class="command">lemma</span></span> nodes_of_graph_from_list<span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>graph_from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> fst<span class="main">`</span>set <span class="free">l</span> <span class="main">∪</span> snd<span class="main">`</span>set <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_from_list_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> edges_of_graph_from_list<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_graph_repr <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"edges <span class="main">(</span>graph_from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> set <span class="free">l</span> <span class="main">∪</span> <span class="main">(</span>set <span class="free">l</span><span class="main">)</span><span class="main">¯</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> valid <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_from_list_def valid_graph_repr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>



<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_weight_repr</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> distinct <span class="main">(</span>map <span class="main">(</span>uedge <span class="keyword1">o</span> fst<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">weight_from_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span><span class="main">×</span>nat<span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">weight_from_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="bound">w</span><span class="main">.</span> <span class="bound">w</span><span class="main">(</span><span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span><span class="main">:=</span><span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> graph_from_list_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"graph_from_list <span class="main">[]</span> <span class="main">=</span> graph_empty"</span></span>
  <span class="quoted"><span class="quoted">"graph_from_list <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="main">=</span> ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_from_list <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_from_list_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> weight_from_list_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"weight_from_list <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>  
  <span class="quoted"><span class="quoted">"weight_from_list <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>weight_from_list <span class="free">xs</span><span class="main">)</span><span class="main">(</span><span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span><span class="main">:=</span><span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> weight_from_list_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> valid_graph_repr_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_graph_repr <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"valid_graph_repr <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">u</span><span class="main">≠</span><span class="free">v</span> <span class="main">∧</span> valid_graph_repr <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_graph_repr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> valid_weight_repr_simps<span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_weight_repr <span class="main">[]</span>"</span></span>  
  <span class="quoted"><span class="quoted">"valid_weight_repr <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="free">w</span><span class="main">)</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> 
    <span class="main">⟷</span> uedge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∉</span>uedge<span class="main">`</span>fst<span class="main">`</span>set <span class="free">xs</span> <span class="main">∧</span> valid_weight_repr <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> valid_weight_repr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def doubleton_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> weight_from_list_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_weight_repr <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weight_from_list <span class="free">l</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> valid_weight_repr_def weight_from_list_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> doubleton_eq_iff<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>    
    
  

<span class="keyword1"><span class="command">context</span></span> adt_wgraph 
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_wgraph_repr</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
  <span class="main">⟷</span> valid_graph_repr <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">∧</span> valid_weight_repr <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="free">add_edge</span> <span class="bound">e</span> <span class="bound">d</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free">empty</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> from_list_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_wgraph_repr <span class="free">l</span> <span class="main">⟹</span> 
    <span class="free">invar</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> 
  <span class="main">∧</span> <span class="free">αg</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> graph_from_list <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>
  <span class="main">∧</span> <span class="free">αw</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> weight_from_list <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> from_list_def valid_wgraph_repr_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> wgraph_specs graph_from_list_simps weight_from_list_simps
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span>
      <span class="operator">intro</span> conjI<span class="main"><span class="keyword3">;</span></span> 
      <span class="operator">clarsimp</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> uedge_def valid_graph_repr_simps valid_weight_repr_simps
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main"><span class="keyword3">;</span></span>
      <span class="operator">subst</span> wgraph_specs<span class="main"><span class="keyword3">;</span></span> 
      <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_of_graph_from_list
    <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">lemma</span></span> from_list_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_wgraph_repr <span class="free">l</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"nodes <span class="main">(</span><span class="free">αg</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fst<span class="main">`</span>fst<span class="main">`</span>set <span class="free">l</span> <span class="main">∪</span> snd<span class="main">`</span>fst<span class="main">`</span>set <span class="free">l</span>"</span></span>
    <span class="quoted"><span class="quoted">"edges <span class="main">(</span><span class="free">αg</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>fst<span class="main">`</span>set <span class="free">l</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>fst<span class="main">`</span>set <span class="free">l</span><span class="main">)</span><span class="main">¯</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">αw</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span> <span class="main">=</span> <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> from_list_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> valid_wgraph_repr_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 
      edges_of_graph_from_list nodes_of_graph_from_list weight_from_list_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> valid_wgraph_repr_presentation<span class="main">:</span> <span class="quoted"><span class="quoted">"valid_wgraph_repr <span class="free">l</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">.</span> <span class="bound">u</span><span class="main">≠</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> distinct <span class="main">[</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span>u<span class="main">,</span>v<span class="main">)</span><span class="main">,</span>d<span class="main">)</span><span class="main">←</span><span class="free">l</span> <span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uedge <span class="main">∘</span> fst <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> uedge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> valid_wgraph_repr_def valid_graph_repr_def valid_weight_repr_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
    
<span class="keyword1"><span class="command">lemma</span></span> from_list_correct_presentation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_wgraph_repr <span class="free">l</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="bound">gi</span><span class="main">=</span>from_list <span class="free">l</span><span class="main">;</span> <span class="bound">g</span><span class="main">=</span><span class="free">αg</span> <span class="bound">gi</span><span class="main">;</span> <span class="bound">w</span><span class="main">=</span><span class="free">αw</span> <span class="bound">gi</span> <span class="keyword1">in</span>
      <span class="free">invar</span> <span class="bound">gi</span> 
    <span class="main">∧</span> nodes <span class="bound">g</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">{</span><span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">∃</span><span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">}</span>
    <span class="main">∧</span> edges <span class="bound">g</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">{</span><span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">}</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="main">∃</span><span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">}</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">.</span> <span class="bound">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span><span class="main">=</span><span class="bound">d</span><span class="main">)</span>
  "</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> Let_def from_list_correct<span class="main">(</span>2-3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> from_list_correct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 0 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 0 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> from_list_correct<span class="main">(</span>4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Prim_Abstract">
<div class="head">
<h1>Theory Prim_Abstract</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract Prim Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Prim_Abstract
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../../HOL/HOL/Main.html">Main</a> 
  <a href="Common.html">Common</a>
  <a href="Undirected_Graph.html">Undirected_Graph</a>
  <span class="quoted">"<a href="../../HOL/HOL-Eisbach/Eisbach.html">HOL-Eisbach.Eisbach</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic Algorithm: Light Edges\label{sec:generic_mst}›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_subset_MST</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">t</span><span class="main">.</span> is_MST <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">t</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊆</span> edges <span class="bound">t</span>"</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> is_subset_MST_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected <span class="free">g</span> <span class="main">⟹</span> is_subset_MST <span class="free">w</span> <span class="free">g</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> exists_MST <span class="keyword1"><span class="command">unfolding</span></span> is_subset_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a start node and a weighted graph›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Prim <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Reachable part of the graph›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rg</span> <span class="main">≡</span> component_of <span class="free">g</span> <span class="free">r</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> reachable_connected<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"connected rg"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> rg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> reachable_edges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"edges rg <span class="main">⊆</span> edges <span class="free">g</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> rg_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> component_edges_subset<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">light_edge</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
  <span class="main">≡</span>   <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∉</span><span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">∈</span>edges rg 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">×</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">.</span> <span class="free">w</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u'</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span>"</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">respects_cut</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">∪</span> <span class="main">(</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span><span class="main">×</span><span class="main">(</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span>"</span></span>
    
<span class="keyword1"><span class="command">lemma</span></span> light_edge_is_safe<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">C</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> subset_MST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_subset_MST <span class="free">w</span> rg <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> respects_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"respects_cut <span class="free">A</span> <span class="free">C</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> light_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"light_edge <span class="free">C</span> <span class="free">u</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_subset_MST <span class="free">w</span> rg <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> crossing_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> min_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">∩</span> <span class="free">C</span><span class="main">×</span><span class="main">-</span><span class="free">C</span><span class="main">.</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u'</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> light_edge <span class="keyword1"><span class="command">unfolding</span></span> light_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> subset_MST <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T</span></span> <span class="keyword2"><span class="keyword">where</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="skolem">T</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> edges <span class="skolem">T</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> is_subset_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"tree <span class="skolem">T</span>"</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T</span> <span class="main">⊆</span> edges rg"</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T</span> <span class="main">=</span> nodes rg"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_MST_def is_spanning_tree_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"connected <span class="skolem">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tree_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">T</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_subset_MST_def <span class="keyword1"><span class="command">using</span></span> T <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∉</span> edges <span class="skolem">T</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∉</span>edges <span class="skolem">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="skolem">T</span> <span class="free">u</span> <span class="skolem">p</span> <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"simple <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> connectedD <span class="quoted"><span class="quoted">‹connected <span class="skolem">T</span>›</span></span> <span class="quoted"><span class="quoted">‹nodes <span class="skolem">T</span> <span class="main">=</span> nodes rg›</span></span> nodesI 
          rtrancl_edges_iff_path simplify_pathE<span class="main">)</span>
      
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> crossing_edge <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      
    <span class="keyword1"><span class="command">from</span></span> find_crossing_edge_on_path<span class="main">[</span><span class="operator">OF</span> p<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∉</span><span class="free">C</span>"</span></span><span class="main">]</span> 
         crossing_edge<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span> xy<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">C</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="free">C</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> ux<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="skolem">T</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="free">u</span> <span class="skolem">p1</span> <span class="skolem">x</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> yv<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>restrict_edges <span class="skolem">T</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="skolem">y</span> <span class="skolem">p2</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> path_change<span class="main">[</span><span class="operator">OF</span> crossing_edge<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> p<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">T</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> contra_subsetD p<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> path_edges xy<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span><span class="main">}</span>"</span></span>
      
    <span class="keyword1"><span class="command">from</span></span> split_tree<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹tree <span class="skolem">T</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="skolem">T</span>›</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T1</span></span> <span class="skolem"><span class="skolem">T2</span></span> <span class="keyword2"><span class="keyword">where</span></span> T12<span class="main">:</span> 
        <span class="quoted"><span class="quoted">"tree <span class="skolem">T1</span>"</span></span> <span class="quoted"><span class="quoted">"tree <span class="skolem">T2</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T1</span> <span class="main">∩</span> nodes <span class="skolem">T2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T</span> <span class="main">=</span> nodes <span class="skolem">T1</span> <span class="main">∪</span> nodes <span class="skolem">T2</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">=</span> <span class="var">?E'</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T1</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span> <span class="main">.</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">T2</span> <span class="main">=</span> <span class="main">{</span> <span class="bound">u</span> <span class="main">.</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">∈</span><span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span>nodes <span class="skolem">T1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span>nodes <span class="skolem">T2</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?T'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ins_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">(</span>graph_join <span class="skolem">T1</span> <span class="skolem">T2</span><span class="main">)</span>"</span></span>    

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree rg <span class="var">?T'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      
      <span class="keyword1"><span class="command">have</span></span> E'_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"sym <span class="main">(</span><span class="var">?E'</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> edgesT_diff_sng_inv_eq sym_conv_converse_eq sym_rtrancl<span class="main">)</span>
      
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>nodes <span class="skolem">T1</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹nodes <span class="skolem">T1</span> <span class="main">=</span> <span class="main">_</span>›</span></span>
        <span class="keyword1"><span class="command">using</span></span> path_rtrancl_edgesD<span class="main">[</span><span class="operator">OF</span> ux<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> symD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> E'_sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
        
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>nodes <span class="skolem">T2</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted"><span class="quoted">‹nodes <span class="skolem">T2</span> <span class="main">=</span> <span class="main">_</span>›</span></span>
        <span class="keyword1"><span class="command">using</span></span> path_rtrancl_edgesD<span class="main">[</span><span class="operator">OF</span> yv<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
              
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"tree <span class="var">?T'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> join_trees<span class="main">)</span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree rg <span class="var">?T'</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> is_spanning_tree_def
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹nodes <span class="skolem">T</span> <span class="main">=</span> nodes rg›</span></span> <span class="quoted"><span class="quoted">‹nodes <span class="skolem">T</span> <span class="main">=</span> nodes <span class="skolem">T1</span> <span class="main">∪</span> nodes <span class="skolem">T2</span>›</span></span><span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹tree <span class="var">?T'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">v</span>›</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">T</span> <span class="main">⊆</span> edges rg›</span></span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">=</span> <span class="var">?E'</span>›</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset crossing_edge<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> edges_sym' insert_absorb 
              nodesI<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> subset_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> 
      
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="var">?T'</span> <span class="main">≤</span> weight <span class="free">w</span> <span class="skolem">T'</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree rg <span class="skolem">T'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">T'</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> ww<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span> <span class="main">≤</span> <span class="free">w</span><span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> min_edge <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="skolem">T</span>›</span></span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">T</span> <span class="main">⊆</span> edges rg›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∈</span><span class="free">C</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">∉</span><span class="free">C</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="var">?T'</span> <span class="main">=</span> weight <span class="free">w</span> <span class="skolem">T</span> <span class="main">-</span> <span class="free">w</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span> <span class="main">+</span> <span class="free">w</span><span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∉</span> edges <span class="skolem">T</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> edges <span class="skolem">T</span>›</span></span> 
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">=</span> edges <span class="skolem">T</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span><span class="main">}</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span> <span class="main">≠</span> <span class="free">v</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Diff_eq Diff_subset add.commute contra_subsetD edges_join 
              edges_restrict_edges minus_inv_sym_aux sup.idem weight_cong 
              weight_del_edge weight_ins_edge<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> weight <span class="free">w</span> <span class="skolem">T</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> weight_ge_edge<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>edges <span class="skolem">T</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">w</span></span><span class="main">]</span> ww <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"weight <span class="free">w</span> <span class="skolem">T</span> <span class="main">≤</span> weight <span class="free">w</span> <span class="skolem">T'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> T<span class="main">(</span>1<span class="main">)</span> <span class="quoted"><span class="quoted">‹is_spanning_tree rg <span class="skolem">T'</span>›</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> is_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="var">?T'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> is_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="free">A</span> <span class="main">⊆</span> edges <span class="var">?T'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> T<span class="main">(</span>2<span class="main">)</span> respects_cut xy<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">T1</span> <span class="main">∪</span> edges <span class="skolem">T2</span> <span class="main">=</span> <span class="var">?E'</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> respects_cut_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹is_MST <span class="free">w</span> rg <span class="var">?T'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_subset_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>        

<span class="keyword2"><span class="keyword">end</span></span>    
   
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Prim: Growing a Tree\label{sec:prim_algo}›</span></span>
<span class="keyword1"><span class="command">context</span></span> Prim <span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The current nodes›</span></span> 
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">∪</span> fst<span class="main">`</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∪</span> snd<span class="main">`</span><span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> respects_cut'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> S <span class="free">A</span> <span class="main">×</span> S <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">corollary</span></span> respects_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"respects_cut <span class="free">A</span> <span class="main">(</span>S <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> respects_cut_def <span class="keyword1"><span class="command">using</span></span> respects_cut' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Refined invariant: Adds connectedness of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>A›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_invar1</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> is_subset_MST <span class="free">w</span> rg <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Measure: Number of nodes not in tree›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T_measure1</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> card <span class="main">(</span>nodes rg <span class="main">-</span> S <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We use a locale that fixes a state and assumes the invariant›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Prim_Invar1_loc <span class="main">=</span> 
  Prim <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="free">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar1<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="free">A</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> subset_MST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_subset_MST <span class="free">w</span> rg <span class="free">A</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> invar1 <span class="keyword1"><span class="command">unfolding</span></span> prim_invar1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> A_connected<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">A</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span><span class="free">A</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> invar1 <span class="keyword1"><span class="command">unfolding</span></span> prim_invar1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> S_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"S <span class="free">A</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">∪</span> fst<span class="main">`</span><span class="free">A</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> S_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> A_connected Domain_fst Not_Domain_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_rem_nodes<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nodes rg <span class="main">-</span> S <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> A_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> edges <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> subset_MST
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> is_MST_def is_spanning_tree_def is_subset_MST_def 
        reachable_edges_subset subset_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> S_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"S <span class="free">A</span> <span class="main">⊆</span> nodes rg"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> DomainE Un_insert_left fst_eq_Domain insert_subset is_MST_def 
        is_spanning_tree_def is_subset_MST_def nodesI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nodes_of_component 
        reachable_nodes_refl rg_def subset_MST subset_iff sup_bot.left_neutral<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> S_edge_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span><span class="main">∈</span>S <span class="free">A</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> S_reachable <span class="keyword1"><span class="command">unfolding</span></span> rg_def
  <span class="keyword1"><span class="command">using</span></span> reachable_nodes_step'<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    
<span class="keyword1"><span class="command">lemma</span></span> edges_S_rg_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">∩</span> S <span class="free">A</span><span class="main">×</span><span class="main">-</span>S <span class="free">A</span> <span class="main">=</span> edges rg <span class="main">∩</span> S <span class="free">A</span><span class="main">×</span><span class="main">-</span>S <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> S_edge_reachable reachable_edges_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
<span class="keyword1"><span class="command">lemma</span></span> T_measure1_less<span class="main">:</span> <span class="quoted"><span class="quoted">"T_measure1 <span class="free">A</span> <span class="main">&lt;</span> card <span class="main">(</span>nodes rg<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> T_measure1_def S_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset S_def S_reachable Un_insert_left le_supE nodes_finite 
        psubsetI psubset_card_mono singletonI subset_Diff_insert<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> finite_A<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> A_edges finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> finite_S<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>S <span class="free">A</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> S_reachable rev_finite_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* TODO: Used? *)</span>
<span class="keyword1"><span class="command">lemma</span></span> S_A_consistent<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes_edges_consistent <span class="main">(</span>S <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">A</span><span class="main">∪</span><span class="free">A</span><span class="main">¯</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nodes_edges_consistent_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> A_edges irrefl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sym_Un_converse<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> respects_cut' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
      
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> Prim <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invar1_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_subset_MST_def prim_invar1_def exists_MST<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> maintain_invar1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> light_edge<span class="main">:</span> <span class="quoted"><span class="quoted">"light_edge <span class="main">(</span>S <span class="free">A</span><span class="main">)</span> <span class="free">u</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">∪</span><span class="free">A</span><span class="main">)</span> 
       <span class="main">∧</span> T_measure1 <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">∪</span><span class="free">A</span><span class="main">)</span> <span class="main">&lt;</span> T_measure1 <span class="free">A</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span> <span class="main">∧</span> <span class="var">?G2</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>

  <span class="keyword1"><span class="command">from</span></span> invar <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">from</span></span> light_edge <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>S <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>S <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> light_edge_def<span class="main">)</span>
      
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar1_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"is_subset_MST <span class="free">w</span> rg <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> light_edge_is_safe<span class="main"><span class="main">[</span></span><span class="operator">OF</span> subset_MST respects_cut light_edge<span class="main"><span class="main">]</span></span><span class="main">)</span>
      
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">ua</span><span class="main">,</span> <span class="bound">va</span><span class="main">)</span><span class="main">∈</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="free">A</span><span class="main">.</span> <span class="main">(</span><span class="bound">va</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">using</span></span> A_connected
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_insert<span class="main">)</span> 
           <span class="main">(</span><span class="operator">metis</span> DomainE S_alt_def converse_rtrancl_into_rtrancl <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>S <span class="free">A</span>›</span></span> 
                    fst_eq_Domain insertE insert_is_Un rtrancl_eq_or_trancl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> A_connected <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtrancl_insert<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> N<span class="main">:</span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">∪</span><span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"S <span class="free">A</span> <span class="main">⊂</span> S <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">}</span><span class="main">∪</span><span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∉</span>S <span class="free">A</span>›</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G2</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> T_measure1_def
    <span class="keyword1"><span class="command">using</span></span> S_reachable N.S_reachable
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> psubset_card_mono<span class="main">)</span>

<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> invar1_finish<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">∩</span> S <span class="free">A</span><span class="main">×</span><span class="main">-</span>S <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="main">(</span>graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">from</span></span> subset_MST <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> MST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="skolem">t</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> edges <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_subset_MST_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"S <span class="free">A</span> <span class="main">=</span> nodes <span class="skolem">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>S <span class="free">A</span> <span class="main">⟹</span> <span class="skolem">u</span><span class="main">∈</span>nodes <span class="skolem">t</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> MST
      <span class="keyword1"><span class="command">unfolding</span></span> is_MST_def is_spanning_tree_def
      <span class="keyword1"><span class="command">using</span></span> S_reachable <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>nodes <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>nodes rg"</span></span>
      <span class="keyword1"><span class="command">using</span></span> MST is_MST_def is_spanning_tree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>edges rg<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> connectedD rg_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span><span class="main">∈</span>S <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>S <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span>S <span class="free">A</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> find_crossing_edge_rtrancl<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span><span class="main">∈</span>S <span class="free">A</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> 1 <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span>S <span class="free">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">r</span><span class="main">∈</span>S <span class="free">A</span>›</span></span><span class="main">]</span> 
        FIN reachable_edges_subset 
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> ComplI IntI contra_subsetD edges_sym' emptyE mem_Sigma_iff<span class="main">)</span>
        
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">t</span> <span class="main">=</span> nodes rg"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> MST <span class="keyword1"><span class="command">unfolding</span></span> is_MST_def is_spanning_tree_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> S_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"S <span class="free">A</span> <span class="main">=</span> nodes rg"</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">t'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t'</span> <span class="main">=</span> graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="free">A</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">t'</span> <span class="main">=</span> S <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Et'<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="skolem">t'</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span><span class="main">∪</span><span class="free">A</span><span class="main">¯</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> t'_def 
    <span class="keyword1"><span class="command">using</span></span> A_edges
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs S_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">t'</span> <span class="main">⊆</span> edges <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> UnE <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">⊆</span> edges <span class="skolem">t</span>›</span></span> converseD edges_sym' subrelI subset_eq<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_spanning_tree rg <span class="skolem">t'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"connected <span class="skolem">t'</span>"</span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Et' S_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_connected converse_rtrancl_into_rtrancl 
                        in_rtrancl_UnI rtrancl_converse
             <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">meson</span> A_connected in_rtrancl_UnI r_into_rtrancl 
                rtrancl_converseI rtrancl_trans
             <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cycle_free <span class="skolem">t'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> MST <span class="quoted"><span class="quoted">‹edges <span class="skolem">t'</span> <span class="main">⊆</span> edges <span class="skolem">t</span>›</span></span> cycle_free_antimono is_MST_def 
                is_spanning_tree_def tree_def<span class="main">)</span>      
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"edges <span class="skolem">t'</span> <span class="main">⊆</span> edges rg"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> MST <span class="quoted"><span class="quoted">‹edges <span class="skolem">t'</span> <span class="main">⊆</span> edges <span class="skolem">t</span>›</span></span> dual_order.trans is_MST_def 
            is_spanning_tree_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_spanning_tree_def tree_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> S_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>                              
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> MST weight_mono<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹edges <span class="skolem">t'</span> <span class="main">⊆</span> edges <span class="skolem">t</span>›</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> t'_def is_MST_def 
    <span class="keyword1"><span class="command">using</span></span> dual_order.trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>    
        
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Prim: Using a Priority Queue\label{sec:using_pq}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a new locale. Note that we could also reuse <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">locale</span></span> Prim<span class="antiquote"><span class="antiquote">}</span></span></span></span>, however,
  this would complicate referencing the constants later in the theories from 
  which we generate the paper.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Prim2 <span class="main">=</span> Prim <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> ugraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Abstraction to edge set›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">u</span> <span class="main">=</span> <span class="main">∞</span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initialization›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initQ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> enat"</span></span>  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initQ</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initπ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> option"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initπ</span> <span class="main">≡</span> Map.empty"</span></span>  


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Step›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">upd_cond</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">≡</span> 
    <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">g</span> 
  <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">≠</span><span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">=</span> None<span class="main">)</span>
  <span class="main">∧</span> enat <span class="main">(</span><span class="free">w</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹State after inner loop›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Qinter</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> 
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> upd_cond <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="keyword1">then</span> enat <span class="main">(</span><span class="free">w</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹State after one step›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q'</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="main">(</span>Qinter <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">:=</span><span class="main">∞</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">π'</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> upd_cond <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="keyword1">then</span> Some <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_invar2_init</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">=</span>initQ <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">=</span>initπ"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_invar2_ctd</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">A</span> <span class="main">=</span> A <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">;</span> <span class="bound">S</span> <span class="main">=</span> S <span class="bound">A</span> <span class="keyword1">in</span>
  prim_invar1 <span class="bound">A</span>
<span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free">r</span> <span class="main">=</span> None <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span>  
<span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">∩</span> <span class="main">(</span><span class="main">-</span><span class="bound">S</span><span class="main">)</span><span class="main">×</span><span class="bound">S</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">∞</span><span class="main">)</span>
<span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="bound">u</span> <span class="main">≠</span> None<span class="main">)</span>
<span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">⟶</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">S</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges rg<span class="main">)</span>
<span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">d</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="bound">u</span> <span class="main">=</span> enat <span class="bound">d</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> 
      <span class="main">⟶</span> <span class="bound">d</span><span class="main">=</span><span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span><span class="bound">S</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">⟶</span> <span class="bound">d</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>  
"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prim_invar2_ctd_alt_aux1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">r</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"A <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prim_invar2_ctd_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span> <span class="main">⟷</span> <span class="main">(</span>
  <span class="keyword1">let</span> <span class="bound">A</span> <span class="main">=</span> A <span class="free">Q</span> <span class="free">π</span><span class="main">;</span> <span class="bound">S</span> <span class="main">=</span> S <span class="bound">A</span><span class="main">;</span> <span class="bound">cE</span><span class="main">=</span>edges rg <span class="main">∩</span> <span class="main">(</span><span class="main">-</span><span class="bound">S</span><span class="main">)</span><span class="main">×</span><span class="bound">S</span> <span class="keyword1">in</span>
    prim_invar1 <span class="bound">A</span>
  <span class="main">∧</span> <span class="free">π</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">∧</span> <span class="free">Q</span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span>  
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="bound">cE</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">∞</span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">⟶</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">S</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges rg<span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">d</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">u</span> <span class="main">=</span> enat <span class="bound">d</span> 
      <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="bound">d</span><span class="main">=</span><span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span><span class="bound">cE</span> <span class="main">⟶</span> <span class="bound">d</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_ctd_def Let_def
  <span class="keyword1"><span class="command">using</span></span> prim_invar2_ctd_alt_aux1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">π</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 3<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 3<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span>lifting<span class="main"><span class="main">)</span></span> option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_invar2</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">≡</span> prim_invar2_init <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">∨</span> prim_invar2_ctd <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T_measure2</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> 
  <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span> <span class="keyword1">then</span> T_measure1 <span class="main">(</span>A <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">)</span> <span class="keyword1">else</span> card <span class="main">(</span>nodes rg<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> Q'_init_eq<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Q' initQ initπ <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="keyword1">then</span> enat <span class="main">(</span><span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="free">r</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> 
  <span class="keyword1"><span class="command">using</span></span> reachable_edges_subset
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q'_def Qinter_def upd_cond_def initQ_def initπ_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Prim.rg_def edges_sym' reachable_nodes_step'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> π'_init_eq<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"π' initQ initπ <span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="free">r</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="keyword1">then</span> Some <span class="free">r</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> 
  <span class="keyword1"><span class="command">using</span></span> reachable_edges_subset
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> π'_def upd_cond_def initQ_def initπ_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Prim.rg_def edges_sym' reachable_nodes_step'<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> A_init_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"A initQ initπ <span class="main">=</span> <span class="main">{}</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> A_def initπ_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> S_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"S <span class="main">{}</span> <span class="main">=</span> <span class="main">{</span><span class="free">r</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> A_init_eq<span class="main">)</span>
      
<span class="keyword1"><span class="command">lemma</span></span> maintain_invar2_first_step<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_init <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">=</span>initQ"</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span><span class="main">=</span>initπ"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_init_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> UNS <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> initQ_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span> 
    
    
  <span class="keyword1"><span class="command">note</span></span> Q'_init_eq π'_init_eq A_init_eq 
    
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>A <span class="main">(</span>Q' initQ initπ <span class="free">r</span><span class="main">)</span> <span class="main">(</span>π' initQ initπ <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q'_init_eq π'_init_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> A_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prim_invar2_ctd_def Let_def invar1_initial<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q'_init_eq π'_init_eq S_empty <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Q' initQ initπ <span class="free">r</span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q'_init_eq<span class="main">)</span>
    
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"initQ <span class="free">r</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initQ_def<span class="main">)</span> 
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> T_measure2_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> T_measure1_def S_empty<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_Diff1_less nodes_finite nodes_of_component 
          reachable_nodes_refl rg_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword1"><span class="command">lemma</span></span> maintain_invar2_first_step_presentation<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_init <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>
       <span class="main">∧</span> T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> maintain_invar2_first_step assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="comment1">(*
  This locale is only used to present the invariant in the paper.
*)</span>
<span class="keyword1"><span class="command">locale</span></span> Prim_Invar2_ctd_Presentation_Loc <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w</span> <span class="free">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q</span> <span class="free">π</span> <span class="free">A</span> <span class="free">S</span> <span class="free">rg</span> <span class="free">cE</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"Prim2.prim_invar2_ctd <span class="free">w</span> <span class="free">g</span> <span class="free">r</span> <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> local_A_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≡</span> Prim2.A <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> local_S_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≡</span> Prim.S <span class="free">r</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> local_rg_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rg</span> <span class="main">≡</span> Prim.rg <span class="free">g</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> local_cE_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cE</span> <span class="main">≡</span> edges <span class="free">rg</span> <span class="main">∩</span> <span class="main">(</span><span class="main">-</span><span class="free">S</span><span class="main">)</span><span class="main">×</span><span class="free">S</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> 
      invar1<span class="main">:</span> <span class="quoted"><span class="quoted">"Prim.prim_invar1 <span class="free">w</span> <span class="free">g</span> <span class="free">r</span> <span class="free">A</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> root_contained<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">r</span> <span class="main">=</span> None <span class="main">∧</span> <span class="free">Q</span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Q_defined<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free">cE</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">u</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> π_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">⟶</span> <span class="bound">v</span><span class="main">∈</span><span class="free">S</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">rg</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G4</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> Q_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span> <span class="bound">d</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">u</span> <span class="main">=</span> enat <span class="bound">d</span> 
      <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="bound">d</span><span class="main">=</span><span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span><span class="free">cE</span> <span class="main">⟶</span> <span class="bound">d</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G5</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Prim2 <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="keyword1"><span class="command">.</span></span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span> <span class="var"><span class="quoted"><span class="var">?G4</span></span></span> <span class="var"><span class="quoted"><span class="var">?G5</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> I
    <span class="keyword1"><span class="command">unfolding</span></span> local_A_def local_S_def local_rg_def local_cE_def 
              prim_invar2_ctd_alt Let_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Prim2<span class="main">)</span> Prim_Invar2_ctd_Presentation_Loc_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Prim_Invar2_ctd_Presentation_Loc <span class="free">w</span> <span class="free">g</span> <span class="free">r</span> <span class="free">Q</span> <span class="free">π</span> <span class="main">⟷</span> prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Prim_Invar2_ctd_Presentation_Loc_def <span class="keyword1"><span class="command">..</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Again, we define a locale to fix a state and assume the invariant›</span></span> 
<span class="keyword1"><span class="command">locale</span></span> Prim_Invar2_ctd_loc <span class="main">=</span>   
  Prim2 <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="free">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Q</span> <span class="free">π</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> invar2<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="quoted">"A <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> invar2 <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_ctd_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> upd_cond_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"upd_cond <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">v'</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">u</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">g</span> <span class="main">∧</span> <span class="free">v'</span><span class="main">∉</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span> <span class="main">∧</span> enat <span class="main">(</span><span class="free">w</span> <span class="main">{</span><span class="free">v'</span><span class="main">,</span><span class="free">u</span><span class="main">}</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">Q</span> <span class="free">v'</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> upd_cond_def S_alt_def <span class="keyword1"><span class="command">unfolding</span></span> A_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fst_eq_Domain<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> π_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">r</span> <span class="main">=</span> None"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q_root<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">r</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> Q_defined<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg<span class="main">;</span> <span class="free">u</span><span class="main">∉</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">;</span> <span class="free">v</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> π_defined<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">∞</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">π</span> <span class="free">u</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> frontier<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">v</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> edges<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">v</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Q_π_consistent<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span><span class="main">;</span> <span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">v</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">d</span> <span class="main">=</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> Q_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span> 
      <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">⟶</span> <span class="free">d</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="bound">v'</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> invar2 <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_ctd_def Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> π_def_on_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">r</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">π</span> <span class="free">u</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def
  <span class="keyword1"><span class="command">unfolding</span></span> A_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  
<span class="keyword1"><span class="command">lemma</span></span> π_def_on_edges_to_S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span><span class="main">≠</span><span class="free">r</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>edges rg<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">π</span> <span class="free">u</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> π_def_on_S <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q_defined π_defined<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> Q_min_is_light<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">v</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"light_edge <span class="main">(</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"A <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"S <span class="var">?A</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> UNS <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    S1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">=</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> π_defined Q_π_consistent 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
          
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> frontier<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> π_root <span class="keyword1"><span class="command">using</span></span> S1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> S1<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span><span class="var">?S</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> UNS <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span> <span class="keyword1"><span class="command">using</span></span> edges<span class="main">[</span><span class="operator">OF</span> S1<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> edges_sym' rev_subsetD<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">u'</span><span class="main">,</span> <span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges rg <span class="main">∩</span> <span class="var">?S</span> <span class="main">×</span> <span class="main">-</span> <span class="var">?S</span><span class="main">.</span> <span class="free">w</span> <span class="main">{</span><span class="skolem">v</span><span class="main">,</span> <span class="free">u</span><span class="main">}</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="bound">u'</span><span class="main">,</span> <span class="bound">v'</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∉</span><span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">)</span><span class="main">∈</span>edges rg"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
  
    <span class="keyword1"><span class="command">from</span></span> Q_defined<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">)</span><span class="main">∈</span>edges rg›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">b</span><span class="main">∉</span><span class="var">?S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">∈</span><span class="var">?S</span>›</span></span><span class="main">]</span> 
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="skolem">b</span> <span class="main">=</span> enat <span class="skolem">d'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
    <span class="keyword1"><span class="command">with</span></span> π_defined <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="skolem">b</span> <span class="main">=</span> Some <span class="skolem">a'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> MIN 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span><span class="main">≤</span><span class="skolem">d'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_ord_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Q_min<span class="main">[</span><span class="operator">OF</span> 1<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">)</span><span class="main">∈</span>edges rg›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">∈</span><span class="var">?S</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d'</span><span class="main">≤</span><span class="free">w</span> <span class="main">{</span><span class="skolem">b</span><span class="main">,</span><span class="skolem">a</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">{</span><span class="skolem">v</span><span class="main">,</span><span class="free">u</span><span class="main">}</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">{</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>  

  <span class="keyword1"><span class="command">have</span></span> LE<span class="main">:</span> <span class="quoted"><span class="quoted">"light_edge <span class="var">?S</span> <span class="skolem">v</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> invar1 <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="var">?S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="var">?S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>edges rg›</span></span> M
    <span class="keyword1"><span class="command">unfolding</span></span> light_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1"><span class="command">lemma</span></span> maintain_invar_ctd<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"A <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"S <span class="var">?A</span>"</span></span>

  <span class="keyword1"><span class="command">from</span></span> Q_min_is_light<span class="main">[</span><span class="operator">OF</span> UNS MIN<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> LE<span class="main">:</span> <span class="quoted"><span class="quoted">"light_edge <span class="var">?S</span> <span class="skolem">v</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Q'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?π'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"A <span class="var">?Q'</span> <span class="var">?π'</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"S <span class="var">?A'</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> NA<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A'</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="var">?A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> A_def  
    <span class="keyword1"><span class="command">unfolding</span></span> Q'_def π'_def upd_cond_def Qinter_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> maintain_invar1<span class="main">[</span><span class="operator">OF</span> invar1 LE<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prim_invar1 <span class="var">?A'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> M1<span class="main">:</span> <span class="quoted"><span class="quoted">"T_measure1 <span class="var">?A'</span> <span class="main">&lt;</span> T_measure1 <span class="var">?A</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> NA<span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> N<span class="main">:</span> Prim_Invar1_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="var"><span class="quoted"><span class="var">?A'</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
              
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?S'</span> <span class="main">=</span> insert <span class="free">u</span> <span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def N.S_alt_def
    <span class="keyword1"><span class="command">unfolding</span></span> Q'_def Qinter_def π'_def upd_cond_def
    <span class="keyword1"><span class="command">unfolding</span></span> A_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff<span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_ctd_def Let_def  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> π'_def upd_cond_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> π_root<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Prim2.Q'_def Prim2.Qinter_def Prim2.upd_cond_def Q_root<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a b
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> Q'_def Qinter_def upd_cond_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_alt_def A_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> reachable_edges_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Prim.S_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> A_def Q_defined edges frontier<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> not_infinity_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> S_alt_def N.S_alt_def 
        <span class="keyword1"><span class="command">unfolding</span></span> A_def Q'_def Qinter_def upd_cond_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span><span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
          <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span> <span class="main">∈</span> edges rg"</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> fst <span class="main">`</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">∞</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> fst <span class="main">`</span> A <span class="free">Q</span> <span class="free">π</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def<span class="main">)</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> a1 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> S_alt_def Q_defined Un_insert_left 
                  edges_irrefl' insert_iff not_infinity_eq sup_bot.left_neutral<span class="main">)</span>
        <span class="keyword1"><span class="command">qed</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fst_eq_Domain<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Domain.intros Q_defined π_def_on_edges_to_S case_prod_conv 
                edges enat.exhaust frontier fst_eq_Domain mem_Collect_eq 
                option.exhaust<span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fst_eq_Domain<span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Q'_def Qinter_def π'_def π_defined enat.distinct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
            fun_upd_apply not_None_eq<span class="main">)</span>
      
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹S <span class="main">(</span>A <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">u</span> <span class="main">(</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span>›</span></span> π'_def 
            frontier insertCI option.inject<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> N.S_edge_reachable upd_cond_def 
          <span class="quoted"><span class="quoted">‹S <span class="main">(</span>A <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">u</span> <span class="main">(</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span>›</span></span> π'_def edges 
          edges_sym' insertI1 option.inject<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Q'_def π'_def Q_π_consistent Qinter_def fun_upd_apply 
            insert_absorb not_enat_eq option.inject the_enat.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> v' d'
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Q'_def Qinter_def upd_cond_def      
      <span class="keyword1"><span class="command">using</span></span> Q_min
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹(<span class="operator">auto</span><span class="keyword3">;</span><span class="operator">fail</span>)<span class="keyword3">?</span>›</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_less less_le_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> π_def_on_edges_to_S <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> reachable_edges_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q_root<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>       
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> N<span class="main">:</span> Prim_Invar2_ctd_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="var"><span class="quoted"><span class="var">?Q'</span></span></span> <span class="var"><span class="quoted"><span class="var">?π'</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> T_measure2_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_root N.Q_root M1<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword2"><span class="keyword">end</span></span>

  
<span class="keyword1"><span class="command">context</span></span> Prim2 <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> maintain_invar2_ctd<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar2_ctd_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">π</span></span> <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">from</span></span> maintain_invar_ctd<span class="main">[</span><span class="operator">OF</span> UNS MIN<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Q_min_is_light_presentation<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">v</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"light_edge <span class="main">(</span>S <span class="main">(</span>A <span class="free">Q</span> <span class="free">π</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar2_ctd_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">π</span></span> <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">from</span></span> Q_min_is_light<span class="main">[</span><span class="operator">OF</span> UNS MIN<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> maintain_invar2_ctd_presentation<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>
       <span class="main">∧</span> T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> maintain_invar2_ctd assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> not_invar2_ctd_init<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"prim_invar2_init <span class="free">Q</span> <span class="free">π</span> <span class="main">⟹</span> <span class="main">¬</span>prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_init_def prim_invar2_ctd_def initQ_def Let_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> invar2_init_init<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_init initQ initπ"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_init_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> invar2_init<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2 initQ initπ"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_def <span class="keyword1"><span class="command">using</span></span> invar2_init_init <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> maintain_invar2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2 <span class="free">Q</span> <span class="free">π</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> <span class="free">Q</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"T_measure2 <span class="main">(</span>Q' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">&lt;</span> T_measure2 <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_def
  <span class="keyword1"><span class="command">using</span></span> maintain_invar2_first_step<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Q</span></span></span></span><span class="main">,</span><span class="operator">OF</span> _ UNS<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> maintain_invar2_ctd<span class="main">[</span><span class="operator">OF</span> _ UNS MIN<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> not_invar2_ctd_init
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> invar2_ctd_finish<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="main">(</span>graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> Prim_Invar2_ctd_loc <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">π</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"A <span class="free">Q</span> <span class="free">π</span>"</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?S</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"S <span class="var">?A</span>"</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> FC<span class="main">:</span> <span class="quoted"><span class="quoted">"edges <span class="free">g</span> <span class="main">∩</span> <span class="var">?S</span> <span class="main">×</span> <span class="main">-</span> <span class="var">?S</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span><span class="var">?S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∉</span><span class="var">?S</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Q_defined<span class="main">[</span><span class="operator">OF</span> edges_sym'<span class="main">]</span> S_edge_reachable <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="skolem">b</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">with</span></span> FIN <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">have</span></span> Aeq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> A_def <span class="keyword1"><span class="command">using</span></span> FIN <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">from</span></span> invar1_finish<span class="main">[</span><span class="operator">OF</span> invar1 FC<span class="main">,</span> <span class="operator">unfolded</span> Aeq<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
  
<span class="keyword1"><span class="command">lemma</span></span> invar2_finish<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar2 <span class="free">Q</span> <span class="free">π</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_MST <span class="free">w</span> rg <span class="main">(</span>graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">π</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"prim_invar2_ctd <span class="free">Q</span> <span class="free">π</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar2_def prim_invar2_init_def initQ_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff FIN <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> FIN invar2_ctd_finish <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Inner Foreach Loop\label{sec:using_foreach}›</span></span>

<span class="keyword1"><span class="command">context</span></span> Prim2 <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">foreach_body</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">if</span> <span class="bound">v</span><span class="main">=</span><span class="free">r</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span>
  <span class="keyword1">else</span>
    <span class="keyword1">case</span> <span class="main">(</span><span class="bound">Q</span> <span class="bound">v</span><span class="main">,</span> <span class="bound">π</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">of</span>
      <span class="main">(</span><span class="main">∞</span><span class="main">,</span>None<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">Q</span><span class="main">(</span><span class="bound">v</span><span class="main">:=</span>enat <span class="bound">d</span><span class="main">)</span><span class="main">,</span> <span class="bound">π</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span>enat <span class="bound">d'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">d</span><span class="main">&lt;</span><span class="bound">d'</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">Q</span><span class="main">(</span><span class="bound">v</span><span class="main">:=</span>enat <span class="bound">d</span><span class="main">)</span><span class="main">,</span> <span class="bound">π</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span><span class="main">∞</span><span class="main">,</span>Some <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span>
  "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> foreach_body_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_body <span class="free">u</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span><span class="main">.</span> 
  <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">π</span> <span class="bound">v</span> <span class="main">=</span> None <span class="main">∨</span> <span class="bound">Q</span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">∞</span><span class="main">)</span> <span class="main">∧</span> enat <span class="bound">d</span> <span class="main">&lt;</span> <span class="bound">Q</span> <span class="bound">v</span> <span class="keyword1">then</span>
    <span class="main">(</span><span class="bound">Q</span><span class="main">(</span><span class="bound">v</span><span class="main">:=</span>enat <span class="bound">d</span><span class="main">)</span><span class="main">,</span> <span class="bound">π</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span><span class="free">u</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1">else</span> 
    <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span>
<span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> foreach_body_def S_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.splits option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fst_eq_Domain fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">foreach</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">foreach</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="free"><span class="bound"><span class="entity">Qπ</span></span></span> <span class="main">=</span> foldr <span class="main">(</span>foreach_body <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="free"><span class="bound"><span class="entity">Qπ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q</span> <span class="bound">V</span><span class="main">.</span> 
  <span class="free">Qigen</span> <span class="bound">Q</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∉</span> fst<span class="main">`</span>set <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="keyword1">then</span> <span class="bound">Q</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">else</span> Qinter <span class="bound">Q</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q</span> <span class="bound">V</span> <span class="bound">π</span><span class="main">.</span> 
  <span class="free">π'gen</span> <span class="bound">Q</span> <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∉</span> fst<span class="main">`</span>set <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="keyword1">then</span> <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">else</span> π' <span class="bound">Q</span> <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> Qc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Qigen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="main">(</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">#</span> <span class="free">adjs</span><span class="main">)</span> <span class="free">x</span> 
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span><span class="main">=</span><span class="free">v</span> <span class="keyword1">then</span> Qinter <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">v</span> <span class="keyword1">else</span> Qigen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">adjs</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Qigen_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">lemma</span></span> πc<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"π'gen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="main">(</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">#</span> <span class="free">adjs</span><span class="main">)</span> <span class="free">x</span> 
  <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span><span class="main">=</span><span class="free">v</span> <span class="keyword1">then</span> π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">v</span> <span class="keyword1">else</span> π'gen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">adjs</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">unfolding</span></span> π'gen_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> foreach_refine_gen<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">adjs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>          
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"foreach <span class="free">u</span> <span class="free">adjs</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">π</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Qigen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">adjs</span><span class="main">,</span>π'gen <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="free">adjs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> foreach_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">adjs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="free">π</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">have</span></span> INVAR_INIT<span class="main">:</span> <span class="quoted"><span class="quoted">"Qigen <span class="skolem">Q</span> <span class="skolem">π</span> <span class="free">u</span> <span class="main">[]</span> <span class="main">=</span> <span class="skolem">Q</span>"</span></span> <span class="quoted"><span class="quoted">"π'gen <span class="skolem">Q</span> <span class="skolem">π</span> <span class="free">u</span> <span class="main">[]</span> <span class="main">=</span> <span class="skolem">π</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Q</span> <span class="skolem">π</span>
    <span class="keyword1"><span class="command">unfolding</span></span> assms Qigen_def π'gen_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff image_def Q'_def π'_def edges_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INVAR_INIT<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">adjs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">d</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="skolem">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">≠</span><span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword1"><span class="command">have</span></span> QinfD<span class="main">:</span> <span class="quoted"><span class="quoted">"Qigen <span class="skolem">Q</span> <span class="skolem">π</span> <span class="free">u</span> <span class="skolem">adjs</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟹</span> <span class="skolem">Q</span> <span class="skolem">v</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> Qigen_def Q'_def Qinter_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Cons.prems
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Cons.IH<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> foreach_body_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Qigen_def Qinter_def upd_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> π'gen_def π'_def upd_cond_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.split option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> πc Qc fun_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> Qinter_def Qigen_def π'_def π'gen_def upd_cond_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
<span class="keyword1"><span class="command">qed</span></span>
      
<span class="keyword1"><span class="command">lemma</span></span> foreach_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">adjs</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"foreach <span class="free">u</span> <span class="free">adjs</span> <span class="main">(</span><span class="free">Q</span><span class="main">,</span><span class="free">π</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Qinter <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">,</span>π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> INVAR_INIT<span class="main">:</span> <span class="quoted"><span class="quoted">"Qigen <span class="skolem">Q</span> <span class="skolem">π</span> <span class="free">u</span> <span class="main">[]</span> <span class="main">=</span> <span class="skolem">Q</span>"</span></span> <span class="quoted"><span class="quoted">"π'gen <span class="skolem">Q</span> <span class="skolem">π</span> <span class="free">u</span> <span class="main">[]</span> <span class="main">=</span> <span class="skolem">π</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Q</span> <span class="skolem">π</span>
    <span class="keyword1"><span class="command">unfolding</span></span> assms Qigen_def π'gen_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff image_def Q'_def π'_def edges_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">adjs</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> fst <span class="main">`</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="free">g</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span> 
    <span class="main">⟷</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> foreach_refine_gen<span class="main">[</span><span class="operator">OF</span> 1<span class="main">]</span> 
    <span class="keyword1"><span class="command">unfolding</span></span> Qigen_def π'gen_def assms upd_cond_def Qinter_def π'_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff image_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> edges_sym'<span class="main">)</span>      
    
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Undirected_Graph_Impl">
<div class="head">
<h1>Theory Undirected_Graph_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Weighted Undirected Graph by Map›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Undirected_Graph_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/Map_Specs.html">HOL-Data_Structures.Map_Specs</a>"</span>
  <a href="Common.html">Common</a>
  <a href="Undirected_Graph_Specs.html">Undirected_Graph_Specs</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Doubleton Set to Pair›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">epair</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> card <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="numeral">2</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">SOME</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">=</span><span class="main">{</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> epair_eqD<span class="main">:</span> <span class="quoted"><span class="quoted">"epair <span class="free">e</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">≠</span><span class="free">y</span> <span class="main">∧</span> <span class="free">e</span><span class="main">=</span><span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="free">e</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> epair_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card_Suc_eq eval_nat_numeral doubleton_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> case_prodD case_prodI someI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> epair_not_sng<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epair <span class="free">e</span> <span class="main">≠</span> Some <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> epair_eqD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> epair_None<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epair <span class="main">{</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">}</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span><span class="free">b</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> epair_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card2_eq<span class="main">)</span> 
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic Implementation›</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  When instantiated with a map ADT, this locale provides a weighted graph ADT.
›</span></span>
<span class="keyword1"><span class="command">locale</span></span> wgraph_by_map <span class="main">=</span> 
  M<span class="main">:</span> Map <span class="quoted"><span class="free">M_empty</span></span> <span class="quoted"><span class="free">M_update</span></span> <span class="quoted"><span class="free">M_delete</span></span> <span class="quoted"><span class="free">M_lookup</span></span> <span class="quoted"><span class="free">M_invar</span></span> 
  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">M_empty</span> <span class="free">M_update</span> <span class="free">M_delete</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'v</span><span class="main">×</span>nat<span class="main">)</span> list<span class="main">)</span> option"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_invar</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">αnodes_aux</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> dom <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">αedges_aux</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
  <span class="main">≡</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">xs</span> <span class="bound">d</span><span class="main">.</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="bound">xs</span> <span class="main">}</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">αg</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> graph <span class="main">(</span>αnodes_aux <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">(</span>αedges_aux <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">αw</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> epair <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="keyword1">of</span> 
  Some <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>
    <span class="keyword1">case</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">u</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> <span class="main">0</span> 
    <span class="main">|</span> Some <span class="bound">xs</span> <span class="main">⇒</span> the_default <span class="main">0</span> <span class="main">(</span>map_of <span class="bound">xs</span> <span class="bound">v</span><span class="main">)</span>
    <span class="main">)</span>
<span class="main">|</span> None <span class="main">⇒</span> <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> 
      <span class="free">M_invar</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>dom <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">xs</span> <span class="main">⟶</span> 
          distinct <span class="main">(</span>map fst <span class="bound">xs</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="bound">u</span><span class="main">∉</span>set <span class="main">(</span>map fst <span class="bound">xs</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="bound">xs</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="main">(</span>the_default <span class="main">[]</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">)</span>"</span></span>
  

<span class="keyword1"><span class="command">lemma</span></span> in_the_default_empty_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span>set <span class="main">(</span>the_default <span class="main">[]</span> <span class="free">m</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs</span><span class="main">.</span> <span class="free">m</span><span class="main">=</span>Some <span class="bound">xs</span> <span class="main">∧</span> <span class="free">x</span><span class="main">∈</span>set <span class="bound">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">auto</span>  
  
<span class="keyword1"><span class="command">lemma</span></span> αedges_irrefl<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> irrefl <span class="main">(</span>αedges_aux <span class="free">g</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> invar_def irrefl_def αedges_aux_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span><span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> αedges_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> sym <span class="main">(</span>αedges_aux <span class="free">g</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> invar_def sym_def αedges_aux_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> 
      
<span class="keyword1"><span class="command">lemma</span></span> αedges_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> αedges_aux <span class="free">g</span> <span class="main">⊆</span> αnodes_aux <span class="free">g</span> <span class="main">×</span> αnodes_aux <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar_def αnodes_aux_def αedges_aux_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
                      
<span class="keyword1"><span class="command">lemma</span></span> αnodes_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> finite <span class="main">(</span>αnodes_aux <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar_def αnodes_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
<span class="keyword1"><span class="command">lemma</span></span> αedges_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> finite <span class="main">(</span>αedges_aux <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> αedges_subset<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adj</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span>nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">adj</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> the_default <span class="main">[]</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty</span> <span class="main">=</span> <span class="free">M_empty</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_edge1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_edge1</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span> <span class="bound">g</span><span class="main">.</span> <span class="free">M_update</span> <span class="bound">u</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">#</span> the_default <span class="main">[]</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="bound">g</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="bound">g</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_edge</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span> <span class="bound">g</span><span class="main">.</span> add_edge1 <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span> <span class="bound">d</span> <span class="main">(</span>add_edge1 <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  

<span class="keyword1"><span class="command">lemma</span></span> edges_αg_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> edges <span class="main">(</span>αg <span class="free">g</span><span class="main">)</span> <span class="main">=</span> αedges_aux <span class="free">g</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> αg_def <span class="keyword1"><span class="command">using</span></span> αedges_sym αedges_irrefl
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> irrefl_def graph_accs<span class="main">)</span>
 
<span class="keyword1"><span class="command">lemma</span></span> nodes_αg_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> nodes <span class="main">(</span>αg <span class="free">g</span><span class="main">)</span> <span class="main">=</span> αnodes_aux <span class="free">g</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> αg_def <span class="keyword1"><span class="command">using</span></span> αedges_subset
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> graph_accs<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> card_doubleton_eq2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">}</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">≠</span><span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  

<span class="keyword1"><span class="command">lemma</span></span> the_dflt_Z_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"the_default <span class="main">0</span> <span class="free">m</span> <span class="main">=</span> <span class="free">d</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">m</span><span class="main">=</span>None <span class="main">∧</span> <span class="free">d</span><span class="main">=</span><span class="main">0</span> <span class="main">∨</span> <span class="free">m</span><span class="main">=</span>Some <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> adj_correct_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"invar <span class="free">g</span> <span class="main">⟹</span> set <span class="main">(</span>adj <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> edges <span class="main">(</span>αg <span class="free">g</span><span class="main">)</span> <span class="main">∧</span> αw <span class="free">g</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">}</span> <span class="main">=</span> <span class="bound">d</span><span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_αg_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> adj_def αedges_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a d 
    <span class="keyword1"><span class="command">unfolding</span></span> adj_def αw_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> the_dflt_Z_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> epair_eqD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> doubleton_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a 
    <span class="keyword1"><span class="command">unfolding</span></span> adj_def αw_def
    <span class="keyword1"><span class="command">using</span></span> αedges_irrefl<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> irrefl_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> epair_eqD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> doubleton_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> invar_def αedges_aux_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> epair_eqD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> doubleton_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> invar_def αedges_aux_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> case_prod_conv map_of_is_SomeI the_default.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
    
<span class="keyword1"><span class="command">lemma</span></span> invar_empty_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"invar empty"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def empty_def M.map_specs<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dist_fst_the_dflt_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>the_default <span class="main">[]</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Some <span class="bound">xs</span> <span class="main">⟶</span> distinct <span class="main">(</span>map fst <span class="bound">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> invar_add_edge_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar <span class="free">g</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="main">∉</span> edges <span class="main">(</span>αg <span class="free">g</span><span class="main">)</span><span class="main">;</span> <span class="free">u</span> <span class="main">≠</span> <span class="free">v</span><span class="main">⟧</span> <span class="main">⟹</span> invar <span class="main">(</span>add_edge <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_αg_aux<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> add_edge_def add_edge1_def invar_def αedges_aux_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>  M.map_specs dist_fst_the_dflt_aux<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  
  
    
<span class="keyword1"><span class="command">sublocale</span></span> adt_wgraph <span class="quoted">αw</span> <span class="quoted">αg</span> <span class="quoted">invar</span> <span class="quoted">adj</span> <span class="quoted">empty</span> <span class="quoted">add_edge</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_correct_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_empty_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> graph_eq_iff nodes_αg_aux invar_empty_aux edges_αg_aux
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αnodes_aux_def αedges_aux_def
        <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_def M.map_specs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> αw_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> empty_def M.map_specs fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>    
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_add_edge_aux<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> g u v d
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_αg_aux nodes_αg_aux graph_eq_iff invar_add_edge_aux<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> add_edge_def add_edge1_def invar_def αnodes_aux_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M.map_specs<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> add_edge_def add_edge1_def invar_def αedges_aux_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M.map_specs <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>      
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> g u v d
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> edges_αg_aux invar_add_edge_aux<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def αw_def add_edge_def add_edge1_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> epair_eqD 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff M.map_specs 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits option.splits if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
          
        
<span class="keyword2"><span class="keyword">end</span></span>
  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Prim_Impl">
<div class="head">
<h1>Theory Prim_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Prim's Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Prim_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Prim_Abstract.html">Prim_Abstract</a>
  <a href="Undirected_Graph_Impl.html">Undirected_Graph_Impl</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/While_Combinator.html">HOL-Library.While_Combinator</a>"</span>
  <span class="quoted">"<a href="../Priority_Search_Trees/PST_RBT.html">Priority_Search_Trees.PST_RBT</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/RBT_Map.html">HOL-Data_Structures.RBT_Map</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using ADT Interfaces\label{sec:prim_data_structs}›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Prim_Impl_Adts <span class="main">=</span> 
  G<span class="main">:</span> adt_wgraph <span class="quoted"><span class="free">G_αw</span></span> <span class="quoted"><span class="free">G_αg</span></span> <span class="quoted"><span class="free">G_invar</span></span> <span class="quoted"><span class="free">G_adj</span></span> <span class="quoted"><span class="free">G_empty</span></span> <span class="quoted"><span class="free">G_add_edge</span></span> 
<span class="main">+</span> M<span class="main">:</span> Map <span class="quoted"><span class="free">M_empty</span></span> <span class="quoted"><span class="free">M_update</span></span> <span class="quoted"><span class="free">M_delete</span></span> <span class="quoted"><span class="free">M_lookup</span></span> <span class="quoted"><span class="free">M_invar</span></span>
<span class="comment1">(*+ S: Set S_empty S_insert S_delete S_isin S_α S_invar*)</span>
<span class="main">+</span> Q<span class="main">:</span> PrioMap <span class="quoted"><span class="free">Q_empty</span></span> <span class="quoted"><span class="free">Q_update</span></span> <span class="quoted"><span class="free">Q_delete</span></span> <span class="quoted"><span class="free">Q_invar</span></span> <span class="quoted"><span class="free">Q_lookup</span></span> <span class="quoted"><span class="free">Q_is_empty</span></span> <span class="quoted"><span class="free">Q_getmin</span></span>
  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">typG</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typQ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> itself"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αw</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> ugraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_invar</span> <span class="free">G_adj</span> <span class="free">G_empty</span> <span class="free">G_add_edge</span>
  
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_empty</span> <span class="free">M_update</span> <span class="free">M_delete</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_invar</span>
  
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_empty</span> <span class="free">Q_update</span> <span class="free">Q_delete</span> <span class="free">Q_invar</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> nat option"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_is_empty</span> <span class="free">Q_getmin</span>
  
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simplifier setup›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> G.wgraph_specs
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> M.map_specs
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Q.prio_map_specs

<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="command">locale</span></span> Prim_Impl_Defs <span class="main">=</span> Prim_Impl_Adts  
  <span class="keyword2"><span class="keyword">where</span></span> typG <span class="main">=</span> <span class="quoted"><span class="free">typG</span></span> <span class="keyword2"><span class="keyword">and</span></span> typM <span class="main">=</span> <span class="quoted"><span class="free">typM</span></span> <span class="keyword2"><span class="keyword">and</span></span> typQ <span class="main">=</span> <span class="quoted"><span class="free">typQ</span></span> <span class="keyword2"><span class="keyword">and</span></span> G_αw <span class="main">=</span> <span class="quoted"><span class="free">G_αw</span></span> <span class="keyword2"><span class="keyword">and</span></span> G_αg <span class="main">=</span> <span class="quoted"><span class="free">G_αg</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">typG</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typQ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> itself"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αw</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>linorder<span class="main">)</span> ugraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'g</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Concrete Algorithm›</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="free">M_lookup</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">foreach_impl_body</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span>
  <span class="keyword1">if</span> <span class="bound">v</span><span class="main">=</span><span class="free">r</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span>
  <span class="keyword1">else</span> 
    <span class="keyword1">case</span> <span class="main">(</span><span class="free">Q_lookup</span> <span class="bound">Qi</span> <span class="bound">v</span><span class="main">,</span> <span class="free">M_lookup</span> <span class="bound">πi</span> <span class="bound">v</span><span class="main">)</span> <span class="keyword1">of</span>
      <span class="main">(</span>None<span class="main">,</span>None<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="free">Q_update</span> <span class="bound">v</span> <span class="bound">d</span> <span class="bound">Qi</span><span class="main">,</span> <span class="free">M_update</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">πi</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span>Some <span class="bound">d'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">d</span><span class="main">&lt;</span><span class="bound">d'</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free">Q_update</span> <span class="bound">v</span> <span class="bound">d</span> <span class="bound">Qi</span><span class="main">,</span> <span class="free">M_update</span> <span class="bound">v</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">πi</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span>None<span class="main">,</span> Some <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">foreach_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span>nat<span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'q</span> <span class="main">×</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">foreach_impl</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="main">=</span> foldr <span class="main">(</span>foreach_impl_body <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">adjs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">πi</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">outer_loop_impl</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="main">≡</span> while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="free">Q_is_empty</span> <span class="bound">Qi</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> 
  <span class="keyword1">let</span>
    <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> <span class="free">Q_getmin</span> <span class="bound">Qi</span><span class="main">;</span>
    <span class="bound">adjs</span> <span class="main">=</span> <span class="free">G_adj</span> <span class="free">g</span> <span class="bound">u</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span> <span class="main">=</span> foreach_impl <span class="bound">Qi</span> <span class="bound">πi</span> <span class="bound">u</span> <span class="bound">adjs</span><span class="main">;</span>
    <span class="bound">Qi</span> <span class="main">=</span> <span class="free">Q_delete</span> <span class="bound">u</span> <span class="bound">Qi</span>
  <span class="keyword1">in</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">πi</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_impl</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span>
  <span class="bound">Qi</span> <span class="main">=</span> <span class="free">Q_update</span> <span class="free">r</span> <span class="main">0</span> <span class="free">Q_empty</span><span class="main">;</span>
  <span class="bound">πi</span> <span class="main">=</span> <span class="free">M_empty</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span> <span class="main">=</span> outer_loop_impl <span class="bound">Qi</span> <span class="bound">πi</span>
  <span class="keyword1">in</span> <span class="bound">πi</span><span class="main">)</span>
"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The whole algorithm as one function›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> prim_impl_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_impl <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> 
  <span class="comment1">― ‹Initialization›</span>
  <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">π</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q_update</span> <span class="free">r</span> <span class="main">0</span> <span class="free">Q_empty</span><span class="main">,</span> <span class="free">M_empty</span><span class="main">)</span><span class="main">;</span>
  <span class="comment1">― ‹Main loop: Iterate until PQ is empty›</span>
  <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span> <span class="main">=</span> 
  while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span> 
    <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> <span class="free">Q_getmin</span> <span class="bound">Q</span><span class="main">;</span>
    <span class="comment1">― ‹Inner loop: Update for adjacent nodes›</span>
    <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span> <span class="main">=</span> 
    foldr <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span>
        <span class="bound">qv</span> <span class="main">=</span> <span class="free">Q_lookup</span> <span class="bound">Q</span> <span class="bound">v</span><span class="main">;</span>
        <span class="bound">πv</span> <span class="main">=</span> <span class="free">M_lookup</span> <span class="bound">π</span> <span class="bound">v</span>
      <span class="keyword1">in</span>
        <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">qv</span><span class="main">≠</span>None <span class="main">∨</span> <span class="bound">πv</span><span class="main">=</span>None<span class="main">)</span> <span class="main">∧</span> enat <span class="bound">d</span> <span class="main">&lt;</span> enat_of_option <span class="bound">qv</span> 
        <span class="keyword1">then</span> <span class="main">(</span><span class="free">Q_update</span> <span class="bound">v</span> <span class="bound">d</span> <span class="bound">Q</span><span class="main">,</span> <span class="free">M_update</span> <span class="bound">v</span> <span class="bound">u</span> <span class="bound">π</span><span class="main">)</span> 
        <span class="keyword1">else</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">)</span>
    <span class="main">)</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="bound">u</span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">;</span> 
    <span class="bound">Q</span> <span class="main">=</span> <span class="free">Q_delete</span> <span class="bound">u</span> <span class="bound">Q</span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span> <span class="bound">π</span><span class="main">)</span>
  <span class="keyword1">in</span> <span class="bound">π</span>
<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_impl_body <span class="skolem">u</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">let</span>
        <span class="bound">qiv</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q_lookup</span> <span class="bound">Qi</span> <span class="bound">v</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">πiv</span> <span class="main">=</span> <span class="free">M_lookup</span> <span class="bound">πi</span> <span class="bound">v</span>
      <span class="keyword1">in</span>
        <span class="keyword1">if</span> <span class="bound">v</span><span class="main">≠</span><span class="free">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">qiv</span><span class="main">≠</span>None <span class="main">∨</span> <span class="bound">πiv</span><span class="main">=</span>None<span class="main">)</span> <span class="main">∧</span> enat <span class="bound">d</span> <span class="main">&lt;</span> enat_of_option <span class="bound">qiv</span> 
        <span class="keyword1">then</span> <span class="main">(</span><span class="free">Q_update</span> <span class="bound">v</span> <span class="bound">d</span> <span class="bound">Qi</span><span class="main">,</span> <span class="free">M_update</span> <span class="bound">v</span> <span class="skolem">u</span> <span class="bound">πi</span><span class="main">)</span> 
        <span class="keyword1">else</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span> <span class="bound">πi</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">unfolding</span></span> foreach_impl_body_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_impl_def outer_loop_impl_def foreach_impl_def 1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>  
  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Abstraction of Result›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Invariant for the result, and its interpretation as (minimum spanning) tree:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> The map <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>πi›</span></span></span></span> and set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Vi›</span></span></span></span> satisfy their implementation invariants
  <span class="antiquoted"><span class="antiquoted">▪</span></span> The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>πi›</span></span></span></span> encodes irreflexive edges consistent with the nodes determined 
    by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Vi›</span></span></span></span>. Note that the edges in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>πi›</span></span></span></span> will not be symmetric, thus we take 
    their symmetric closure <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>E∪E¯›</span></span></span></span>.
    
›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar_MST</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="main">≡</span> <span class="free">M_invar</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">α_MST</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="main">≡</span> graph <span class="main">{</span><span class="free">r</span><span class="main">}</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span> <span class="bound">v</span><span class="main">.</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of State›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Prim_Impl <span class="main">=</span> Prim_Impl_Defs 
  <span class="keyword2"><span class="keyword">where</span></span> typG <span class="main">=</span> <span class="quoted"><span class="free">typG</span></span> <span class="keyword2"><span class="keyword">and</span></span> typM <span class="main">=</span> <span class="quoted"><span class="free">typM</span></span> <span class="keyword2"><span class="keyword">and</span></span> typQ <span class="main">=</span> <span class="quoted"><span class="free">typQ</span></span> <span class="keyword2"><span class="keyword">and</span></span> G_αw <span class="main">=</span> <span class="quoted"><span class="free">G_αw</span></span> <span class="keyword2"><span class="keyword">and</span></span> G_αg <span class="main">=</span> <span class="quoted"><span class="free">G_αg</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">typG</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typM</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> itself"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">typQ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> itself"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αw</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_αg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>linorder<span class="main">)</span> ugraph"</span></span> 
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G_invar</span> <span class="free">g</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
               
<span class="keyword1"><span class="command">sublocale</span></span> Prim2 <span class="quoted"><span class="quoted">"<span class="free">G_αw</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G_αg</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="free">r</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Abstraction of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The priority map implements a function of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">‹<span class="tfree"><span class="tfree">'v</span></span><span class="main"><span class="main">⇒</span></span>enat›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, 
  mapping <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="main"><span class="quoted"><span class="main">∞</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_α</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">≡</span> enat_of_option <span class="keyword1">o</span> <span class="free">Q_lookup</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">::</span> <span class="tfree">'v</span> <span class="main">⇒</span> enat"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Q_α_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"Q_α <span class="free">Q_empty</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Q_α_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Q</span> <span class="main">⟹</span> Q_α <span class="main">(</span><span class="free">Q_update</span> <span class="free">u</span> <span class="free">d</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Q_α <span class="free">Q</span><span class="main">)</span><span class="main">(</span><span class="free">u</span> <span class="main">:=</span> enat <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Q_α_is_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Q</span> <span class="main">⟹</span> <span class="free">Q_lookup</span> <span class="free">Q</span> <span class="main">=</span> Map.empty <span class="main">⟷</span> Q_α <span class="free">Q</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Q_α_delete<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Q</span> <span class="main">⟹</span> Q_α <span class="main">(</span><span class="free">Q_delete</span> <span class="free">u</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Q_α <span class="free">Q</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">:=</span><span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Q_α_min<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_getmin</span> <span class="free">Qi</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">d</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="free">Qi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Q_α <span class="free">Qi</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> enat <span class="free">d</span> <span class="main">≤</span> Q_α <span class="free">Qi</span> <span class="bound">v</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> Q.map_getmin<span class="main">[</span><span class="operator">OF</span> MIN<span class="main">]</span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_lookup</span> <span class="free">Qi</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">d</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>ran <span class="main">(</span><span class="free">Q_lookup</span> <span class="free">Qi</span><span class="main">)</span><span class="main">.</span> <span class="free">d</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> NE I <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_of_option.elims enat_ord_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> enat_ord_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> ranI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemmas</span></span> Q_α_specs <span class="main">=</span> Q_α_empty Q_α_update Q_α_is_empty Q_α_delete


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Concrete Invariant›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The implementation invariants of the concrete state's components,
  and the abstract invariant of the state's abstraction›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_invar_impl</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="main">≡</span> 
    <span class="free">Q_invar</span> <span class="free"><span class="bound"><span class="entity">Qi</span></span></span> <span class="main">∧</span> <span class="free">M_invar</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span> <span class="main">∧</span> prim_invar2 <span class="main">(</span>Q_α <span class="free"><span class="bound"><span class="entity">Qi</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">πi</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> Prim_Impl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> foreach_impl_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Qi</span> <span class="free">Vi</span> <span class="free">πi</span> <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">≡</span> Q_α <span class="free">Qi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="main">≡</span> <span class="free">M_lookup</span> <span class="free">πi</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_impl <span class="free">Qi</span> <span class="free">πi</span> <span class="free">u</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Qi'</span><span class="main">,</span><span class="free">πi'</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="free">Qi</span> <span class="free">πi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="free">πi'</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Q_α <span class="free">Qi'</span> <span class="main">=</span> Qinter <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_lookup</span> <span class="free">πi'</span> <span class="main">=</span> π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="free">πi</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar_impl_def Q_def π_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Qi</span> <span class="skolem">πi</span> <span class="skolem">d</span> <span class="skolem">v</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">adjs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> nat<span class="main">)</span> list"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="skolem">Qi</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="skolem">πi</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">adjs</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">case</span> foreach_impl_body <span class="free">u</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">(</span><span class="skolem">Qi</span><span class="main">,</span> <span class="skolem">πi</span><span class="main">)</span> <span class="keyword1">of</span> 
         <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span> <span class="bound">πi</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">Q_invar</span> <span class="bound">Qi</span> <span class="main">∧</span> <span class="free">M_invar</span> <span class="bound">πi</span><span class="main">)</span> 
              <span class="main">∧</span> map_prod Q_α <span class="free">M_lookup</span> <span class="main">(</span>foreach_impl_body <span class="free">u</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">(</span><span class="skolem">Qi</span><span class="main">,</span> <span class="skolem">πi</span><span class="main">)</span><span class="main">)</span> 
                <span class="main">=</span> foreach_body <span class="free">u</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">(</span>Q_α <span class="skolem">Qi</span><span class="main">,</span> <span class="free">M_lookup</span> <span class="skolem">πi</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> foreach_impl_body_def foreach_body_def  
      <span class="keyword1"><span class="command">unfolding</span></span> Q_α_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> aux<span class="main">=</span>this

  <span class="keyword1"><span class="command">from</span></span> foldr_refine<span class="main">[</span>
    <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> <span class="free">Q_invar</span> <span class="bound">Qi</span> <span class="main">∧</span> <span class="free">M_invar</span> <span class="bound">πi</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> α<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"map_prod Q_α <span class="free">M_lookup</span>"</span></span><span class="main">,</span>
    <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">πi</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"foreach_impl_body <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"foreach_body <span class="free">u</span>"</span></span>
    <span class="main">]</span>
  <span class="keyword2"><span class="keyword">and</span></span> A aux<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?adjs3</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span>"</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="free">πi'</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach <span class="free">u</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>Q_α <span class="free">Qi</span><span class="main">,</span> <span class="free">M_lookup</span> <span class="free">πi</span><span class="main">)</span> 
              <span class="main">=</span> <span class="main">(</span>Q_α <span class="free">Qi'</span><span class="main">,</span> <span class="free">M_lookup</span> <span class="free">πi'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> foreach_impl_def foreach_def 
    <span class="keyword1"><span class="command">unfolding</span></span> Q_def π_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="free">πi'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> 1 foreach_refine<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> adjs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> u<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">u</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> 
    <span class="quoted"><span class="quoted">"Q_α <span class="free">Qi'</span> <span class="main">=</span> Qinter <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_lookup</span> <span class="free">πi'</span> <span class="main">=</span> π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_def π_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> foreach_impl_correct_presentation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Qi</span> <span class="free">Vi</span> <span class="free">πi</span> <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">≡</span> Q_α <span class="free">Qi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">π</span> <span class="main">≡</span> <span class="free">M_lookup</span> <span class="free">πi</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_impl <span class="free">Qi</span> <span class="free">πi</span> <span class="free">u</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Qi'</span><span class="main">,</span><span class="free">πi'</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="free">Qi</span> <span class="free">πi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Qi'</span> <span class="main">∧</span> <span class="free">M_invar</span> <span class="free">πi'</span> 
        <span class="main">∧</span> Q_α <span class="free">Qi'</span> <span class="main">=</span> Qinter <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span> <span class="main">∧</span> <span class="free">M_lookup</span> <span class="free">πi'</span> <span class="main">=</span> π' <span class="free">Q</span> <span class="free">π</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> foreach_impl_correct assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="comment1">(*&gt;*)</span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">T_measure_impl</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> T_measure2 <span class="main">(</span>Q_α <span class="bound">Qi</span><span class="main">)</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="bound">πi</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prim_invar_impl_init<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="main">(</span><span class="free">Q_update</span> <span class="free">r</span> <span class="main">0</span> <span class="free">Q_empty</span><span class="main">)</span> <span class="free">M_empty</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> invar2_init 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prim_invar_impl_def Q_α_specs initQ_def initπ_def zero_enat_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> maintain_prim_invar_impl<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> 
      I<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="free">Qi</span> <span class="free">πi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="free">Qi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_getmin</span> <span class="free">Qi</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">d</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      FOREACH<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_impl <span class="free">Qi</span> <span class="free">πi</span> <span class="free">u</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Qi'</span><span class="main">,</span> <span class="free">πi'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="main">(</span><span class="free">Q_delete</span> <span class="free">u</span> <span class="free">Qi'</span><span class="main">)</span> <span class="free">πi'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
     <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"T_measure_impl <span class="main">(</span><span class="free">Q_delete</span> <span class="free">u</span> <span class="free">Qi'</span><span class="main">,</span> <span class="free">πi'</span><span class="main">)</span> <span class="main">&lt;</span> T_measure_impl <span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">πi</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G2</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> II<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> I<span class="main">[</span><span class="operator">unfolded</span> prim_invar_impl_def<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> FI<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> foreach_impl_correct<span class="main">[</span><span class="operator">OF</span> FOREACH I<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> MIN' <span class="main">=</span> Q_α_min<span class="main">[</span><span class="operator">OF</span> MIN _ NE<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar_impl_def
    <span class="keyword1"><span class="command">using</span></span> Q_α_delete maintain_invar2<span class="main">[</span><span class="operator">OF</span> _ MIN'<span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q'_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> prim_invar_impl_def T_measure_impl_def
    <span class="keyword1"><span class="command">using</span></span> Q_α_delete maintain_invar2<span class="main">[</span><span class="operator">OF</span> _ MIN'<span class="main">]</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Q'_def Q_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> FI<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> II Q'_def Q_α_def 
        <span class="quoted"><span class="quoted">‹<span class="main">⋀</span><span class="bound">π</span><span class="main">.</span> prim_invar2 <span class="main">(</span>Q_α <span class="free">Qi</span><span class="main">)</span> <span class="bound">π</span> 
            <span class="main">⟹</span> T_measure2 <span class="main">(</span>Q' <span class="main">(</span>Q_α <span class="free">Qi</span><span class="main">)</span> <span class="bound">π</span> <span class="free">u</span><span class="main">)</span> <span class="main">(</span>π' <span class="main">(</span>Q_α <span class="free">Qi</span><span class="main">)</span> <span class="bound">π</span> <span class="free">u</span><span class="main">)</span> 
                <span class="main">&lt;</span> T_measure2 <span class="main">(</span>Q_α <span class="free">Qi</span><span class="main">)</span> <span class="bound">π</span>›</span></span><span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>      

<span class="keyword1"><span class="command">lemma</span></span> maintain_prim_invar_impl_presentation<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> 
      I<span class="main">:</span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="free">Qi</span> <span class="free">πi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="free">Qi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_getmin</span> <span class="free">Qi</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">d</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      FOREACH<span class="main">:</span> <span class="quoted"><span class="quoted">"foreach_impl <span class="free">Qi</span> <span class="free">πi</span> <span class="free">u</span> <span class="main">(</span><span class="free">G_adj</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">Qi'</span><span class="main">,</span> <span class="free">πi'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prim_invar_impl <span class="main">(</span><span class="free">Q_delete</span> <span class="free">u</span> <span class="free">Qi'</span><span class="main">)</span> <span class="free">πi'</span>
       <span class="main">∧</span> T_measure_impl <span class="main">(</span><span class="free">Q_delete</span> <span class="free">u</span> <span class="free">Qi'</span><span class="main">,</span> <span class="free">πi'</span><span class="main">)</span> <span class="main">&lt;</span> T_measure_impl <span class="main">(</span><span class="free">Qi</span><span class="main">,</span><span class="free">πi</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> maintain_prim_invar_impl assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> prim_invar_impl_finish<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">Q_is_empty</span> <span class="free">Q</span><span class="main">;</span> prim_invar_impl <span class="free">Q</span> <span class="free">π</span><span class="main">⟧</span> 
    <span class="main">⟹</span> invar_MST <span class="free">π</span> <span class="main">∧</span> is_MST <span class="main">(</span><span class="free">G_αw</span> <span class="free">g</span><span class="main">)</span> rg <span class="main">(</span>α_MST <span class="free">π</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> invar2_finish
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_α_specs prim_invar_impl_def invar_MST_def α_MST_def Let_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> prim_impl_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prim_impl <span class="main">=</span> <span class="free">πi</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"invar_MST <span class="free">πi</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="quoted"><span class="quoted">"is_MST <span class="main">(</span><span class="free">G_αw</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span>component_of <span class="main">(</span><span class="free">G_αg</span> <span class="free">g</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>α_MST <span class="free">πi</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">let</span> <span class="main">(</span><span class="bound">Qi</span><span class="main">,</span> <span class="bound">πi</span><span class="main">)</span> <span class="main">=</span> outer_loop_impl <span class="main">(</span><span class="free">Q_update</span> <span class="free">r</span> <span class="main">0</span> <span class="free">Q_empty</span><span class="main">)</span> <span class="free">M_empty</span> <span class="keyword1">in</span> 
    invar_MST <span class="bound">πi</span> <span class="main">∧</span> is_MST <span class="main">(</span><span class="free">G_αw</span> <span class="free">g</span><span class="main">)</span> rg <span class="main">(</span>α_MST <span class="bound">πi</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> outer_loop_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> while_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
      P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">Qi</span><span class="main">,</span><span class="bound">πi</span><span class="main">)</span><span class="main">.</span> prim_invar_impl <span class="bound">Qi</span> <span class="bound">πi</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> r<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure T_measure_impl"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹<span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main">:</span> prod.splits <span class="quasi_keyword">simp</span><span class="main">:</span> Q_α_specs›</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prim_invar_impl_init maintain_prim_invar_impl 
                         prim_invar_impl_finish<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> rg_def prim_impl_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> prim_impl_correct_presentation<span class="main">:</span>
  <span class="quoted"><span class="quoted">"invar_MST prim_impl 
  <span class="main">∧</span> is_MST <span class="main">(</span><span class="free">G_αw</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span>component_of <span class="main">(</span><span class="free">G_αg</span> <span class="free">g</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>α_MST prim_impl<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> prim_impl_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="comment1">(*&gt;*)</span>  
    
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation with Actual Data Structures\label{sec:prim_inst_ds}›</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> 
  G<span class="main">:</span> wgraph_by_map <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> 
        <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  <span class="keyword2"><span class="keyword">defines</span></span> G_empty <span class="main">=</span> <span class="quoted">G.empty</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_add_edge <span class="main">=</span> <span class="quoted">G.add_edge</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_add_edge1 <span class="main">=</span> <span class="quoted">G.add_edge1</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_adj <span class="main">=</span> <span class="quoted">G.adj</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_from_list <span class="main">=</span> <span class="quoted">G.from_list</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_valid_wgraph_repr <span class="main">=</span> <span class="quoted">G.valid_wgraph_repr</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="comment1">(* FIXME: Something is strange with generated constants. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> G_from_list_unfold<span class="main">:</span>  <span class="quoted"><span class="quoted">"G_from_list <span class="main">=</span> G.from_list"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_add_edge_def G_empty_def G_from_list_def<span class="main">)</span>
  
<span class="comment1">(* FIXME: The interpretation does not generate a code theorem at all!? *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"G_from_list <span class="free">l</span> <span class="main">=</span> foldr <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">e</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> G_add_edge <span class="bound">e</span> <span class="bound">d</span><span class="main">)</span> <span class="free">l</span> G_empty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G.from_list_def G_from_list_unfold<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">global_interpretation</span></span> Prim_Impl_Adts _ _ _
  <span class="quoted">G.αw</span> <span class="quoted">G.αg</span> <span class="quoted">G.invar</span> <span class="quoted">G.adj</span> <span class="quoted">G.empty</span> <span class="quoted">G.add_edge</span>
  
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> P<span class="main">:</span> Prim_Impl_Defs <span class="quoted">G.invar</span> <span class="quoted">G.adj</span> <span class="quoted">G.empty</span> <span class="quoted">G.add_edge</span>
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  
  _ _ _ <span class="quoted">G.αw</span> <span class="quoted">G.αg</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span>  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">r</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> prim_impl <span class="main">=</span> <span class="quoted">P.prim_impl</span>
      <span class="keyword2"><span class="keyword">and</span></span> outer_loop_impl <span class="main">=</span> <span class="quoted">P.outer_loop_impl</span>
      <span class="keyword2"><span class="keyword">and</span></span> foreach_impl <span class="main">=</span> <span class="quoted">P.foreach_impl</span>
      <span class="keyword2"><span class="keyword">and</span></span> foreach_impl_body <span class="main">=</span> <span class="quoted">P.foreach_impl_body</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> 


<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> P.prim_impl_alt  
  
  
<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"G.invar <span class="free">g</span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>  
  
<span class="keyword1"><span class="command">interpretation</span></span> AUX<span class="main">:</span> Prim_Impl
  <span class="quoted">G.invar</span> <span class="quoted">G.adj</span> <span class="quoted">G.empty</span> <span class="quoted">G.add_edge</span>
  
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  
  <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">r</span></span> _ _ _ <span class="quoted">G.αw</span> <span class="quoted">G.αg</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">r</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>
  
<span class="keyword1"><span class="command">lemmas</span></span> prim_impl_correct <span class="main">=</span> AUX.prim_impl_correct<span class="main">[</span><span class="operator">folded</span> prim_impl_def<span class="main">]</span> 
  
<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Adding a Graph-From-List Parser›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_list_impl</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> 
  <span class="main">≡</span> <span class="keyword1">if</span> G_valid_wgraph_repr <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span>prim_impl <span class="main">(</span>G_from_list <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Main Correctness Theorem›</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> prim_list_impl<span class="antiquote"><span class="antiquote">}</span></span></span></span> algorithm returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span>, if the input was 
  invalid. Otherwise it returns <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹Some <span class="main"><span class="main">(</span></span><span class="free"><span class="free">πi</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">Vi</span></span><span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which satisfy the 
  map/set invariants and encode a minimum spanning tree of the component of the
  graph that contains <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span>.
  
  Notes:
    <span class="antiquoted"><span class="antiquoted">▪</span></span> If <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span> is n ot a node of the graph, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>component_of›</span></span></span></span> will return the graph
      with the only node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span>. (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] component_of_not_node<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
›</span></span>
  
<span class="keyword1"><span class="command">theorem</span></span> prim_list_impl_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> prim_list_impl <span class="free">l</span> <span class="free">r</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="main">¬</span>G.valid_wgraph_repr <span class="free">l</span> <span class="comment1">― ‹Invalid input›</span>
  <span class="main">|</span> Some <span class="bound">πi</span> <span class="main">⇒</span> 
        G.valid_wgraph_repr <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">Gi</span> <span class="main">=</span> G.from_list <span class="free">l</span> <span class="keyword1">in</span> G.invar <span class="bound">Gi</span> <span class="comment1">― ‹Valid input›</span>
        <span class="main">∧</span> P.invar_MST <span class="bound">πi</span> <span class="comment1">― ‹Output satisfies invariants›</span>
        <span class="main">∧</span> is_MST <span class="main">(</span>G.αw <span class="bound">Gi</span><span class="main">)</span> <span class="main">(</span>component_of <span class="main">(</span>G.αg <span class="bound">Gi</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>P.α_MST <span class="free">r</span> <span class="bound">πi</span><span class="main">)</span><span class="main">)</span> <span class="comment1">― ‹and represents MST›</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> prim_list_impl_def G_from_list_unfold
  <span class="keyword1"><span class="command">using</span></span> prim_impl_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"G.from_list <span class="free"><span class="free">l</span></span>"</span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main">]</span> G.from_list_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">l</span></span></span></span></span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> prim_list_impl_correct_presentation<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> prim_list_impl <span class="free">l</span> <span class="free">r</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="main">¬</span>G.valid_wgraph_repr <span class="free">l</span> <span class="comment1">― ‹Invalid input›</span>
  <span class="main">|</span> Some <span class="bound">πi</span> <span class="main">⇒</span> <span class="keyword1">let</span> 
      <span class="bound">g</span><span class="main">=</span>G.αg <span class="main">(</span>G.from_list <span class="free">l</span><span class="main">)</span><span class="main">;</span> 
      <span class="bound">w</span><span class="main">=</span>G.αw <span class="main">(</span>G.from_list <span class="free">l</span><span class="main">)</span><span class="main">;</span> 
      <span class="bound">rg</span><span class="main">=</span>component_of <span class="bound">g</span> <span class="free">r</span><span class="main">;</span>
      <span class="bound">t</span><span class="main">=</span>P.α_MST <span class="free">r</span> <span class="bound">πi</span>
    <span class="keyword1">in</span> 
        G.valid_wgraph_repr <span class="free">l</span> <span class="comment1">― ‹Valid input›</span> 
      <span class="main">∧</span> P.invar_MST <span class="bound">πi</span> <span class="comment1">― ‹Output satisfies invariants›</span>
      <span class="main">∧</span> is_MST <span class="bound">w</span> <span class="bound">rg</span> <span class="bound">t</span> <span class="comment1">― ‹and represents MST›</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> prim_list_impl_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
  
      
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code Generation and Test\label{sec:prim_exec}›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prim_list_impl_int</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prim_list_impl_int</span> <span class="main">≡</span> prim_list_impl"</span></span>


<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">prim_list_impl</span></span> <span class="quoted"><span class="quoted">prim_list_impl_int</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML


<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

                                  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≡</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≡</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≡</span> <span class="numeral">3</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≡</span> <span class="numeral">4</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">≡</span> <span class="numeral">5</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">≡</span> <span class="numeral">6</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≡</span> <span class="numeral">7</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">≡</span> <span class="numeral">8</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≡</span> <span class="numeral">9</span>"</span></span>


<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>prim_list_impl_int <span class="main">[</span>
  <span class="main">(</span><span class="main">(</span>a<span class="main">,</span>b<span class="main">)</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>a<span class="main">,</span>h<span class="main">)</span><span class="main">,</span><span class="numeral">8</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>b<span class="main">,</span>h<span class="main">)</span><span class="main">,</span><span class="numeral">11</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>b<span class="main">,</span>c<span class="main">)</span><span class="main">,</span><span class="numeral">8</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>h<span class="main">,</span>i<span class="main">)</span><span class="main">,</span><span class="numeral">7</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>h<span class="main">,</span>g<span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>c<span class="main">,</span>i<span class="main">)</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>g<span class="main">,</span>i<span class="main">)</span><span class="main">,</span><span class="numeral">6</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>c<span class="main">,</span>d<span class="main">)</span><span class="main">,</span><span class="numeral">7</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>c<span class="main">,</span>f<span class="main">)</span><span class="main">,</span><span class="numeral">4</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>g<span class="main">,</span>f<span class="main">)</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>d<span class="main">,</span>f<span class="main">)</span><span class="main">,</span><span class="numeral">14</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>d<span class="main">,</span>e<span class="main">)</span><span class="main">,</span><span class="numeral">9</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="main">(</span>e<span class="main">,</span>f<span class="main">)</span><span class="main">,</span><span class="numeral">10</span><span class="main">)</span>
<span class="main">]</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>




<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Chapter_Dijkstra">
<div class="head">
<h1>Theory Chapter_Dijkstra</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Dijkstra's Shortest Path Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\noindent
  Dijkstra's algorithm~\cite{Dijk59} is a classical algorithm to determine the shortest
  paths from a root node to all other nodes in a weighted directed graph. 
  Although it solves a different problem, and works on a different type of graphs, 
  its structure is very similar to Prim's algorithm. 
  In particular, like Prim's algorithm, it has a simple loop structure and can be efficiently 
  implemented by a priority queue. 
  
  Again, our formalization of Dijkstra's algorithm follows the presentation 
  of Cormen et al.~\cite{Cormen-Leiserson-Rivest}. However, for the sake of simplicity, 
  our algorithm does not compute actual shortest paths, but only their weights. 
›</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Chapter_Dijkstra
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Directed_Graph">
<div class="head">
<h1>Theory Directed_Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Weighted Directed Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Directed_Graph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Common.html">Common</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A weighted graph is represented by a function from edges to weights.

  For simplicity, we use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">enat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as weights, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">∞</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> meaning 
  that there is no edge.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> <span class="main">⇒</span> enat"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We encapsulate weighted graphs into a locale that fixes a graph›</span></span>
<span class="keyword1"><span class="command">locale</span></span> WGraph <span class="main">=</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> wgraph"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Set of edges with finite weight›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">.</span> <span class="free">w</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">≠</span> <span class="main">∞</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A path between nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is a list of edge weights
  of a sequence of edges from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>.
  
  Note that a path may also contain edges with weight <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∞›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> enat list <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">path</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">uh</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="free">w</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">uh</span><span class="main">)</span> <span class="main">∧</span> <span class="free">path</span> <span class="bound">uh</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"path <span class="free">u</span> <span class="main">(</span><span class="free">ls1</span><span class="main">@</span><span class="free">ls2</span><span class="main">)</span> <span class="free">v</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> path <span class="free">u</span> <span class="free">ls1</span> <span class="bound">w</span> <span class="main">∧</span> path <span class="bound">w</span> <span class="free">ls2</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ls1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There is a singleton path between every two nodes 
  (it's weight might be <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∞›</span></span></span></span>).›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> triv_path<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="free">u</span> <span class="main">[</span><span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Shortcut for the set of all paths between two nodes›</span></span>    
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">paths</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">p</span> <span class="main">.</span> path <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> paths_ne<span class="main">:</span> <span class="quoted"><span class="quoted">"paths <span class="free">u</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> triv_path <span class="keyword1"><span class="command">unfolding</span></span> paths_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If there is a path from a node inside a set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>, to a node outside 
  a set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>, this path must contain an edge from inside <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> to outside <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> find_leave_edgeE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">u</span> <span class="free">p</span> <span class="free">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">x</span> <span class="free">y</span> <span class="free">p2</span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">p1</span><span class="main">@</span><span class="free">w</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">#</span><span class="free">p2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∉</span><span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">u</span> <span class="free">p1</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">y</span> <span class="free">p2</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p1</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">p2</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> <span class="bound">p1</span><span class="main">@</span><span class="free">w</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">#</span><span class="bound">p2</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">∈</span><span class="free">S</span> <span class="main">∧</span> <span class="bound">y</span><span class="main">∉</span><span class="free">S</span> <span class="main">∧</span> path <span class="free">u</span> <span class="bound">p1</span> <span class="bound">x</span> <span class="main">∧</span> path <span class="bound">y</span> <span class="bound">p2</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">=</span><span class="free">w</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> PX<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="skolem">x</span> <span class="skolem">p</span> <span class="free">v</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">S</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> PX <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span><span class="free">S</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">from</span></span> Cons.IH<span class="main">[</span><span class="operator">OF</span> PX True <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∉</span><span class="free">S</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> WGraph.path.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> append_Cons<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Distance›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The (minimum) distance between two nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is called <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>δ u v›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">δ</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">LEAST</span> <span class="bound">w</span><span class="main">::</span>enat<span class="main">.</span> <span class="bound">w</span><span class="main">∈</span>sum_list<span class="main">`</span>paths <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> obtain_shortest_path<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="free">p</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">=</span> sum_list <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> δ_def <span class="keyword1"><span class="command">using</span></span> paths_ne
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Collect_empty_eq LeastI_ex WGraph.paths_def imageI image_iff 
          mem_Collect_eq paths_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shortest_path_least<span class="main">:</span>  
  <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="free">p</span> <span class="free">u</span> <span class="main">⟹</span> δ <span class="free">s</span> <span class="free">u</span> <span class="main">≤</span> sum_list <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> δ_def paths_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Least_le<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> distance_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">s</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> shortest_path_least<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> distance_direct<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">w</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="free">u</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> shortest_path_least<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">w</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Triangle inequality: The distance from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is shorter than 
  the distance from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> and the edge weight from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>. ›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> triangle<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">v</span> <span class="main">≤</span> δ <span class="free">s</span> <span class="free">u</span> <span class="main">+</span> <span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="main">(</span><span class="skolem">p</span><span class="main">@</span><span class="main">[</span><span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="skolem">p</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">(</span><span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> sum_list <span class="main">`</span> paths <span class="free">s</span> <span class="free">u</span> <span class="main">⊆</span> sum_list <span class="main">`</span> paths <span class="free">s</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> paths_def image_iff <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> path.simps path_append<span class="main">)</span> 
  <span class="keyword1"><span class="command">from</span></span> least_antimono<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> paths_ne <span class="keyword1"><span class="command">have</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">y</span><span class="main">::</span>enat<span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> sum_list <span class="main">`</span> paths <span class="free">s</span> <span class="free">v</span><span class="main">)</span> 
    <span class="main">≤</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">x</span><span class="main">::</span>enat<span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="main">(+)</span> <span class="main">(</span><span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> sum_list <span class="main">`</span> paths <span class="free">s</span> <span class="free">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> paths_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sum_list <span class="main">`</span> paths <span class="free">s</span> <span class="free">u</span><span class="main">)</span> <span class="main">+</span> <span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Least_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">(</span><span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"sum_list<span class="main">`</span>paths <span class="free">s</span> <span class="free">u</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> paths_def mem_Collect_eq 
                          obtain_shortest_path shortest_path_least<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> δ_def <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Any prefix of a shortest path is a shortest path itself.
  Note: The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>&lt; ∞›</span></span></span></span> conditions are required to avoid saturation in adding to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∞›</span></span></span></span>!
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> shortest_path_prefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">x</span> <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">u</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> DSU<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">=</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">≤</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms shortest_path_least <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>δ <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p<span class="hidden">⇩</span><sub>1</sub>'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="skolem">p<span class="hidden">⇩</span><sub>1</sub>'</span> <span class="main">&lt;</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> obtain_shortest_path<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹path <span class="free">x</span> <span class="free">p<span class="hidden">⇩</span><sub>2</sub></span> <span class="free">u</span>›</span></span> shortest_path_least<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p<span class="hidden">⇩</span><sub>1</sub>'</span><span class="main">@</span><span class="free">p<span class="hidden">⇩</span><sub>2</sub></span>"</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> DSU <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">=</span> sum_list <span class="free">p<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> DSU <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> le_iff_add <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
      
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Directed_Graph_Specs">
<div class="head">
<h1>Theory Directed_Graph_Specs</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract Datatype for Weighted Directed Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Directed_Graph_Specs
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Directed_Graph.html">Directed_Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> adt_wgraph <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span>nat<span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty_graph</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'g</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'g</span> <span class="main">⇒</span> <span class="tfree">'g</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> succ_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set <span class="main">(</span><span class="free">succ</span> <span class="free">g</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">α</span> <span class="free">g</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> empty_graph_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">empty_graph</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="free">empty_graph</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> add_edge_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="free">g</span> <span class="free">e</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">add_edge</span> <span class="free">e</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="free">g</span> <span class="free">e</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟹</span> <span class="free">α</span> <span class="main">(</span><span class="free">add_edge</span> <span class="free">e</span> <span class="free">d</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">(</span><span class="free">e</span><span class="main">:=</span>enat <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">lemmas</span></span> wgraph_specs <span class="main">=</span> succ_correct empty_graph_correct add_edge_correct
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> adt_finite_wgraph <span class="main">=</span> adt_wgraph <span class="keyword2"><span class="keyword">where</span></span> α<span class="main">=</span><span class="quoted"><span class="free">α</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> finite <span class="main">(</span>WGraph.edges <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Constructing Weighted Graphs from Lists›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> edges_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"WGraph.edges <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WGraph.edges_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> edges_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"WGraph.edges <span class="main">(</span><span class="free">g</span><span class="main">(</span><span class="free">e</span><span class="main">:=</span>enat <span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Set.insert <span class="free">e</span> <span class="main">(</span>WGraph.edges <span class="free">g</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WGraph.edges_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A list represents a graph if there are no multi-edges or duplicate edges›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_graph_rep</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> 
  <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">d</span> <span class="bound">d'</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d'</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟶</span> <span class="bound">d</span><span class="main">=</span><span class="bound">d'</span><span class="main">)</span>
<span class="main">∧</span> distinct <span class="free"><span class="bound"><span class="entity">l</span></span></span>
  "</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Alternative characterization: all node pairs must be distinct›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> valid_graph_rep_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"valid_graph_rep <span class="free">l</span> <span class="main">⟷</span> distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_graph_rep_def distinct_map inj_on_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> valid_graph_rep_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"valid_graph_rep <span class="main">[]</span>"</span></span>
  <span class="quoted"><span class="quoted">"valid_graph_rep <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span><span class="free">d</span><span class="main">)</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span> <span class="main">⟷</span> valid_graph_rep <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d'</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span><span class="bound">d'</span><span class="main">)</span><span class="main">∉</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_graph_rep_def<span class="main">)</span>

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For a valid graph representation, there is exactly one graph that 
  corresponds to it›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> valid_graph_rep_ex1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"valid_graph_rep <span class="free">l</span> <span class="main">⟹</span> <span class="main">∃!</span> <span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">w</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> valid_graph_rep_code
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span>
        <span class="keyword1">if</span> <span class="main">∃</span><span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="keyword1">then</span> enat <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">∞</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> someI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_map inj_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main"><span class="keyword3">;</span></span> 
           <span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> w w'
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> not_enat_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define this graph using determinate choice›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wgraph_of_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="keyword1">THE</span> <span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">d</span><span class="main">.</span> <span class="bound">w</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>  

<span class="keyword1"><span class="command">locale</span></span> wgraph_from_list_algo <span class="main">=</span> adt_wgraph 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="free">add_edge</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free">empty_graph</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges_undef</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> edges_undef_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"edges_undef <span class="main">[]</span> <span class="free">w</span>"</span></span>  
  <span class="quoted"><span class="quoted">"edges_undef <span class="free">l</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"edges_undef <span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">#</span><span class="free">l</span><span class="main">)</span> <span class="free">w</span> <span class="main">⟷</span> edges_undef <span class="free">l</span> <span class="free">w</span> <span class="main">∧</span> <span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="quoted"><span class="quoted">"edges_undef <span class="free">l</span> <span class="main">(</span><span class="free">w</span><span class="main">(</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">:=</span> enat <span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> edges_undef <span class="free">l</span> <span class="free">w</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">d'</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span><span class="bound">d'</span><span class="main">)</span><span class="main">∉</span>set <span class="free">l</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> edges_undef_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> from_list_correct_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph_rep <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"edges_undef <span class="free">l</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">g'</span> <span class="main">≡</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="free">add_edge</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span><span class="main">)</span> <span class="free">l</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">d</span><span class="main">.</span> <span class="free">α</span> <span class="free">g'</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span> <span class="main">⟷</span> <span class="free">α</span> <span class="free">g</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1-3<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> g'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">g</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wgraph_specs <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> from_list_correct'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph_rep <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">,</span><span class="free">d</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟷</span> <span class="free">α</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> from_list_def 
  <span class="keyword1"><span class="command">using</span></span> from_list_correct_aux<span class="main">[</span><span class="operator">OF</span> assms<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">empty_graph</span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wgraph_specs<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> from_list_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph_rep <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> wgraph_of_list <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> theI'<span class="main">[</span><span class="operator">OF</span> valid_graph_rep_ex1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> wgraph_of_list_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>wgraph_of_list <span class="free">l</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="skolem">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">,</span> <span class="skolem">d</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">d</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span> <span class="main">=</span> wgraph_of_list <span class="free">l</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> from_list_correct_aux<span class="main">[</span><span class="operator">OF</span> assms<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">empty_graph</span></span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff wgraph_specs from_list_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> enat.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span>from_list <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms from_list_correct'<span class="main">)</span>
    
<span class="keyword1"><span class="command">qed</span></span>    
    
<span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dijkstra_Abstract">
<div class="head">
<h1>Theory Dijkstra_Abstract</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract Dijkstra Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra_Abstract
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Directed_Graph.html">Directed_Graph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Algorithm›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> estimate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> enat"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a start node and a weighted graph›</span></span>
<span class="keyword1"><span class="command">locale</span></span> Dijkstra <span class="main">=</span> WGraph <span class="quoted"><span class="free">w</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">s</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relax all outgoing edges of node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">relax_outgoing</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> estimate <span class="main">⇒</span> <span class="tfree">'v</span> estimate"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">relax_outgoing</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">v</span><span class="main">.</span> min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="bound">v</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">+</span> <span class="free">w</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initialization›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">initD</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span><span class="main">(</span><span class="free">s</span><span class="main">:=</span><span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">initS</span> <span class="main">≡</span> <span class="main">{}</span>"</span></span>  
  
      
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relaxing will never increase estimates›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> relax_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"relax_outgoing <span class="free">u</span> <span class="free">D</span> <span class="free">v</span> <span class="main">≤</span> <span class="free">D</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_dnodes</span> <span class="main">≡</span> Set.insert <span class="free">s</span> <span class="main">{</span> <span class="bound">v</span> <span class="main">.</span> <span class="main">∃</span><span class="bound">u</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">≠</span><span class="main">∞</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfinished_dnodes</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> all_dnodes <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfinished_nodes_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"unfinished_dnodes <span class="free">S</span> <span class="main">⊆</span> all_dnodes"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unfinished_dnodes_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Invariant›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The invariant is defined as locale›</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> Dijkstra_Invar <span class="main">=</span> Dijkstra <span class="quoted"><span class="free">w</span></span> <span class="quoted"><span class="free">s</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> estimate"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> upper_bound<span class="main">:</span> <span class="quoted"><span class="quoted">‹δ <span class="free">s</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">D</span> <span class="free">u</span>›</span></span> <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>D›</span></span> is a valid estimate›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s_in_S<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">s</span><span class="main">∈</span><span class="free">S</span> <span class="main">∨</span> <span class="main">(</span><span class="free">D</span><span class="main">=</span><span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">∞</span><span class="main">)</span><span class="main">(</span><span class="free">s</span><span class="main">:=</span><span class="main">0</span><span class="main">)</span> <span class="main">∧</span> <span class="free">S</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span>›</span></span> <span class="comment1">― ‹The start node is 
    finished, or we are in initial state›</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> S_precise<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">S</span> <span class="main">⟹</span> <span class="free">D</span> <span class="free">u</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="comment1">― ‹Finished nodes have precise 
    estimate›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S_relaxed<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">S</span> <span class="main">⟹</span> <span class="free">D</span> <span class="free">u</span> <span class="main">≤</span> δ <span class="free">s</span> <span class="free">v</span> <span class="main">+</span> <span class="free">w</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">u</span><span class="main">)</span>›</span></span> <span class="comment1">― ‹Outgoing edges of 
    finished nodes have been relaxed, using precise distance›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">D_invar</span> <span class="main">≡</span> Dijkstra_Invar <span class="free">w</span> <span class="free">s</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The invariant holds for the initial state›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra<span class="main">)</span> invar_init<span class="main">:</span> <span class="quoted"><span class="quoted">"D_invar initD initS"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> initD_def initS_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def distance_direct<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relaxing some edges maintains the upper bound property›</span></span>    
<span class="keyword1"><span class="command">lemma</span></span> maintain_upper_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">≤</span> <span class="main">(</span>relax_outgoing <span class="free">v</span> <span class="free">D</span><span class="main">)</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def upper_bound <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> triangle upper_bound add_right_mono dual_order.trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Relaxing edges will not affect nodes with already precise estimates›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> relax_precise_id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">v</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">v</span> <span class="main">⟹</span> relax_outgoing <span class="free">u</span> <span class="free">D</span> <span class="free">v</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> maintain_upper_bound upper_bound relax_mono
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In particular, relaxing edges will not affect finished nodes›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> relax_finished_id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">S</span> <span class="main">⟹</span> relax_outgoing <span class="free">u</span> <span class="free">D</span> <span class="free">v</span> <span class="main">=</span> <span class="free">D</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_precise relax_precise_id<span class="main">)</span>  
      
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The least (finite) estimate among all nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> not in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> is already precise.
  This will allow us to add the node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>. ›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> maintain_S_precise_and_connected<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∉</span><span class="free">S</span> <span class="main">⟶</span> <span class="free">D</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">D</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We start with a case distinction whether we are in the first 
    step of the loop, where we process the start node, or in subsequent steps,
    where the start node has already been finished.›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">s</span>"</span></span><span class="main">)</span>  
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">s</span>"</span></span> <span class="comment1">― ‹First step of loop›</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span> s_in_S <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≠</span><span class="free">s</span>›</span></span> <span class="comment1">― ‹Later step of loop›</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The start node has already been finished›</span></span>   
  <span class="keyword1"><span class="command">with</span></span> s_in_S MIN <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="free">s</span><span class="main">∈</span><span class="free">S</span>›</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> <span class="keyword1"><span class="command">using</span></span> infinity_ne_i0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we handle the case that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> is unreachable.›</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">‹δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>›</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span><span class="main">)</span>"</span></span> <span class="comment1">― ‹Node is unreachable (infinite distance)›</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By the upper-bound property, we get <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D u = δ s u = ∞›</span></span></span></span>›</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> upper_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="comment1">― ‹Main case: Node has finite distance›</span>
 
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Consider a shortest path from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>›</span></span>        
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="skolem">p</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> DSU<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">=</span> sum_list <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> obtain_shortest_path<span class="main">)</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It goes from inside <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> to outside <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>, so there must be an edge at the border.
      Let <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(x,y)›</span></span></span></span> be such an edge, with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x∈S›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y∉S›</span></span></span></span>.›</span></span>
    <span class="keyword1"><span class="command">from</span></span> find_leave_edgeE<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹path <span class="free">s</span> <span class="skolem">p</span> <span class="free">u</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">s</span><span class="main">∈</span><span class="free">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p1</span> <span class="main">@</span> <span class="free">w</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">p2</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> DECOMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∉</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="skolem">p1</span> <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="skolem">y</span> <span class="skolem">p2</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As prefixes of shortest paths are again shortest paths, the shortest 
          path to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> ends with edge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(x,y)›</span></span></span></span> ›</span></span>  
    <span class="keyword1"><span class="command">have</span></span> DSX<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="skolem">x</span> <span class="main">=</span> sum_list <span class="skolem">p1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> DSY<span class="main">:</span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="skolem">y</span> <span class="main">=</span> δ <span class="free">s</span> <span class="skolem">x</span> <span class="main">+</span> <span class="free">w</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> shortest_path_prefix<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p1</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">x</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">w</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">x</span></span><span class="main"><span class="main">,</span></span><span class="skolem"><span class="skolem">y</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">#</span></span><span class="skolem"><span class="skolem">p2</span></span>"</span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="main">]</span> 
        <span class="keyword2"><span class="keyword">and</span></span> shortest_path_prefix<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">p1</span></span><span class="main"><span class="main">@</span></span><span class="main"><span class="main">[</span></span><span class="free"><span class="free">w</span></span> <span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">x</span></span><span class="main"><span class="main">,</span></span><span class="skolem"><span class="skolem">y</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span>"</span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">y</span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p2</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>›</span></span> DECOMP 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> DSU<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Upon adding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>, this edge has been relaxed with the precise
       estimate for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>. At this point the estimate for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> has become 
       precise, too›</span></span>  
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∈</span><span class="free">S</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="skolem">y</span> <span class="main">=</span> δ <span class="free">s</span> <span class="skolem">y</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> S_relaxed antisym_conv upper_bound<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The shortest path to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>y›</span></span></span></span> is a prefix of that to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>, thus 
      it shorter or equal›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> δ <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> DSU <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DSX DSY<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The estimate for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> is an upper bound›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">D</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> upper_bound <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> was a node with smallest estimate›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="free">D</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">∉</span><span class="free">S</span>›</span></span> MIN <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This closed a cycle in the inequation chain. Thus, by 
      antisymmetry, all items are equal. In particular, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D u = δ s u›</span></span></span></span>, qed.›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>    
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A step of Dijkstra's algorithm maintains the invariant.
  More precisely, in a step of Dijkstra's algorithm, 
  we pick a node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u∉S›</span></span></span></span> with least finite estimate, relax the outgoing 
  edges of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>, and add <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span>.›</span></span>    
<span class="keyword1"><span class="command">theorem</span></span> maintain_D_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∉</span><span class="free">S</span> <span class="main">⟶</span> <span class="free">D</span> <span class="free">u</span> <span class="main">≤</span> <span class="free">D</span> <span class="bound">v</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"D_invar <span class="main">(</span>relax_outgoing <span class="free">u</span> <span class="free">D</span><span class="main">)</span> <span class="main">(</span>Set.insert <span class="free">u</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">‹<span class="free">s</span><span class="main">∈</span><span class="free">S</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> maintain_upper_bound<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> maintain_S_precise_and_connected<span class="main">[</span><span class="operator">OF</span> UNS MIN<span class="main">]</span> S_precise        
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_precise_id<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">using</span></span> maintain_S_precise_and_connected<span class="main">[</span><span class="operator">OF</span> UNS MIN<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def S_relaxed min.coboundedI1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> s_in_S UNI distance_direct 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When the algorithm is finished, i.e., when there are 
  no unfinished nodes with finite estimates left,
  then all estimates are accurate.›</span></span>  
<span class="keyword1"><span class="command">lemma</span></span> invar_finish_imp_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span><span class="main">∉</span><span class="free">S</span> <span class="main">⟶</span> <span class="free">D</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">=</span> δ <span class="free">s</span> <span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">S</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The estimates of finished nodes are accurate›</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> S_precise <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span> <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D u›</span></span></span></span> is minimal, and minimal estimates are precise›</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> F maintain_S_precise_and_connected<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">qed</span></span>  
  
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A step decreases the set of unfinished nodes.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> unfinished_nodes_decr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unfinished_dnodes <span class="main">(</span>Set.insert <span class="free">u</span> <span class="free">S</span><span class="main">)</span> <span class="main">⊂</span> unfinished_dnodes <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There is a path to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>›</span></span>
  <span class="keyword1"><span class="command">from</span></span> UNI <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> upper_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span> leD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> is among <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>all_dnodes›</span></span></span></span>›</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>all_dnodes"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"path <span class="free">s</span> <span class="skolem">p</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"sum_list <span class="skolem">p</span> <span class="main">&lt;</span> <span class="main">∞</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> obtain_shortest_path<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">u</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹δ <span class="free">s</span> <span class="free">u</span> <span class="main">&lt;</span> <span class="main">∞</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Dijkstra.all_dnodes_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Which implies the proposition›</span></span>
  <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∉</span><span class="free">S</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unfinished_dnodes_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
        
<span class="keyword2"><span class="keyword">end</span></span>  


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement by Priority Map and Map›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In a second step, we implement <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> by a priority map <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> and a map <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V›</span></span></span></span>.
  Both map nodes to finite weights, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> maps unfinished nodes, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V›</span></span></span></span> 
  maps finished nodes.

  Note that this implementation is slightly non-standard: 
  In the standard implementation, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span> contains also unfinished nodes with 
  infinite weight.
  
  We chose this implementation because it avoids enumerating all nodes of 
  the graph upon initialization of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span>.
  However, on relaxing an edge to a node not in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Q›</span></span></span></span>, we require an extra 
  lookup to check whether the node is finished. 
›</span></span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>enat›</span></span></span></span> by Option›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our maps are functions to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nat option›</span></span></span></span>,which are interpreted as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>enat›</span></span></span></span>,
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span> being <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>∞›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">enat_of_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option <span class="main">⇒</span> enat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">enat_of_option</span> None <span class="main">=</span> <span class="main">∞</span>"</span></span> 
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">enat_of_option</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> enat <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_inj<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> enat_of_option <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> enat <span class="free">n</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"enat_of_option <span class="free">x</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">=</span> enat_of_option <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">∞</span> <span class="main">=</span> enat_of_option <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> enat_of_option_le_conv<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"enat_of_option <span class="free">m</span> <span class="main">≤</span> enat_of_option <span class="free">n</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">m</span><span class="main">,</span><span class="free">n</span><span class="main">)</span> <span class="keyword1">of</span> 
      <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span>None<span class="main">)</span> <span class="main">⇒</span> True
    <span class="main">|</span> <span class="main">(</span>Some <span class="bound">a</span><span class="main">,</span> Some <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">≤</span><span class="bound">b</span>
    <span class="main">|</span> <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> False
  <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D,S›</span></span></span></span> by Priority Map and Map›</span></span>
<span class="keyword1"><span class="command">context</span></span> Dijkstra <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a coupling relation, that connects the concrete with the 
  abstract data. ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">coupling</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≡</span> 
  <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">=</span> enat_of_option <span class="keyword1">o</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">++</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span>
<span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">=</span> dom <span class="free"><span class="bound"><span class="entity">V</span></span></span>
<span class="main">∧</span> dom <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">∩</span> dom <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that our coupling relation is functional.›</span></span>
<span class="comment1">(* TODO: Why not use functions instead? *)</span>
<span class="keyword1"><span class="command">lemma</span></span> coupling_fun<span class="main">:</span> <span class="quoted"><span class="quoted">"coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D</span> <span class="free">S</span> <span class="main">⟹</span> coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D'</span> <span class="free">S'</span> <span class="main">⟹</span> <span class="free">D'</span><span class="main">=</span><span class="free">D</span> <span class="main">∧</span> <span class="free">S'</span><span class="main">=</span><span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coupling_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The concrete version of the invariant.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">D_invar'</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">≡</span>
  <span class="main">∃</span><span class="bound">D</span> <span class="bound">S</span><span class="main">.</span> coupling <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="bound">D</span> <span class="bound">S</span> <span class="main">∧</span> D_invar <span class="bound">D</span> <span class="bound">S</span>"</span></span>

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Refinement of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>relax-outgoing›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relax_outgoing'</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">du</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">case</span> <span class="free">w</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
    <span class="main">∞</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
  <span class="main">|</span> enat <span class="bound">d</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∈</span>dom <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="keyword1">then</span> None <span class="keyword1">else</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="bound">d'</span> <span class="main">⇒</span> Some <span class="main">(</span>min <span class="bound">d'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
"</span></span>

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A step preserves the coupling relation.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Invar<span class="main">)</span> coupling_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> UNI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">du</span>"</span></span>
  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coupling 
    <span class="main">(</span><span class="main">(</span>relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span><span class="main">)</span><span class="main">(</span><span class="free">u</span><span class="main">:=</span>None<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">V</span><span class="main">(</span><span class="free">u</span><span class="main">↦</span><span class="free">du</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">(</span>relax_outgoing <span class="free">u</span> <span class="free">D</span><span class="main">)</span> <span class="main">(</span>Set.insert <span class="free">u</span> <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> C <span class="keyword1"><span class="command">unfolding</span></span> coupling_def 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ext conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">elim</span> conjE<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> α<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">=</span> enat_of_option <span class="main">∘</span> <span class="free">V</span> <span class="main">++</span> <span class="free">Q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">=</span> dom <span class="free">V</span>"</span></span> 
     <span class="keyword2"><span class="keyword">and</span></span> DD<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="free">V</span> <span class="main">∩</span> dom <span class="free">Q</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
   
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Set.insert <span class="free">u</span> <span class="free">S</span> <span class="main">=</span> dom <span class="main">(</span><span class="free">V</span><span class="main">(</span><span class="free">u</span> <span class="main">↦</span> <span class="free">du</span><span class="main">)</span><span class="main">)</span>"</span></span>   
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> α<span class="main">)</span>
     
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">du</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="free">u</span> <span class="main">=</span> None"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> DD UNI UNS <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> α<span class="main">)</span>
    
  <span class="keyword1"><span class="command">from</span></span> DD 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dom <span class="main">(</span><span class="free">V</span><span class="main">(</span><span class="free">u</span> <span class="main">↦</span> <span class="free">du</span><span class="main">)</span><span class="main">)</span> <span class="main">∩</span> dom <span class="main">(</span><span class="main">(</span>relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span><span class="main">)</span><span class="main">(</span><span class="free">u</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 3 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing'_def dom_def 
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits enat.splits option.splits<span class="main">)</span>
  
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"relax_outgoing <span class="free">u</span> <span class="free">D</span> <span class="skolem">v</span> 
    <span class="main">=</span> <span class="main">(</span>enat_of_option <span class="main">∘</span> <span class="free">V</span><span class="main">(</span><span class="free">u</span> <span class="main">↦</span> <span class="free">du</span><span class="main">)</span> <span class="main">++</span> <span class="main">(</span>relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span><span class="main">)</span><span class="main">(</span><span class="free">u</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">)</span> <span class="skolem">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">S</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> DD
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> relax_finished_id<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing'_def map_add_apply α min_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits enat.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing_def relax_outgoing'_def map_add_apply α min_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits enat.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>    
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Refinement of initial state›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">initQ</span> <span class="main">≡</span> Map.empty<span class="main">(</span><span class="free">s</span><span class="main">↦</span><span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">initV</span> <span class="main">≡</span> Map.empty"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> coupling_init<span class="main">:</span>
  <span class="quoted"><span class="quoted">"coupling initQ initV initD initS"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> coupling_def initD_def initQ_def initS_def initV_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coupling_def relax_outgoing_def map_add_apply enat_0 
    <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split enat.split
    <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
  
<span class="keyword1"><span class="command">lemma</span></span> coupling_cond<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Q</span> <span class="main">=</span> Map.empty<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span><span class="main">∉</span><span class="free">S</span> <span class="main">⟶</span> <span class="free">D</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">∞</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coupling_def<span class="main">)</span>

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Termination argument: Refinement of unfinished nodes.›</span></span>  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unfinished_dnodes'</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">≡</span> unfinished_dnodes <span class="main">(</span>dom <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> coupling_unfinished<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D</span> <span class="free">S</span> <span class="main">⟹</span> unfinished_dnodes' <span class="free">V</span> <span class="main">=</span> unfinished_dnodes <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coupling_def unfinished_dnodes'_def unfinished_dnodes_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementing graph by successor list›</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">relax_outgoing''</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">du</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Q</span><span class="main">.</span>
  <span class="keyword1">case</span> <span class="bound">Q</span> <span class="bound">v</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span>dom <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="keyword1">then</span> <span class="bound">Q</span> <span class="keyword1">else</span> <span class="bound">Q</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span>
            <span class="main">|</span> Some <span class="bound">d'</span> <span class="main">⇒</span> <span class="bound">Q</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span>min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span> <span class="bound">d'</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> relax_outgoing''_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">l</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span><span class="main">}</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"relax_outgoing'' <span class="free">l</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="main">=</span> relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
  
  <span class="keyword1"><span class="command">have</span></span> aux1<span class="main">:</span>
     <span class="quoted"><span class="quoted">"relax_outgoing'' <span class="free">l</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="skolem">v</span> 
     <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">v</span><span class="main">∈</span>snd<span class="main">`</span>set <span class="free">l</span> <span class="keyword1">then</span> relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="skolem">v</span> <span class="keyword1">else</span> <span class="free">Q</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"set <span class="free">l</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> enat <span class="bound">d</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span> <span class="quoted"><span class="skolem">v</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing''_def relax_outgoing'_def image_iff
      <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> if_splits option.splits<span class="main">)</span>
  
  <span class="keyword1"><span class="command">have</span></span> aux2<span class="main">:</span>  
    <span class="quoted"><span class="quoted">"relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="skolem">v</span> <span class="main">=</span> <span class="free">Q</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> relax_outgoing'_def<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"relax_outgoing'' <span class="free">l</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="skolem">v</span> <span class="main">=</span> relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span> <span class="skolem">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> aux1
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹<span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main">:</span> aux2 assms›</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Directed_Graph_Impl">
<div class="head">
<h1>Theory Directed_Graph_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Weighted Digraph Implementation by Adjacency Map›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Directed_Graph_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Directed_Graph_Specs.html">Directed_Graph_Specs</a>
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/Map_Specs.html">HOL-Data_Structures.Map_Specs</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> wgraph_by_map <span class="main">=</span> 
  M<span class="main">:</span> Map <span class="quoted"><span class="free">M_empty</span></span> <span class="quoted"><span class="free">M_update</span></span> <span class="quoted"><span class="free">M_delete</span></span> <span class="quoted"><span class="free">M_lookup</span></span> <span class="quoted"><span class="free">M_invar</span></span> 
  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">M_empty</span> <span class="free">M_update</span> <span class="free">M_delete</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>nat<span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list<span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_invar</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">u</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="main">∞</span> 
  <span class="main">|</span> Some <span class="bound">l</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="main">∃</span><span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="bound">l</span> <span class="keyword1">then</span> enat <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="bound">l</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">∞</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> 
    <span class="free">M_invar</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">l</span><span class="main">∈</span>ran <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">.</span> distinct <span class="main">(</span>map snd <span class="bound">l</span><span class="main">)</span><span class="main">)</span> 
  <span class="main">∧</span> finite <span class="main">(</span>WGraph.edges <span class="main">(</span>α <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">succ</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> the_default <span class="main">[]</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">empty_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty_graph</span> <span class="main">=</span> <span class="free">M_empty</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">add_edge</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">d</span> <span class="bound">g</span><span class="main">.</span> <span class="free">M_update</span> <span class="bound">u</span> <span class="main">(</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">#</span> the_default <span class="main">[]</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="bound">g</span> <span class="bound">u</span><span class="main">)</span><span class="main">)</span> <span class="bound">g</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> adt_finite_wgraph <span class="quoted">invar</span> <span class="quoted">succ</span> <span class="quoted">empty_graph</span> <span class="quoted">add_edge</span> <span class="quoted">α</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> g u 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">M_lookup</span> <span class="skolem">g</span> <span class="skolem">u</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def α_def succ_def ran_def
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> distinct_map_snd_inj someI
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits
        <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
                <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def α_def empty_graph_def add_edge_def M.map_specs 
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
                <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def α_def empty_graph_def add_edge_def M.map_specs 
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>    
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Explicit proof to nicely handle finiteness constraint, using already
     proved shape of abstract result›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">e</span> <span class="skolem">d</span>
  <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="skolem">g</span>"</span></span> <span class="quoted"><span class="quoted">"α <span class="skolem">g</span> <span class="skolem">e</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> AAE<span class="main">:</span> <span class="quoted"><span class="quoted">"α <span class="main">(</span>add_edge <span class="skolem">e</span> <span class="skolem">d</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>α <span class="skolem">g</span><span class="main">)</span><span class="main">(</span><span class="skolem">e</span> <span class="main">:=</span> enat <span class="skolem">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def α_def add_edge_def M.map_specs
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_splits prod.splits
    <span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invar <span class="main">(</span>add_edge <span class="skolem">e</span> <span class="skolem">d</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def AAE<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def α_def empty_graph_def add_edge_def M.map_specs ran_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_splits prod.splits<span class="main">)</span>      
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>     

<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dijkstra_Impl">
<div class="head">
<h1>Theory Dijkstra_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Dijkstra's Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Dijkstra_Abstract.html">Dijkstra_Abstract</a>
  <span class="quoted">"<a href="Directed_Graph_Impl.html">Directed_Graph_Impl</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/While_Combinator.html">HOL-Library.While_Combinator</a>"</span>
  <span class="quoted">"<a href="../Priority_Search_Trees/PST_RBT.html">Priority_Search_Trees.PST_RBT</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/RBT_Map.html">HOL-Data_Structures.RBT_Map</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using ADT Interfaces›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Dijkstra_Impl_Adts <span class="main">=</span> 
  G<span class="main">:</span> adt_finite_wgraph <span class="quoted"><span class="free">G_invar</span></span> <span class="quoted"><span class="free">G_succ</span></span> <span class="quoted"><span class="free">G_empty</span></span> <span class="quoted"><span class="free">G_add</span></span> <span class="quoted"><span class="free">G_α</span></span>
<span class="main">+</span> M<span class="main">:</span> Map <span class="quoted"><span class="free">M_empty</span></span> <span class="quoted"><span class="free">M_update</span></span> <span class="quoted"><span class="free">M_delete</span></span> <span class="quoted"><span class="free">M_lookup</span></span> <span class="quoted"><span class="free">M_invar</span></span>
<span class="main">+</span> Q<span class="main">:</span> PrioMap <span class="quoted"><span class="free">Q_empty</span></span> <span class="quoted"><span class="free">Q_update</span></span> <span class="quoted"><span class="free">Q_delete</span></span> <span class="quoted"><span class="free">Q_invar</span></span> <span class="quoted"><span class="free">Q_lookup</span></span> <span class="quoted"><span class="free">Q_is_empty</span></span> <span class="quoted"><span class="free">Q_getmin</span></span>
  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">)</span> wgraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_invar</span> <span class="free">G_succ</span> <span class="free">G_empty</span> <span class="free">G_add</span>
  
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_empty</span> <span class="free">M_update</span> <span class="free">M_delete</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> nat option"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">M_invar</span>
  
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_empty</span> <span class="free">Q_update</span> <span class="free">Q_delete</span> <span class="free">Q_invar</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'q</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> nat option"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Q_is_empty</span> <span class="free">Q_getmin</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simplifier setup›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> G.wgraph_specs
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> M.map_specs
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Q.prio_map_specs

<span class="keyword2"><span class="keyword">end</span></span>  
  

<span class="keyword1"><span class="command">context</span></span> PrioMap <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_getminE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">getmin</span> <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span><span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free">m</span> <span class="main">≠</span> Map.empty"</span></span> 
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k'</span> <span class="bound">p'</span><span class="main">.</span> <span class="free">lookup</span> <span class="free">m</span> <span class="bound">k'</span> <span class="main">=</span> Some <span class="bound">p'</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">≤</span><span class="bound">p'</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> map_getmin<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main">)</span>
    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> Dijkstra_Impl_Defs <span class="main">=</span> Dijkstra_Impl_Adts <span class="keyword2"><span class="keyword">where</span></span> G_α <span class="main">=</span> <span class="quoted"><span class="free">G_α</span></span>
  <span class="main">+</span> Dijkstra <span class="quoted"><span class="quoted">‹<span class="free">G_α</span> <span class="free">g</span>›</span></span> <span class="quoted"><span class="free">s</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>linorder<span class="main">)</span> wgraph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="free">s</span> 


<span class="keyword1"><span class="command">locale</span></span> Dijkstra_Impl <span class="main">=</span> Dijkstra_Impl_Defs <span class="keyword2"><span class="keyword">where</span></span> G_α <span class="main">=</span> <span class="quoted"><span class="free">G_α</span></span>  
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'g</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">::</span>linorder<span class="main">)</span> wgraph"</span></span> 
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G_invar<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G_invar</span> <span class="free">g</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">lemma</span></span> finite_all_dnodes<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite all_dnodes"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"all_dnodes <span class="main">⊆</span> Set.insert <span class="free">s</span> <span class="main">(</span>snd <span class="main">`</span> edges<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> all_dnodes_def edges_def image_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> G.finite<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>finite_subset<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> finite_unfinished_dnodes<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>unfinished_dnodes <span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> unfinished_nodes_subset<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> fold_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">I</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free">α</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span> <span class="bound">x</span> <span class="main">(</span><span class="free">α</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">(</span>fold <span class="free">f</span> <span class="free">l</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="free">α</span> <span class="main">(</span>fold <span class="free">f</span> <span class="free">l</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> fold <span class="free">f'</span> <span class="free">l</span> <span class="main">(</span><span class="free">α</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">Q_relax_outgoing</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">du</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">d</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">Q</span><span class="main">.</span>
  <span class="keyword1">case</span> <span class="free">Q_lookup</span> <span class="bound">Q</span> <span class="bound">v</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> <span class="keyword1">if</span> <span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="bound">v</span> <span class="main">≠</span> None <span class="keyword1">then</span> <span class="bound">Q</span> <span class="keyword1">else</span> <span class="free">Q_update</span> <span class="bound">v</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span> <span class="bound">Q</span>
  <span class="main">|</span> Some <span class="bound">d'</span> <span class="main">⇒</span> <span class="free">Q_update</span> <span class="bound">v</span> <span class="main">(</span>min <span class="main">(</span><span class="free"><span class="bound"><span class="entity">du</span></span></span><span class="main">+</span><span class="bound">d</span><span class="main">)</span> <span class="bound">d'</span><span class="main">)</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">G_succ</span> <span class="free">g</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> Q_relax_outgoing<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="main">(</span>Q_relax_outgoing <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span><span class="main">)</span> 
       <span class="main">∧</span> <span class="free">Q_lookup</span> <span class="main">(</span>Q_relax_outgoing <span class="free">u</span> <span class="free">du</span> <span class="free">V</span> <span class="free">Q</span><span class="main">)</span> 
          <span class="main">=</span> relax_outgoing' <span class="free">u</span> <span class="free">du</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free">V</span><span class="main">)</span> <span class="main">(</span><span class="free">Q_lookup</span> <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> relax_outgoing''_refine<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> l<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">G_succ</span> <span class="free">g</span> <span class="free">u</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Q_relax_outgoing_def relax_outgoing''_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fold_refine<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">Q_invar</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> α<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">Q_lookup</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">D_invar_impl</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">≡</span> 
  <span class="free">Q_invar</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">∧</span> <span class="free">M_invar</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">∧</span> D_invar' <span class="main">(</span><span class="free">Q_lookup</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">Q_initQ</span> <span class="main">≡</span> <span class="free">Q_update</span> <span class="free">s</span> <span class="main">0</span> <span class="free">Q_empty</span>"</span></span>
          
<span class="keyword1"><span class="command">lemma</span></span> Q_init_Q<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="main">(</span>Q_initQ<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_lookup</span> <span class="main">(</span>Q_initQ<span class="main">)</span> <span class="main">=</span> initQ"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Q_initQ_def initQ_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">M_initV</span> <span class="main">≡</span> <span class="free">M_empty</span>"</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> M_initS<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> M_initV"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_lookup</span> M_initV <span class="main">=</span> initV"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> M_initV_def initV_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="free">Q_getmin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span> 
  <span class="quoted"><span class="quoted">"<span class="free">dijkstra_loop</span> <span class="main">≡</span> while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">V</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="bound">Q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">V</span><span class="main">)</span><span class="main">.</span> 
    <span class="keyword1">let</span>
      <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">du</span><span class="main">)</span> <span class="main">=</span> <span class="free">Q_getmin</span> <span class="bound">Q</span><span class="main">;</span>
      <span class="bound">Q</span> <span class="main">=</span> Q_relax_outgoing <span class="bound">u</span> <span class="bound">du</span> <span class="bound">V</span> <span class="bound">Q</span><span class="main">;</span>
      <span class="bound">Q</span> <span class="main">=</span> <span class="free">Q_delete</span> <span class="bound">u</span> <span class="bound">Q</span><span class="main">;</span>
      <span class="bound">V</span> <span class="main">=</span> <span class="free">M_update</span> <span class="bound">u</span> <span class="bound">du</span> <span class="bound">V</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">V</span><span class="main">)</span>
  <span class="main">)</span> <span class="main">(</span>Q_initQ<span class="main">,</span>M_initV<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> Dijkstra_Impl_Defs<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">dijkstra</span> <span class="main">≡</span> snd dijkstra_loop"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> transfer_preconditions<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"coupling <span class="free">Q</span> <span class="free">V</span> <span class="free">D</span> <span class="free">S</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> Some <span class="free">du</span> <span class="main">⟷</span> <span class="free">D</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">du</span> <span class="main">∧</span> <span class="free">u</span><span class="main">∉</span><span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coupling_def<span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> dijkstra_loop_invar_and_empty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> dijkstra_loop <span class="keyword1">of</span> <span class="main">(</span><span class="bound">Q</span><span class="main">,</span><span class="bound">V</span><span class="main">)</span> <span class="main">⇒</span> D_invar_impl <span class="bound">Q</span> <span class="bound">V</span> <span class="main">∧</span> <span class="free">Q_is_empty</span> <span class="bound">Q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dijkstra_loop_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> while_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"case_prod D_invar_impl"</span></span> 
    <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> r<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image finite_psubset <span class="main">(</span>unfinished_dnodes' <span class="keyword1">o</span> <span class="free">M_lookup</span> <span class="keyword1">o</span> snd<span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹(<span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main">:</span> prod.splits)<span class="keyword3">?</span>›</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D_invar_impl_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D_invar'_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> coupling_init<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> initD_def initS_def invar_init <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>  
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Q</span> <span class="skolem">V</span> <span class="skolem">u</span> <span class="skolem">du</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">Q_is_empty</span> <span class="skolem">Q</span>"</span></span> <span class="quoted"><span class="quoted">"D_invar_impl <span class="skolem">Q</span> <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_getmin</span> <span class="skolem">Q</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">du</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_lookup</span> <span class="skolem">Q</span> <span class="main">≠</span> Map.empty"</span></span> <span class="quoted"><span class="quoted">"D_invar' <span class="main">(</span><span class="free">Q_lookup</span> <span class="skolem">Q</span><span class="main">)</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q_invar</span> <span class="skolem">Q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> <span class="skolem">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q_lookup</span> <span class="skolem">Q</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">du</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k'</span> <span class="bound">p'</span><span class="main">.</span> <span class="free">Q_lookup</span> <span class="skolem">Q</span> <span class="bound">k'</span> <span class="main">=</span> Some <span class="bound">p'</span> <span class="main">⟶</span> <span class="skolem">du</span> <span class="main">≤</span> <span class="bound">p'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D_invar_impl_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> Q.map_getminE<span class="main">)</span>
    
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">D</span></span> <span class="skolem"><span class="skolem">S</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"D_invar <span class="skolem">D</span> <span class="skolem">S</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> COUPLING<span class="main">:</span> <span class="quoted"><span class="quoted">"coupling <span class="main">(</span><span class="free">Q_lookup</span> <span class="skolem">Q</span><span class="main">)</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">)</span> <span class="skolem">D</span> <span class="skolem">S</span>"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> ABS_PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">D</span> <span class="skolem">u</span> <span class="main">=</span> enat <span class="skolem">du</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∉</span><span class="skolem">S</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span> <span class="main">∉</span> <span class="skolem">S</span> <span class="main">⟶</span> <span class="skolem">D</span> <span class="skolem">u</span> <span class="main">≤</span> <span class="skolem">D</span> <span class="bound">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D_invar'_def transfer_preconditions less_eq_enat_def 
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> enat.splits<span class="main">)</span> 
    
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> Dijkstra_Invar <span class="quoted"><span class="quoted">"<span class="free">G_α</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="skolem">D</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
  <span class="keyword1"><span class="command">have</span></span> COUPLING'<span class="main">:</span> <span class="quoted"><span class="quoted">"coupling 
    <span class="main">(</span><span class="main">(</span>relax_outgoing' <span class="skolem">u</span> <span class="skolem">du</span> <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">)</span> <span class="main">(</span><span class="free">Q_lookup</span> <span class="skolem">Q</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="skolem">u</span> <span class="main">:=</span> None<span class="main">)</span><span class="main">)</span> 
    <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">(</span><span class="skolem">u</span> <span class="main">↦</span> <span class="skolem">du</span><span class="main">)</span><span class="main">)</span> 
    <span class="main">(</span>relax_outgoing <span class="skolem">u</span> <span class="skolem">D</span><span class="main">)</span> 
    <span class="main">(</span>Set.insert <span class="skolem">u</span> <span class="skolem">S</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> coupling_step<span class="main">[</span><span class="operator">OF</span> COUPLING <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span><span class="skolem">S</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">D</span> <span class="skolem">u</span> <span class="main">=</span> enat <span class="skolem">du</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"D_invar_impl <span class="main">(</span><span class="free">Q_delete</span> <span class="skolem">u</span> <span class="main">(</span>Q_relax_outgoing <span class="skolem">u</span> <span class="skolem">du</span> <span class="skolem">V</span> <span class="skolem">Q</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">M_update</span> <span class="skolem">u</span> <span class="skolem">du</span> <span class="skolem">V</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> maintain_D_invar<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span><span class="skolem">S</span>›</span></span><span class="main">]</span> ABS_PRE
    <span class="keyword1"><span class="command">using</span></span> COUPLING'
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D_invar_impl_def D_invar'_def<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unfinished_dnodes' <span class="main">(</span><span class="free">M_lookup</span> <span class="main">(</span><span class="free">M_update</span> <span class="skolem">u</span> <span class="skolem">du</span> <span class="skolem">V</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">⊂</span> unfinished_dnodes' <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">)</span> 
      <span class="main">∧</span> finite <span class="main">(</span>unfinished_dnodes' <span class="main">(</span><span class="free">M_lookup</span> <span class="skolem">V</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> coupling_unfinished<span class="main">[</span><span class="operator">OF</span> COUPLING<span class="main">]</span> coupling_unfinished<span class="main">[</span><span class="operator">OF</span> COUPLING'<span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> unfinished_nodes_decr<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∉</span><span class="skolem">S</span>›</span></span><span class="main">]</span> ABS_PRE
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>  
  
<span class="keyword1"><span class="command">lemma</span></span> dijkstra_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">M_invar</span> dijkstra"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">M_lookup</span> dijkstra <span class="free">u</span> <span class="main">=</span> Some <span class="free">d</span> <span class="main">⟷</span> δ <span class="free">s</span> <span class="free">u</span> <span class="main">=</span> enat <span class="free">d</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dijkstra_loop_invar_and_empty
  <span class="keyword1"><span class="command">unfolding</span></span> dijkstra_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">all</span> <span class="quoted">‹<span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main">:</span> D_invar_impl_def›</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> D_invar'_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> Q V D S  
    <span class="keyword1"><span class="command">using</span></span> Dijkstra_Invar.invar_finish_imp_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">G_α</span> <span class="free">g</span>"</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="skolem">D</span></span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="free">u</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coupling_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> domIff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  
<span class="keyword2"><span class="keyword">end</span></span>       


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Instantiation of ADTs and Code Generation›</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> 
  G<span class="main">:</span> wgraph_by_map <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> 
                   <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  <span class="keyword2"><span class="keyword">defines</span></span> G_empty <span class="main">=</span> <span class="quoted">G.empty_graph</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_add_edge <span class="main">=</span> <span class="quoted">G.add_edge</span>
      <span class="keyword2"><span class="keyword">and</span></span> G_succ <span class="main">=</span> <span class="quoted">G.succ</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">global_interpretation</span></span> Dijkstra_Impl_Adts
  <span class="quoted">G.α</span> <span class="quoted">G.invar</span> <span class="quoted">G.succ</span> <span class="quoted">G.empty_graph</span> <span class="quoted">G.add_edge</span>
  
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> D<span class="main">:</span> Dijkstra_Impl_Defs  
  <span class="quoted">G.invar</span> <span class="quoted">G.succ</span> <span class="quoted">G.empty_graph</span> <span class="quoted">G.add_edge</span>
  
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  
  <span class="quoted">G.α</span> <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">s</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'v</span><span class="main">::</span>linorder"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> dijkstra <span class="main">=</span> <span class="quoted">D.dijkstra</span>
      <span class="keyword2"><span class="keyword">and</span></span> dijkstra_loop <span class="main">=</span> <span class="quoted">D.dijkstra_loop</span>
      <span class="keyword2"><span class="keyword">and</span></span> Q_relax_outgoing <span class="main">=</span> <span class="quoted">D.Q_relax_outgoing</span>
      <span class="keyword2"><span class="keyword">and</span></span> M_initV <span class="main">=</span> <span class="quoted">D.M_initV</span>
      <span class="keyword2"><span class="keyword">and</span></span> Q_initQ <span class="main">=</span> <span class="quoted">D.Q_initQ</span>
  <span class="keyword1"><span class="command">..</span></span>
  
<span class="comment1">(* TODO: Why is this fix necessary? *)</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>    
  D.dijkstra_def D.dijkstra_loop_def  
  
<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"G.invar <span class="free">g</span>"</span></span>  
<span class="keyword2"><span class="keyword">begin</span></span>  
  
<span class="keyword1"><span class="command">interpretation</span></span> AUX<span class="main">:</span> Dijkstra_Impl
  <span class="quoted">G.invar</span> <span class="quoted">G.succ</span> <span class="quoted">G.empty_graph</span> <span class="quoted">G.add_edge</span>
  
  <span class="quoted">RBT_Set.empty</span> <span class="quoted">RBT_Map.update</span> <span class="quoted">RBT_Map.delete</span> <span class="quoted">Lookup2.lookup</span> <span class="quoted">RBT_Map.M.invar</span>
  
  <span class="quoted">PST_RBT.empty</span> <span class="quoted">PST_RBT.update</span> <span class="quoted">PST_RBT.delete</span> <span class="quoted">PST_RBT.PM.invar</span> 
  <span class="quoted">Lookup2.lookup</span> <span class="quoted">PST_RBT.rbt_is_empty</span> <span class="quoted">pst_getmin</span>
  
  <span class="quoted"><span class="free">g</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted">G.α</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">s</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemmas</span></span> dijkstra_correct <span class="main">=</span> AUX.dijkstra_correct<span class="main">[</span><span class="operator">folded</span> dijkstra_def<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Combination with Graph Parser›</span></span>  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We combine the algorithm with a parser from lists to graphs›</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> 
  G<span class="main">:</span> wgraph_from_list_algo <span class="quoted">G.α</span> <span class="quoted">G.invar</span> <span class="quoted">G.succ</span> <span class="quoted">G.empty_graph</span> <span class="quoted">G.add_edge</span>
  <span class="keyword2"><span class="keyword">defines</span></span> from_list <span class="main">=</span> <span class="quoted">G.from_list</span>
  <span class="keyword1"><span class="command">..</span></span>
  
  
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dijkstra_list</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">if</span> valid_graph_rep <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span>dijkstra <span class="main">(</span>from_list <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> dijkstra_list_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> dijkstra_list <span class="free">l</span> <span class="free">s</span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> <span class="main">¬</span>valid_graph_rep <span class="free">l</span>
  <span class="main">|</span> Some <span class="bound">D</span> <span class="main">⇒</span> 
        valid_graph_rep <span class="free">l</span> 
      <span class="main">∧</span> M.invar <span class="bound">D</span> 
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">d</span><span class="main">.</span> lookup <span class="bound">D</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">d</span> <span class="main">⟷</span> WGraph.δ <span class="main">(</span>wgraph_of_list <span class="free">l</span><span class="main">)</span> <span class="free">s</span> <span class="bound">u</span> <span class="main">=</span> enat <span class="bound">d</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dijkstra_list_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dijkstra_correct G.from_list_correct<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">dijkstra_list</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML OCaml<span class="main">?</span> Scala Haskell<span class="main">?</span>
  
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"dijkstra_list <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">7</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"dijkstra_list <span class="main">[</span><span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">7</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">]</span> <span class="numeral">3</span>"</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>