<div id="Sup_Lattice">
<div class="head">
<h1>Theory Sup_Lattice</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Sup-Lattices and Other Simplifications
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Sup-Lattices and Other Simplifications›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Sup_Lattice
  <span class="keyword2"><span class="keyword">imports</span></span>  <a href="../../HOL/HOL/Main.html">Main</a> 
           <span class="quoted">"<a href="../../HOL/HOL-Library/Lattice_Syntax.html">HOL-Library.Lattice_Syntax</a>"</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some definitions for orderings and lattices in Isabelle could be simpler. The strict order in 
in ord could be defined instead of being axiomatised. The function mono could have been defined on ord
and not on order---even on a general (di)graph it serves as a morphism. In complete lattices, the 
supremum---and dually the infimum---suffices to define the other operations (in the Isabelle/HOL-definition
infimum, binary supremum and infimum, bottom and top element are axiomatised). This not only increases
the number of proof obligations in subclass or sublocale statements, instantiations or interpretations,
it also complicates situations where suprema are presented faithfully, e.g. mapped onto suprema in 
some subalgebra, whereas infima in the subalgebra are different from those in the super-structure.›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It would be even nicer to use a class less-eq which dispenses with the strict order symbol
in ord. Then one would not have to redefine this symbol in all instantiations or interpretations.
At least, it does not carry any proof obligations.›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ub-set yields the set of all upper bounds of a set; lb-set the set of all lower bounds.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ub_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ub_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lb_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lb_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ord_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">ord_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Sup_Lattice-ord_pres_mono"><span class="command">lemma</span></span> ord_pres_mono<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">=</span> ord_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def ord_pres_def<span class="main">)</span>

<span class="keyword1"><span class="command">class</span></span> preorder_lean <span class="main">=</span> ord <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> preorder_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> preorder_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">z</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">le</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">le</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="main">¬</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≥</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> preorder_lean <span class="main">⊆</span> prel<span class="main">:</span> preorder <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_def preorder_refl preorder_trans<span class="main">)</span>
 
<span class="keyword1"><span class="command">class</span></span> order_lean <span class="main">=</span> preorder_lean <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> order_antisym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≥</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> order_lean <span class="main">⊆</span> posl<span class="main">:</span> order <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">class</span></span> Sup_lattice <span class="main">=</span> order_lean <span class="main">+</span> Sup <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Sups_upper<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">⨆</span><span class="free">X</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Sups_least<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">z</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">⨆</span><span class="free">X</span> <span class="main">≤</span> <span class="free">z</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Infs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Infs</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span>  <span class="main">⨆</span><span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sups</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sups</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">⨆</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">infs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">infs</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> Infs<span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bots</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">bots</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tops</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tops</span> <span class="main">=</span> Infs<span class="main">{}</span>"</span></span>

<span class="keyword1" id="Sup_Lattice-Infs_prop"><span class="command">lemma</span></span> Infs_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"Infs <span class="main">=</span> Sup <span class="main">∘</span> lb_set"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Infs_def prel.lb_set_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">class</span></span> Inf_lattice <span class="main">=</span> order_lean <span class="main">+</span> Inf <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Infi_lower<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="main">⨅</span><span class="free">X</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Infi_greatest<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">⟹</span> <span class="free">z</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">z</span> <span class="main">≤</span> <span class="main">⨅</span><span class="free">X</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Supi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Supi</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">supi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">supi</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> Supi<span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">infi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">infi</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">boti</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">boti</span> <span class="main">=</span> Supi<span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">topi</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">topi</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{}</span>"</span></span>

<span class="keyword1" id="Sup_Lattice-Supi_prop"><span class="command">lemma</span></span> Supi_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"Supi <span class="main">=</span> Inf <span class="main">∘</span> ub_set"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Supi_def prel.ub_set_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Inf_lattice <span class="main">⊆</span> ldual<span class="main">:</span> Sup_lattice <span class="quoted">Inf</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"ldual.Infs <span class="main">=</span> Supi"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ldual.infs <span class="main">=</span> supi"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ldual.sups <span class="main">=</span> infi"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ldual.tops <span class="main">=</span> boti"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ldual.bots <span class="main">=</span> topi"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.Sup_lattice Inf <span class="main">(≥)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Infi_lower Infi_greatest preorder_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> ldual<span class="main">:</span> Sup_lattice <span class="quoted">Inf</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"ldual.Infs <span class="main">=</span> Supi"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldual.Infs_def Supi_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ldual.infs <span class="main">=</span> supi"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a ldual.infs_def supi_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ldual.sups <span class="main">=</span> infi"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldual.sups_def infi_def<span class="main">)</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ldual.tops <span class="main">=</span> boti"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a ldual.tops_def boti_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ldual.bots <span class="main">=</span> topi"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldual.bots_def topi_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Sup_lattice <span class="main">⊆</span> supclat<span class="main">:</span> complete_lattice <span class="quoted">Infs</span> <span class="quoted">Sup_class.Sup</span> <span class="quoted">infs</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span> <span class="quoted">sups</span> <span class="quoted">bots</span> <span class="quoted">tops</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Infs_def infs_def sups_def bots_def tops_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Sups_least<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sups_upper<span class="main">)</span>
       
 <span class="keyword1"><span class="command">sublocale</span></span> Inf_lattice <span class="main">⊆</span> infclat<span class="main">:</span> complete_lattice <span class="quoted">Inf_class.Inf</span> <span class="quoted">Supi</span> <span class="quoted">infi</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span> <span class="quoted">supi</span> <span class="quoted">boti</span> <span class="quoted">topi</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ldual.Sups_upper ldual.Sups_least ldual.supclat.Inf_lower ldual.supclat.Inf_greatest<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>










</pre>
</div><div id="Order_Duality">
<div class="head">
<h1>Theory Order_Duality</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Ad-Hoc Duality for Orderings and Lattices
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Ad-Hoc Duality for Orderings and Lattices›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Duality
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Sup_Lattice.html">Sup_Lattice</a>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This component presents an "explicit" formalisation of order and lattice duality. It augments the data type based one
 used by Wenzel in his lattice components \cite{Wenzel}, and complements the "implicit" formalisation given by locales. It uses a functor dual, 
supplied within a type class, which is simply a bijection (isomorphism) between types, with the constraint that
the dual of a dual object is the original object. In Wenzel's formalisation, by contrast, dual is a bijection, but not
 idempotent or involutive. In the past, Preoteasa has used a similar approach with Isabelle~\cite{Preoteasa11b}.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Duality is such a fundamental concept in order and lattice theory that it probably deserves to be included in the type classes
for these objects, as in this section.›</span></span>

<span class="keyword1"><span class="command">class</span></span> dual <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">dual</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">∂</span></span></span>"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inj_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main"><span class="free">∂</span></span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> invol_dual <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free">∂</span></span> <span class="main">∘</span> <span class="main"><span class="free">∂</span></span> <span class="main">=</span> id"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This type class allows one to define a type dual. It is actually a dependent type
for which dual can be instantiated.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> dual <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span>dual<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_dual

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹At the moment I have no use for this type.›</span></span>

<span class="keyword1"><span class="command">context</span></span> dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-invol_dual_var"><span class="command">lemma</span></span> invol_dual_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Order_Duality-surj_dual"><span class="command">lemma</span></span> surj_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> surj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invol_dual_var<span class="main">)</span>

<span class="keyword1" id="Order_Duality-bij_dual"><span class="command">lemma</span></span> bij_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bij_def inj_dual surj_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-inj_dual_iff"><span class="command">lemma</span></span> inj_dual_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> inj_dual injD<span class="main">)</span>

<span class="keyword1" id="Order_Duality-dual_iff"><span class="command">lemma</span></span> dual_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Duality-the_inv_dual"><span class="command">lemma</span></span> the_inv_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"the_inv <span class="main">∂</span> <span class="main">=</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply id_def invol_dual_var inj_dual surj_dual surj_fun_eq the_inv_f_o_f_id<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In boolean algebras, duality is of course De Morgan duality and can be expressed within the language.›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> boolean_algebra <span class="main">⊆</span> ba_dual<span class="main">:</span> dual <span class="quoted"><span class="quoted">"uminus"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_dual</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>dual"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">∂<span class="hidden">⇩</span><sub>F</sub></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> <span class="main">∂</span>"</span></span>  

<span class="keyword1" id="Order_Duality-map_dual_func1"><span class="command">lemma</span></span> map_dual_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span> <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> comp_assoc comp_id invol_dual map_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Duality-map_dual_func2"><span class="command">lemma</span></span> map_dual_func2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Duality-map_dual_nat_iso"><span class="command">lemma</span></span> map_dual_nat_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> id <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc map_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Duality-map_dual_invol"><span class="command">lemma</span></span> map_dual_invol <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_dual_def comp_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus map-dual is naturally isomorphic to the identify functor: The function dual is a natural transformation 
between  map-dual and the identity functor, and, because it has a two-sided inverse --- itself, it is a natural isomorphism.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The generic function set-dual provides another natural transformation (see below). Before introducing it, we introduce useful notation 
for a widely used function.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">η</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Order_Duality-eta_inj"><span class="command">lemma</span></span> eta_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj η"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">set_dual</span> <span class="main">=</span> η <span class="main">∘</span> <span class="main">∂</span>"</span></span>

<span class="keyword1" id="Order_Duality-set_dual_prop"><span class="command">lemma</span></span> set_dual_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"set_dual <span class="main">(</span><span class="main">∂</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply dual_iff set_dual_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next four lemmas show that (functional) image and preimage are functors (on functions). This does not really belong here, 
but it is useful for what follows. The interaction between duality and (pre)images is needed in applications.›</span></span>

<span class="keyword1" id="Order_Duality-image_func1"><span class="command">lemma</span></span> image_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span> 

<span class="keyword1" id="Order_Duality-image_func2"><span class="command">lemma</span></span> image_func2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Duality-vimage_func1"><span class="command">lemma</span></span> vimage_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(-`)</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(-`)</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(-`)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vimage_comp<span class="main">)</span>

<span class="keyword1" id="Order_Duality-vimage_func2"><span class="command">lemma</span></span> vimage_func2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(-`)</span> id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Duality-iso_image"><span class="command">lemma</span></span> iso_image<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="main">(`)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_mono monoI<span class="main">)</span>

<span class="keyword1" id="Order_Duality-iso_preimage"><span class="command">lemma</span></span> iso_preimage<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="main">(-`)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monoI vimage_mono<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-image_dual"><span class="command">lemma</span></span> image_dual <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> image_func1 image_func2 invol_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-vimage_dual"><span class="command">lemma</span></span> vimage_dual <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(-`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">(-`)</span> <span class="main">∂</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set.comp<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following natural transformation between the powerset functor (image) and the identity functor
is well known.›</span></span>

<span class="keyword1" id="Order_Duality-power_set_func_nat_trans"><span class="command">lemma</span></span> power_set_func_nat_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"η <span class="main">∘</span> id <span class="free">f</span> <span class="main">=</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">∘</span> η"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As an instance, set-dual is a natural transformation with built-in type coercion.›</span></span>

<span class="keyword1" id="Order_Duality-dual_singleton"><span class="command">lemma</span></span> dual_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> η <span class="main">=</span> η <span class="main">∘</span> <span class="main">∂</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Duality-finite_dual"><span class="command">lemma</span></span> finite_dual <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> finite"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">using</span></span> inj_dual finite_vimageI inj_vimage_image_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Duality-finite_dual_var"><span class="command">lemma</span></span> finite_dual_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span> <span class="main">=</span> finite <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_def finite_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-subset_dual"><span class="command">lemma</span></span> subset_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">=</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> image_dual pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Order_Duality-subset_dual1"><span class="command">lemma</span></span> subset_dual1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">⊆</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">⊆</span> <span class="main">∂</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_dual inj_image_subset_iff<span class="main">)</span> 

<span class="keyword1" id="Order_Duality-dual_empty"><span class="command">lemma</span></span> dual_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">`</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Duality-dual_UNIV"><span class="command">lemma</span></span> dual_UNIV <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">`</span> UNIV <span class="main">=</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> surj_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual1"><span class="command">lemma</span></span> fun_dual1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc comp_id invol_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual2"><span class="command">lemma</span></span> fun_dual2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc fun.map_id invol_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual3"><span class="command">lemma</span></span> fun_dual3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_id image_dual o_assoc<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual4"><span class="command">lemma</span></span> fun_dual4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc id_comp image_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual5"><span class="command">lemma</span></span> fun_dual5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc fun_dual1 fun_dual2<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual6"><span class="command">lemma</span></span> fun_dual6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc fun_dual3 fun_dual4<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual7"><span class="command">lemma</span></span> fun_dual7<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc fun_dual2 fun_dual3<span class="main">)</span>

<span class="keyword1" id="Order_Duality-fun_dual8"><span class="command">lemma</span></span> fun_dual8<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">∂</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc fun_dual1 fun_dual4<span class="main">)</span>

<span class="keyword1" id="Order_Duality-map_dual_dual"><span class="command">lemma</span></span> map_dual_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">g</span> <span class="main">=</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> map_dual_invol pointfree_idE<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next facts show incrementally that the dual of a complete lattice is a complete lattice.›</span></span>

<span class="keyword1"><span class="command">class</span></span> ord_with_dual <span class="main">=</span> dual <span class="main">+</span> ord <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ord_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">∂</span> <span class="free">y</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">x</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-dual_dual_ord"><span class="command">lemma</span></span> dual_dual_ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_iff ord_dual<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Duality-ord_pres_dual"><span class="command">lemma</span></span> ord_pres_dual<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord_with_dual"</span></span>   
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord_pres <span class="free">f</span> <span class="main">⟹</span> ord_pres <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_dual_ord map_dual_def ord_pres_def<span class="main">)</span>

<span class="keyword1" id="Order_Duality-map_dual_anti"><span class="command">lemma</span></span> map_dual_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ord_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord_with_dual<span class="main">)</span> <span class="main">≤</span> <span class="free">g</span>  <span class="main">⟹</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">g</span> <span class="main">≤</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def map_dual_def ord_dual<span class="main">)</span>
  
<span class="keyword1"><span class="command">class</span></span> preorder_with_dual <span class="main">=</span> ord_with_dual <span class="main">+</span> preorder

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-less_dual_def_var"><span class="command">lemma</span></span> less_dual_def_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="main">∂</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_dual_ord less_le_not_le<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">class</span></span> order_with_dual <span class="main">=</span> preorder_with_dual <span class="main">+</span> order

<span class="keyword1" id="Order_Duality-iso_map_dual"><span class="command">lemma</span></span> iso_map_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order_with_dual"</span></span>   
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_pres_dual ord_pres_mono<span class="main">)</span>

<span class="keyword1"><span class="command">class</span></span> lattice_with_dual <span class="main">=</span> lattice <span class="main">+</span> dual <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sup_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">∂</span> <span class="free">y</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subclass</span></span> order_with_dual
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> inf.absorb_iff2 sup_absorb1 sup_commute sup_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Duality-inf_dual"><span class="command">lemma</span></span> inf_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">∂</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invol_dual_var sup_dual_def<span class="main">)</span> 

<span class="keyword1" id="Order_Duality-inf_to_sup"><span class="command">lemma</span></span> inf_to_sup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">∂</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inf_dual dual_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Duality-sup_to_inf"><span class="command">lemma</span></span> sup_to_inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">∂</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_dual<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">class</span></span> bounded_lattice_with_dual <span class="main">=</span> lattice_with_dual <span class="main">+</span> bounded_lattice

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-bot_dual"><span class="command">lemma</span></span> bot_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_dual_ord dual_iff le_bot top_greatest<span class="main">)</span>

<span class="keyword1" id="Order_Duality-top_dual"><span class="command">lemma</span></span> top_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bot_dual dual_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">class</span></span> boolean_algebra_with_dual <span class="main">=</span> lattice_with_dual <span class="main">+</span> boolean_algebra

<span class="keyword1"><span class="command">sublocale</span></span> boolean_algebra <span class="main">⊆</span> badual<span class="main">:</span> boolean_algebra_with_dual _ _ _ _ _ _ _ _ <span class="quoted">uminus</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">class</span></span> Sup_lattice_with_dual <span class="main">=</span> Sup_lattice <span class="main">+</span> dual <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Sups_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">∘</span> Sup <span class="main">=</span> Infs <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> Inf_lattice_with_dual <span class="main">=</span> Inf_lattice <span class="main">+</span> dual <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Sups_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">∘</span> Supi <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_lattice_with_dual <span class="main">=</span> complete_lattice <span class="main">+</span> dual <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Sups_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">∘</span> Sup <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Sup_lattice_with_dual <span class="main">⊆</span> sclatd<span class="main">:</span> complete_lattice_with_dual <span class="quoted">Infs</span> <span class="quoted">Sup</span> <span class="quoted">infs</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span> <span class="quoted">sups</span> <span class="quoted">bots</span> <span class="quoted">tops</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sups_dual_def<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> Inf_lattice_with_dual <span class="main">⊆</span> iclatd<span class="main">:</span> complete_lattice_with_dual <span class="quoted">Inf</span> <span class="quoted">Supi</span> <span class="quoted">infi</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted">le</span> <span class="quoted">supi</span> <span class="quoted">boti</span> <span class="quoted">topi</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sups_dual_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Duality-Inf_dual"><span class="command">lemma</span></span> Inf_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">∘</span> Inf <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc comp_id fun.map_id Sups_dual_def image_dual invol_dual<span class="main">)</span>

<span class="keyword1" id="Order_Duality-Inf_dual_var"><span class="command">lemma</span></span> Inf_dual_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_dest Inf_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Duality-Inf_to_Sup"><span class="command">lemma</span></span> Inf_to_Sup<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sups_dual_def image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Duality-Inf_to_Sup_var"><span class="command">lemma</span></span> Inf_to_Sup_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span><span class="free">X</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Inf_dual_var dual_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Duality-Sup_to_Inf"><span class="command">lemma</span></span> Sup_to_Inf<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_dual image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Duality-Sup_to_Inf_var"><span class="command">lemma</span></span> Sup_to_Inf_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">X</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">⨅</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_to_Inf <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Order_Duality-Sup_dual_def_var"><span class="command">lemma</span></span> Sup_dual_def_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨅</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_dest Sups_dual_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Duality-bot_dual_def"><span class="command">lemma</span></span> bot_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf_UNIV Sup_UNIV Sups_dual_def surj_dual o_eq_dest<span class="main">)</span>

<span class="keyword1" id="Order_Duality-top_dual_def"><span class="command">lemma</span></span> top_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bot_dual_def dual_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Duality-inf_dual2"><span class="command">lemma</span></span> inf_dual2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">∂</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_eq_elim Inf_dual Inf_empty Inf_insert SUP_insert inf_top.right_neutral<span class="main">)</span>

<span class="keyword1" id="Order_Duality-sup_dual"><span class="command">lemma</span></span> sup_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">∂</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inf_dual2 dual_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subclass</span></span> lattice_with_dual
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inf_dual sup_dual<span class="main">)</span>

<span class="keyword1"><span class="command">subclass</span></span> bounded_lattice_with_dual<span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>





</pre>
</div><div id="Order_Lattice_Props">
<div class="head">
<h1>Theory Order_Lattice_Props</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Properties of Orderings and Lattices
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Properties of Orderings and Lattices›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Lattice_Props
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Order_Duality.html">Order_Duality</a>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Definitions for Orderings and Lattices›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The first definition is for order morphisms --- isotone (order-preserving, monotone) functions. 
An order isomorphism is an order-preserving bijection. This should be defined in the class ord, but mono requires order.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ord_homset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">ord_homset</span> <span class="main">=</span> <span class="main">{</span><span class="bound">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">.</span> mono <span class="bound">f</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ord_embed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">ord_embed</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ord_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ord_iso</span> <span class="main">=</span> bij <span class="main">⊓</span> mono <span class="main">⊓</span> <span class="main">(</span>mono <span class="main">∘</span> the_inv<span class="main">)</span>"</span></span>

<span class="keyword1" id="Order_Lattice_Props-ord_embed_alt"><span class="command">lemma</span></span> ord_embed_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_embed <span class="free">f</span> <span class="main">=</span> <span class="main">(</span>mono <span class="free">f</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mono_def ord_embed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-ord_embed_homset"><span class="command">lemma</span></span> ord_embed_homset<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_embed <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∈</span> ord_homset"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def ord_embed_def ord_homset_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ord_embed_inj"><span class="command">lemma</span></span> ord_embed_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_embed <span class="free">f</span> <span class="main">⟹</span> inj <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ord_embed_def inj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_ord_embed"><span class="command">lemma</span></span> ord_iso_ord_embed<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> ord_embed <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ord_iso_def ord_embed_def bij_def inj_def mono_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> inj_def the_inv_f_f<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_alt"><span class="command">lemma</span></span> ord_iso_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">=</span> <span class="main">(</span>ord_embed <span class="free">f</span> <span class="main">∧</span> surj <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ord_iso_def ord_embed_def surj_def bij_def inj_def mono_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span> <span class="main">(</span><span class="operator">metis</span> eq_iff inj_def the_inv_f_f<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_the_inv"><span class="command">lemma</span></span> ord_iso_the_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span>the_inv <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_iso_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_inv1"><span class="command">lemma</span></span> ord_iso_inv1<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span>the_inv <span class="free">f</span><span class="main">)</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ord_embed_inj ord_iso_ord_embed the_inv_into_f_f <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_inv2"><span class="command">lemma</span></span> ord_iso_inv2<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">(</span>the_inv <span class="free">f</span><span class="main">)</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">using</span></span> f_the_inv_into_f ord_embed_inj ord_iso_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> ord_homset <span class="main">=</span> <span class="quoted"><span class="quoted">"ord_homset<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> set"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ord_homset_def mono_def<span class="main">)</span> 

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_ord_homset 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next definition is for the set of fixpoints of a given function. It is important in the context of orders,
for instance for proving Tarski's fixpoint theorem, but does not really belong here.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Fix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">Fix</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Order_Lattice_Props-retraction_prop"><span class="command">lemma</span></span> retraction_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply f_inv_into_f rangeI<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-retraction_prop_fix"><span class="command">lemma</span></span> retraction_prop_fix<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">⟹</span> range <span class="free">f</span> <span class="main">=</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Fix_def <span class="keyword1"><span class="command">using</span></span> retraction_prop <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-Fix_map_dual"><span class="command">lemma</span></span> Fix_map_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"Fix <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> Fix"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Fix_def map_dual_def comp_def fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Collect_cong invol_dual pointfree_idE setcompr_eq_image<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Fix_map_dual_var"><span class="command">lemma</span></span> Fix_map_dual_var<span class="main">:</span> <span class="quoted"><span class="quoted">"Fix <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">`</span> <span class="main">(</span>Fix <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fix_map_dual o_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-gfp_dual"><span class="command">lemma</span></span> gfp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">∘</span> gfp <span class="main">=</span> lfp <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span>gfp <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span><span class="main">{</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≤</span> <span class="skolem">f</span> <span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gfp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≤</span> <span class="skolem">f</span> <span class="bound">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_dual_def_var<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{</span><span class="main">∂</span> <span class="bound">u</span> <span class="main">|</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">≤</span> <span class="skolem">f</span> <span class="bound">u</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setcompr_eq_image<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{</span><span class="bound">u</span> <span class="main">|</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="skolem">f</span><span class="main">)</span> <span class="bound">u</span> <span class="main">≤</span> <span class="bound">u</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> dual_dual_ord dual_iff map_dual_def o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span>gfp <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> lfp <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lfp_def<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-gfp_dual_var"><span class="command">lemma</span></span> gfp_dual_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> lfp <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_elim gfp_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props-gfp_to_lfp"><span class="command">lemma</span></span> gfp_to_lfp<span class="main">:</span> <span class="quoted"><span class="quoted">"gfp <span class="main">=</span> <span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">∘</span> lfp <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc fun_dual2 gfp_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-gfp_to_lfp_var"><span class="command">lemma</span></span> gfp_to_lfp_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gfp <span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span>lfp <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gfp_dual_var invol_dual_var<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-lfp_dual"><span class="command">lemma</span></span> lfp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">∘</span> lfp <span class="main">=</span> gfp <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc gfp_to_lfp map_dual_invol<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-lfp_dual_var"><span class="command">lemma</span></span> lfp_dual_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span>lfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> gfp <span class="main">(</span>map_dual <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_dest_lhs lfp_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-lfp_to_gfp"><span class="command">lemma</span></span> lfp_to_gfp<span class="main">:</span> <span class="quoted"><span class="quoted">"lfp <span class="main">=</span> <span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">∘</span> gfp <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc gfp_dual map_dual_invol<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-lfp_to_gfp_var"><span class="command">lemma</span></span> lfp_to_gfp_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp <span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span>gfp <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invol_dual_var lfp_dual_var<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-lfp_in_Fix"><span class="command">lemma</span></span> lfp_in_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> lfp <span class="free">f</span> <span class="main">∈</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Fix_def lfp_unfold mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-gfp_in_Fix"><span class="command">lemma</span></span> gfp_in_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> gfp <span class="free">f</span> <span class="main">∈</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Fix_def gfp_unfold mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-nonempty_Fix"><span class="command">lemma</span></span> nonempty_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> Fix <span class="free">f</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lfp_in_Fix <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next the minimal and maximal elements of an ordering are defined.›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">min_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">max_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">max_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> ord_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-min_max_set_dual"><span class="command">lemma</span></span> min_max_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> min_set <span class="main">=</span> max_set <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> max_set_def min_set_def fun_eq_iff comp_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">using</span></span> dual_dual_ord inj_dual_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-min_max_set_dual_var"><span class="command">lemma</span></span> min_max_set_dual_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">`</span> <span class="main">(</span>min_set <span class="free">X</span><span class="main">)</span> <span class="main">=</span> max_set <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_dest min_max_set_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>  

<span class="keyword1" id="Order_Lattice_Props-max_min_set_dual"><span class="command">lemma</span></span> max_min_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> max_set <span class="main">=</span> min_set <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> comp_id fun.map_comp id_comp image_dual min_max_set_dual<span class="main">)</span>  

<span class="keyword1" id="Order_Lattice_Props-min_to_max_set"><span class="command">lemma</span></span> min_to_max_set<span class="main">:</span> <span class="quoted"><span class="quoted">"min_set <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> max_set <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_id image_dual max_min_set_dual o_assoc<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-max_min_set_dual_var"><span class="command">lemma</span></span> max_min_set_dual_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">`</span> <span class="main">(</span>max_set <span class="free">X</span><span class="main">)</span> <span class="main">=</span> min_set <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> comp_eq_dest max_min_set_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-min_to_max_set_var"><span class="command">lemma</span></span> min_to_max_set_var<span class="main">:</span> <span class="quoted"><span class="quoted">"min_set <span class="free">X</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">`</span> <span class="main">(</span>max_set <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_min_set_dual_var pointfree_idE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, directed and filtered sets, upsets, downsets, filters and ideals in posets are defined.›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">directed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">directed</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filtered</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">filtered</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇓</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇓</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇑</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">↓</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">↓</span></span> <span class="main">=</span> <span class="main">⇓</span> <span class="main">∘</span> η"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">↑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">↑</span></span> <span class="main">=</span> <span class="main">⇑</span> <span class="main">∘</span> η"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>  
  <span class="quoted"><span class="quoted">"<span class="free">downsets</span> <span class="main">=</span> Fix <span class="main">⇓</span>"</span></span>
 
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">upsets</span> <span class="main">=</span> Fix <span class="main">⇑</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">downclosed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> downsets<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">upclosed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> upsets<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ideals</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ideals</span> <span class="main">=</span> <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> downclosed_set <span class="bound">X</span> <span class="main">∧</span> directed <span class="bound">X</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filters</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filters</span> <span class="main">=</span> <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> upclosed_set <span class="bound">X</span> <span class="main">∧</span> filtered <span class="bound">X</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">idealp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> ideals"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">filterp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> filters"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹These notions are pair-wise dual.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Filtered and directed sets are dual.›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-filtered_directed_dual"><span class="command">lemma</span></span> filtered_directed_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> directed"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filtered_def directed_def fun_eq_iff comp_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> finite_imageI imageI image_mono dual_dual_ord<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> finite_subset_image imageE ord_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-directed_filtered_dual"><span class="command">lemma</span></span> directed_filtered_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> filtered"</span></span>
  <span class="keyword1"><span class="command">using</span></span> filtered_directed_dual <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_id image_dual o_assoc<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props-filtered_to_directed"><span class="command">lemma</span></span> filtered_to_directed<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">=</span> directed <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply directed_filtered_dual<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Upsets and downsets are dual.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-downset_set_upset_set_dual"><span class="command">lemma</span></span> downset_set_upset_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> <span class="main">⇑</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_set_def upset_set_def fun_eq_iff comp_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> image_eqI ord_dual<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> dual_iff image_iff mem_Collect_eq ord_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_downset_set_dual"><span class="command">lemma</span></span> upset_set_downset_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> <span class="main">⇓</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> downset_set_upset_set_dual <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> comp_id id_comp image_dual o_assoc<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_to_downset_set"><span class="command">lemma</span></span> upset_set_to_downset_set<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇓</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc downset_set_upset_set_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_to_downset_set2"><span class="command">lemma</span></span> upset_set_to_downset_set2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="free">X</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">`</span> <span class="main">(</span><span class="main">⇓</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_set_to_downset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_upset_dual"><span class="command">lemma</span></span> downset_upset_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">↓</span> <span class="main">=</span> <span class="main">↑</span> <span class="main">∘</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> downset_def upset_def upset_set_to_downset_set <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-upset_to_downset"><span class="command">lemma</span></span> upset_to_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">↑</span> <span class="main">=</span> <span class="main">↓</span> <span class="main">∘</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc id_apply ord.downset_def ord.upset_def power_set_func_nat_trans upset_set_downset_set_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_to_downset2"><span class="command">lemma</span></span> upset_to_downset2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span> <span class="main">=</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">↓</span> <span class="main">∘</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> comp_assoc downset_upset_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_to_downset3"><span class="command">lemma</span></span> upset_to_downset3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">`</span> <span class="main">(</span><span class="main">↓</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_to_downset2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downsets_upsets_dual"><span class="command">lemma</span></span> downsets_upsets_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> downsets<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">∈</span> upsets<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downsets_def upsets_def Fix_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_eq_dest downset_set_upset_set_dual image_inv_f_f inj_dual mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_setp_upset_setp_dual"><span class="command">lemma</span></span> downset_setp_upset_setp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"upclosed_set <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> downclosed_set"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downclosed_set_def upclosed_set_def <span class="keyword1"><span class="command">using</span></span> downsets_upsets_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-upsets_to_downsets"><span class="command">lemma</span></span> upsets_to_downsets<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> upsets<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">∈</span> downsets<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downsets_upsets_dual image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_setp_downset_setp_dual"><span class="command">lemma</span></span> upset_setp_downset_setp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> upclosed_set"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_id downset_setp_upset_setp_dual image_dual o_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Filters and ideals are dual.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-ideals_filters_dual"><span class="command">lemma</span></span> ideals_filters_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> ideals<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span> <span class="main">∈</span> filters<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_eq_dest_lhs directed_filtered_dual image_inv_f_f image_is_empty inv_unique_comp filters_def ideals_def inj_dual invol_dual mem_Collect_eq upset_setp_downset_setp_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-idealp_filterp_dual"><span class="command">lemma</span></span> idealp_filterp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"idealp <span class="main">=</span> filterp <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ideals_filters_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-filters_to_ideals"><span class="command">lemma</span></span> filters_to_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> filters<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span> <span class="main">∈</span> ideals<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ideals_filters_dual image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-filterp_idealp_dual"><span class="command">lemma</span></span> filterp_idealp_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"filterp <span class="main">=</span> idealp <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filters_to_ideals<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of Orderings›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-directed_nonempty"><span class="command">lemma</span></span> directed_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> directed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-directed_ub"><span class="command">lemma</span></span> directed_ub<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> empty_subsetI directed_def finite.emptyI finite_insert insert_subset order_refl<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_set_prop"><span class="command">lemma</span></span> downset_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span> <span class="main">=</span> Union <span class="main">∘</span> <span class="main">(`)</span> <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_set_def downset_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-downset_set_prop_var"><span class="command">lemma</span></span> downset_set_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span><span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_set_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_prop"><span class="command">lemma</span></span> downset_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↓</span><span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_def downset_set_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-downset_prop2"><span class="command">lemma</span></span> downset_prop2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> <span class="main">↓</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ideals_downsets"><span class="command">lemma</span></span> ideals_downsets<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> downsets"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downclosed_set_def ideals_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-ideals_directed"><span class="command">lemma</span></span> ideals_directed<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">⟹</span> directed <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ideals_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> preorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-directed_prop"><span class="command">lemma</span></span> directed_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟹</span> directed <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Y</span> <span class="main">⟹</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> h1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">F</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> h2 insert_iff insert_subset order_trans<span class="main">)</span> 
  <span class="keyword1"><span class="command">qed</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> directed_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-directed_alt"><span class="command">lemma</span></span> directed_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> directed_prop directed_nonempty directed_ub<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_set_prop_var2"><span class="command">lemma</span></span> downset_set_prop_var2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">⇓</span><span class="free">X</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> <span class="main">⇓</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_set_def <span class="keyword1"><span class="command">using</span></span> order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props-downclosed_set_iff"><span class="command">lemma</span></span> downclosed_set_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"downclosed_set <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downclosed_set_def downsets_def Fix_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-downclosed_downset_set"><span class="command">lemma</span></span> downclosed_downset_set<span class="main">:</span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downclosed_set_iff downset_set_prop_var2 downset_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downclosed_downset"><span class="command">lemma</span></span> downclosed_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">(</span><span class="main">↓</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downclosed_downset_set downset_def<span class="main">)</span>
 
<span class="keyword1" id="Order_Lattice_Props-downset_set_ext"><span class="command">lemma</span></span> downset_set_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> le_fun_def id_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

<span class="keyword1" id="Order_Lattice_Props-downset_set_iso"><span class="command">lemma</span></span> downset_set_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props-downset_set_idem"><span class="command">lemma</span></span> downset_set_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span> <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff downset_set_def <span class="keyword1"><span class="command">using</span></span> order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-downset_faithful"><span class="command">lemma</span></span> downset_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↓</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↓</span><span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_prop subset_eq<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downset_iso_iff"><span class="command">lemma</span></span> downset_iso_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">↓</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↓</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atMost_iff downset_prop order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following proof uses the Axiom of Choice.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-downset_directed_downset_var"><span class="command">lemma</span></span> downset_directed_downset_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> directed <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword3"><span class="command">assume</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> h3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">⊆</span> <span class="main">⇓</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span>  <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> downset_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟶</span>  <span class="bound">f</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">f</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> choice<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> finite <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">f</span> <span class="main">`</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_imageI h2 image_subsetI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Z</span><span class="main">.</span> finite <span class="bound">Z</span> <span class="main">∧</span> <span class="bound">Z</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Z</span><span class="main">.</span> finite <span class="bound">Z</span> <span class="main">∧</span> <span class="bound">Z</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> directed_def h1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> order_trans<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> directed_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> directed_def downset_set_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Ball_Collect order_refl order_trans subsetCE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-downset_directed_downset"><span class="command">lemma</span></span> downset_directed_downset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> directed"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Lattice_Props-directed_downset_ideals"><span class="command">lemma</span></span> directed_downset_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇓</span><span class="free">X</span> <span class="main">∈</span> ideals<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> CollectI Fix_def directed_alt downset_set_idem downclosed_set_def downsets_def ideals_def o_def ord.ideals_directed<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-downclosed_Fix"><span class="command">lemma</span></span> downclosed_Fix<span class="main">:</span> <span class="quoted"><span class="quoted">"downclosed_set <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇓</span><span class="free">X</span> <span class="main">=</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> CollectD Fix_def downclosed_downset_set downclosed_set_def downsets_def<span class="main">)</span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props-downset_iso"><span class="command">lemma</span></span> downset_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_iso_iff mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-mono_downclosed"><span class="command">lemma</span></span> mono_downclosed<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> downclosed_set <span class="bound">Y</span> <span class="main">⟶</span> downclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span>"</span></span>   
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms downclosed_set_iff monoD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> downclosed_set <span class="free">X</span> <span class="main">⟶</span> downclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1" id="Order_Lattice_Props-downclosed_mono"><span class="command">lemma</span></span> downclosed_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> downclosed_set <span class="bound">Y</span> <span class="main">⟶</span> downclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">(</span><span class="main">↓</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> downclosed_set_def downsets_def Fix_def downset_set_def downset_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="main">(</span><span class="main">↓</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"downclosed_set <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">f</span> <span class="skolem">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vimage_def downset_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">z</span> <span class="main">≤</span> <span class="free">f</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">f</span> <span class="bound">w</span> <span class="main">≤</span> <span class="free">f</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> downclosed_set_def downclosed_set_def downsets_def Fix_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-mono_downclosed_iff"><span class="command">lemma</span></span> mono_downclosed_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> downclosed_set <span class="bound">Y</span> <span class="main">⟶</span> downclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mono_downclosed downclosed_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> order
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-downset_inj"><span class="command">lemma</span></span> downset_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> injI downset_iso_iff eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">⊆</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇓</span><span class="free">X</span> <span class="main">⊆</span> <span class="main">⇓</span><span class="free">Y</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-lat_ideals"><span class="command">lemma</span></span> lat_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> downsets <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ideals_def directed_alt downsets_def Fix_def downset_set_def downclosed_set_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> sup.cobounded1 sup.orderE sup.orderI sup_absorb2 sup_left_commute mem_Collect_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> bounded_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-bot_ideal"><span class="command">lemma</span></span> bot_ideal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">⟹</span> <span class="main">⊥</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ideals_def downclosed_set_def downsets_def Fix_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-Sup_downset_id"><span class="command">lemma</span></span> Sup_downset_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">↓</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_atMost atMost_def downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-downset_Sup_id"><span class="command">lemma</span></span> downset_Sup_id<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">↓</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper downset_prop le_funI subsetI<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_Sup_var"><span class="command">lemma</span></span> Inf_Sup_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨅</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_ball_eq Inf_eq_Sup<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_pres_downset_var"><span class="command">lemma</span></span> Inf_pres_downset_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">↓</span><span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Inf_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Dual Properties of Orderings›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-filtered_nonempty"><span class="command">lemma</span></span> filtered_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> filtered_to_directed ord.directed_nonempty <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-filtered_lb"><span class="command">lemma</span></span> filtered_lb<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> filtered_to_directed directed_ub dual_dual_ord <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_prop_var"><span class="command">lemma</span></span> upset_set_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span><span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_Union downset_set_prop_var upset_set_to_downset_set2 upset_to_downset2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_prop"><span class="command">lemma</span></span> upset_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="main">=</span> Union <span class="main">∘</span> <span class="main">(`)</span> <span class="main">↑</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_set_prop_var<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_prop"><span class="command">lemma</span></span> upset_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upset_to_downset3 downset_prop image_def <span class="keyword1"><span class="command">using</span></span> dual_dual_ord <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-upset_prop2"><span class="command">lemma</span></span> upset_prop2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> <span class="main">↑</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-filters_upsets"><span class="command">lemma</span></span> filters_upsets<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> upsets"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upclosed_set_def filters_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-filters_filtered"><span class="command">lemma</span></span> filters_filtered<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">⟹</span> filtered <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filters_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> preorder_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-filtered_prop"><span class="command">lemma</span></span> filtered_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> filtered <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filtered_to_directed 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> directed_prop<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> image_iff ord_dual<span class="main">)</span>
 
<span class="keyword1" id="Order_Lattice_Props-filtered_alt"><span class="command">lemma</span></span> filtered_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> image_empty directed_alt filtered_to_directed filtered_lb filtered_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-up_set_prop_var2"><span class="command">lemma</span></span> up_set_prop_var2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">⇑</span><span class="free">X</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> <span class="main">⇑</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> downset_set_prop_var2 dual_iff ord_dual upset_set_to_downset_set2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-upclosed_set_iff"><span class="command">lemma</span></span> upclosed_set_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"upclosed_set <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upclosed_set_def upsets_def Fix_def upset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-upclosed_upset_set"><span class="command">lemma</span></span> upclosed_upset_set<span class="main">:</span> <span class="quoted"><span class="quoted">"upclosed_set <span class="main">(</span><span class="main">⇑</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> up_set_prop_var2 upclosed_set_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props-upclosed_upset"><span class="command">lemma</span></span> upclosed_upset<span class="main">:</span> <span class="quoted"><span class="quoted">"upclosed_set <span class="main">(</span><span class="main">↑</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_def upclosed_upset_set<span class="main">)</span> 
  
<span class="keyword1" id="Order_Lattice_Props-upset_set_ext"><span class="command">lemma</span></span> upset_set_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_def comp_id image_mono le_fun_def downset_set_ext image_dual upset_set_to_downset_set2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_set_anti"><span class="command">lemma</span></span> upset_set_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> image_mono downset_set_iso upset_set_to_downset_set2 mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-up_set_idem"><span class="command">lemma</span></span> up_set_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc downset_set_idem upset_set_downset_set_dual upset_set_to_downset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_faithful"><span class="command">lemma</span></span> upset_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↑</span><span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_image_subset_iff downset_faithful dual_dual_ord inj_dual upset_to_downset3<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_anti_iff"><span class="command">lemma</span></span> upset_anti_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">↑</span><span class="free">y</span> <span class="main">⊆</span> <span class="main">↑</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> downset_iso_iff ord_dual upset_to_downset3 subset_image_iff upset_faithful<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_filtered_upset"><span class="command">lemma</span></span> upset_filtered_upset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> filtered"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc directed_filtered_dual downset_directed_downset upset_set_downset_set_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-filtered_upset_filters"><span class="command">lemma</span></span> filtered_upset_filters<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">(</span><span class="main">⇑</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇑</span><span class="free">X</span> <span class="main">∈</span> filters<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply directed_downset_ideals filtered_to_directed filterp_idealp_dual upset_set_downset_set_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upclosed_Fix"><span class="command">lemma</span></span> upclosed_Fix<span class="main">:</span> <span class="quoted"><span class="quoted">"upclosed_set <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇑</span><span class="free">X</span> <span class="main">=</span> <span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Fix_def upclosed_set_def upsets_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props-upset_anti"><span class="command">lemma</span></span> upset_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"antimono <span class="main">(</span><span class="main">↑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antimono_def upset_anti_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-mono_upclosed"><span class="command">lemma</span></span> mono_upclosed<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> upclosed_set <span class="bound">Y</span> <span class="main">⟶</span> upclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms monoD upclosed_set_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-mono_upclosed"><span class="command">lemma</span></span> mono_upclosed<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> upclosed_set <span class="free">X</span> <span class="main">⟶</span> upclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">X</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1" id="Order_Lattice_Props-upclosed_mono"><span class="command">lemma</span></span> upclosed_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> upclosed_set <span class="bound">Y</span> <span class="main">⟶</span> upclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms dual_order.refl mem_Collect_eq monoI order.trans upclosed_set_iff vimageE vimageI2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-mono_upclosed_iff"><span class="command">lemma</span></span> mono_upclosed_iff<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> upclosed_set <span class="bound">Y</span> <span class="main">⟶</span> upclosed_set <span class="main">(</span><span class="free">f</span> <span class="main">-`</span> <span class="bound">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mono_upclosed upclosed_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> order_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-upset_inj"><span class="command">lemma</span></span> upset_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">↑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_compose inj_on_imageI2 downset_inj inj_dual upset_to_downset<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">⊆</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇑</span><span class="free">Y</span> <span class="main">⊆</span> <span class="main">⇑</span><span class="free">X</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> lattice_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-lat_filters"><span class="command">lemma</span></span> lat_filters<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> upsets <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filters_to_ideals upsets_to_downsets inf_to_sup lat_ideals
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> image_iff image_inv_f_f image_is_empty inj_image_mem_iff inv_unique_comp inj_dual invol_dual<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> bounded_lattice_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-top_filter"><span class="command">lemma</span></span> top_filter<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">⟹</span> <span class="main">⊤</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bot_ideal inj_image_mem_iff inj_dual filters_to_ideals top_dual <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice_with_dual
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-Inf_upset_id"><span class="command">lemma</span></span> Inf_upset_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Inf <span class="main">∘</span> <span class="main">↑</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_assoc comp_id Sup_downset_id Sups_dual_def downset_upset_dual invol_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-upset_Inf_id"><span class="command">lemma</span></span> upset_Inf_id<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">↑</span> <span class="main">∘</span> Inf"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_lower le_funI subsetI upset_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_Inf_var"><span class="command">lemma</span></span> Sup_Inf_var<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="main">⨅</span><span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_ball_eq Sup_eq_Inf<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_dual_upset_var"><span class="command">lemma</span></span> Sup_dual_upset_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Shunting Laws›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The first set of laws supplies so-called shunting laws for boolean algebras. 
Such laws rather belong into Isabelle Main.›</span></span>

<span class="keyword1"><span class="command">context</span></span> boolean_algebra
<span class="keyword2"><span class="keyword">begin</span></span>
    
<span class="keyword1" id="Order_Lattice_Props-shunt1"><span class="command">lemma</span></span> shunt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">standard</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span>  <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sup.mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sup_inf_distrib1<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">≤</span> <span class="main">(</span><span class="main">-</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span> <span class="main">⊓</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inf_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span>  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inf.boundedE inf_sup_distrib2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-shunt2"><span class="command">lemma</span></span> shunt2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="main">-</span><span class="free">y</span> <span class="main">≤</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shunt1<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-meet_shunt"><span class="command">lemma</span></span> meet_shunt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_iff shunt1<span class="main">)</span>
  
<span class="keyword1" id="Order_Lattice_Props-join_shunt"><span class="command">lemma</span></span> join_shunt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊤</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> compl_sup compl_top_eq double_compl meet_shunt<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-meet_shunt_var"><span class="command">lemma</span></span> meet_shunt_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_eq meet_shunt<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-join_shunt_var"><span class="command">lemma</span></span> join_shunt_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⟶</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊤</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of Complete Lattices›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Inf_closed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">Y</span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">⨅</span><span class="bound">Y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Sup_closed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">Y</span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">⨆</span><span class="bound">Y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">inf_closed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sup_closed_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following facts about complete lattices add to those in the Isabelle libraries.›</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The translation between sup and Sup could be improved. The sup-theorems should be direct
consequences of Sup-ones. In addition, duality between sup and inf is currently not exploited.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-sup_Sup"><span class="command">lemma</span></span> sup_Sup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Lattice_Props-inf_Inf"><span class="command">lemma</span></span> inf_Inf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">{</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next two lemmas are about Sups and Infs of indexed families. These are interesting for
iterations and fixpoints.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-fSup_unfold"><span class="command">lemma</span></span> fSup_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">0</span> <span class="main">⊔</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> antisym sup_least<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sup_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sup_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Sup_least<span class="main">)</span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper le_supI2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_unfold"><span class="command">lemma</span></span> fInf_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">0</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> antisym inf_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Inf_greatest<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">using</span></span> Inf_lower inf.coboundedI2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_lower<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Inf_mono<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props-Sup_sup_closed"><span class="command">lemma</span></span> Sup_sup_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_closed_set <span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice set<span class="main">)</span> <span class="main">⟹</span> sup_closed_set <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Sup_closed_set_def empty_subsetI insert_subsetI sup_Sup sup_closed_set_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_inf_closed"><span class="command">lemma</span></span> Inf_inf_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_closed_set <span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice set<span class="main">)</span> <span class="main">⟹</span> inf_closed_set <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_closed_set_def empty_subsetI inf_Inf inf_closed_set_def insert_subset<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Sup- and Inf-Preservation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, important notation for morphism between posets and lattices is introduced: 
sup-preservation, inf-preservation and related properties.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Sup_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Sup_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Sup <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Inf_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Inf_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Inf <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sup_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sup_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inf_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">inf_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bot_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>bot <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>bot<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bot_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">top_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>top <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>top<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">top_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Sup_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Sup_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Sup <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Inf_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Inf_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Inf <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sup_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sup_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inf_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">inf_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bot_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>bot <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>top<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">bot_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">top_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>top <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>bot<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">top_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Inf-preservation and sup-preservation relate with duality.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-Inf_pres_map_dual_var"><span class="command">lemma</span></span> Inf_pres_map_dual_var<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">=</span> Sup_pres <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="main">⨅</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">x</span><span class="main">.</span> <span class="main">∂</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="main">∂</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="main">∂</span> <span class="main">`</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span> <span class="skolem">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Sup_dual_def_var image_image invol_dual_var subset_dual<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨅</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Sup_dual_def_var subset_dual<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_dual_def fun_eq_iff Inf_dual_var Sup_dual_def_var image_comp<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-Inf_pres_map_dual"><span class="command">lemma</span></span> Inf_pres_map_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="main">=</span> Sup_pres <span class="main">∘</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="skolem">f</span> <span class="main">=</span> <span class="main">(</span>Sup_pres <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span><span class="main">)</span> <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_pres_map_dual_var<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-Sup_pres_map_dual_var"><span class="command">lemma</span></span> Sup_pres_map_dual_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">=</span> Inf_pres <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_pres_map_dual_var fun_dual5 map_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_pres_map_dual"><span class="command">lemma</span></span> Sup_pres_map_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="main">=</span> Inf_pres <span class="main">∘</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_pres_map_dual comp_assoc map_dual_invol<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemmas relate isotonicity of functions between complete lattices 
with weak (left) preservation properties of sups and infs.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-fun_isol"><span class="command">lemma</span></span> fun_isol<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fun_isor"><span class="command">lemma</span></span> fun_isor<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_sup_pres"><span class="command">lemma</span></span> Sup_sup_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> sup_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Sup_empty Sup_insert comp_apply image_insert sup_bot.right_neutral<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_inf_pres"><span class="command">lemma</span></span> Inf_inf_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span><span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> inf_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_insert Inf_empty Inf_insert comp_eq_elim inf_top.right_neutral<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_bot_pres"><span class="command">lemma</span></span> Sup_bot_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> bot_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> SUP_empty Sup_empty comp_eq_elim<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_top_pres"><span class="command">lemma</span></span> Inf_top_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> top_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> INF_empty Inf_empty comp_eq_elim<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_sup_dual"><span class="command">lemma</span></span> Sup_sup_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_dual <span class="free">f</span> <span class="main">⟹</span> sup_dual <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_eq_elim image_empty image_insert inf_Inf sup_Sup<span class="main">)</span>    

<span class="keyword1" id="Order_Lattice_Props-Inf_inf_dual"><span class="command">lemma</span></span> Inf_inf_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_dual <span class="free">f</span> <span class="main">⟹</span> inf_dual <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> comp_eq_elim image_empty image_insert inf_Inf sup_Sup<span class="main">)</span>   

<span class="keyword1" id="Order_Lattice_Props-Sup_bot_dual"><span class="command">lemma</span></span> Sup_bot_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_dual <span class="free">f</span> <span class="main">⟹</span> bot_dual <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> INF_empty Sup_empty comp_eq_elim<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_top_dual"><span class="command">lemma</span></span> Inf_top_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_dual <span class="free">f</span> <span class="main">⟹</span> top_dual <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_empty SUP_empty comp_eq_elim<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹However, Inf-preservation does not imply top-preservation and 
Sup-preservation does not imply bottom-preservation.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> top_pres <span class="free">f</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> bot_pres <span class="free">f</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-iso_Inf_subdistl"><span class="command">lemma</span></span> iso_Inf_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span><span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complete_lattice_class.le_Inf_iff le_funI Inf_lower monoD<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-iso_Sup_supdistl"><span class="command">lemma</span></span> iso_Sup_supdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> complete_lattice_class.Sup_le_iff le_funI Sup_upper monoD<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_subdistl_iso"><span class="command">lemma</span></span> Inf_subdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def le_fun_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> complete_lattice_class.le_INF_iff Inf_atLeast atLeast_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_supdistl_iso"><span class="command">lemma</span></span> Sup_supdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def le_fun_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> complete_lattice_class.SUP_le_iff Sup_atMost atMost_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-supdistl_iso"><span class="command">lemma</span></span> supdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup<span class="main">)</span> <span class="main">=</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_supdistl_iso iso_Sup_supdistl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Order_Lattice_Props-subdistl_iso"><span class="command">lemma</span></span> subdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Inf_subdistl_iso iso_Inf_subdistl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_Inf_pres"><span class="command">lemma</span></span> ord_iso_Inf_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∘</span> Inf"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"the_inv <span class="free">f</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="var">?g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_iso_the_inv<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
    <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
   <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨅</span><span class="skolem">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="var">?g</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="main">⨅</span><span class="skolem">X</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt<span class="main">)</span>
   <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="var">?g</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Inf_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="main">⨅</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_INF_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨅</span><span class="skolem">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="main">⨅</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⨅</span><span class="skolem">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨅</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.antisym order_refl<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-ord_iso_Sup_pres"><span class="command">lemma</span></span> ord_iso_Sup_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span> <span class="main">⟹</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∘</span> Sup"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?g</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"the_inv <span class="free">f</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="var">?g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord_iso_the_inv<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
    <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
   <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">X</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">X</span> <span class="main">≤</span> <span class="var">?g</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt<span class="main">)</span>
   <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="var">?g</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>
     <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">X</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span> <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.antisym order_refl<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right preservation of sups and infs is trivial.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-fSup_distr"><span class="command">lemma</span></span> fSup_distr<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fSup_distr_var"><span class="command">lemma</span></span> fSup_distr_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">F</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">F</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_distr"><span class="command">lemma</span></span> fInf_distr<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_apply Inf_fun_def Sup.SUP_cong<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props-fInf_distr_var"><span class="command">lemma</span></span> fInf_distr_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span><span class="free">F</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">F</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_apply INF_cong INF_image Inf_apply image_comp image_def image_image<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next set of lemma revisits the preservation properties in the function space.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-fSup_subdistl"><span class="command">lemma</span></span> fSup_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(∘)</span> <span class="free">f</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_isol supdistl_iso<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props-fSup_subdistl_var"><span class="command">lemma</span></span> fSup_subdistl_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨆</span><span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_isol mono_Sup<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_subdistl"><span class="command">lemma</span></span> fInf_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="main">(∘)</span> <span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_isol subdistl_iso<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_subdistl_var"><span class="command">lemma</span></span> fInf_subdistl_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨅</span><span class="free">G</span> <span class="main">≤</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_isol mono_Inf<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fSup_distl"><span class="command">lemma</span></span> fSup_distl<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> Sup_pres <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fSup_distl_var"><span class="command">lemma</span></span> fSup_distl_var<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨆</span><span class="free">G</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_distl"><span class="command">lemma</span></span> fInf_distl<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> Inf_pres <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-fInf_distl_var"><span class="command">lemma</span></span> fInf_distl_var<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨅</span><span class="free">G</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_comp<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Downsets preserve infs whereas upsets preserve sups.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-Inf_pres_downset"><span class="command">lemma</span></span> Inf_pres_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Inf_iff<span class="main">)</span>
 
<span class="keyword1" id="Order_Lattice_Props-Sup_dual_upset"><span class="command">lemma</span></span> Sup_dual_upset<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_dual <span class="main">(</span><span class="main">↑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upset_prop fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Images of Sup-morphisms are closed under Sups and images of Inf-morphisms are closed under Infs.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-Sup_pres_Sup_closed"><span class="command">lemma</span></span> Sup_pres_Sup_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> Sup_closed_set <span class="main">(</span>range <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Sup_closed_set_def comp_eq_elim range_eqI subset_image_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Inf_pres_Inf_closed"><span class="command">lemma</span></span> Inf_pres_Inf_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> Inf_closed_set <span class="main">(</span>range <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Inf_closed_set_def comp_eq_elim range_eqI subset_image_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is well known that functions into complete lattices form complete lattices. Here, such results are shown for
the subclasses of isotone functions, where additional closure conditions must be respected.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> iso <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">.</span> mono <span class="bound">f</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_ord_homset_cases ord_homset_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_iso

<span class="keyword1"><span class="command">instantiation</span></span> iso <span class="main">::</span> <span class="main">(</span><span class="quoted">complete_lattice</span><span class="main">)</span> <span class="quoted">complete_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Inf_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso set <span class="main">⇒</span> <span class="tfree">'a</span> iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">Sup</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> SUP_subset_mono Sup_apply mono_def subsetI<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Sup_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso set <span class="main">⇒</span> <span class="tfree">'a</span> iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">Inf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_lower2 Inf_apply le_INF_iff mono_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bot_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monoI<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">sup_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso <span class="main">⇒</span> <span class="tfree">'a</span> iso <span class="main">⇒</span> <span class="tfree">'a</span> iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">inf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> inf_apply inf_mono monoD monoI<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">top_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mono_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">inf_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso <span class="main">⇒</span> <span class="tfree">'a</span> iso <span class="main">⇒</span> <span class="tfree">'a</span> iso"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">sup</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> mono_def sup.mono sup_apply<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso <span class="main">⇒</span> <span class="tfree">'a</span> iso <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice iso <span class="main">⇒</span> <span class="tfree">'a</span> iso <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_fun_def Sup_upper Sup_least Inf_lower Inf_greatest<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Duality has been baked into this result because of its relevance for predicate transformers. A proof
where Sups are mapped to Sups and Infs to Infs is certainly possible, but two instantiation of the same type
and the same classes are unfortunately impossible. Interpretations could be used instead.

A corresponding result for Inf-preseving functions and Sup-lattices, is proved in components on transformers,
as more advanced properties about Inf-preserving functions are needed.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Alternative Definitions for Complete Boolean Algebras›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The current definitions of complete boolean algebras deviates from that in most textbooks in that
a distributive law with infinite sups and infinite infs is used. There are interesting applications, for instance 
in topology, where weaker laws are needed --- for instance for frames and locales.›</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_heyting_algebra <span class="main">=</span> complete_lattice <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ch_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">⨆</span><span class="free">Y</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Complete Heyting algebras are also known as frames or locales (they differ with respect to their morphisms).›</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_co_heyting_algebra <span class="main">=</span> complete_lattice <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> co_ch_dist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="main">⨅</span><span class="free">Y</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_boolean_algebra_alt <span class="main">=</span> complete_lattice <span class="main">+</span> boolean_algebra

<span class="keyword1"><span class="command">instance</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">complete_boolean_algebra_alt</span><span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_boolean_algebra_alt
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subclass</span></span> complete_heyting_algebra
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">Y</span> 
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">⊓</span> <span class="main">⨆</span><span class="skolem">Y</span> <span class="main">≤</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="skolem">Y</span> <span class="main">≤</span> <span class="main">-</span><span class="skolem">x</span> <span class="main">⊔</span> <span class="skolem">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf.commute shunt1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="main">-</span><span class="skolem">x</span> <span class="main">⊔</span> <span class="skolem">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Sup_le_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">⊓</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf.commute shunt1<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">⊓</span> <span class="main">⨆</span><span class="skolem">Y</span> <span class="main">≤</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">⨆</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> local.SUP_le_iff<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊓</span> <span class="main">⨆</span><span class="skolem">Y</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">Y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subclass</span></span> complete_co_heyting_algebra
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INF_greatest Inf_lower2<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_refl le_INF_iff le_Inf_iff shunt2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-de_morgan1"><span class="command">lemma</span></span> de_morgan1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="main">-</span><span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="free">X</span> <span class="main">≤</span> <span class="main">-</span><span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> compl_le_swap1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">-</span><span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> compl_le_swap1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> le_INF_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="main">-</span><span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span><span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> antisym <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-de_morgan2"><span class="command">lemma</span></span> de_morgan2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> de_morgan1 ba_dual.dual_iff ba_dual.image_dual pointfree_idE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_boolean_algebra_alt_with_dual <span class="main">=</span> complete_lattice_with_dual <span class="main">+</span> complete_boolean_algebra_alt

<span class="keyword1"><span class="command">instantiation</span></span> set <span class="main">::</span> <span class="main">(</span><span class="quoted">type</span><span class="main">)</span> <span class="quoted">complete_boolean_algebra_alt_with_dual</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">dual_set</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">dual_set</span> <span class="main">=</span> uminus"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">intro_classes</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ba_dual.inj_dual dual_set_def comp_def uminus_Sup id_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_boolean_algebra_alt
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> cba_dual<span class="main">:</span> complete_boolean_algebra_alt_with_dual _ _ _ _ _ _ _ _ <span class="quoted">uminus</span> _ _
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> de_morgan2 de_morgan1<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Atomic Boolean Algebras›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, atomic boolean algebras are defined.›</span></span>

<span class="keyword1"><span class="command">context</span></span> bounded_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Atoms are covers of bottom.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">atom</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">⊥</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">atom_map</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> atom <span class="bound">y</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Order_Lattice_Props-atom_map_def_var"><span class="command">lemma</span></span> atom_map_def_var<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="free">x</span> <span class="main">=</span> <span class="main">↓</span><span class="free">x</span> <span class="main">∩</span> Collect atom"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_map_def downset_def downset_set_def comp_def atom_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props-atom_map_atoms"><span class="command">lemma</span></span> atom_map_atoms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>range atom_map<span class="main">)</span> <span class="main">=</span> Collect atom"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_map_def atom_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> atoms <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span>atom_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>bounded_lattice <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_atoms

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">at_map</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>bounded_lattice <span class="main">⇒</span> <span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">at_map</span> <span class="main">=</span> Abs_atoms <span class="main">∘</span> atom_map"</span></span>

<span class="keyword1"><span class="command">class</span></span> atomic_boolean_algebra <span class="main">=</span> boolean_algebra <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> atomicity<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> atom <span class="bound">y</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> complete_atomic_boolean_algebra <span class="main">=</span> complete_lattice <span class="main">+</span> atomic_boolean_algebra

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subclass</span></span> complete_boolean_algebra_alt<span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Here are two equivalent definitions for atoms; first in boolean algebras, and then in complete 
boolean algebras.›</span></span>

<span class="keyword1"><span class="command">context</span></span> boolean_algebra
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following two conditions are taken from Koppelberg's book~\cite{Koppelberg89}.›</span></span>

<span class="keyword1" id="Order_Lattice_Props-atom_neg"><span class="command">lemma</span></span> atom_neg<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atom_def dual_order.order_iff_strict inf.cobounded1 inf.commute meet_shunt<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-atom_sup"><span class="command">lemma</span></span> atom_sup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⊔</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inf.orderE le_supI1 shunt2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-sup_atom"><span class="command">lemma</span></span> sup_atom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⊔</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> atom <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bot_less inf.absorb2 less_le_not_le meet_shunt sup_compl_top<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-atom_sup_iff"><span class="command">lemma</span></span> atom_sup_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⊔</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_neg atom_sup sup_atom<span class="main">)</span>  

<span class="keyword1" id="Order_Lattice_Props-atom_neg_iff"><span class="command">lemma</span></span> atom_neg_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_neg atom_sup sup_atom<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-atom_map_bot_pres"><span class="command">lemma</span></span> atom_map_bot_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">⊥</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atom_def atom_map_def le_bot <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props-atom_map_top_pres"><span class="command">lemma</span></span> atom_map_top_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">⊤</span> <span class="main">=</span> Collect atom"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_boolean_algebra_alt
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props-atom_Sup"><span class="command">lemma</span></span> atom_Sup<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">-</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">⨆</span><span class="bound">Y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Sup_least Sup_upper2 compl_le_swap1 le_iff_inf meet_shunt<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props-Sup_atom"><span class="command">lemma</span></span> Sup_atom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">⨆</span><span class="bound">Y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> atom <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">⨆</span><span class="bound">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⊔</span> <span class="bound">z</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> insert_iff sup_Sup sup_bot.right_neutral<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h1 sup_atom<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props-atom_Sup_iff"><span class="command">lemma</span></span> atom_Sup_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="main">⨆</span><span class="bound">Y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> atom_neg atom_Sup Sup_atom<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>




</pre>
</div><div id="Representations">
<div class="head">
<h1>Theory Representations</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Representation Theorems for Orderings and Lattices
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Representation Theorems for Orderings and Lattices›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Representations
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Order_Lattice_Props.html">Order_Lattice_Props</a>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Representation of Posets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The isomorphism between partial orders and downsets with set inclusion is well known. It forms the basis of Priestley and Stone duality.
I show it not only for objects, but also order morphisms, hence establish equivalences and isomorphisms between categories.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> downset <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_downset
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The map ds yields the isomorphism between the set and the powerset level if its range is restricted to downsets.›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'a</span> downset"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">ds</span> <span class="main">=</span> Abs_downset <span class="main">∘</span> <span class="main">↓</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a complete lattice, its inverse is Sup.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">SSup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">SSup</span> <span class="main">=</span> Sup <span class="main">∘</span> Rep_downset"</span></span>

<span class="keyword1" id="Representations-ds_SSup_inv"><span class="command">lemma</span></span> ds_SSup_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"ds <span class="main">∘</span> SSup <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'a</span> downset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ds_def SSup_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Rep_downset Rep_downset_inverse cSup_atMost eq_id_iff imageE o_def ord_class.atMost_def ord_class.downset_prop<span class="main">)</span>

<span class="keyword1" id="Representations-SSup_ds_inv"><span class="command">lemma</span></span> SSup_ds_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"SSup <span class="main">∘</span> ds <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ds_def SSup_def fun_eq_iff id_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_downset_inverse pointfree_idE<span class="main">)</span> 

<span class="keyword1"><span class="command">instantiation</span></span> downset <span class="main">::</span> <span class="main">(</span><span class="quoted">ord</span><span class="main">)</span> <span class="quoted">order</span>
<span class="keyword2"><span class="keyword">begin</span></span> 
  
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_downset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'a</span> downset <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_downset <span class="bound">X</span> <span class="main">⊆</span> Rep_downset <span class="bound">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_downset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'a</span> downset <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_downset <span class="bound">X</span> <span class="main">⊂</span> Rep_downset <span class="bound">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Rep_downset_inject less_eq_downset_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Representations-ds_iso"><span class="command">lemma</span></span> ds_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"mono ds"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def ds_def fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_downset_inverse downset_iso_iff less_eq_downset.rep_eq rangeI<span class="main">)</span>
 
<span class="keyword1" id="Representations-ds_faithful"><span class="command">lemma</span></span> ds_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"ds <span class="free">x</span> <span class="main">≤</span> ds <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_downset_inverse downset_faithful ds_def less_eq_downset.rep_eq<span class="main">)</span>

<span class="keyword1" id="Representations-ds_inj"><span class="command">lemma</span></span> ds_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>ds<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span> downset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ds_faithful dual_order.antisym injI<span class="main">)</span>

<span class="keyword1" id="Representations-ds_surj"><span class="command">lemma</span></span> ds_surj<span class="main">:</span> <span class="quoted"><span class="quoted">"surj ds"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Rep_downset Rep_downset_inverse ds_def image_iff o_apply surj_def<span class="main">)</span>

<span class="keyword1" id="Representations-ds_bij"><span class="command">lemma</span></span> ds_bij<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">(</span>ds<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span> downset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bijI ds_inj ds_surj<span class="main">)</span>

<span class="keyword1" id="Representations-ds_ord_iso"><span class="command">lemma</span></span> ds_ord_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso ds"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ord_iso_def comp_def inf_bool_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> UNIV_I ds_bij ds_faithful ds_inj ds_iso ds_surj f_the_inv_into_f inf1I mono_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The morphishms between orderings and downsets are isotone functions. One can define functors mapping back and forth between these.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_ds</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'b</span> downset<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_ds</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> ds <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> SSup"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This definition is actually contrived. We have shown that a function f between posets P and Q is isotone if and only if the 
inverse image of f maps downclosed sets in Q to downclosed sets in P. There is the following duality: ds is a natural transformation 
between the identity functor and the preimage functor as a contravariant functor from P to Q. Hence orderings with isotone maps and 
downsets with downset-preserving maps are dual, which is a first step towards Stone duality. I don't see a way of proving this with Isabelle, 
as the types of the preimage of f are the wrong way and I don't see how I could capture opposition with what I have.›</span></span> 

<span class="comment1">(*lemma "mono (f::'a::complete_lattice ⇒ 'b::complete_lattimap_ds f = Abs_downset ∘ (-`) f ∘ Rep_downset" doesn't work! *)</span>

<span class="keyword1" id="Representations-map_ds_prop"><span class="command">lemma</span></span> map_ds_prop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_ds <span class="free">f</span> <span class="main">∘</span> ds <span class="main">=</span> ds <span class="main">∘</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_ds_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SSup_ds_inv comp_assoc<span class="main">)</span>

<span class="keyword1" id="Representations-map_ds_prop2"><span class="command">lemma</span></span> map_ds_prop2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_ds <span class="free">f</span> <span class="main">∘</span> ds <span class="main">=</span> ds <span class="main">∘</span> id <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_ds_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SSup_ds_inv comp_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is part of showing that map-ds is naturally isomorphic to the identity functor, ds being the natural isomorphism.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_SSup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'b</span> downset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_SSup</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">=</span> SSup <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">∘</span> ds"</span></span>

<span class="keyword1" id="Representations-map_ds_iso_pres"><span class="command">lemma</span></span> map_ds_iso_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span>map_ds <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff mono_def map_ds_def ds_def SSup_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_downset_inverse Sup_subset_mono downset_iso_iff less_eq_downset.rep_eq rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_iso_pres"><span class="command">lemma</span></span> map_SSup_iso_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">F</span> <span class="main">⟹</span> mono <span class="main">(</span>map_SSup <span class="free">F</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff mono_def map_SSup_def ds_def SSup_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_downset_inverse Sup_subset_mono downset_iso_iff less_eq_downset.rep_eq rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_prop"><span class="command">lemma</span></span> map_SSup_prop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ds <span class="main">∘</span> map_SSup <span class="free">F</span> <span class="main">=</span> <span class="free">F</span> <span class="main">∘</span> ds"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_SSup_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ds_SSup_inv fun.map_id0 id_def rewriteL_comp_comp<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_prop2"><span class="command">lemma</span></span> map_SSup_prop2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ds <span class="main">∘</span> map_SSup <span class="free">F</span> <span class="main">=</span> id <span class="free">F</span> <span class="main">∘</span> ds"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_SSup_prop<span class="main">)</span>

<span class="keyword1" id="Representations-map_ds_func1"><span class="command">lemma</span></span> map_ds_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_ds id <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice downset<span class="main">⇒</span> <span class="tfree">'a</span> downset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ds_SSup_inv map_ds_def<span class="main">)</span>

<span class="keyword1" id="Representations-map_ds_func2"><span class="command">lemma</span></span> map_ds_func2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_ds <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_ds <span class="free">f</span> <span class="main">∘</span> map_ds <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_ds_def fun_eq_iff comp_def ds_def SSup_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_downset_inverse Sup_atMost atMost_def downset_prop rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_func1"><span class="command">lemma</span></span> map_SSup_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_SSup <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice downset<span class="main">⇒</span> <span class="tfree">'a</span> downset<span class="main">)</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SSup_ds_inv map_SSup_def<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_func2"><span class="command">lemma</span></span> map_SSup_func2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'c</span> downset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_SSup <span class="main">(</span><span class="free">F</span> <span class="main">∘</span> <span class="free">G</span><span class="main">)</span> <span class="main">=</span> map_SSup <span class="free">F</span> <span class="main">∘</span> map_SSup <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_SSup_def fun_eq_iff comp_def id_def ds_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply ds_SSup_inv ds_def id_apply<span class="main">)</span>

<span class="keyword1" id="Representations-map_SSup_map_ds_inv"><span class="command">lemma</span></span> map_SSup_map_ds_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"map_SSup <span class="main">∘</span> map_ds <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> SSup_ds_inv comp_def eq_id_iff fun.map_comp fun.map_id0 id_apply map_SSup_prop map_ds_prop<span class="main">)</span>

<span class="keyword1" id="Representations-map_ds_map_SSup_inv"><span class="command">lemma</span></span> map_ds_map_SSup_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"map_ds <span class="main">∘</span> map_SSup <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'b</span> downset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_SSup_def map_ds_def SSup_def ds_def id_def comp_def fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Rep_downset Rep_downset_inverse Sup_downset_id image_iff pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-inj_map_ds"><span class="command">lemma</span></span> inj_map_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>map_ds<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'b</span> downset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> SSup_ds_inv fun.map_id0 id_comp inj_def map_ds_prop rewriteR_comp_comp2<span class="main">)</span>

<span class="keyword1" id="Representations-inj_map_SSup"><span class="command">lemma</span></span> inj_map_SSup<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>map_SSup<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice downset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_on_id inj_on_imageI2 map_ds_map_SSup_inv<span class="main">)</span>

<span class="keyword1" id="Representations-map_ds_map_SSup_iff"><span class="command">lemma</span></span> map_ds_map_SSup_iff<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> map_ds <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map_SSup <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_eq inj_map_ds map_ds_map_SSup_inv pointfree_idE<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This gives an isomorphism between categories.›</span></span>

<span class="keyword1" id="Representations-surj_map_ds"><span class="command">lemma</span></span> surj_map_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>map_ds<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> downset <span class="main">⇒</span> <span class="tfree">'b</span> downset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_ds_map_SSup_iff surj_def<span class="main">)</span>

<span class="keyword1" id="Representations-surj_map_SSup"><span class="command">lemma</span></span> surj_map_SSup<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>map_SSup<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual downset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual downset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> map_ds_map_SSup_iff surjI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹There is of course a dual result for upsets with the reverse inclusion ordering. Once again, it seems impossible to capture 
the "real" duality that uses the inverse image functor.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> upset <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="main">↑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_upset
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">us</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'a</span> upset"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> Abs_upset <span class="main">∘</span> <span class="main">↑</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">IInf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice upset <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">IInf</span> <span class="main">=</span> Inf <span class="main">∘</span> Rep_upset"</span></span>

<span class="keyword1" id="Representations-us_ds"><span class="command">lemma</span></span> us_ds<span class="main">:</span> <span class="quoted"><span class="quoted">"us <span class="main">=</span> Abs_upset <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> Rep_downset <span class="main">∘</span> ds <span class="main">∘</span> <span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>ord_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> us_def ds_def fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_downset_inverse upset_to_downset2<span class="main">)</span>

<span class="keyword1" id="Representations-IInf_SSup"><span class="command">lemma</span></span> IInf_SSup<span class="main">:</span> <span class="quoted"><span class="quoted">"IInf <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> SSup <span class="main">∘</span> Abs_downset <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span><span class="main">∂</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">∘</span> Rep_upset"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> IInf_def SSup_def fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Abs_downset_inverse Rep_upset Sup_dual_def_var image_iff rangeI subset_dual upset_to_downset3<span class="main">)</span>

<span class="keyword1" id="Representations-us_IInf_inv"><span class="command">lemma</span></span> us_IInf_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"us <span class="main">∘</span> IInf <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> us_def IInf_def fun_eq_iff id_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Inf_upset_id Rep_upset Rep_upset_inverse f_the_inv_into_f pointfree_idE upset_inj<span class="main">)</span>

<span class="keyword1" id="Representations-IInf_us_inv"><span class="command">lemma</span></span> IInf_us_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"IInf <span class="main">∘</span> us <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> us_def IInf_def fun_eq_iff id_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_upset_inverse Sup_Inf_var Sup_atLeastAtMost Sup_dual_upset_var order_refl rangeI<span class="main">)</span>
 
<span class="keyword1"><span class="command">instantiation</span></span> upset <span class="main">::</span> <span class="main">(</span><span class="quoted">ord</span><span class="main">)</span> <span class="quoted">order</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_upset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'a</span> upset <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_upset <span class="bound">X</span> <span class="main">⊇</span> Rep_upset <span class="bound">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_upset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'a</span> upset <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_upset <span class="bound">X</span> <span class="main">⊃</span> Rep_upset <span class="bound">Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le less_eq_upset.rep_eq Rep_upset_inject<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1" id="Representations-us_iso"><span class="command">lemma</span></span> us_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> us <span class="free">x</span> <span class="main">≤</span> us <span class="main">(</span><span class="free">y</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_upset_inverse less_eq_upset.rep_eq upset_anti_iff us_def<span class="main">)</span>
 
<span class="keyword1" id="Representations-us_faithful"><span class="command">lemma</span></span> us_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"us <span class="free">x</span> <span class="main">≤</span> us <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_upset_inverse upset_faithful us_def less_eq_upset.rep_eq<span class="main">)</span>

<span class="keyword1" id="Representations-us_inj"><span class="command">lemma</span></span> us_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> inj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> us_faithful dual_order.antisym<span class="main">)</span>

<span class="keyword1" id="Representations-us_surj"><span class="command">lemma</span></span> us_surj<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> surj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rep_upset Rep_upset_inverse comp_def image_iff us_def<span class="main">)</span>

<span class="keyword1" id="Representations-us_bij"><span class="command">lemma</span></span> us_bij<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bij_def us_surj us_inj<span class="main">)</span>

<span class="keyword1" id="Representations-us_ord_iso"><span class="command">lemma</span></span> us_ord_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"ord_iso <span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ord_iso_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> UNIV_I f_the_inv_into_f monoI us_iso us_bij us_faithful us_inj us_surj<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_us</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'b</span> upset<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_us</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> us <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> IInf"</span></span>

<span class="keyword1" id="Representations-map_us_prop"><span class="command">lemma</span></span> map_us_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"map_us <span class="free">f</span> <span class="main">∘</span> <span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span> <span class="main">=</span> us <span class="main">∘</span> id <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_us_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IInf_us_inv comp_assoc<span class="main">)</span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_IInf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'b</span> upset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_IInf</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">=</span> IInf <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">F</span></span></span> <span class="main">∘</span> us"</span></span>

<span class="keyword1" id="Representations-map_IInf_prop"><span class="command">lemma</span></span> map_IInf_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>us<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span> <span class="main">∘</span> map_IInf <span class="free">F</span> <span class="main">=</span> id <span class="free">F</span> <span class="main">∘</span> us"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"us <span class="main">∘</span> map_IInf <span class="free">F</span> <span class="main">=</span> <span class="main">(</span>us <span class="main">∘</span> IInf<span class="main">)</span> <span class="main">∘</span> <span class="free">F</span> <span class="main">∘</span> us"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun.map_comp map_IInf_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> us_IInf_inv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Representations-map_us_func1"><span class="command">lemma</span></span> map_us_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_us id <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'a</span> upset<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_us_def fun_eq_iff comp_def us_def id_def IInf_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-map_us_func2"><span class="command">lemma</span></span> map_us_func2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_us <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_us <span class="free">f</span> <span class="main">∘</span> map_us <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_us_def fun_eq_iff comp_def us_def IInf_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_upset_inverse Sup_Inf_var Sup_atLeastAtMost Sup_dual_upset_var order_refl rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-map_IInf_func1"><span class="command">lemma</span></span> map_IInf_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_IInf id <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_IInf_def fun_eq_iff comp_def id_def us_def IInf_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_upset_inverse pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-map_IInf_func2"><span class="command">lemma</span></span> map_IInf_func2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual upset"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'c</span> upset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_IInf <span class="main">(</span><span class="free">F</span> <span class="main">∘</span> <span class="free">G</span><span class="main">)</span> <span class="main">=</span> map_IInf <span class="free">F</span> <span class="main">∘</span> map_IInf <span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_IInf_def fun_eq_iff comp_def id_def us_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply id_apply us_IInf_inv us_def<span class="main">)</span>

<span class="keyword1" id="Representations-map_IInf_map_us_inv"><span class="command">lemma</span></span> map_IInf_map_us_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"map_IInf <span class="main">∘</span> map_us <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_IInf_def map_us_def IInf_def us_def id_def comp_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_upset_inverse pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-map_us_map_IInf_inv"><span class="command">lemma</span></span> map_us_map_IInf_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"map_us <span class="main">∘</span> map_IInf <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual upset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'b</span> upset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_IInf_def map_us_def IInf_def us_def id_def comp_def fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-inj_map_us"><span class="command">lemma</span></span> inj_map_us<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>map_us<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'b</span> upset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_us_def us_def IInf_def inj_def comp_def fun_eq_iff
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Abs_upset_inverse Inf_upset_id pointfree_idE rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-inj_map_IInf"><span class="command">lemma</span></span> inj_map_IInf<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>map_IInf<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual upset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_IInf_def fun_eq_iff inj_def comp_def IInf_def us_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-map_us_map_IInf_iff"><span class="command">lemma</span></span> map_us_map_IInf_iff<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> map_us <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map_IInf <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_eq inj_map_us map_us_map_IInf_inv pointfree_idE<span class="main">)</span>

<span class="keyword1" id="Representations-map_us_mono_pres"><span class="command">lemma</span></span> map_us_mono_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span>map_us <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def map_us_def comp_def us_def IInf_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_upset_inverse Inf_superset_mono less_eq_upset.rep_eq rangeI upset_anti_iff<span class="main">)</span>

<span class="keyword1" id="Representations-map_IInf_mono_pres"><span class="command">lemma</span></span> map_IInf_mono_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual upset"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">F</span> <span class="main">⟹</span> mono <span class="main">(</span>map_IInf <span class="free">F</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def map_IInf_def comp_def us_def IInf_def
  <span class="keyword1"><span class="command">oops</span></span> 

<span class="keyword1" id="Representations-surj_map_us"><span class="command">lemma</span></span> surj_map_us<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>map_us<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> upset <span class="main">⇒</span> <span class="tfree">'b</span> upset<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_us_map_IInf_iff surj_def<span class="main">)</span>

<span class="keyword1" id="Representations-surj_map_IInf"><span class="command">lemma</span></span> surj_map_IInf<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>map_IInf<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual upset <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual upset<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> map_us_map_IInf_iff surjI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Hence we have again an isomorphism --- or rather equivalence --- between categories. Here, however, duality is not consistently picked up.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Stone's Theorem in the Presence of Atoms›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Atom-map is a boolean algebra morphism.›</span></span>

<span class="keyword1"><span class="command">context</span></span> boolean_algebra
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Representations-atom_map_compl_pres"><span class="command">lemma</span></span> atom_map_compl_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="main">-</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Collect atom <span class="main">-</span> atom_map <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="main">-</span><span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">y</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="main">-</span><span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">y</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="skolem">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atom_sup_iff inf.orderE meet_shunt sup_compl_top top.ordering_top_axioms ordering_top.extremum<span class="main">)</span>
   <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">∈</span> Collect atom <span class="main">-</span> atom_map <span class="free">x</span><span class="main">)</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
   <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="main">-</span><span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">∈</span> Collect atom <span class="main">-</span> atom_map <span class="free">x</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Representations-atom_map_sup_pres"><span class="command">lemma</span></span> atom_map_sup_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> atom_map <span class="free">x</span> <span class="main">∪</span> atom_map <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">z</span> <span class="main">∧</span> <span class="skolem">z</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">z</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">∨</span> <span class="skolem">z</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_sup_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="free">x</span> <span class="main">∪</span> atom_map <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="free">x</span> <span class="main">∪</span> atom_map <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Representations-atom_map_inf_pres"><span class="command">lemma</span></span> atom_map_inf_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> atom_map <span class="free">x</span> <span class="main">∩</span> atom_map <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Diff_Un atom_map_compl_pres atom_map_sup_pres compl_inf double_compl<span class="main">)</span>

<span class="keyword1" id="Representations-atom_map_minus_pres"><span class="command">lemma</span></span> atom_map_minus_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> atom_map <span class="free">x</span> <span class="main">-</span> atom_map <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atom_map_compl_pres atom_map_def diff_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The homomorphic images of boolean algebras under atom-map are boolean algebras 
--- in fact powerset boolean algebras.›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> atoms <span class="main">::</span> <span class="main">(</span><span class="quoted">boolean_algebra</span><span class="main">)</span> <span class="quoted">boolean_algebra</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Rep_atoms <span class="bound">x</span> <span class="main">-</span> Rep_atoms <span class="bound">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span>  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Collect atom <span class="main">-</span> Rep_atoms <span class="bound">x</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bot_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Abs_atoms <span class="main">{}</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">sup_atoms</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Rep_atoms <span class="bound">x</span> <span class="main">∪</span> Rep_atoms <span class="bound">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">top_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Abs_atoms <span class="main">(</span>Collect atom<span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">inf_atoms</span> <span class="main">::</span>  <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Rep_atoms <span class="bound">x</span> <span class="main">∩</span> Rep_atoms <span class="bound">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> Rep_atoms <span class="bound">x</span> <span class="main">⊆</span> Rep_atoms <span class="bound">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> Rep_atoms <span class="bound">x</span> <span class="main">⊂</span> Rep_atoms <span class="bound">y</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_classes</span>
                 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le<span class="main">)</span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_atoms_inject less_eq_atoms.abs_eq<span class="main">)</span>
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff inf_le1 rangeI<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff inf_le2 rangeI<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff le_iff_sup rangeI sup_inf_distrib1<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_sup_pres image_iff image_iff inf.orderE inf_sup_aci<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> le_iff_sup order_refl rangeI rangeI<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_sup_pres image_iff inf_sup_aci<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> le_iff_sup rangeI sup.left_commute sup.right_idem<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> Abs_atoms_inverse<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Rep_atoms atom_map_sup_pres image_iff rangeI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command">using</span></span> Abs_atoms_inverse atom_map_bot_pres <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> Abs_atoms_inverse Rep_atoms atom_map_compl_pres atom_map_top_pres diff_eq double_compl inf_le1 rangeE rangeI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_inf_pres atom_map_sup_pres image_iff rangeI sup_inf_distrib1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Abs_atoms_inverse Diff_disjoint Rep_atoms atom_map_compl_pres rangeE rangeI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_atoms_inverse uminus_atoms.abs_eq Rep_atoms Un_Diff_cancel atom_map_compl_pres atom_map_inf_pres atom_map_minus_pres atom_map_sup_pres atom_map_top_pres diff_eq double_compl inf_compl_bot_right rangeE rangeI sup_commute sup_compl_top<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">smt</span> Abs_atoms_inverse Rep_atoms atom_map_compl_pres atom_map_inf_pres atom_map_minus_pres diff_eq rangeE rangeI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The homomorphism atom-map can then be restricted in its output type to the powerset boolean algebra.›</span></span>

<span class="keyword1" id="Representations-at_map_bot_pres"><span class="command">lemma</span></span> at_map_bot_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at_map_def atom_map_bot_pres bot_atoms.transfer<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_top_pres"><span class="command">lemma</span></span> at_map_top_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> at_map_def atom_map_top_pres top_atoms.transfer<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_compl_pres"><span class="command">lemma</span></span> at_map_compl_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">∘</span> uminus <span class="main">=</span> uminus <span class="main">∘</span> at_map"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_atoms_inverse at_map_def atom_map_compl_pres uminus_atoms.abs_eq<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_sup_pres"><span class="command">lemma</span></span> at_map_sup_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> at_map <span class="free">x</span> <span class="main">⊔</span> at_map <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Abs_atoms_inverse atom_map_sup_pres rangeI sup_atoms.transfer<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_inf_pres"><span class="command">lemma</span></span> at_map_inf_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> at_map <span class="free">x</span> <span class="main">⊓</span> at_map <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Abs_atoms_inverse atom_map_inf_pres inf_atoms.transfer rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_minus_pres"><span class="command">lemma</span></span> at_map_minus_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> at_map <span class="free">x</span> <span class="main">-</span> at_map <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_atoms_inverse atom_map_minus_pres minus_atoms.abs_eq<span class="main">)</span>


<span class="keyword1"><span class="command">context</span></span> atomic_boolean_algebra
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In atomic boolean algebras, atom-map is an embedding that maps atoms of the boolean algebra to 
those of the powerset boolean algebra. Analogous properties hold for at-map.›</span></span>

<span class="keyword1" id="Representations-inj_atom_map"><span class="command">lemma</span></span> inj_atom_map<span class="main">:</span> <span class="quoted"><span class="quoted">"inj atom_map"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">⊓</span> <span class="main">-</span><span class="skolem">y</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">-</span><span class="skolem">x</span> <span class="main">⊓</span> <span class="skolem">y</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> meet_shunt<span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> atom <span class="bound">z</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">z</span> <span class="main">≤</span> <span class="skolem">x</span> <span class="main">⊓</span> <span class="main">-</span><span class="skolem">y</span> <span class="main">∨</span> <span class="bound">z</span> <span class="main">≤</span> <span class="main">-</span><span class="skolem">x</span> <span class="main">⊓</span> <span class="skolem">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atomicity <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span><span class="main">.</span> atom <span class="bound">z</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">∈</span> atom_map <span class="skolem">x</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="bound">z</span> <span class="main">∈</span> atom_map <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">¬</span><span class="main">(</span><span class="bound">z</span> <span class="main">∈</span> atom_map <span class="skolem">x</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">∈</span> atom_map <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> atom_def atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> diff_eq inf.orderE meet_shunt_var<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"atom_map <span class="skolem">x</span> <span class="main">≠</span> atom_map <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> injI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Representations-atom_map_atom_pres"><span class="command">lemma</span></span> atom_map_atom_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">⟹</span> atom_map <span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> atom_def atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bot_less dual_order.order_iff_strict<span class="main">)</span>

<span class="keyword1" id="Representations-atom_map_atom_pres2"><span class="command">lemma</span></span> atom_map_atom_pres2<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span> <span class="main">⟹</span> atom <span class="main">(</span>atom_map <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"atom <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"atom_map <span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_atom_pres<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span>atom_map <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> bounded_lattice_class.atom_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Representations-inj_at_map"><span class="command">lemma</span></span> inj_at_map<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>at_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>atomic_boolean_algebra <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Abs_atoms_inverse inj_atom_map inj_def rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_atom_pres"><span class="command">lemma</span></span> at_map_atom_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>atomic_boolean_algebra<span class="main">)</span> <span class="main">⟹</span> at_map <span class="free">x</span> <span class="main">=</span> Abs_atoms <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_atom_pres<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_atom_pres2"><span class="command">lemma</span></span> at_map_atom_pres2<span class="main">:</span> <span class="quoted"><span class="quoted">"atom <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>atomic_boolean_algebra<span class="main">)</span> <span class="main">⟹</span> atom <span class="main">(</span>at_map <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_atoms_inverse atom_def atom_map_atom_pres2 atom_map_bot_pres bot_atoms.abs_eq less_atoms.abs_eq rangeI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Homomorphic images of atomic boolean algebras under atom-map are therefore atomic (rather obviously).›</span></span>

<span class="keyword1"><span class="command">instance</span></span> atoms <span class="main">::</span> <span class="main">(</span><span class="quoted">atomic_boolean_algebra</span><span class="main">)</span> <span class="quoted">atomic_boolean_algebra</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">intro_classes</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> atoms"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> at_map <span class="bound">y</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_atoms_cases rangeE<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> at_map <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> atom <span class="bound">z</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> at_map_bot_pres atomicity <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">=</span> at_map <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> atom <span class="main">(</span>at_map <span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> at_map <span class="bound">z</span> <span class="main">≤</span> at_map <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> at_map_atom_pres2 at_map_sup_pres sup.orderE sup_ge2<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> atom <span class="bound">y</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_boolean_algebra_alt
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In complete boolean algebras, atom-map is surjective; more precisely it is the left inverse
of Sup, at least for sets of atoms. Below, this statement is made more explicit for at-map.›</span></span>

<span class="keyword1" id="Representations-surj_atom_map"><span class="command">lemma</span></span> surj_atom_map<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">⊆</span> Collect atom <span class="main">⟹</span> <span class="free">Y</span> <span class="main">=</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">⊆</span> Collect atom"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">⊆</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Sup_upper atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">⊆</span> Collect atom"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">Y</span> <span class="main">⟶</span> atom <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
  <span class="keyword3"><span class="command">assume</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∈</span> Collect atom <span class="main">-</span> <span class="free">Y</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">⊓</span> <span class="skolem">z</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> DiffE a h atom_def dual_order.not_eq_order_implies_strict inf.absorb_iff2 inf_le2 meet_shunt mem_Collect_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">Y</span> <span class="main">⊓</span> <span class="skolem">z</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Sup_least meet_shunt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span> <span class="main">∉</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">Y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_map_bot_pres atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span>  <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">Y</span><span class="main">)</span> <span class="main">⊆</span> <span class="free">Y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this setting, atom-map is a complete boolean algebra morphism.›</span></span>

<span class="keyword1" id="Representations-atom_map_Sup_pres"><span class="command">lemma</span></span> atom_map_Sup_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">z</span> <span class="main">∧</span> <span class="skolem">z</span> <span class="main">≤</span> <span class="main">⨆</span><span class="free">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span>atom <span class="skolem">z</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="skolem">z</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_Sup_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">z</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Representations-atom_map_Sup_pres_var"><span class="command">lemma</span></span> atom_map_Sup_pres_var<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">∘</span> Sup <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> atom_map"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_Sup_pres<span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For Inf-preservation, it is important that Infs are restricted to homomorphic images; 
hence they need to be pushed into the set of all atoms.›</span></span>

<span class="keyword1" id="Representations-atom_map_Inf_pres"><span class="command">lemma</span></span> atom_map_Inf_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> Collect atom <span class="main">∩</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"atom_map <span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> atom_map <span class="main">(</span><span class="main">-</span><span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Collect_cong SUP_le_iff atom_map_def compl_le_compl_iff compl_le_swap1 le_Inf_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Collect atom <span class="main">-</span> atom_map <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">-</span><span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> atom_map_compl_pres <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Collect atom <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="main">(</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> atom_map_Sup_pres<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Collect atom <span class="main">-</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> Collect atom <span class="main">-</span> atom_map <span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> atom_map_compl_pres <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> Collect atom <span class="main">∩</span> <span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> atom_map <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It follows that homomorphic images of complete boolean algebras under atom-map form
complete boolean algebras.›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> atoms <span class="main">::</span> <span class="main">(</span><span class="quoted">complete_boolean_algebra_alt</span><span class="main">)</span> <span class="quoted">complete_boolean_algebra_alt</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Inf_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt atoms set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Collect atom <span class="main">∩</span> Inter <span class="main">(</span><span class="main">(`)</span> Rep_atoms <span class="bound">X</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span>  <span class="class_parameter">Sup_atoms</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt atoms set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt atoms"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span><span class="main">.</span> Abs_atoms <span class="main">(</span>Union <span class="main">(</span><span class="main">(`)</span> Rep_atoms <span class="bound">X</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Abs_atoms_inverse image_iff inf_le1 le_Inf_iff le_infI2 order_refl rangeI surj_atom_map<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Abs_atoms_inverse Int_subset_iff Rep_atoms Sup_upper atom_map_atoms inf_le1 le_INF_iff rangeI surj_atom_map<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Abs_atoms_inverse Rep_atoms SUP_least SUP_upper Sup_upper atom_map_atoms rangeI surj_atom_map<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Abs_atoms_inverse Rep_atoms SUP_least Sup_upper atom_map_atoms rangeI surj_atom_map<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Once more, properties proved above can now be restricted to at-map.›</span></span>

<span class="keyword1" id="Representations-surj_at_map_var"><span class="command">lemma</span></span>  surj_at_map_var<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">∘</span> Sup <span class="main">∘</span> Rep_atoms <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt atoms <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def fun_eq_iff id_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rep_atoms Rep_atoms_inverse Sup_upper atom_map_atoms surj_atom_map<span class="main">)</span>

<span class="keyword1" id="Representations-surj_at_map"><span class="command">lemma</span></span> surj_at_map<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">(</span>at_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> surj_def at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rep_atoms Rep_atoms_inverse image_iff<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_Sup_pres"><span class="command">lemma</span></span> at_map_Sup_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">∘</span> Sup <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span>at_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff at_map_def comp_def atom_map_Sup_pres <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Abs_atoms_inverse Sup.SUP_cong Sup_atoms.transfer UN_extend_simps<span class="main"><span class="main">(</span></span>10<span class="main"><span class="main">)</span></span> rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_Sup_pres_var"><span class="command">lemma</span></span> at_map_Sup_pres_var<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt<span class="main">)</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">(</span>at_map <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> at_map_Sup_pres comp_eq_elim <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Representations-at_map_Inf_pres"><span class="command">lemma</span></span> at_map_Inf_pres<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> Abs_atoms <span class="main">(</span>Collect atom <span class="main">⊓</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">(</span>Rep_atoms <span class="main">(</span>at_map <span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Abs_atoms_inverse Sup.SUP_cong atom_map_Inf_pres rangeI<span class="main">)</span>

<span class="keyword1" id="Representations-at_map_Inf_pres_var"><span class="command">lemma</span></span> at_map_Inf_pres_var<span class="main">:</span> <span class="quoted"><span class="quoted">"at_map <span class="main">∘</span> Inf <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span>at_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_boolean_algebra_alt <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_atoms.abs_eq at_map_Inf_pres image_image<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, on complete atomic boolean algebras (CABAs), at-map is an isomorphism, that is, a bijection 
that preserves the complete boolean algebra operations. Thus every CABA is isomorphic to a powerset boolean algebra
and every powerset boolean algebra is a CABA. The bijective pair is given by at-map and Sup (defined on the powerset algebra).
This theorem is a little version of Stone's theorem. In the general case, ultrafilters play the role of atoms.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> atom_map <span class="main">=</span> <span class="main">(</span>id<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_atomic_boolean_algebra <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def id_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Union_upper atom_map_atoms inj_atom_map inj_def rangeI surj_atom_map<span class="main">)</span>

<span class="keyword1" id="Representations-inj_at_map_var"><span class="command">lemma</span></span> inj_at_map_var<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> Rep_atoms <span class="main">∘</span> at_map  <span class="main">=</span> <span class="main">(</span>id <span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_atomic_boolean_algebra <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">unfolding</span></span> at_map_def comp_def fun_eq_iff id_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Abs_atoms_inverse Union_upper atom_map_atoms inj_atom_map inj_def rangeI surj_atom_map<span class="main">)</span>

<span class="keyword1" id="Representations-bij_at_map"><span class="command">lemma</span></span> bij_at_map<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">(</span>at_map<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_atomic_boolean_algebra <span class="main">⇒</span> <span class="tfree">'a</span> atoms<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bij_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_at_map surj_at_map<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> atoms <span class="main">::</span> <span class="main">(</span><span class="quoted">complete_atomic_boolean_algebra</span><span class="main">)</span> <span class="quoted">complete_atomic_boolean_algebra</span><span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A full consideration of Stone duality is left for future work.›</span></span>

<span class="comment1">(* Failed attempt to prove Tarski's fixpoint theorem: The problem is that we want to use mono, but this has two type parameters. It doesn't work inside of the one-type-parameter typedef.
Yet isotonicity is needed to prove inhabitance of the type. I could develop a theory of isotone endos and prove the existence of 
lfps and gfps, duplicating the more general facts for mono. But that's not the point. Because of this I see no direct way of proving
Tarski's fixpoint theorem. Any way out?

class complete_lattice_with_iso = complete_lattice +
  fixes f :: "'a ⇒ 'a"
(*  assumes isof: "x ≤ y ⟹ f x ≤ f y"*)

typedef (overloaded) 'a Fix = "Fix (f::'a::complete_lattice_with_iso ⇒ 'a)" 


setup_lifting type_definition_Fix

*)</span>

<span class="keyword2"><span class="keyword">end</span></span>





</pre>
</div><div id="Galois_Connections">
<div class="head">
<h1>Theory Galois_Connections</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Galois Connections
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Galois Connections›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Galois_Connections
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Order_Lattice_Props.html">Order_Lattice_Props</a>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions and Basic Properties›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The approach follows the Compendium of Continuous Lattices~\cite{GierzHKLMS80}, without attempting completeness. 
First, left and right adjoints of a Galois connection are defined.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adj</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊣</span>"</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">⊣</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ladj</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">⨅</span><span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">radj</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord<span class="main">)</span>  <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">⨆</span><span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Galois_Connections-ladj_radj_dual"><span class="command">lemma</span></span> ladj_radj_dual<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ladj <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span>radj <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ladj <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span><span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∂</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ladj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Collect_cong Inf_dual_var dual_dual_ord dual_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span>  <span class="main">∂</span> <span class="main">(</span><span class="main">⨆</span><span class="main">{</span><span class="main">∂</span> <span class="bound">y</span><span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="main">∂</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> setcompr_eq_image<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ladj_def radj_def map_dual_def comp_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Collect_cong invol_dual_var<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Galois_Connections-radj_ladj_dual"><span class="command">lemma</span></span> radj_ladj_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"radj <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span>ladj <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="main">∂</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fun_dual5 invol_dual_var ladj_radj_dual map_dual_def<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-ladj_prop"><span class="command">lemma</span></span> ladj_prop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>ord_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ladj <span class="free">g</span> <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(-`)</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">↑</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ladj_def vimage_def upset_prop fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Galois_Connections-radj_prop"><span class="command">lemma</span></span> radj_prop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>ord"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"radj <span class="free">f</span> <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(-`)</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> radj_def vimage_def downset_prop fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The first set of properties holds without any sort assumptions.›</span></span>

<span class="keyword1" id="Galois_Connections-adj_iso1"><span class="command">lemma</span></span> adj_iso1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def mono_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.refl dual_order.trans<span class="main">)</span> 

<span class="keyword1" id="Galois_Connections-adj_iso2"><span class="command">lemma</span></span> adj_iso2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> mono <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def mono_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.refl dual_order.trans<span class="main">)</span> 

<span class="keyword1" id="Galois_Connections-adj_comp"><span class="command">lemma</span></span> adj_comp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> adj <span class="free">h</span> <span class="free">k</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">h</span><span class="main">)</span> <span class="main">⊣</span> <span class="main">(</span><span class="free">k</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_def<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_dual"><span class="command">lemma</span></span> adj_dual<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">g</span><span class="main">)</span> <span class="main">⊣</span> <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def map_dual_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> dual_dual_ord invol_dual_var<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties for (Pre)Orders›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next set of properties holds in preorders or orders.›</span></span>

<span class="keyword1" id="Galois_Connections-adj_cancel1"><span class="command">lemma</span></span> adj_cancel1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">≤</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_def le_funI<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_cancel2"><span class="command">lemma</span></span> adj_cancel2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> id <span class="main">≤</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_def eq_iff le_funI<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_prop"><span class="command">lemma</span></span> adj_prop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span><span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">≤</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> adj_cancel1 adj_cancel2 order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Galois_Connections-adj_cancel_eq1"><span class="command">lemma</span></span> adj_cancel_eq1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def comp_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_iff order_refl order_trans<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_cancel_eq2"><span class="command">lemma</span></span> adj_cancel_eq2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def comp_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> eq_iff order_refl order_trans<span class="main">)</span> 

<span class="keyword1" id="Galois_Connections-adj_idem1"><span class="command">lemma</span></span> adj_idem1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_cancel_eq1 rewriteL_comp_comp<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_idem2"><span class="command">lemma</span></span> adj_idem2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>preorder"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_cancel_eq2 rewriteL_comp_comp<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_iso3"><span class="command">lemma</span></span> adj_iso3<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_iso1 adj_iso2 monoD monoI<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_iso4"><span class="command">lemma</span></span> adj_iso4<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_iso1 adj_iso2 monoD monoI<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_canc1"><span class="command">lemma</span></span> adj_canc1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>ord"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="free">y</span> <span class="main">⟶</span> <span class="free">g</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff<span class="main">)</span>
 
<span class="keyword1" id="Galois_Connections-adj_canc2"><span class="command">lemma</span></span> adj_canc2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>ord <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">y</span> <span class="main">⟶</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_sur_inv"><span class="command">lemma</span></span> adj_sur_inv<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>surj <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> id<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def surj_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_id_iff eq_iff order_refl order_trans<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_surj_inj"><span class="command">lemma</span></span> adj_surj_inj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>surj <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>inj <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def inj_def surj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff order_trans<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_inj_inv"><span class="command">lemma</span></span> adj_inj_inv<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>inj <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> id<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> adj_cancel_eq1 eq_id_iff inj_def o_apply<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-adj_inj_surj"><span class="command">lemma</span></span> adj_inj_surj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span>inj <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>surj <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def inj_def surj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eq_iff order_trans<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-surj_id_the_inv"><span class="command">lemma</span></span> surj_id_the_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> id <span class="main">⟹</span> <span class="free">g</span> <span class="main">=</span> the_inv <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply id_apply inj_on_id inj_on_imageI2 surj_fun_eq the_inv_f_f<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-inj_id_the_inv"><span class="command">lemma</span></span> inj_id_the_inv<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> id <span class="main">⟹</span> <span class="free">f</span> <span class="main">=</span> the_inv <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="free">f</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> the_inv <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> comp_apply eq_id_iff inj_on_id inj_on_imageI2 the_inv_f_f<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties for Complete Lattices›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next laws state that a function between complete lattices preserves infs 
  if and only if it has a lower adjoint.›</span></span>

<span class="keyword1" id="Galois_Connections-radj_Inf_pres"><span class="command">lemma</span></span> radj_Inf_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⊣</span> <span class="free">g</span><span class="main">)</span> <span class="main">⟹</span> Inf_pres <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def adj_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> INF_greatest Inf_lower dual_order.refl dual_order.trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Inf_greatest dual_order.refl le_INF_iff<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-ladj_Sup_pres"><span class="command">lemma</span></span> ladj_Sup_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="free">f</span> <span class="main">⊣</span> <span class="bound">g</span><span class="main">)</span> <span class="main">⟹</span> Sup_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_pres_map_dual_var adj_dual radj_Inf_pres <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Galois_Connections-radj_adj"><span class="command">lemma</span></span> radj_adj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span>radj <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def radj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cSup_eq_maximum eq_iff mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-ladj_adj"><span class="command">lemma</span></span> ladj_adj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span>ladj <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def ladj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cInf_eq_minimum eq_iff mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-Inf_pres_radj_aux"><span class="command">lemma</span></span> Inf_pres_radj_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span>ladj <span class="free">g</span><span class="main">)</span> <span class="main">⊣</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
   <span class="keyword3"><span class="command">assume</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"ladj <span class="free">g</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">(</span>ladj <span class="free">g</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">≤</span> <span class="free">g</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_subdistl_iso a monoD<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span><span class="main">{</span><span class="free">g</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="free">g</span> <span class="bound">y</span><span class="main">}</span> <span class="main">≤</span> <span class="free">g</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> a comp_eq_dest_lhs setcompr_eq_image ladj_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="free">g</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> dual_order.trans le_Inf_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ladj <span class="free">g</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">⟶</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="free">g</span> <span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> adj_def ladj_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> CollectI Inf_lower<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Galois_Connections-Sup_pres_ladj_aux"><span class="command">lemma</span></span> Sup_pres_ladj_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊣</span> <span class="main">(</span>radj <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Inf_pres_radj_aux Sup_pres_map_dual_var adj_dual fun_dual5 map_dual_def radj_adj<span class="main">)</span>

<span class="keyword1" id="Galois_Connections-Inf_pres_radj"><span class="command">lemma</span></span> Inf_pres_radj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">g</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⊣</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Inf_pres_radj_aux <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Galois_Connections-Sup_pres_ladj"><span class="command">lemma</span></span> Sup_pres_ladj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="free">f</span> <span class="main">⊣</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_pres_ladj_aux <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Galois_Connections-Inf_pres_upper_adj_eq"><span class="command">lemma</span></span> Inf_pres_upper_adj_eq<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Inf_pres <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⊣</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> radj_Inf_pres Inf_pres_radj <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Galois_Connections-Sup_pres_ladj_eq"><span class="command">lemma</span></span> Sup_pres_ladj_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup_pres <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">g</span><span class="main">.</span> <span class="free">f</span> <span class="main">⊣</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_pres_ladj ladj_Sup_pres <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Galois_Connections-Sup_downset_adj"><span class="command">lemma</span></span> Sup_downset_adj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice set <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⊣</span> <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> adj_def downset_prop Sup_le_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Galois_Connections-Sup_downset_adj_var"><span class="command">lemma</span></span> Sup_downset_adj_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup <span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice set<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">⊆</span> <span class="main">↓</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_downset_adj adj_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Once again many statements arise by duality, which Isabelle usually picks up.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Fixpoint_Fusion">
<div class="head">
<h1>Theory Fixpoint_Fusion</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Fixpoint Fusion
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Fixpoint Fusion›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Fixpoint_Fusion
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Galois_Connections.html">Galois_Connections</a>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Least and greatest fixpoint fusion laws for adjoints in a Galois connection, 
including some variants, are proved in this section. Again, the laws for least and greatest fixpoints are duals. ›</span></span>

<span class="keyword1" id="Fixpoint_Fusion-lfp_Fix"><span class="command">lemma</span></span> lfp_Fix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> lfp <span class="free">f</span> <span class="main">=</span> <span class="main">⨅</span><span class="main">(</span>Fix <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lfp_def Fix_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_mono Inf_superset_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> Inf_lower lfp_def lfp_unfold mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Fixpoint_Fusion-gfp_Fix"><span class="command">lemma</span></span> gfp_Fix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> gfp <span class="free">f</span> <span class="main">=</span> <span class="main">⨆</span><span class="main">(</span>Fix <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iso_map_dual gfp_to_lfp lfp_Fix Fix_map_dual_var Sup_to_Inf_var<span class="main">)</span>

<span class="keyword1" id="Fixpoint_Fusion-gfp_little_fusion"><span class="command">lemma</span></span> gfp_little_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> gfp <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">f</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">g</span> <span class="main">(</span><span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> le_funD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="free">g</span> <span class="main">(</span><span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> gfp_fixpoint<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> gfp <span class="free">g</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gfp_upperbound<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fixpoint_Fusion-lfp_little_fusion"><span class="command">lemma</span></span> lfp_little_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">∘</span> <span class="free">h</span> <span class="main">≤</span> <span class="free">h</span> <span class="main">∘</span> <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfp <span class="free">g</span> <span class="main">≤</span> <span class="free">h</span> <span class="main">(</span>lfp <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>map_dual <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms iso_map_dual<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_dual <span class="free">h</span> <span class="main">∘</span> map_dual <span class="free">f</span> <span class="main">≤</span> map_dual <span class="free">g</span> <span class="main">∘</span> map_dual <span class="free">h</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms map_dual_anti map_dual_func1<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> a comp_eq_elim dual_dual_ord fun_dual1 gfp_little_fusion lfp_dual_var map_dual_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fixpoint_Fusion-gfp_fusion"><span class="command">lemma</span></span> gfp_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="main">⊣</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> gfp <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> gfp <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> gfp_little_fusion<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">hl</span></span> <span class="keyword2"><span class="keyword">where</span></span> conn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="skolem">hl</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="free">h</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms adj_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hl</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">≤</span> <span class="skolem">hl</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span> <span class="main">∘</span> <span class="skolem">hl</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">meson</span> conn assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> monoE order_refl order_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="skolem">hl</span> <span class="main">∘</span> <span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="skolem">hl</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> comp_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hl</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> <span class="skolem">hl</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> conn inf.coboundedI2 inf.orderE order_refl<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hl</span> <span class="main">(</span>gfp <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">(</span><span class="skolem">hl</span> <span class="main">(</span>gfp <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_eq_dest_lhs gfp_unfold assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">hl</span> <span class="main">(</span>gfp <span class="free">g</span><span class="main">)</span> <span class="main">≤</span> gfp <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gfp_upperbound<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"gfp <span class="free">g</span> <span class="main">≤</span> <span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conn<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> a eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Fixpoint_Fusion-lfp_fusion"><span class="command">lemma</span></span> lfp_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="free">h</span> <span class="main">⊣</span> <span class="bound">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>lfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> lfp <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> map_dual <span class="bound">f</span> <span class="main">⊣</span> map_dual <span class="free">h</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> adj_dual assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>map_dual <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> iso_map_dual<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span>map_dual <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> iso_map_dual<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_dual <span class="free">h</span> <span class="main">∘</span> map_dual <span class="free">f</span> <span class="main">=</span> map_dual <span class="free">g</span> <span class="main">∘</span> map_dual <span class="free">h</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> map_dual_func1<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>   
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> a adj_dual b c gfp_fusion ladj_adj ladj_radj_dual lfp_dual_var lfp_to_gfp_var radj_adj<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1" id="Fixpoint_Fusion-gfp_fusion_inf_pres"><span class="command">lemma</span></span> gfp_fusion_inf_pres<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>gfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> gfp <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_pres_radj assms gfp_fusion<span class="main">)</span>

<span class="keyword1" id="Fixpoint_Fusion-lfp_fusion_sup_pres"><span class="command">lemma</span></span> lfp_fusion_sup_pres<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">h</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">h</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>lfp <span class="free">f</span><span class="main">)</span> <span class="main">=</span> lfp <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_pres_ladj assms lfp_fusion<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following facts are usueful for the semantics of isotone predicate transformers. 
A dual statement for least fixpoints can be proved, but is not spelled out here.›</span></span>

<span class="keyword1" id="Fixpoint_Fusion-k_adju"><span class="command">lemma</span></span> k_adju<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">F</span><span class="main">.</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">F</span><span class="main">::</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⊣</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> fun_eq_iff Inf_pres_radj<span class="main">)</span>

<span class="keyword1" id="Fixpoint_Fusion-k_adju_var"><span class="command">lemma</span></span> k_adju_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">F</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span><span class="main">∀</span><span class="bound">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">.</span> <span class="main">(</span><span class="bound">F</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span> <span class="main">≤</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="free">y</span><span class="main">)</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> k_adju <span class="keyword1"><span class="command">unfolding</span></span> adj_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Fixpoint_Fusion-gfp_fusion_var"><span class="command">lemma</span></span> gfp_fusion_var<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">F</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">F</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">h</span><span class="main">.</span> <span class="free">F</span> <span class="bound">h</span> <span class="free">x</span> <span class="main">=</span> <span class="free">g</span> <span class="main">(</span><span class="bound">h</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gfp <span class="free">F</span> <span class="free">x</span> <span class="main">=</span> gfp <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> assms eq_iff gfp_fixpoint gfp_upperbound k_adju_var monoE order_refl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This time, Isabelle is picking up dualities rather inconsistently.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Closure_Operators">
<div class="head">
<h1>Theory Closure_Operators</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Closure and Co-Closure Operators
  Author: Georg Struth 
  Maintainer: Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Closure and Co-Closure Operators›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Closure_Operators
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Galois_Connections.html">Galois_Connections</a> 

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Closure Operators›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Closure and coclosure operators in orders and complete lattices are defined in this section,
and some basic properties are proved. Isabelle infers the appropriate types. Facts are 
taken mainly from the Compendium of Continuous Lattices~\cite{GierzHKLMS80} and 
Rosenthal's book on quantales~\cite{Rosenthal90}.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">clop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">clop</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span>id <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∧</span> mono <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Closure_Operators-clop_extensive"><span class="command">lemma</span></span> clop_extensive<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> id <span class="main">≤</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_extensive_var"><span class="command">lemma</span></span> clop_extensive_var<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def le_fun_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_iso"><span class="command">lemma</span></span> clop_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_iso_var"><span class="command">lemma</span></span> clop_iso_var<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def mono_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_idem"><span class="command">lemma</span></span> clop_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antisym clop_def le_fun_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_Fix_range"><span class="command">lemma</span></span> clop_Fix_range<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span>Fix <span class="free">f</span> <span class="main">=</span> range <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_idem retraction_prop_fix<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_idem_var"><span class="command">lemma</span></span> clop_idem_var<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_idem retraction_prop<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_Inf_closed_var"><span class="command">lemma</span></span> clop_Inf_closed_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>  <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>"</span></span>    
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def mono_def comp_def le_fun_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> antisym id_apply le_INF_iff order_refl<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_top"><span class="command">lemma</span></span> clop_top<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_extensive_var top.extremum_uniqueI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">f</span> <span class="free">y</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="comment1">(*nitpick *)</span>
  <span class="keyword1"><span class="command">oops</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">f</span> <span class="free">y</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="comment1">(*nitpick *)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1" id="Closure_Operators-clop_closure"><span class="command">lemma</span></span> clop_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_idem retraction_prop<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_closure_set"><span class="command">lemma</span></span> clop_closure_set<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> range <span class="free">f</span> <span class="main">=</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_Fix_range<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_closure_prop"><span class="command">lemma</span></span> clop_closure_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>clop<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual<span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">(</span>Inf <span class="main">∘</span> <span class="main">↑</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def mono_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_closure_prop_var"><span class="command">lemma</span></span> clop_closure_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice<span class="main">.</span> <span class="main">⨅</span><span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def comp_def le_fun_def mono_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_lower le_Inf_iff<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_alt"><span class="command">lemma</span></span> clop_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>clop <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def mono_def le_fun_def comp_def id_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.refl order_trans<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally it is shown that adjoints in a Galois connection yield closure operators.›</span></span>

<span class="keyword1" id="Closure_Operators-clop_adj"><span class="command">lemma</span></span> clop_adj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> clop <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_cancel2 adj_idem2 adj_iso4 clop_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Closure operators are monads for posets, and monads arise from adjunctions. 
This fact is not formalised at this point. But here is the first step: every function 
can be decomposed into a surjection followed by an injection.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">surj_on</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Closure_Operators-surj_surj_on"><span class="command">lemma</span></span> surj_surj_on<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span> <span class="main">⟹</span> surj_on <span class="free">f</span> <span class="free">Y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> surjD surj_on_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-fun_surj_inj"><span class="command">lemma</span></span> fun_surj_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">g</span> <span class="bound">h</span><span class="main">.</span> <span class="free">f</span> <span class="main">=</span> <span class="bound">g</span> <span class="main">∘</span> <span class="bound">h</span> <span class="main">∧</span> surj_on <span class="bound">h</span> <span class="main">(</span>range <span class="free">f</span><span class="main">)</span> <span class="main">∧</span> inj_on <span class="bound">g</span> <span class="main">(</span>range <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="skolem">h</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"surj_on <span class="skolem">h</span> <span class="main">(</span>range <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> imageE surj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> inj_on_def surj_on_def fun_eq_iff <span class="keyword1"><span class="command">using</span></span> a <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Connections between downsets, upsets and closure operators are outlined next.›</span></span>

<span class="keyword1" id="Closure_Operators-preorder_clop"><span class="command">lemma</span></span> preorder_clop<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="main">⇓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def downset_set_ext downset_set_iso<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_preorder_aux"><span class="command">lemma</span></span> clop_preorder_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">f</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span> <span class="main">⟷</span> <span class="free">f</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_alt<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_preorder"><span class="command">lemma</span></span> clop_preorder<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> class.preorder <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">f</span> <span class="main">{</span><span class="bound">y</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span> <span class="main">⊂</span> <span class="free">f</span> <span class="main">{</span><span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def mono_def le_fun_def id_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> subset_not_subset_eq<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-preorder_clop_dual"><span class="command">lemma</span></span> preorder_clop_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span><span class="main">⇑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder_with_dual set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_def upset_set_anti upset_set_ext<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The closed elements of any closure operator over a complete lattice form an Inf-closed set (a Moore family).›</span></span>

<span class="keyword1" id="Closure_Operators-clop_Inf_closed"><span class="command">lemma</span></span> clop_Inf_closed<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> Inf_closed_set <span class="main">(</span>Fix <span class="free">f</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def Inf_closed_set_def mono_def le_fun_def comp_def id_def Fix_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf_greatest Inf_lower antisym mem_Collect_eq subsetCE<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_top_Fix"><span class="command">lemma</span></span> clop_top_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="main">⊤</span> <span class="main">∈</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_Fix_range clop_closure clop_top<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Conversely, every Inf-closed subset of a complete lattice is the set of fixpoints of some closure operator.›</span></span>
 
<span class="keyword1" id="Closure_Operators-Inf_closed_clop"><span class="command">lemma</span></span> Inf_closed_clop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_closed_set <span class="free">X</span> <span class="main">⟹</span> clop <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">⨅</span><span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Collect_mono_iff Inf_superset_mono clop_alt dual_order.trans le_Inf_iff mem_Collect_eq<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-Inf_closed_clop_var"><span class="command">lemma</span></span> Inf_closed_clop_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> range <span class="free">f</span> <span class="main">⟹</span> <span class="main">⨅</span><span class="free">X</span> <span class="main">∈</span> range <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_closed_set_def clop_Fix_range clop_Inf_closed subsetI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is well known that downsets and upsets over an ordering form subalgebras of the complete powerset lattice.›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> downsets <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="main">⇓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_downsets

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> upsets <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="main">⇑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_upsets

<span class="keyword1"><span class="command">instantiation</span></span> downsets <span class="main">::</span> <span class="main">(</span><span class="quoted">order</span><span class="main">)</span> <span class="quoted">Inf_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Inf_downsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> downsets set <span class="main">⇒</span> <span class="tfree">'a</span> downsets"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Abs_downsets <span class="main">∘</span> Inf <span class="main">∘</span> <span class="main">(`)</span> Rep_downsets"</span></span><span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_downsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> downsets <span class="main">⇒</span> <span class="tfree">'a</span> downsets <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_downsets <span class="bound">X</span> <span class="main">⊆</span> Rep_downsets <span class="bound">Y</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_downsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> downsets <span class="main">⇒</span> <span class="tfree">'a</span> downsets <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_downsets <span class="bound">X</span> <span class="main">⊂</span> Rep_downsets <span class="bound">Y</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_classes</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Closure_Operators.less_eq_downsets.abs_eq Rep_downsets_inject<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_downsets_inverse INF_lower Inf_closed_clop_var Rep_downsets image_iff o_def preorder_clop<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">smt</span> comp_def Abs_downsets_inverse Inf_closed_clop_var Rep_downsets image_iff le_INF_iff preorder_clop<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> upsets <span class="main">::</span> <span class="main">(</span><span class="quoted">order_with_dual</span><span class="main">)</span> <span class="quoted">Inf_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Inf_upsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> upsets set <span class="main">⇒</span> <span class="tfree">'a</span> upsets"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"Abs_upsets <span class="main">∘</span> Inf <span class="main">∘</span> <span class="main">(`)</span> Rep_upsets"</span></span><span class="keyword1"><span class="command">.</span></span>
  
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_upsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> upsets <span class="main">⇒</span> <span class="tfree">'a</span> upsets <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_upsets <span class="bound">X</span> <span class="main">⊆</span> Rep_upsets <span class="bound">Y</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_upsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> upsets <span class="main">⇒</span> <span class="tfree">'a</span> upsets <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> Rep_upsets <span class="bound">X</span> <span class="main">⊂</span> Rep_upsets <span class="bound">Y</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_classes</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Closure_Operators.less_eq_upsets.abs_eq Rep_upsets_inject<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> Abs_upsets_inverse Inf_closed_clop_var Inf_lower Rep_upsets comp_apply image_iff preorder_clop_dual<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">smt</span> comp_def Abs_upsets_inverse Inf_closed_clop_var Inter_iff Rep_upsets image_iff preorder_clop_dual subsetCE subsetI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It has already been shown in the section on representations that the map ds, which maps elements of the order to its downset, is an order 
embedding. However, the duality between the underlying ordering and the lattices of up- and down-closed sets as categories can probably not be expressed, 
as there is no easy access to contravariant functors. ›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Co-Closure Operators›</span></span>
                                
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, the co-closure (or kernel) operation satisfies dual laws.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">coclop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">coclop</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≤</span> id <span class="main">∧</span> mono <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Closure_Operators-coclop_dual"><span class="command">lemma</span></span> coclop_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>coclop<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> clop <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> coclop_def clop_def id_def mono_def map_dual_def comp_def fun_eq_iff le_fun_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invol_dual_var ord_dual<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_dual_var"><span class="command">lemma</span></span> coclop_dual_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">=</span> clop <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_dual<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_dual"><span class="command">lemma</span></span> clop_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>clop<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> coclop <span class="main">∘</span> <span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_dual comp_assoc map_dual_invol<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_dual_var"><span class="command">lemma</span></span> clop_dual_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"clop <span class="free">f</span> <span class="main">=</span> coclop <span class="main">(</span><span class="keyword1">∂<span class="hidden">⇩</span><sub>F</sub></span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_dual<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_coextensive"><span class="command">lemma</span></span> coclop_coextensive<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">≤</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_coextensive_var"><span class="command">lemma</span></span> coclop_coextensive_var<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> coclop_def le_funD <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Closure_Operators-coclop_iso"><span class="command">lemma</span></span> coclop_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_iso_var"><span class="command">lemma</span></span> coclop_iso_var<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟶</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_iso monoD<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_idem"><span class="command">lemma</span></span> coclop_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antisym coclop_def le_fun_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_closure"><span class="command">lemma</span></span> coclop_closure<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_idem retraction_prop<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_Fix_range"><span class="command">lemma</span></span> coclop_Fix_range<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span>Fix <span class="free">f</span> <span class="main">=</span> range <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_idem retraction_prop_fix<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_idem_var"><span class="command">lemma</span></span> coclop_idem_var<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_idem retraction_prop<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_Sup_closed_var"><span class="command">lemma</span></span> coclop_Sup_closed_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>  <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> coclop_def mono_def comp_def le_fun_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> SUP_le_iff antisym id_apply order_refl<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-Sup_closed_coclop_var"><span class="command">lemma</span></span> Sup_closed_coclop_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> range <span class="free">f</span> <span class="main">⟹</span> <span class="main">⨆</span><span class="free">X</span> <span class="main">∈</span> range <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf.INF_id_eq Sup.SUP_cong antisym coclop_closure coclop_coextensive_var coclop_iso id_apply mono_SUP<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_bot"><span class="command">lemma</span></span> coclop_bot<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bot.extremum_uniqueI coclop_coextensive_var<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">f</span> <span class="free">y</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span> <span class="comment1">(*nitpick*)</span> 
  <span class="keyword1"><span class="command">oops</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">f</span> <span class="free">y</span>"</span></span> <span class="comment1">(*nitpick*)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span> <span class="comment1">(*nitpick *)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1" id="Closure_Operators-coclop_coclosure"><span class="command">lemma</span></span> coclop_coclosure<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> range <span class="free">f</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_idem retraction_prop<span class="main">)</span>
                                              
<span class="keyword1" id="Closure_Operators-coclop_coclosure_set"><span class="command">lemma</span></span> coclop_coclosure_set<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> range <span class="free">f</span> <span class="main">=</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_idem retraction_prop_fix<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_coclosure_prop"><span class="command">lemma</span></span> coclop_coclosure_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>coclop<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">(</span>Sup <span class="main">∘</span> <span class="main">↓</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coclop_def mono_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_coclosure_prop_var"><span class="command">lemma</span></span> coclop_coclosure_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"coclop <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice<span class="main">.</span> <span class="main">⨆</span><span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Sup_atMost atMost_def coclop_def comp_apply eq_id_iff eq_refl mono_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_alt"><span class="command">lemma</span></span> coclop_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>coclop <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> coclop_def mono_def le_fun_def comp_def id_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.refl order_trans<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-coclop_adj"><span class="command">lemma</span></span> coclop_adj<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="free">g</span> <span class="main">⟹</span> coclop <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> adj_cancel1 adj_idem1 adj_iso3 coclop_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, a subset of a complete lattice is Sup-closed if and only if it is the set of fixpoints
of some co-closure operator.›</span></span>

<span class="keyword1" id="Closure_Operators-coclop_Sup_closed"><span class="command">lemma</span></span> coclop_Sup_closed<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"coclop <span class="free">f</span> <span class="main">⟹</span> Sup_closed_set <span class="main">(</span>Fix <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> coclop_def Sup_closed_set_def mono_def le_fun_def comp_def id_def Fix_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Sup_least Sup_upper antisym_conv mem_Collect_eq subsetCE<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-Sup_closed_coclop"><span class="command">lemma</span></span> Sup_closed_coclop<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_closed_set <span class="free">X</span> <span class="main">⟹</span> coclop <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="main">⨆</span><span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Sup_closed_set_def coclop_def mono_def le_fun_def comp_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Sup_least eq_id_iff mem_Collect_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> Collect_mono_iff Sup_subset_mono dual_order.trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_mono_iff Sup_subset_mono Sup_upper<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complete Lattices of Closed Elements›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The machinery developed allows showing that the closed elements in a complete
lattice (with respect to some closure operation) form themselves a complete lattice.›</span></span>

<span class="keyword1"><span class="command">class</span></span> cl_op <span class="main">=</span> ord <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">cl_op</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> clop_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">cl_op</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> clop_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">cl_op</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">cl_op</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> clop_wtrans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cl_op</span> <span class="main">(</span><span class="free">cl_op</span> <span class="free">x</span><span class="main">)</span> <span class="main">≤</span> <span class="free">cl_op</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> clattice_with_clop <span class="main">=</span> complete_lattice <span class="main">+</span> cl_op

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Closure_Operators-clop_cl_op"><span class="command">lemma</span></span> clop_cl_op<span class="main">:</span> <span class="quoted"><span class="quoted">"clop cl_op"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def le_fun_def comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cl_op_class.clop_ext cl_op_class.clop_iso cl_op_class.clop_wtrans order_class.mono_def<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_idem"><span class="command">lemma</span></span> clop_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cl_op <span class="main">∘</span> cl_op <span class="main">=</span> cl_op"</span></span>
  <span class="keyword1"><span class="command">using</span></span> clop_ext clop_wtrans order.antisym <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Closure_Operators-clop_idem_var"><span class="command">lemma</span></span> clop_idem_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cl_op <span class="main">(</span>cl_op <span class="free">x</span><span class="main">)</span> <span class="main">=</span> cl_op <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antisym clop_ext clop_wtrans<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-clop_range_Fix"><span class="command">lemma</span></span> clop_range_Fix<span class="main">:</span> <span class="quoted"><span class="quoted">"range cl_op <span class="main">=</span> Fix cl_op"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> retraction_prop_fix<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-Inf_closed_cl_op_var"><span class="command">lemma</span></span> Inf_closed_cl_op_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> range cl_op <span class="main">⟹</span> <span class="main">⨅</span><span class="free">X</span> <span class="main">∈</span> range cl_op"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> range cl_op"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> cl_op <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> retraction_prop<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"cl_op <span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨅</span><span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Inf_lower clop_ext clop_iso dual_order.antisym le_Inf_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rangeI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Closure_Operators-inf_closed_cl_op_var"><span class="command">lemma</span></span> inf_closed_cl_op_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> range cl_op <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> range cl_op <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">∈</span> range cl_op"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf_closed_cl_op_var UnI1 insert_iff insert_is_Un inf_Inf<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span><span class="main">::</span><span class="quoted">clattice_with_clop</span> cl_op_im <span class="main">=</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span>cl_op<span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_cl_op_im

<span class="keyword1" id="Closure_Operators-cl_op_prop"><span class="command">lemma</span></span> cl_op_prop <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cl_op <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> cl_op <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>cl_op <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>clattice_with_clop<span class="main">)</span> <span class="main">≤</span> cl_op <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cl_op_class.clop_iso clop_ext clop_wtrans inf_sup_ord<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> le_iff_sup sup.absorb_iff1 sup_left_commute<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-cl_op_prop_var"><span class="command">lemma</span></span> cl_op_prop_var <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cl_op <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> cl_op <span class="free">y</span><span class="main">)</span> <span class="main">=</span> cl_op <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>cl_op <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>clattice_with_clop<span class="main">)</span> <span class="main">≤</span> cl_op <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cl_op_prop clattice_with_clop_class.clop_idem_var<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> cl_op_im <span class="main">::</span> <span class="main">(</span><span class="quoted">clattice_with_clop</span><span class="main">)</span> <span class="quoted">complete_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Inf_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im set <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">Inf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_closed_cl_op_var<span class="main">)</span>
 
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">Sup_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im set <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">X</span><span class="main">.</span> cl_op <span class="main">(</span><span class="main">⨆</span><span class="bound">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">inf_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">inf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_closed_cl_op_var<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">sup_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> cl_op <span class="main">(</span><span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> <span class="tfree">'a</span> cl_op_im <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bot_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"cl_op <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">top_cl_op_im</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cl_op_im"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> clop_cl_op clop_closure clop_top<span class="main">)</span>


<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
                 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le Inf_lower Inf_greatest<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> clop_cl_op clop_extensive_var dual_order.trans inf_sup_ord<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> clop_cl_op clop_extensive_var dual_order.trans sup_ge2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> cl_op_class.clop_iso clop_cl_op clop_closure le_sup_iff<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Sup_upper clop_cl_op clop_extensive_var dual_order.trans<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Sup_le_iff cl_op_class.clop_iso clop_cl_op clop_closure<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This statement is perhaps less useful as it might seem, because it is difficult to make it cooperate with concrete closure operators, 
which one would not generally like to define within a type class. Alternatively, a sublocale statement could perhaps be given. It would also 
have been nice to prove this statement for Sup-lattices---this would have cut down the number of proof obligations significantly.
But this would require a tighter integration of these structures. A similar statement could have been proved for co-closure operators. But this would
not lead to new insights.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next I show that for every surjective Sup-preserving function between complete lattices there is a closure operator 
such that the set of closed elements is isomorphic to the range of the surjection.›</span></span>

<span class="keyword1" id="Closure_Operators-surj_Sup_pres_id"><span class="command">lemma</span></span> surj_Sup_pres_id<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> <span class="main">(</span>radj <span class="free">f</span><span class="main">)</span> <span class="main">=</span> id"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">⊣</span> <span class="main">(</span>radj <span class="free">f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Sup_pres_ladj assms<span class="main">(</span>2<span class="main">)</span> radj_adj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> adj_sur_inv assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Closure_Operators-surj_Sup_pres_inj"><span class="command">lemma</span></span> surj_Sup_pres_inj<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span>radj <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms comp_eq_dest_lhs id_apply injI surj_Sup_pres_id<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-surj_Sup_pres_inj_on"><span class="command">lemma</span></span> surj_Sup_pres_inj_on<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span>range <span class="main">(</span>radj <span class="free">f</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Sup_pres_ladj_aux adj_idem2 assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> comp_apply inj_on_def retraction_prop<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-surj_Sup_pres_bij_on"><span class="command">lemma</span></span> surj_Sup_pres_bij_on<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bij_betw <span class="free">f</span> <span class="main">(</span>range <span class="main">(</span>radj <span class="free">f</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bij_betw_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> surj_Sup_pres_inj_on <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> image_cong_simp<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">)</span></span> UNIV_I assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> comp_apply id_apply image_image surj_Sup_pres_id surj_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Thus the restriction of $f$ to the set of closed elements is indeed a bijection. The final fact
shows that it preserves Sups of closed elements, and hence is an isomorphism of complete lattices.›</span></span>

<span class="keyword1" id="Closure_Operators-surj_Sup_pres_iso"><span class="command">lemma</span></span> surj_Sup_pres_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice_with_dual <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice_with_dual"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"surj <span class="free">f</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">(</span><span class="main">(</span>radj <span class="free">f</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> comp_def pointfree_idE surj_Sup_pres_id<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Quick Example: Dedekind-MacNeille Completions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹I only outline the basic construction. Additional facts about join density, and that the completion yields 
the least complete lattice that contains all Sups and Infs of the underlying posets, are left for future consideration.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">dm</span> <span class="main">≡</span> lb_set <span class="main">∘</span> ub_set"</span></span>

<span class="keyword1" id="Closure_Operators-up_set_prop"><span class="command">lemma</span></span> up_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder set<span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> ub_set <span class="free">X</span> <span class="main">=</span> <span class="main">⋂</span><span class="main">{</span><span class="main">↑</span><span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ub_set_def upset_def upset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1" id="Closure_Operators-lb_set_prop"><span class="command">lemma</span></span> lb_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder set<span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> lb_set <span class="free">X</span> <span class="main">=</span> <span class="main">⋂</span><span class="main">{</span><span class="main">↓</span><span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lb_set_def downset_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1" id="Closure_Operators-dm_downset_var"><span class="command">lemma</span></span> dm_downset_var<span class="main">:</span> <span class="quoted"><span class="quoted">"dm <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">↓</span><span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lb_set_def ub_set_def downset_def downset_set_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">meson</span> order_refl order_trans<span class="main">)</span>

<span class="keyword1" id="Closure_Operators-dm_downset"><span class="command">lemma</span></span> dm_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"dm <span class="main">∘</span> η <span class="main">=</span> <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>preorder <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dm_downset_var fun.map_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Closure_Operators-dm_inj"><span class="command">lemma</span></span> dm_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">(</span><span class="main">(</span>dm<span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order set <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span> <span class="main">∘</span> η<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dm_downset downset_inj<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"clop <span class="main">(</span>lb_set <span class="main">∘</span> ub_set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> clop_def lb_set_def ub_set_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command">unfolding</span></span> le_fun_def comp_def id_def mono_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Order_Lattice_Props_Loc">
<div class="head">
<h1>Theory Order_Lattice_Props_Loc</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Locale-Based Duality
  Author: Georg Struth 
  Maintainer:Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Locale-Based Duality›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Lattice_Props_Loc
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> 
          <span class="quoted">"<a href="../../HOL/HOL-Library/Lattice_Syntax.html">HOL-Library.Lattice_Syntax</a>"</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This section explores order and lattice duality based on locales. Used within the context of a class or locale, 
this is very effective, though more opaque than the previous approach. Outside of such a context, however, it apparently
cannot be used for dualising theorems. Examples are properties of  functions between orderings or lattices.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Fix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">Fix</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">min_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">max_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">max_set</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">x</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">directed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">directed</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filtered</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">filtered</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇓</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇓</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇑</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">↓</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">↓</span></span> <span class="main">=</span> <span class="main">⇓</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">↑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">↑</span></span> <span class="main">=</span> <span class="main">⇑</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>  
  <span class="quoted"><span class="quoted">"<span class="free">downsets</span> <span class="main">=</span> Fix <span class="main">⇓</span>"</span></span>
 
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upsets</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">upsets</span> <span class="main">=</span> Fix <span class="main">⇑</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">downset_setp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> downsets"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">upset_setp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> upsets"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ideals</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ideals</span> <span class="main">=</span> <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> downset_setp <span class="bound">X</span> <span class="main">∧</span> directed <span class="bound">X</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filters</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>  set set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filters</span> <span class="main">=</span> <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> upset_setp <span class="bound">X</span> <span class="main">∧</span> filtered <span class="bound">X</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">idealp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> ideals"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">filterp</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> filters"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Sup_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Sup_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Sup <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Inf_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Inf_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Inf <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sup_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sup_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inf_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">inf_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bot_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>bot <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>bot<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bot_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">top_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>top <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>top<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">top_pres</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Sup_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Sup_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Sup <span class="main">=</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Inf_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>Inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>Sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Inf_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> Inf <span class="main">=</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sup_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>sup <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>inf<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sup_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inf_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>inf <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>sup<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">inf_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bot_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>bot <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>top<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
 <span class="quoted"><span class="quoted">"<span class="free">bot_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">top_dual</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>top <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>bot<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">top_dual</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Duality via Locales›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ord <span class="main">⊆</span> dual_ord<span class="main">:</span> ord <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> dual_max_set<span class="main">:</span> <span class="quoted"><span class="quoted">"max_set <span class="main">=</span> dual_ord.min_set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dual_filtered<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">=</span> dual_ord.directed"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dual_upset_set<span class="main">:</span> <span class="quoted"><span class="quoted">"upset_set <span class="main">=</span> dual_ord.downset_set"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dual_upset<span class="main">:</span> <span class="quoted"><span class="quoted">"upset <span class="main">=</span> dual_ord.downset"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dual_upsets<span class="main">:</span> <span class="quoted"><span class="quoted">"upsets <span class="main">=</span> dual_ord.downsets"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> dual_filters<span class="main">:</span> <span class="quoted"><span class="quoted">"filters <span class="main">=</span> dual_ord.ideals"</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">unfolding</span></span> max_set_def ord.min_set_def fun_eq_iff <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">unfolding</span></span> filtered_def ord.directed_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> upset_set_def ord.downset_set_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ord.downset_def ord.downset_set_def ord.upset_def ord.upset_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> upsets_def ord.downsets_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> ord.downset_set_def upset_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> filters_def ord.ideals_def Fix_def ord.downsets_def upsets_def ord.downset_set_def upset_set_def ord.directed_def filtered_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">sublocale</span></span> preorder <span class="main">⊆</span> dual_preorder<span class="main">:</span> preorder <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">using</span></span> order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">sublocale</span></span> order <span class="main">⊆</span> dual_order<span class="main">:</span> order <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> lattice <span class="main">⊆</span> dual_lattice<span class="main">:</span> lattice <span class="quoted">sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span> <span class="quoted">inf</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> bounded_lattice <span class="main">⊆</span> dual_bounded_lattice<span class="main">:</span> bounded_lattice <span class="quoted">sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span> <span class="quoted">inf</span> <span class="quoted"><span class="main">⊤</span></span> <span class="quoted"><span class="main">⊥</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> boolean_algebra <span class="main">⊆</span> dual_boolean_algebra<span class="main">:</span> boolean_algebra <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊔</span> <span class="main">-</span><span class="bound">y</span>"</span></span> <span class="quoted">uminus</span> <span class="quoted">sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span> <span class="quoted">inf</span> <span class="quoted"><span class="main">⊤</span></span> <span class="quoted"><span class="main">⊥</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inf_sup_distrib1<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> complete_lattice <span class="main">⊆</span> dual_complete_lattice<span class="main">:</span> complete_lattice <span class="quoted">Sup</span> <span class="quoted">Inf</span> <span class="quoted">sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span> <span class="quoted">inf</span> <span class="quoted"><span class="main">⊤</span></span> <span class="quoted"><span class="main">⊥</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> dual_gfp<span class="main">:</span> <span class="quoted"><span class="quoted">"gfp <span class="main">=</span> dual_complete_lattice.lfp"</span></span>  
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"class.complete_lattice Sup Inf sup <span class="main">(≥)</span> <span class="main">(&gt;)</span> inf <span class="main">⊤</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper Sup_least Inf_lower Inf_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> dual_complete_lattice<span class="main">:</span> complete_lattice <span class="quoted">Sup</span> <span class="quoted">Inf</span> <span class="quoted">sup</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&gt;)</span>"</span></span> <span class="quoted">inf</span> <span class="quoted"><span class="main">⊤</span></span> <span class="quoted"><span class="main">⊥</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"gfp <span class="main">=</span> dual_complete_lattice.lfp"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> gfp_def dual_complete_lattice.lfp_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_min_set"><span class="command">lemma</span></span> dual_min_set<span class="main">:</span> <span class="quoted"><span class="quoted">"min_set <span class="main">=</span> dual_ord.max_set"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.dual_max_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_directed"><span class="command">lemma</span></span> dual_directed<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">=</span> dual_ord.filtered"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>dual_ord.dual_filtered<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_downset"><span class="command">lemma</span></span> dual_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"downset <span class="main">=</span> dual_ord.upset"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_downset_set"><span class="command">lemma</span></span> dual_downset_set<span class="main">:</span> <span class="quoted"><span class="quoted">"downset_set <span class="main">=</span> dual_ord.upset_set"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_downsets"><span class="command">lemma</span></span> dual_downsets<span class="main">:</span> <span class="quoted"><span class="quoted">"downsets <span class="main">=</span> dual_ord.upsets"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.dual_upsets<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_ideals"><span class="command">lemma</span></span> dual_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"ideals <span class="main">=</span> dual_ord.filters"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.dual_filters<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-dual_lfp"><span class="command">lemma</span></span> dual_lfp<span class="main">:</span> <span class="quoted"><span class="quoted">"lfp <span class="main">=</span> dual_complete_lattice.gfp"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_complete_lattice.dual_gfp<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of Orderings, Again›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-directed_nonempty"><span class="command">lemma</span></span> directed_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> directed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-directed_ub"><span class="command">lemma</span></span> directed_ub<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> empty_subsetI directed_def finite.emptyI finite_insert insert_subset order_refl<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_set_prop"><span class="command">lemma</span></span> downset_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span> <span class="main">=</span> Union <span class="main">∘</span> <span class="main">(`)</span> <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_set_def downset_def fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_set_prop_var"><span class="command">lemma</span></span> downset_set_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span><span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_set_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_prop"><span class="command">lemma</span></span> downset_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↓</span><span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_def downset_set_def fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> preorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-directed_prop"><span class="command">lemma</span></span> directed_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟹</span> directed <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Y</span> <span class="main">⟹</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> empty
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> h1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">F</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> h2 insert_iff insert_subset order_trans<span class="main">)</span> 
  <span class="keyword1"><span class="command">qed</span></span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> directed_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-directed_alt"><span class="command">lemma</span></span> directed_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> directed_prop directed_nonempty directed_ub<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_set_ext"><span class="command">lemma</span></span> downset_set_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> le_fun_def id_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_set_iso"><span class="command">lemma</span></span> downset_set_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_set_idem"><span class="command">lemma</span></span> downset_set_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇓</span> <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> <span class="main">⇓</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff downset_set_def comp_def <span class="keyword1"><span class="command">using</span></span> order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_faithful"><span class="command">lemma</span></span> downset_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↓</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↓</span><span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_prop subset_eq<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_iso_iff"><span class="command">lemma</span></span> downset_iso_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">↓</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↓</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> atMost_iff downset_prop order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_directed_downset_var"><span class="command">lemma</span></span> downset_directed_downset_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> directed <span class="free">X</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Y</span>
  <span class="keyword3"><span class="command">assume</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">Y</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> h3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">Y</span> <span class="main">⊆</span> <span class="main">⇓</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span>  <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> downset_set_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span> <span class="main">⟶</span>  <span class="bound">f</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">f</span> <span class="bound">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> choice<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">f</span><span class="main">.</span> finite <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> <span class="skolem">Y</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">f</span> <span class="main">`</span> <span class="skolem">Y</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_imageI h2 image_subsetI<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Z</span><span class="main">.</span> finite <span class="bound">Z</span> <span class="main">∧</span> <span class="bound">Z</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">Z</span><span class="main">.</span> finite <span class="bound">Z</span> <span class="main">∧</span> <span class="bound">Z</span> <span class="main">⊆</span> <span class="free">X</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">z</span> <span class="main">∈</span> <span class="bound">Z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> directed_def h1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="skolem">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> order_trans<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> directed_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"directed <span class="free">X</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> directed_def downset_set_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Ball_Collect order_refl order_trans subsetCE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_directed_downset"><span class="command">lemma</span></span> downset_directed_downset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> directed"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-directed_downset_ideals"><span class="command">lemma</span></span> directed_downset_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">(</span><span class="main">⇓</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇓</span><span class="free">X</span> <span class="main">∈</span> ideals<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Fix_def comp_apply directed_alt downset_set_idem downsets_def ideals_def mem_Collect_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_iso"><span class="command">lemma</span></span> downset_iso<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_iso_iff mono_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> order
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_inj"><span class="command">lemma</span></span> downset_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">↓</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> injI downset_iso_iff eq_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-lat_ideals"><span class="command">lemma</span></span> lat_ideals<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> downsets <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊔</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ideals_def directed_alt downsets_def Fix_def downset_set_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">smt</span> sup.cobounded1 sup.orderE sup.orderI sup_absorb2 sup_left_commute mem_Collect_eq<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> bounded_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-bot_ideal"><span class="command">lemma</span></span> bot_ideal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> ideals <span class="main">⟹</span> <span class="main">⊥</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ideals_def downsets_def Fix_def downset_set_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_downset_id"><span class="command">lemma</span></span> Sup_downset_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">↓</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_atMost atMost_def downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-downset_Sup_id"><span class="command">lemma</span></span> downset_Sup_id<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">↓</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper downset_prop le_funI subsetI<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_Sup_var"><span class="command">lemma</span></span> Inf_Sup_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨅</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collect_ball_eq Inf_eq_Sup<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_pres_downset_var"><span class="command">lemma</span></span> Inf_pres_downset_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↓</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">↓</span><span class="main">(</span><span class="main">⨅</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Inf_iff<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-lfp_in_Fix"><span class="command">lemma</span></span> lfp_in_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> lfp <span class="free">f</span> <span class="main">∈</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Fix_def lfp_unfold <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-gfp_in_Fix"><span class="command">lemma</span></span> gfp_in_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> gfp <span class="free">f</span> <span class="main">∈</span> Fix <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Fix_def gfp_unfold <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-nonempty_Fix"><span class="command">lemma</span></span> nonempty_Fix<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> Fix <span class="free">f</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lfp_in_Fix <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Dual Properties of Orderings from Locales›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹These properties can be proved very smoothly overall. But only within the context of a class
or locale!›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-filtered_nonempty"><span class="command">lemma</span></span> filtered_nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filtered dual_ord.directed_nonempty<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-filtered_lb"><span class="command">lemma</span></span> filtered_lb<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filtered dual_ord.directed_ub<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_set_prop"><span class="command">lemma</span></span> upset_set_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="main">=</span> Union <span class="main">∘</span> <span class="main">(`)</span> <span class="main">↑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.downset_set_prop dual_upset dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_set_prop_var"><span class="command">lemma</span></span> upset_set_prop_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span><span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.downset_set_prop_var dual_upset dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_prop"><span class="command">lemma</span></span> upset_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_ord.downset_prop dual_upset<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> preorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-filtered_prop"><span class="command">lemma</span></span> filtered_prop<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> filtered <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filtered dual_preorder.directed_prop<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-filtered_alt"><span class="command">lemma</span></span> filtered_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="free">X</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">z</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filtered dual_preorder.directed_alt<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_set_ext"><span class="command">lemma</span></span> upset_set_ext<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_preorder.downset_set_ext dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_set_anti"><span class="command">lemma</span></span> upset_set_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_preorder.downset_set_iso dual_upset_set<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props_Loc-up_set_idem"><span class="command">lemma</span></span> up_set_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⇑</span> <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> <span class="main">⇑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_faithful"><span class="command">lemma</span></span> upset_faithful<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">↑</span><span class="free">x</span> <span class="main">⊆</span> <span class="main">↑</span><span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_preorder.downset_faithful dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_anti_iff"><span class="command">lemma</span></span> upset_anti_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">↑</span><span class="free">y</span> <span class="main">⊆</span> <span class="main">↑</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_preorder.downset_iso_iff dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_filtered_upset"><span class="command">lemma</span></span> upset_filtered_upset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> filtered"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filtered dual_upset_set<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-filtered_upset_filters"><span class="command">lemma</span></span> filtered_upset_filters<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">(</span><span class="main">⇑</span><span class="free">X</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇑</span><span class="free">X</span> <span class="main">∈</span> filters<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dual_filtered dual_preorder.directed_downset_ideals dual_upset_set ord.dual_filters <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> order
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_inj"><span class="command">lemma</span></span> upset_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">↑</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_order.downset_inj dual_upset<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-lat_filters"><span class="command">lemma</span></span> lat_filters<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> upsets <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∀</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊓</span> <span class="bound">y</span> <span class="main">∈</span> <span class="free">X</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_filters dual_lattice.lat_ideals dual_ord.downsets_def dual_upset_set upsets_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> bounded_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-top_filter"><span class="command">lemma</span></span> top_filter<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> filters <span class="main">⟹</span> <span class="main">⊤</span> <span class="main">∈</span> <span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_bounded_lattice.bot_ideal dual_filters<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_upset_id"><span class="command">lemma</span></span> Inf_upset_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Inf <span class="main">∘</span> <span class="main">↑</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_Inf_id"><span class="command">lemma</span></span> upset_Inf_id<span class="main">:</span> <span class="quoted"><span class="quoted">"id <span class="main">≤</span> <span class="main">↑</span> <span class="main">∘</span> Inf"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_complete_lattice.downset_Sup_id dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_Inf_var"><span class="command">lemma</span></span> Sup_Inf_var<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="main">⨅</span><span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">⨆</span><span class="free">X</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_complete_lattice.Inf_Sup_var dual_upset<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_dual_upset_var"><span class="command">lemma</span></span> Sup_dual_upset_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋂</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">↑</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">↑</span><span class="main">(</span><span class="main">⨆</span><span class="free">X</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_complete_lattice.Inf_pres_downset_var dual_upset<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples that Do Not Dualise›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-upset_anti"><span class="command">lemma</span></span> upset_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"antimono <span class="main">(</span><span class="main">↑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> antimono_def upset_anti_iff<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fSup_unfold"><span class="command">lemma</span></span> fSup_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">0</span> <span class="main">⊔</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> antisym sup_least<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sup_upper<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sup_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Sup_least<span class="main">)</span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_upper le_supI2<span class="main">)</span>


<span class="keyword1" id="Order_Lattice_Props_Loc-fInf_unfold"><span class="command">lemma</span></span> fInf_unfold<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span><span class="main">::</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">0</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> antisym inf_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Inf_greatest<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">using</span></span> Inf_lower inf.coboundedI2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_lower<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> Inf_mono<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fun_isol"><span class="command">lemma</span></span> fun_isol<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fun_isor"><span class="command">lemma</span></span> fun_isor<span class="main">:</span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_fun_def mono_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_sup_pres"><span class="command">lemma</span></span> Sup_sup_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> sup_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Sup_empty Sup_insert comp_apply image_insert sup_bot.right_neutral<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_inf_pres"><span class="command">lemma</span></span> Inf_inf_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span><span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> inf_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_insert comp_eq_elim dual_complete_lattice.Sup_empty dual_complete_lattice.Sup_insert inf_top.right_neutral<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_bot_pres"><span class="command">lemma</span></span> Sup_bot_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup_pres <span class="free">f</span> <span class="main">⟹</span> bot_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> SUP_empty Sup_empty comp_eq_elim<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_top_pres"><span class="command">lemma</span></span> Inf_top_pres<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Inf_pres <span class="free">f</span> <span class="main">⟹</span> top_pres <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> INF_empty comp_eq_elim dual_complete_lattice.Sup_empty<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> complete_lattice
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-iso_Inf_subdistl"><span class="command">lemma</span></span> iso_Inf_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms complete_lattice_class.le_Inf_iff le_funI Inf_lower monoD<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-iso_Sup_supdistl"><span class="command">lemma</span></span> iso_Sup_supdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms complete_lattice_class.SUP_le_iff le_funI dual_complete_lattice.Inf_lower monoD<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_subdistl_iso"><span class="command">lemma</span></span> Inf_subdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def le_fun_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> complete_lattice_class.le_INF_iff Inf_atLeast atLeast_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_supdistl_iso"><span class="command">lemma</span></span> Sup_supdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup <span class="main">⟹</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mono_def le_fun_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> complete_lattice_class.SUP_le_iff Sup_atMost atMost_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-supdistl_iso"><span class="command">lemma</span></span> supdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> Sup<span class="main">)</span> <span class="main">=</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Sup_supdistl_iso iso_Sup_supdistl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-subdistl_iso"><span class="command">lemma</span></span> subdistl_iso<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> mono <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Inf_subdistl_iso iso_Inf_subdistl <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fSup_distr"><span class="command">lemma</span></span> fSup_distr<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_pres <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf.INF_cong SUP_apply Sup_apply<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fSup_distr_var"><span class="command">lemma</span></span> fSup_distr_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨆</span><span class="free">F</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">F</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Inf.INF_cong SUP_apply Sup_apply<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fInf_distr"><span class="command">lemma</span></span> fInf_distr<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_apply Inf.INF_cong Inf_apply<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fInf_distr_var"><span class="command">lemma</span></span> fInf_distr_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⨅</span><span class="free">F</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">=</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">f</span> <span class="main">∈</span> <span class="free">F</span><span class="main">.</span> <span class="bound">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> INF_apply Inf.INF_cong Inf_apply<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fSup_subdistl"><span class="command">lemma</span></span> fSup_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"mono <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(∘)</span> <span class="free">f</span> <span class="main">∘</span> Sup"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_least Sup_upper le_fun_def monoD image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fSup_subdistl_var"><span class="command">lemma</span></span> fSup_subdistl_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span> <span class="main">≤</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨆</span><span class="free">G</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> SUP_least Sup_upper le_fun_def monoD image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fInf_subdistl"><span class="command">lemma</span></span> fInf_subdistl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="main">(∘)</span> <span class="free">f</span> <span class="main">∘</span> Inf <span class="main">≤</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">(</span><span class="main">(∘)</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INF_greatest Inf_lower le_fun_def monoD image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-fInf_subdistl_var"><span class="command">lemma</span></span> fInf_subdistl_var<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">::</span>complete_lattice"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">⨅</span><span class="free">G</span> <span class="main">≤</span> <span class="main">(</span><span class="main">⨅</span><span class="bound">g</span> <span class="main">∈</span> <span class="free">G</span><span class="main">.</span> <span class="free">f</span> <span class="main">∘</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INF_greatest Inf_lower le_fun_def monoD image_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Loc-Inf_pres_downset"><span class="command">lemma</span></span> Inf_pres_downset<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf_pres <span class="main">(</span><span class="main">↓</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_prop fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Inf_iff<span class="main">)</span>
 
<span class="keyword1" id="Order_Lattice_Props_Loc-Sup_dual_upset"><span class="command">lemma</span></span> Sup_dual_upset<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup_dual <span class="main">(</span><span class="main">↑</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>complete_lattice <span class="main">⇒</span> <span class="tfree">'a</span> set<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> upset_prop fun_eq_iff comp_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This approach could probably be combined with the explicit functor-based one. This may be good for proofs, but seems conceptually rather ugly.›</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Order_Lattice_Props_Wenzel">
<div class="head">
<h1>Theory Order_Lattice_Props_Wenzel</h1>
</div>
<pre class="source"><span class="comment1">(* 
  Title: Duality Based on a Data Type
  Author: Georg Struth 
  Maintainer:Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Duality Based on a Data Type›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Lattice_Props_Wenzel
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> 
          <span class="quoted">"<a href="../../HOL/HOL-Library/Lattice_Syntax.html">HOL-Library.Lattice_Syntax</a>"</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Wenzel's Approach Revisited›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This approach is similar to, but inferior to the explicit class-based one. The main caveat is that duality is not involutive 
with this approach, and this allows dualising less theorems.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹I copy Wenzel's development \cite{Wenzel} in this subsection and extend it with additional properties. I show only the most important properties.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> dual <span class="main">=</span> dual <span class="main">(</span><span class="free"><span class="entity">un_dual</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1"><span class="keyword1">∂</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">notation</span></span> un_dual <span class="main">(</span><span class="quoted">"<span class="keyword1">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span><span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inj"><span class="command">lemma</span></span> dual_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> injI <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_surj"><span class="command">lemma</span></span> dual_surj<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dual.exhaust_sel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_bij"><span class="command">lemma</span></span> dual_bij<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bijI dual_inj dual_surj<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Dual is not idempotent, and I see no way of imposing this condition. Yet at least an inverse exists --- namely un-dual..›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv1"><span class="command">lemma</span></span> dual_inv1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv2"><span class="command">lemma</span></span> dual_inv2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂</span> <span class="main">∘</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_inj"><span class="command">lemma</span></span> dual_inv_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual.expand injI<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_surj"><span class="command">lemma</span></span> dual_inv_surj<span class="main">:</span> <span class="quoted"><span class="quoted">"surj <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.sel surj_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_bij"><span class="command">lemma</span></span> dual_inv_bij<span class="main">:</span> <span class="quoted"><span class="quoted">"bij <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bij_def dual_inv_inj dual_inv_surj<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_iff"><span class="command">lemma</span></span> dual_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Isabelle data types come with a number of generic functions.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The functor map-dual lifts functions to dual types. Isabelle's generic definition is not straightforward to 
understand and use. Yet conceptually it can be explained as follows.›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_def_var"><span class="command">lemma</span></span> map_dual_def_var <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>map_dual<span class="main">::</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> dual <span class="main">⇒</span> <span class="tfree">'b</span> dual<span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.map_sel dual_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_def_var2"><span class="command">lemma</span></span> map_dual_def_var2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">∘</span> map_dual <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rewriteL_comp_comp<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_func1"><span class="command">lemma</span></span> map_dual_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_dual <span class="free">f</span> <span class="main">∘</span> map_dual <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.exhaust dual.map<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_func2"><span class="command">lemma</span></span> map_dual_func2 <span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The functor map-dual has an inverse functor as well.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_dual_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> dual <span class="main">⇒</span> <span class="tfree">'b</span> dual<span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_dual_inv</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> <span class="main">∂</span>"</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_inv_func1"><span class="command">lemma</span></span> map_dual_inv_func1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual_inv id <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_dual_inv_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_inv_func2"><span class="command">lemma</span></span> map_dual_inv_func2<span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual_inv <span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> map_dual_inv <span class="free">f</span> <span class="main">∘</span> map_dual_inv <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def map_dual_inv_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_iff<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_inv1"><span class="command">lemma</span></span> map_dual_inv1<span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual <span class="main">∘</span> map_dual_inv <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff map_dual_def_var map_dual_inv_def comp_def id_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_iff<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props_Wenzel-map_dual_inv2"><span class="command">lemma</span></span> map_dual_inv2<span class="main">:</span> <span class="quoted"><span class="quoted">"map_dual_inv <span class="main">∘</span> map_dual <span class="main">=</span> id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff map_dual_def_var map_dual_inv_def comp_def id_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_iff<span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Hence dual is an isomorphism between categories.›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-subset_dual"><span class="command">lemma</span></span> subset_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">=</span> <span class="free">Y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">X</span> <span class="main">=</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_inj image_comp image_inv_f_f inv_o_cancel dual_inv2<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-subset_dual1"><span class="command">lemma</span></span> subset_dual1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">⊆</span> <span class="free">Y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∂</span> <span class="main">`</span> <span class="free">X</span> <span class="main">⊆</span> <span class="main">∂</span> <span class="main">`</span> <span class="free">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_inj inj_image_subset_iff<span class="main">)</span> 

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_ball"><span class="command">lemma</span></span> dual_ball<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="main">∂</span> <span class="main">`</span> <span class="free">X</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_ball"><span class="command">lemma</span></span> dual_inv_ball<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="free">X</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_all"><span class="command">lemma</span></span> dual_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.collapse<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_all"><span class="command">lemma</span></span> dual_inv_all<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_inv_surj surj_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_ex"><span class="command">lemma</span></span> dual_ex<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UNIV_I bex_imageD dual_surj<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_ex"><span class="command">lemma</span></span> dual_inv_ex<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.sel<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_Collect"><span class="command">lemma</span></span> dual_Collect<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">∂</span> <span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.exhaust<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_inv_Collect"><span class="command">lemma</span></span> dual_inv_Collect<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual.collapse dual.inject<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-fun_dual1"><span class="command">lemma</span></span> fun_dual1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-fun_dual2"><span class="command">lemma</span></span> fun_dual2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">∘</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-fun_dual3"><span class="command">lemma</span></span> fun_dual3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> subset_dual<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-fun_dual4"><span class="command">lemma</span></span> fun_dual4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">=</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∂</span> <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">=</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fun_dual2 fun_dual3 o_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next facts show incrementally that the dual of a complete lattice is a complete lattice.
This follows once again Wenzel.›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> dual <span class="main">::</span> <span class="main">(</span><span class="quoted">ord</span><span class="main">)</span> <span class="quoted">ord</span>
<span class="keyword2"><span class="keyword">begin</span></span>  

<span class="keyword1"><span class="command">definition</span></span> less_eq_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span> <span class="main">=</span> rel_dual <span class="main">(≥)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> less_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span> <span class="main">=</span> rel_dual <span class="main">(&gt;)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span><span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-less_eq_dual_def_var"><span class="command">lemma</span></span> less_eq_dual_def_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free">y</span> <span class="main">≤</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual.rel_sel less_eq_dual_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual.rel_sel less_eq_dual_def<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-less_dual_def_var"><span class="command">lemma</span></span> less_dual_def_var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free">y</span> <span class="main">&lt;</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual.rel_sel less_dual_def<span class="main">)</span> 

<span class="keyword1"><span class="command">instance</span></span> dual <span class="main">::</span> <span class="main">(</span><span class="quoted">preorder</span><span class="main">)</span> <span class="quoted">preorder</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_dual_def_var less_eq_dual_def_var less_le_not_le<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_eq_dual_def_var<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> less_eq_dual_def_var order_trans<span class="main">)</span>
 
<span class="keyword1"><span class="command">instance</span></span> dual <span class="main">::</span> <span class="main">(</span><span class="quoted">order</span><span class="main">)</span> <span class="quoted">order</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual.expand less_eq_dual_def_var<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_anti"><span class="command">lemma</span></span> dual_anti<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">∂</span> <span class="free">y</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_inj less_eq_dual_def the_inv_f_f<span class="main">)</span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-dual_anti_iff"><span class="command">lemma</span></span> dual_anti_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">≤</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∂</span> <span class="free">y</span> <span class="main">≤</span> <span class="main">∂</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_inj less_eq_dual_def the_inv_f_f<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹map-dual does not map isotone functions to antitone ones. It simply lifts the type!›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"mono <span class="free">f</span> <span class="main">⟹</span> mono <span class="main">(</span>map_dual <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_dual_def_var mono_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> comp_apply dual_anti less_eq_dual_def_var<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> dual <span class="main">::</span> <span class="main">(</span><span class="quoted">lattice</span><span class="main">)</span> <span class="quoted">lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> inf_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊔</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> sup_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">∂</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊓</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dual_inj inf_dual_def sup_dual_def less_eq_dual_def_var the_inv_f_f<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> dual <span class="main">::</span> <span class="main">(</span><span class="quoted">complete_lattice</span><span class="main">)</span> <span class="quoted">complete_lattice</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> Inf_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"Inf <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> Sup <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> Sup_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"Sup <span class="main">=</span> <span class="main">∂</span> <span class="main">∘</span> Inf <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> bot_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">⊤</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> top_dual_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊤</span> <span class="main">=</span> <span class="main">∂</span> <span class="main">⊥</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span>
   <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Inf_dual_def top_dual_def Sup_dual_def bot_dual_def dual_inj le_INF_iff SUP_le_iff INF_lower SUP_upper less_eq_dual_def_var the_inv_f_f<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, directed and filtered sets, upsets, downsets, filters and ideals in posets are defined.›</span></span>

<span class="keyword1"><span class="command">context</span></span> ord
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">directed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">directed</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filtered</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">filtered</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">downset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇓</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇓</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">upset_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇑</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="main"><span class="free">⇑</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Examples that Do Not Dualise›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Filtered and directed sets are dual.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Proofs could be simplified if dual was idempotent.›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-filtered_directed_dual"><span class="command">lemma</span></span> filtered_directed_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"filtered <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> directed"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>filtered <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="skolem">X</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span><span class="main">)</span><span class="main">.</span> <span class="main">∂</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">∂</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> filtered_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> dual_iff finite_subset_image subset_dual subset_dual1<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="skolem">X</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_anti_iff dual_inv_surj finite_subset_image top.extremum<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>filtered <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> directed <span class="skolem">X</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> directed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-directed_filtered_dual"><span class="command">lemma</span></span> directed_filtered_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"directed <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span> <span class="main">=</span> filtered"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>directed <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="skolem">X</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="main">(</span><span class="main">∂<span class="hidden">⇧</span><sup>-</sup></span> <span class="main">`</span> <span class="bound">Y</span><span class="main">)</span><span class="main">.</span> <span class="main">∂</span> <span class="bound">y</span> <span class="main">≤</span> <span class="main">∂</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> directed_def comp_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">metis</span> dual_iff finite_subset_image subset_dual subset_dual1<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">Y</span><span class="main">.</span> finite <span class="bound">Y</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">⊆</span> <span class="skolem">X</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span><span class="main">∀</span><span class="bound">y</span> <span class="main">∈</span> <span class="bound">Y</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dual_anti_iff<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_inv_surj finite_subset_image top_greatest<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>directed <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> filtered <span class="skolem">X</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> filtered_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This example illustrates the deficiency of the approach. In the class-based approach the second proof is trivial.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next example shows that this is a systematic problem.›</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-downset_set_upset_set_dual"><span class="command">lemma</span></span> downset_set_upset_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇓</span> <span class="main">=</span> <span class="main">⇑</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span> <span class="skolem">X</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇓</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> <span class="main">{</span><span class="main">∂</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> downset_set_def setcompr_eq_image<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="main">∂</span> <span class="bound">y</span> <span class="main">|</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="main">∂</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">∂</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_anti_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="main">∈</span> <span class="main">∂</span> <span class="main">`</span> <span class="skolem">X</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> dual.exhaust image_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇓</span><span class="main">)</span> <span class="skolem">X</span> <span class="main">=</span> <span class="main">(</span><span class="main">⇑</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span><span class="main">)</span> <span class="skolem">X</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> upset_set_def<span class="main">)</span><span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fun_eq_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Order_Lattice_Props_Wenzel-upset_set_downset_set_dual"><span class="command">lemma</span></span> upset_set_downset_set_dual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(`)</span> <span class="main">∂</span> <span class="main">∘</span> <span class="main">⇑</span> <span class="main">=</span> <span class="main">⇓</span> <span class="main">∘</span> <span class="main">(`)</span> <span class="main">∂</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> downset_set_def upset_set_def fun_eq_iff comp_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dual_anti<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> dual.exhaust dual_anti_iff mem_Collect_eq rev_image_eqI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>









</pre>
</div>