<div id="Multiset">
<div class="head"><h1>Theory Multiset</h1>
<span class="command">theory</span> <span class="name">Multiset</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multiset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{Multiset} contains a minimal multiset structure.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Multiset</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A minimal multiset theory›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Völzer, p. 84, does specify that messages in transit are modelled using
  multisets.
  
  We decided to implement a tiny structure for multisets, just fitting our needs.
  These multisets allow to add new values to them, to check for elements existing
  in a certain multiset, filter elements according to boolean predicates, remove
  elements and to create a new multiset from a single element.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A multiset for a type is a mapping from the elements of the type to natural
  numbers. So, we record how often a message has to be processed in the future.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>multiset</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mElem</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a multiset ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ∈# _"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mElem a ms ≡ 0 &lt; ms a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Hence the union of two multisets is the addition of the number of the
  elements and therefore the associative and the commutative laws holds for
  the union.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mUnion</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a multiset ⇒ 'a multiset ⇒ 'a multiset"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ∪# _"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mUnion msA msB v ≡ msA v + msB v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Correspondingly the subtraction is defined and the commutative law holds.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mRm</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a multiset ⇒ 'a ⇒ 'a multiset"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ -# _"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mRm ms rm v ≡ if v = rm then ms v - 1 else ms v"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mSingleton</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a multiset"</span></span></span><span>          </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"{# _ }"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mSingleton a v ≡ if a = v then 1 else 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The lemma \isb{AXc} adds just the fact we need for our proofs about
  the commutativity of the union of multisets while elements are removed.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AXc</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c1 ≠ c2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c1 ∈# X"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c2 ∈# X"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A1 ∪# ((A2 ∪# (X -# c2)) -# c1)) 
      = (A2 ∪# ((A1 ∪# (X -# c1)) -# c2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(A2 ∪# ((A1 ∪# (X -# c1)) -# c2)) 
         = (A2 ∪# (A1 ∪# ((X -# c1) -# c2)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"... = (A1 ∪# ((A2 ∪# (X -# c2)) -# c1)) "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="AsynchronousSystem">
<div class="head"><h1>Theory AsynchronousSystem</h1>
<span class="command">theory</span> <span class="name">AsynchronousSystem</span><br/>
<span class="keyword">imports</span> <a href="Multiset.html"><span class="name">Multiset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹AsynchronousSystem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{AsynchronousSystem} defines a message datatype and a transition system locale to
  model asynchronous distributed computation. It establishes a diamond property for a
  special reachability relation within such transition systems.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AsynchronousSystem</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Multiset</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  The formalization is type-parameterized over
  \begin{description}
    \item[\var{'p} process identifiers.] Corresponds to the set $P$ in Völzer.
      Finiteness is not yet demanded, but will be in \file{FLPSystem}.
    \item[\var{'s} process states.] Corresponds to $S$, countability is not
      imposed.
    \item[\var{'v} message payloads.] Corresponds to the interprocess
      communication part of $M$ from Völzer. The whole of $M$ is captured by
      \isb{messageValue}.
  \end{description}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Messages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A \isb{message} is either an initial input message telling a process
  which value it should introduce to the consensus negotiation, a message
  to the environment communicating the consensus outcome, or a message
  passed from one process to some other.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'p</span><span class="delimiter">,</span><span> </span><span class="tfree">'v</span><span class="delimiter">)</span><span> </span><span>message</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>InMsg</span><span> </span><span class="tfree">'p</span><span> </span><span>bool</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;_, inM _&gt;"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>OutMsg</span><span> </span><span>bool</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;⊥, outM _&gt;"</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>Msg</span><span> </span><span class="tfree">'p</span><span> </span><span class="tfree">'v</span><span>      </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"&lt;_, _&gt;"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A message value is the content of a message, which a process may receive. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'v</span><span> </span><span>messageValue</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>Bool</span><span> </span><span>bool</span><span>
</span><span class="delimiter">|</span><span> </span><span>Value</span><span> </span><span class="tfree">'v</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>unpackMessage</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message ⇒ 'v messageValue"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"unpackMessage &lt;p, inM b&gt;  = Bool b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unpackMessage &lt;p, v&gt;      = Value v"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"unpackMessage &lt;⊥, outM v&gt; = Bool False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>isReceiverOf</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ ('p, 'v) message ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p1 (&lt;p2, inM v&gt;) = (p1 = p2)"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p1 (&lt;p2, v&gt;) =     (p1 = p2)"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p1 (&lt;⊥,outM v&gt;) =  False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>msg</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf q msg"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ≠ q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ isReceiverOf p msg"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Configurations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Here we formalize a configuration as detailed in section 2 of Völzer's paper.

  Note that Völzer imposes the finiteness of the message multiset by
  definition while we do not do so. In \isb{FiniteMessages}
  We prove the finiteness to follow from the assumption that only
  finitely many messages can be sent at once.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'p</span><span class="delimiter">,</span><span> </span><span class="tfree">'v</span><span class="delimiter">,</span><span> </span><span class="tfree">'s</span><span class="delimiter">)</span><span> </span><span>configuration</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's"</span></span></span><span>
</span><span>  </span><span>msgs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('p, 'v) message) multiset"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  C.f. Völzer: \textquote{A step is identified with a message $(p, m)$. A step $(p, m)$ is enabled
  in a configuration c if $\var{msgs}_c$ contains the message $(p, m)$.}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>enabled</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ ('p, 'v) message ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled cfg msg ≡ (msg ∈# msgs cfg)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The system locale›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The locale describing a system is derived by slight refactoring from the
  following passage of Völzer:
  \begin{displayquote}
    A process $p$ consists of an initial state $s_p \in S$ and a step transition
    function, which assigns to each pair $(m, s)$ of a message value $m$ and
    a process state $s$ a follower state and a finite set of messages (the
    messages to be sent by $p$ in a step).
  \end{displayquote}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>asynchronousSystem</span><span> </span><span class="delimiter">=</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>sends</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ ('p, 'v) message multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Proc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Proc ≡ (UNIV :: 'p set)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The step relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The step relation is defined analogously to Völzer:
  \begin{displayquote}
    {[}If enabled, a step may{]} occur, resulting in a follower
    configuration $c^\prime$, where $c^\prime$ is obtained from $c$ by removing
    $(p, m)$ from $\var{msgs}_c$, changing $p$'s state and adding the set of
    messages to $\var{msgs}_c$ according to the step transition function
    associated with $p$. We denote this by $c \xrightarrow{p,m} c^\prime$.
  \end{displayquote}
  There are no steps consuming output messages.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>steps</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration
   ⇒ ('p, 'v) message
   ⇒ ('p, 'v, 's) configuration
   ⇒ bool"</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ ↦ _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span>70</span><span class="delimiter">,</span><span>70</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span>StepInMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ &lt;p, inM v&gt; ↦ cfg2 = (
  (∀ s. ((s = p) ⟶ states cfg2 p = trans p (states cfg1 p) (Bool v))
      ∧ ((s ≠ p) ⟶ states cfg2 s = states cfg1 s))
   ∧ enabled cfg1 &lt;p, inM v&gt;
   ∧ msgs cfg2 = (sends p (states cfg1 p) (Bool v)
                  ∪# (msgs cfg1 -# &lt;p, inM v&gt;)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>StepMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ &lt;p, v&gt; ↦ cfg2 = (
  (∀ s. ((s = p) ⟶ states cfg2 p = trans p (states cfg1 p) (Value v))
      ∧ ((s ≠ p) ⟶ states cfg2 s = states cfg1 s))
   ∧ enabled cfg1 &lt;p, v&gt;
   ∧ msgs cfg2 = (sends p (states cfg1 p) (Value v)
                  ∪# (msgs cfg1 -# &lt;p, v&gt;)))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>StepOutMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ &lt;⊥,outM v&gt; ↦ cfg2 = 
    False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The system is distributed and asynchronous in the sense that the processing
  of messages only affects the process the message is directed to while the
  rest stays unchanged.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoReceivingNoChange</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isReceiverOf p m"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"states cfg1 p = states cfg2 p "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>q</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CaseM</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m = &lt;q, inM b'&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Step</span><span> </span><span>CaseM</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>q</span><span> </span><span>v'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CaseM</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m = &lt;q, v'&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Step</span><span> </span><span>CaseM</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ExistsMsg</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m ∈# (msgs cfg1)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoMessageLossStep</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬isReceiverOf p m'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 m' ≤ msgs cfg2 m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OutOnlyGrowing</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>b</span><span class="delimiter">::</span><span>bool</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span class="delimiter">::</span><span class="tfree">'p</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p m"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 &lt;⊥, outM b&gt; 
  = (msgs cfg1 &lt;⊥, outM b&gt;) + 
    sends p (states cfg1 p) (unpackMessage m) &lt;⊥, outM b&gt;"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = &lt;⊥, outM b&gt; ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MNotOut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ &lt;⊥, outM b&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgFunction</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 
                    = ((sends p (states cfg1 p) (unpackMessage m)) 
                      ∪# ((msgs cfg1) -# m))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>pa</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PaIsP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pa = p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(unpackMessage m) = Bool bool"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isReceiverOf_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ &lt;p, inM bool&gt; ↦ cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>InMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) 
                       ∪# (msgs cfg1 -# &lt;p, inM bool&gt;))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) 
                       ∪# (msgs cfg1 -# m))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PaIsP</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>InMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepInMsg</span><span> </span><span>assms</span><span> </span><span>PaIsP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>pa</span><span> </span><span>va</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>PaIsP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pa = p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(unpackMessage m) = Value va"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isReceiverOf_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ &lt;p, va&gt; ↦ cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Msg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Value va) 
                       ∪# (msgs cfg1 -# &lt;p, va&gt;))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Value va) 
                       ∪# (msgs cfg1 -# m))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PaIsP</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Msg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepInMsg</span><span> </span><span>assms</span><span> </span><span>PaIsP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((sends p (states cfg1 p) (unpackMessage m)) 
         ∪# ((msgs cfg1) -# m)) &lt;⊥, outM b&gt; 
       = ((sends p (states cfg1 p) (unpackMessage m)) 
         ∪# (msgs cfg1)) &lt;⊥, outM b&gt;"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MNotOut</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 &lt;⊥, outM b&gt; 
       = (msgs cfg1 &lt;⊥, outM b&gt;) + 
         sends p (states cfg1 p) (unpackMessage m) &lt;⊥, outM b&gt;"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MsgFunction</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OtherMessagesOnlyGrowing</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m ≠ m'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 m' ≤ msgs cfg2 m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Völzer: \textquote{Note that steps are enabled persistently, i.e., an
  enabled step remains enabled as long as it does not occur.}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>OnlyOccurenceDisables</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ m ↦ cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>En</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg1 m'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>NotEn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (enabled cfg2 m')"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">print_cases</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>p</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) 
                              ∪# (msgs cfg1 -# &lt;p, inM bool&gt;))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InMsg</span><span> </span><span>En</span><span> </span><span>NotEn</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enabled_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>bool</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends p (states cfg1 p) (Value v) 
                              ∪# (msgs cfg1 -# &lt;p, v&gt;))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Msg</span><span> </span><span>En</span><span> </span><span>NotEn</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enabled_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reachability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>reachable</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"  ('p, 'v, 's) configuration 
  ⇒ ('p, 'v, 's) configuration
  ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span>init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg1"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ reachable cfg1 cfg2; (cfg2 ⊢ msg ↦ cfg3) ⟧ 
          ⟹ reachable cfg1 cfg3"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ReachableStepFirst</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg cfg'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg = cfg' ∨ (∃ cfg1 msg p . (cfg ⊢ msg ↦ cfg1) ∧ enabled cfg msg 
                    ∧ isReceiverOf p msg  
                    ∧ reachable cfg1 cfg')"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> 
</span><span>    </span><span>metis</span><span> </span><span>StepOutMsg</span><span> </span><span>ExistsMsg</span><span> </span><span>init</span><span> </span><span>enabled_def</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>    </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>message.exhaust</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>asynchronousSystem.step</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ReachableTrans</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>cfg3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" 'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg2 cfg3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg3"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg2 cfg3 ⟹ reachable cfg1 cfg2 ⟹ reachable cfg1 cfg3"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1'</span><span> </span><span>cfg2'</span><span> </span><span>msg</span><span> </span><span>cfg3'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2'"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"cfg2' ⊢ msg ↦ cfg3'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg3'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>stepReachable</span><span> </span><span class="delimiter">::</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration
  ⇒ ('p ,'v) message
  ⇒ ('p, 'v, 's) configuration
  ⇒ bool"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"stepReachable c1 msg c2 ≡ 
    ∃ c' c''. reachable c1 c' ∧ (c' ⊢ msg ↦ c'') ∧ reachable c'' c2 "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StepReachable</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span> </span><span>cfg'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg cfg'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled cfg msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (enabled cfg' msg)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable cfg msg cfg'"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>msga</span><span> </span><span>cfg3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg2 ⊢ msga ↦ cfg3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ReachCfg1Cfg2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>IV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(enabled cfg1 msg ⟹ ¬ enabled cfg2 msg 
        ⟹ stepReachable cfg1 msg cfg2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>AssumpInduct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg1 msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled cfg3 msg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ReachCfg2Cfg3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg2 cfg3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>reachable.init</span><span> </span><span>reachable.step</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable cfg1 msg cfg3"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 msg"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 msg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msga = msg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OnlyOccurenceDisables</span><span> </span><span>Step</span><span> </span><span>AssumpInduct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable cfg1 msg cfg3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReachCfg1Cfg2</span><span> </span><span>Step</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>stepReachable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>init</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpNotEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled cfg2 msg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable cfg1 msg cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IV</span><span> </span><span>AssumpInduct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable cfg1 msg cfg3"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReachCfg2Cfg3</span><span> </span><span>ReachableTrans</span><span> </span><span>asynchronousSystem.stepReachable_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Reachability with special process activity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We say that \isb{qReachable cfg1 Q cfg2} iff cfg2 is reachable from cfg1
  only by activity of processes from Q.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>qReachable</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration 
  ⇒ 'p set 
  ⇒ ('p,'v,'s) configuration 
  ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>  
</span><span>  </span><span>InitQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg1"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>StepQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ qReachable cfg1 Q cfg2; (cfg2 ⊢ msg ↦ cfg3) ;
            ∃ p ∈ Q . isReceiverOf p msg ⟧ 
          ⟹ qReachable cfg1 Q cfg3"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We say that \isb{withoutQReachable cfg1 Q cfg2} iff cfg2 is reachable from cfg1
  with no activity of processes from Q.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>withoutQReachable</span><span> </span><span class="delimiter">::</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration 
  ⇒ 'p set 
  ⇒ ('p,'v,'s) configuration 
  ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cfg1 Q cfg2 ≡ 
    qReachable cfg1 ((UNIV :: 'p set ) - Q) cfg2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Obviously q-reachability (and thus also without-q-reachability) implies 
  reachability.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>QReachImplReach</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" 'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>InitQ</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>StepQ</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>QReachableTrans</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>cfg3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">" 'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg3"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>StepQ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NotInQFrozenQReachability</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∉ Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"states cfg1 p = states cfg2 p"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1'</span><span> </span><span>Q'</span><span> </span><span>cfg2'</span><span> </span><span>msg</span><span> </span><span>cfg3</span><span> </span><span>p'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1' Q' cfg2'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg2' ⊢ msg ↦ cfg3"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p' msg"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p' ∈ Q'"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∉ Q'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Rec</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (isReceiverOf p msg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"states cfg2' p = states cfg3 p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> </span><span>NoReceivingNoChange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>WithoutQReachablFrozenQ</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cfg1 Q cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"states cfg1 p = states cfg2 p"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>NotInQFrozenQReachability</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoActivityNoMessageLoss</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∉ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p m'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(msgs cfg1 m') ≤ (msgs cfg2 m')"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>StepQ</span><span> </span><span>cfg1'</span><span> </span><span>Q'</span><span> </span><span>cfg2'</span><span> </span><span>msg</span><span> </span><span>cfg3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p' ∈ Q'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p' msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(isReceiverOf p' m')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m'</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NoMessageLossStep</span><span> </span><span>StepQ</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>P'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2' m' ≤ msgs cfg3 m'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>StepQ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1' m' ≤ msgs cfg3 m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoMessageLoss</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cfg1 Q cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∈ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p m'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(msgs cfg1 m') ≤ (msgs cfg2 m')"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>NoActivityNoMessageLoss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoOutMessageLoss</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(msgs cfg1 &lt;⊥, outM v&gt;) ≤ (msgs cfg2 &lt;⊥, outM v&gt;)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span> </span><span>cfg'</span><span> </span><span>msg</span><span> </span><span>cfg2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssInduct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg'"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 &lt;⊥, outM v&gt; ≤ msgs cfg' &lt;⊥, outM v&gt;"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cfg' ⊢ msg ↦ cfg2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AssInduct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg' &lt;⊥, outM v&gt; ≤ msgs cfg2 &lt;⊥, outM v&gt;"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AssInduct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" msgs cfg1 &lt;⊥, outM v&gt; ≤ msgs cfg2 &lt;⊥, outM v&gt;"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StillEnabled</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg1</span><span> </span><span>cfg2</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cfg1 Q cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ∈ Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled cfg1 msg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 msg"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>enabled_def</span><span> </span><span>NoMessageLoss</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_0_eq</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Initial reachability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>initial</span><span> </span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initial cfg ≡
        (∀ p::'p . (∃ v::bool . ((msgs cfg (&lt;p, inM v&gt;)) = 1)))
      ∧ (∀ p m1 m2 . ((m1 ∈# (msgs cfg)) ∧ (m2 ∈# (msgs cfg)) 
         ∧ isReceiverOf p m1 ∧ isReceiverOf p m2) ⟶ (m1 = m2))
      ∧ (∀ v::bool . (msgs cfg) (&lt;⊥, outM v&gt;) = 0)
      ∧ (∀ p v. (msgs cfg) (&lt;p, v&gt;) = 0)
      ∧ states cfg = start"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>initReachable</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initReachable cfg ≡ ∃cfg0 . initial cfg0 ∧ reachable cfg0 cfg"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InitialIsInitReachable</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>reachable.init</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initReachable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Diamond property of reachability›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DiamondOne</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>m</span><span> </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>StepP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg ⊢ m  ↦ cfg1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>PNotQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (isReceiverOf p m')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf q m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (isReceiverOf q m)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>StepWithoutP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg ⊢ m' ↦ cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ cfg' :: ('p,'v,'s) configuration . (cfg1 ⊢ m' ↦ cfg')
        ∧ (cfg2 ⊢ m ↦ cfg')"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>p</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>StepWithoutP</span><span> </span><span>ExistsMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" m' ∈# (msgs cfg) "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' ∈# (msgs cfg1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>Rec</span><span> </span><span>NoMessageLossStep</span><span> </span><span>le_neq_implies_less</span><span> </span><span>le_antisym</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>gr_implies_not0</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnM'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg1 m'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>StepP</span><span> </span><span>ExistsMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈# (msgs cfg) "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈# (msgs cfg2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>NoMessageLossStep</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_0_eq</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 m"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CaseM</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m = &lt;p, inM b&gt;"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m'</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepWithoutP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>q</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' = ⦇states = λs. (
      if s = q then
        trans q (states cfg q) (Bool b')
      else if s = p then
        trans p (states cfg p) (Bool b)
      else
        states cfg s),
      msgs = ((sends q (states cfg q) (Bool b')) 
        ∪# (((sends p (states cfg p) (Bool b))
            ∪# ((msgs cfg)-# m)) -# m'))⦈ "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>StepP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1 ⊢ m' ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span>  </span><span>EnM'</span><span> </span><span>Rec</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cfg'_def</span><span> </span><span>InMsg</span><span> </span><span>CaseM</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EnM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg2 ⊢ m ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InMsg</span><span> </span><span>cfg'_def</span><span> </span><span>StepP</span><span> </span><span>StepP'</span><span> </span><span>StepWithoutP</span><span> </span><span>NoReceivingNoChange</span><span>  
</span><span>            </span><span>Rec'</span><span> </span><span>CaseM</span><span> </span><span>EnM'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>msgCfg</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 = (sends p (states cfg p) (Bool b)  
                     ∪# (msgs cfg -# &lt;p, inM b&gt;))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends q (states cfg q) (Bool b') 
                     ∪# (msgs cfg -# &lt;q, inM b'&gt;))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>CaseM</span><span> </span><span>InMsg</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>msgCfg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(sends q (states cfg q) (Bool b') ∪# (msgs cfg1 -# &lt;q, inM b'&gt;)) =
         (sends p (states cfg p) (Bool b) ∪# (msgs cfg2 -# &lt;p, inM b&gt;))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CaseM</span><span> </span><span>InMsg</span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>AXc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends q (states cfg q) (Bool b')"</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends p (states cfg p) (Bool b)"</span></span></span><span class="delimiter">]</span><span>         
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>q</span><span> </span><span>v'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' = ⦇states = λs. (
      if s = q then
        trans q (states cfg q) (Value v')
      else if s = p then
        trans p (states cfg p) (Bool b)
      else
        states cfg s),
      msgs = ((sends q (states cfg q) (Value v')) 
        ∪# (((sends p (states cfg p) (Bool b))
            ∪# ((msgs cfg)-# m))
            -# m'))⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>StepP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1 ⊢ m' ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>EnM'</span><span> </span><span>Rec</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Msg</span><span> </span><span>CaseM</span><span> </span><span>cfg'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EnM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg2 ⊢ m ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Msg</span><span> </span><span>cfg'_def</span><span> </span><span>StepP</span><span> </span><span>StepP'</span><span> </span><span>StepWithoutP</span><span> </span><span>NoReceivingNoChange</span><span> </span><span>Rec'</span><span> </span><span>CaseM</span><span> </span><span>EnM'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>clarify</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>msgCfg1</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 = (sends p (states cfg p) (Bool b)   
                      ∪# (msgs cfg -# &lt;p, inM b&gt;))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends q (states cfg q) (Value v') 
                      ∪# (msgs cfg -# &lt;q,  v'&gt;))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>CaseM</span><span> </span><span>Msg</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>msgCfg1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(sends q (states cfg q) (Value v') ∪# (msgs cfg1 -# &lt;q, v'&gt;)) =
         (sends p (states cfg p) (Bool b) ∪# (msgs cfg2 -# &lt;p, inM b&gt;))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CaseM</span><span> </span><span>Msg</span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>AXc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends q (states cfg q) (Value v')"</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends p (states cfg p) (Bool b)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>StepWithoutP</span><span> </span><span>ExistsMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" m' ∈# (msgs cfg) "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' ∈# (msgs cfg1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>Rec</span><span> </span><span>NoMessageLossStep</span><span> </span><span>le_neq_implies_less</span><span> </span><span>le_antisym</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>gr_implies_not0</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnM'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg1 m'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>StepP</span><span> </span><span>ExistsMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈# (msgs cfg) "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈# (msgs cfg2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>NoMessageLossStep</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_0_eq</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 m"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>CaseM</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"m = &lt;p, v&gt;"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>m'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepWithoutP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>q</span><span> </span><span>b'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' = ⦇states = λs. (
      if s = q then
        trans q (states cfg q) (Bool b')
      else if s = p then
        trans p (states cfg p) (Value v)
      else
        states cfg s),
      msgs = ((sends q (states cfg q) (Bool b')) 
        ∪# (((sends p (states cfg p) (Value v))
        ∪# ((msgs cfg)-# m))
        -# m'))⦈ "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>StepP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1 ⊢ m' ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>InMsg</span><span> </span><span>EnM'</span><span> </span><span>Rec</span><span> </span><span>CaseM</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EnM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg2 ⊢ m ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InMsg</span><span> </span><span>cfg'_def</span><span> </span><span>StepP</span><span> </span><span>StepP'</span><span> </span><span>StepWithoutP</span><span> </span><span>NoReceivingNoChange</span><span> </span><span>Rec'</span><span> 
</span><span>            </span><span>CaseM</span><span> </span><span>EnM'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>msgCfg</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 = (sends p (states cfg p) (Value v)
          ∪# (msgs cfg -# &lt;p, v&gt;))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends q (states cfg q) (Bool b')
          ∪# (msgs cfg -# &lt;q, inM b'&gt;))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>CaseM</span><span> </span><span>InMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>msgCfg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (sends q (states cfg q) (Bool b') 
                         ∪# (msgs cfg1 -# &lt;q, inM b'&gt;)) 
                       = (sends p (states cfg p) (Value v) 
                         ∪# (msgs cfg2 -# &lt;p, v&gt;))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CaseM</span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>InMsg</span><span> </span><span>AXc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends q (states cfg q) (Bool b')"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends p (states cfg p) (Value v)"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>q</span><span> </span><span>v'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' = ⦇states = λs. (
      if s = q then
        trans q (states cfg q) (Value v')
      else if s = p then
        trans p (states cfg p) (Value v)
      else
        states cfg s),
      msgs = ((sends q (states cfg q) (Value v')) 
        ∪# (((sends p (states cfg p) (Value v))
        ∪# ((msgs cfg)-# m))
        -# m'))⦈ "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>StepP'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1 ⊢ m' ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>Msg</span><span> </span><span>EnM'</span><span> </span><span>Rec</span><span> </span><span>CaseM</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>EnM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg2 ⊢ m ↦ cfg')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Msg</span><span> </span><span>cfg'_def</span><span> </span><span>StepP</span><span> </span><span>StepP'</span><span> </span><span>StepWithoutP</span><span> </span><span>NoReceivingNoChange</span><span> </span><span>Rec'</span><span> </span><span>CaseM</span><span> </span><span>EnM'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>msgCfg</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg1 = (sends p (states cfg p) (Value v)
          ∪# (msgs cfg -# &lt;p, v&gt;))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs cfg2 = (sends q (states cfg q) (Value v')
          ∪# (msgs cfg -# &lt;q, v'&gt;))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg m'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>CaseM</span><span> </span><span>Msg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>msgCfg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" (sends q (states cfg q) (Value v') 
                         ∪# (msgs cfg1 -# &lt;q, v'&gt;)) 
                       = (sends p (states cfg p) (Value v) 
                         ∪# (msgs cfg2 -# &lt;p, v&gt;))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CaseM</span><span> </span><span>StepP</span><span> </span><span>StepWithoutP</span><span> </span><span>Rec'</span><span> </span><span>Msg</span><span> 
</span><span>          </span><span>AXc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"m'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends q (states cfg q) (Value v')"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sends p (states cfg p) (Value v)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>enabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DiamondTwo</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>QReach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg Q cfg1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg  ⊢ msg ↦ cfg2"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∃p∈Proc - Q. isReceiverOf p msg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ (cfg' :: ('p,'v,'s) configuration) . (cfg1  ⊢ msg ↦ cfg') 
  ∧ qReachable cfg2 Q cfg'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg ⊢ msg ↦ cfg2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p∈UNIV - Q. isReceiverOf p msg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg ⊢ msg ↦ cfg2) ∧ qReachable cfg2 Q cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg'.(cfg ⊢ msg ↦ cfg') ∧ qReachable cfg2 Q cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg</span><span> </span><span>Q</span><span> </span><span>cfg1'</span><span> </span><span>msga</span><span> </span><span>cfg1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"(cfg ⊢ msg ↦ cfg2)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∃p∈UNIV - Q. isReceiverOf p msg)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((cfg ⊢ msg ↦ cfg2) ⟹
     (∃p∈UNIV - Q. isReceiverOf p msg) ⟹
     (∃cfg'. (cfg1' ⊢ msg ↦ cfg') ∧ qReachable cfg2 Q cfg'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃cfg'. (cfg1' ⊢ msg ↦ cfg') ∧ (∃p∈UNIV - Q. isReceiverOf p msg) 
        ∧ qReachable cfg2 Q cfg')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Cfg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1' ⊢ msg ↦ cfg')"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∃p∈UNIV - Q. isReceiverOf p msg)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p∈UNIV - Q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Step2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cfg1' ⊢ msga ↦ cfg1)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∃p∈Q. isReceiverOf p msga)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(qReachable cfg Q cfg1')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p'∈Q"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p' msga"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>P</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≠ p'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>P</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>P'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isReceiverOf p' msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isReceiverOf p msga"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">[</span><span>of</span><span> </span><span>p'</span><span> </span><span>msga</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>msg</span><span> </span><span>p'</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notEq</span><span> </span><span>P'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>P</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cfg'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Step2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃cfg''. (cfg' ⊢ msga ↦ cfg'') ∧ (cfg1 ⊢ msg ↦ cfg'')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DiamondOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfg''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Cfg''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' ⊢ msga ↦ cfg''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg1 ⊢ msg ↦ cfg''"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cfg''</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Step2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cfg'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg''"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>cfg2</span><span> </span><span>Q</span><span> </span><span>cfg''</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cfg'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cfg''</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(cfg1 ⊢ msg ↦ cfg'') ∧ qReachable cfg2 Q cfg''"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg'. (cfg1 ⊢ msg ↦ cfg') ∧ qReachable cfg2 Q cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Proposition 1 of Völzer.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Diamond</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p,'v,'s) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>QReach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg Q cfg1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>WithoutQReach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cfg Q cfg2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ cfg'. withoutQReachable cfg1 Q cfg' 
     ∧ qReachable cfg2 Q cfg'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>notQ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"notQ ≡ UNIV - Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>WithoutQReach</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg notQ cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>QReach</span><span> </span><span>notQ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg2</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 (UNIV - Q) cfg1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∃cfg'. qReachable cfg1 (UNIV - Q) cfg' 
        ∧ qReachable cfg2 Q cfg'"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg</span><span> </span><span>cfg2'</span><span> </span><span>cfg2</span><span> </span><span>msg</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Ass1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" qReachable cfg Q cfg1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg (UNIV - Q) cfg2' "</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Ass2</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg2' ⊢ msg ↦ cfg2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p∈UNIV - Q. isReceiverOf p msg"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg Q cfg1 ⟹ ∃cfg'. qReachable cfg1 (UNIV - Q) cfg' 
      ∧ qReachable cfg2' Q cfg'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Ass1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg'. qReachable cfg1 (UNIV - Q) cfg' 
      ∧ qReachable cfg2' Q cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>Cfg'1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2' Q cfg'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>Cfg'</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 (UNIV - Q) cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cfg'1</span><span> </span><span>Ass2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∃cfg''.(cfg' ⊢ msg ↦ cfg'') ∧ qReachable cfg2 Q cfg''"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DiamondTwo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfg''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>Cfg''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg' ⊢ msg ↦ cfg''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg2 Q cfg''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cfg'</span><span> </span><span>Cfg''</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Ass2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 (UNIV - Q) cfg''"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>cfg1</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV-Q"</span></span></span><span> </span><span>cfg''</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cfg''</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∃cfg'. qReachable cfg1 (UNIV - Q) cfg' 
        ∧ qReachable cfg2 Q cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant finite message count›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FiniteMessages</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>FiniteProcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite Proc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>FiniteSends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ p s m. finite {v. v ∈# (sends p s m)}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>InitReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {msg . msg ∈# msgs cfg}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ init . initial init ∧ reachable init cfg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initReachable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>init</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial init"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable init cfg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitMsgs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{msg . msg ∈# msgs init} 
    = { msg . (msg ∈# msgs init) ∧ (∃ p v. &lt;p, v&gt; = msg)} 
      ∪ { msg . (msg ∈# msgs init) ∧ (∃ v.  &lt;⊥, outM v&gt; = msg)}
      ∪ { msg . (msg ∈# msgs init) ∧ (∃ p v.  &lt;p, inM v&gt; = msg)}"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>metis</span><span> </span><span>message.exhaust</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{ msg . (msg ∈# msgs init) ∧ (∃ p v. &lt;p, v&gt; = msg)} = {}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>initial_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>init</span><span class="delimiter">]</span><span> </span><span>Init</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>less_not_refl3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"{ msg . (msg ∈# msgs init) ∧ (∃ v.  &lt;⊥, outM v&gt; = msg)} = {}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>initial_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>init</span><span class="delimiter">]</span><span> </span><span>Init</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>less_not_refl3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p . finite {&lt;p, inM True&gt;, &lt;p, inM False&gt;}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SubsetMsg</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ p. { msg . (msg ∈# msgs init) 
      ∧ (∃ v::bool .  &lt;p, inM v&gt; = msg)} 
      ⊆ {&lt;p, inM True&gt;, &lt;p, inM False&gt;}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllFinite</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ p. finite { msg . (msg ∈# msgs init) 
      ∧ (∃ v::bool .  &lt;p, inM v&gt; = msg)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" { msg . (msg ∈# msgs init) 
    ∧ (∃ p∈Proc . ∃ v::bool.  &lt;p, inM v&gt; = msg)} 
      = (⋃ p ∈ Proc . { msg . (msg ∈# msgs init) 
    ∧ (∃ v::bool .  &lt;p, inM v&gt; = msg)})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite  { msg . (msg ∈# msgs init) 
    ∧ (∃ p∈Proc . ∃ v::bool.  &lt;p, inM v&gt; = msg)}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllFinite</span><span> </span><span>FiniteProcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>InitFinite</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"finite {msg . msg ∈# msgs init}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>InitMsgs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Init</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>InitFinite</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>msg</span><span> </span><span>cfg3</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assmsInduct</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"finite {msg. msg ∈# msgs cfg2}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg2 ⊢ msg ↦ cfg3"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"finite {msg. msg ∈# msgs cfg1}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable init cfg"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"finite {msg. msg ∈# msgs init}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assmsInduct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg "</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>StepOutMsg</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>       </span><span>message.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cfg3 = ((msgs cfg2 -# msg) ∪# (sends p (states cfg2 p) 
      (unpackMessage msg) ))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assmsInduct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgSet</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{msg. msg ∈#  msgs cfg3 } 
      = {m. m ∈# ((msgs cfg2 -# msg) ∪# (sends p (states cfg2 p) 
        (unpackMessage msg) )) } "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{v. v ∈# (msgs cfg2 -# msg)} ⊆ {msg. msg ∈# msgs cfg2}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {v. (v ∈# sends p (states cfg2 p) (unpackMessage msg))
        ∨ (v ∈# (msgs cfg2 -# msg))}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FiniteSends</span><span> </span><span>assmsInduct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {msg. msg ∈# msgs cfg3}"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MsgSet</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="ListUtilities">
<div class="head"><h1>Theory ListUtilities</h1>
<span class="command">theory</span> <span class="name">ListUtilities</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ListUtilities›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{ListUtilities} defines a (proper) prefix relation for lists, and proves some
  additional lemmata, mostly about lists.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>ListUtilities</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List Prefixes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>prefixList</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList [] (x # xs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList xa xb ⟹ prefixList (x # xa) (x # xb)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrefixListHasTail</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>l1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>l2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ l . l2 = l1 @ l ∧ l ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>prefixList.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrefixListMonotonicity</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>l1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>l2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length l1 &lt; length l2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>prefixList.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TailIsPrefixList</span><span> </span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>l1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tail</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail ≠ []"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 (l1 @ tail)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l1</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x xs . tail = x # xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList [] tail"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prefixList.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>l1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 (l1 @ tail)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (a # l1) (a # l1 @ tail)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prefixList.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrefixListTransitive</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>l1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>l2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>l3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l2"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l2 l3"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l3"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ l12 . l2 = l1 @ l12 ∧ l12 ≠ []"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListHasTail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l12</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Extend1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l2 = l1 @ l12 ∧ l12 ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Extend2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ l23 . l3 = l2 @ l23 ∧ l23 ≠ []"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListHasTail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l23</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Extend2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l3 = l2 @ l23 ∧ l23 ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l3 = l1 @ (l12 @ l23) ∧ (l12 @ l23) ≠ []"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Extend1</span><span> </span><span>Extend2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ l . l3 = l1 @ l ∧ l ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TailIsPrefixList</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lemmas for lists and nat predicates›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NatPredicateTippingPoint</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>n2</span><span> </span><span>Pr</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Min</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Pr0</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Pr 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>NotPrN2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Pr n2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃n&lt;n2. Pr n ∧ ¬Pr (Suc n)"</span></span></span><span>                       
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>classical</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. Pr n ⟶ n &lt; n2 ⟶ Pr (Suc n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n. n &lt; n2 ⟹ Pr n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; n2 ⟹ Pr n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pr0</span><span> </span><span>Asm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Asm</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n2 - 1"</span></span></span><span class="delimiter">]</span><span> </span><span>Min</span><span> </span><span>NotPrN2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MinPredicate</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ n . P n"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃ n0 . (P n0) ∧ (∀ n' . (P n') ⟶ (n' ≥ n0)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LeastI2_wellorder</span><span> </span><span>Suc_n_not_le_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The lemma \isb{MinPredicate2} describes one case of \isb{MinPredicate}
  where the aforementioned smallest element is zero.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MinPredicate2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . P n"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ n0 . (P n0) ∧ (n0 = 0 ∨ ¬ P (n0 - 1))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>MinPredicate</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>diff_is_0_eq</span><span> </span><span>diff_mult_distrib</span><span> </span><span>mult_eq_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \isb{PredicatePairFunction} allows to obtain functions mapping two arguments
  to pairs from 4-ary predicates which are left-total on their first
  two arguments.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PredicatePairFunction</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ 'c ⇒ 'd ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2 . ∃y1 y2 . (P x1 x2 y1 y2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃f . ∀x1 x2 . ∃y1 y2 .
    (f x1 x2) = (y1, y2) 
    ∧ (P x1 x2 (fst (f x1 x2)) (snd (f x1 x2)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>P'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' x y = P (fst x) (snd x) (fst y) (snd y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ∃y. P' x  y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. ∀x. P' x (f x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. P' x (f x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' x1 x2 = f (x1, x2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. P' x (f' (fst x) (snd x))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f'. ∀x. P' x (f' (fst x) (snd x))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PredicatePairFunctions2</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ 'c ⇒ 'd ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2 . ∃y1 y2 . (P x1 x2 y1 y2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2 . ∃y1 y2 .
    (f1 x1 x2) = y1 ∧ (f2 x1 x2) = y2 
    ∧ (P x1 x2 (f1 x1 x2) (f2 x1 x2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>thesis</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀f1 f2. ∀x1 x2. P x1 x2 (f1 x1 x2) (f2 x1 x2) ⟹ False"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2. ∃y1 y2. f x1 x2 = (y1, y2) ∧ P x1 x2 (fst (f x1 x2)) (snd (f x1 x2))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PredicatePairFunction</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f1 x1 x2 = fst (f x1 x2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f2 x1 x2 = snd (f x1 x2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span class="delimiter">[</span><span>of</span><span> </span><span>f1</span><span> </span><span>f2</span><span class="delimiter">]</span><span> </span><span>F</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f1_def</span><span> </span><span>f2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PredicatePairFunctions2Inv</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b ⇒ 'c ⇒ 'd ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>A1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2 . ∃y1 y2 . (P x1 x2 y1 y2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>f1</span><span> </span><span>f2</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x1 x2 . (P x1 x2 (f1 x1 x2) (f2 x1 x2))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PredicatePairFunctions2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SmallerMultipleStepsWithLimit</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>k</span><span> </span><span>A</span><span> </span><span>limit</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ n ≥ limit . (A (Suc n)) &lt; (A n)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ n ≥ limit . (A (n + k)) ≤ (A n) - k"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n≥limit. A (n + k) ≤ A n - k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"limit ≤ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A (Suc (n + k)) &lt; A (n + k)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A (Suc (n + k)) &lt; A n - k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A (Suc (n + k)) ≤ A n - Suc k"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessI</span><span> </span><span>add_Suc_right</span><span> </span><span>add_diff_cancel_left'</span><span> 
</span><span>       </span><span>less_diff_conv</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PrefixSameOnLow</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>l1</span><span> </span><span>l2</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ index &lt; length l1 . l1 ! index = l2 ! index"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>prefixList.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xa</span><span> </span><span>xb</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span>index</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpProof</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList xa xb"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀index &lt; length xa. xa ! index = xb ! index"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"prefixList l1 l2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index &lt; Suc (length xa)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x # xa) ! index = (x # xb) ! index"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpProof</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"index = 0"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>KeepProperty</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>P</span><span> </span><span>Q</span><span> </span><span>low</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ i ≥ low . P i ⟶ (P (Suc i) ∧ Q i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P low"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ i ≥ low . Q i"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Assump</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀i≥low. P i ⟶ P (Suc i) ∧ Q i"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"P low"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"low ≤ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i≥low. P i ⟶ P (Suc i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i ≥ low . P i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Assump</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dec_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Assump</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q i"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Assump</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ListLenDrop</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>i</span><span> </span><span>la</span><span> </span><span>lb</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length lb"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i ≥ la"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lb ! i ∈ set (drop la lb)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>in_set_member</span><span> </span><span>member_rec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>       </span><span>set_drop_subset_set_drop</span><span> </span><span>rev_subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DropToShift</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>l</span><span> </span><span>i</span><span> </span><span>list</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"l + i &lt; length list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(drop l list) ! i = list ! (l + i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SetToIndex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>liste</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>AssumpSetToIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set liste"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ index &lt; length liste . a = liste ! index"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LenInduct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀xs. ∀ys. length ys &lt; length xs ⟶ a ∈ set ys 
          ⟶ (∃index&lt;length ys. a = ys ! index) 
          ⟹ a ∈ set xs ⟶ (∃index&lt;length xs. a = xs ! index)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpLengthInduction</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀ys. length ys &lt; length xs ⟶ a ∈ set ys 
      ⟶ (∃index&lt;length ys. a = ys ! index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set xs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ x xs' . xs = x#xs'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpLengthInduction</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ListMem.cases</span><span> </span><span>ListMem_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>xs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>XSSplit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = x#xs'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ insert x (set xs')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_simps</span><span> </span><span>AssumpLengthInduction</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x ∨ a ∈ set xs'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃index&lt;length xs. a = xs ! index"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = x"</span></span></span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃index&lt;length xs. x = xs ! index"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XSSplit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpCases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set xs'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs' &lt; length xs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XSSplit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃index&lt;length xs'. a = xs' ! index"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpLengthInduction</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>AssumpCases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃index&lt;length xs. a = xs ! index"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>XSSplit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ index &lt; length liste . a = liste ! index"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_induct</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"λl. a ∈ set l ⟶ (∃ index &lt; length l . a = l ! index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"liste"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span>AssumpSetToIndex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DropToIndex</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l</span><span> </span><span>liste</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>AssumpDropToIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (drop l liste)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ i ≥ l . i &lt; length liste ∧ a = liste ! i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ index &lt; length (drop l liste) . a = (drop l liste) ! index"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpDropToIndex</span><span> </span><span>SetToIndex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"drop l liste"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>index</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Index</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"index &lt; length (drop l liste)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"a = (drop l liste) ! index"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l + index &lt; length liste"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Index</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_drop</span><span> </span><span>less_diff_conv</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = liste ! (l + index)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DropToShift</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index"</span></span></span><span class="delimiter">]</span><span> </span><span>Index</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i≥l. i &lt; length liste ∧ a = liste ! i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹l + index &lt; length liste›</span></span></span><span> </span><span>le_add1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Execution">
<div class="head"><h1>Theory Execution</h1>
<span class="command">theory</span> <span class="name">Execution</span><br/>
<span class="keyword">imports</span> <a href="AsynchronousSystem.html"><span class="name">AsynchronousSystem</span></a> <a href="ListUtilities.html"><span class="name">ListUtilities</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{Execution} introduces a locale for executions within asynchronous systems.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Execution</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AsynchronousSystem</span><span> </span><span>ListUtilities</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Execution locale definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A (finite) execution within a system is a list of configurations \isb{exec}
  accompanied by a list of messages \isb{trace} such that the first configuration
  is initial and every next state can be reached processing the messages
  in \isb{trace}.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>execution</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>asynchronousSystem</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span>    
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>sends</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ ('p, 'v) message multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's"</span></span></span><span>
</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>exec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>trace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>notEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec ≥ 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec - 1 = length trace"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>base</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial (hd exec)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ i &lt; length exec - 1 ; cfg1 = exec ! i ; cfg2 = exec ! (i + 1) ⟧
      ⟹ ((cfg1 ⊢ trace ! i ↦ cfg2)) "</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>execMsg</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p,'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"execMsg n ≡ (trace ! n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>execConf</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p, 'v, 's) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"execConf n  ≡ (exec ! n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Enabledness and occurrence in the execution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>minimalEnabled</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"minimalEnabled msg ≡ (∃ p . isReceiverOf p msg) 
    ∧ (enabled (last exec) msg)
    ∧ (∃ n . n &lt; length exec ∧ enabled (execConf n) msg 
      ∧ (∀ n' ≥ n . n' &lt; length trace ⟶ msg ≠ (execMsg n'))
    ∧ (∀ n' msg' . ((∃ p . isReceiverOf p msg') 
      ∧ (enabled (last exec) msg') 
      ∧ n' &lt; length trace 
      ∧ enabled (execConf n') msg' 
      ∧ (∀ n'' ≥ n' . n'' &lt; length trace ⟶ msg' ≠ 
                      (execMsg n''))) ⟶ n' ≥ n))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>firstOccurrence</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message ⇒ nat ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>                    
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"firstOccurrence msg n ≡ (∃ p . isReceiverOf p msg) 
    ∧ (enabled (last exec) msg) ∧ n &lt; (length exec)
    ∧ enabled (execConf n) msg 
    ∧ (∀ n' ≥ n . n' &lt; length trace ⟶ msg ≠ (execMsg n'))
    ∧ ( n ≠ 0 ⟶ (¬ enabled (execConf (n - 1)) msg 
      ∨ msg = execMsg (n - 1)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FirstOccurrenceExists</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃p. isReceiverOf p msg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ n . firstOccurrence msg n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec - 1 &lt; length exec 
    ∧ (∀ n' ≥ (length exec - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_diff_cancel</span><span> </span><span>leD</span><span> </span><span>notEmpty</span><span> </span><span>zero_less_diff</span><span> 
</span><span>      </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NNotInTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n &lt; length exec . 
    (∀ n'≥n . n' &lt; length trace ⟶ trace ! n' ≠ msg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n0 &lt; length exec . 
    (∀ n'≥n0 . n' &lt; length trace ⟶ trace ! n' ≠ msg) ∧
    ((n0 = 0) 
      ∨ ¬ (∀ n' ≥ (n0 - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinPredicate2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx.(x &lt; length exec 
      ∧ (∀n'≥x.(n'&lt;length trace ⟶ trace ! n' ≠ msg)))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n0. n0 &lt; length exec 
    ∧ (∀ n'≥n0 . n' &lt; length trace ⟶ trace ! n' ≠ msg) 
    ∧ ((n0 = 0) 
      ∨ ¬ (∀ n' ≥ (n0 - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N0a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length exec 
    ∧ (∀ n'≥n0 . n' &lt; length trace ⟶ trace ! n' ≠ msg) 
    ∧ ((n0 = 0) 
      ∨ ¬ (∀ n' ≥ (n0 - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length exec"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∀ n'≥n0 . n' &lt; length trace ⟶ trace ! n' ≠ msg)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((n0 = 0) 
      ∨ ¬ (∀ n' ≥ (n0 - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N0'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 = 0 ∨ trace ! (n0 - 1) = msg"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 = 0"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>N0NotZero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∀ n' ≥ (n0 - 1) . n' &lt; length trace ⟶ trace ! n' ≠ msg)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 - 1 &lt; length trace"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>length</span><span> </span><span>N0NotZero</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>calculation</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execMsg (n0 - Suc 0) = msg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>diff_Suc_eq_diff_pred</span><span> 
</span><span>         </span><span>diff_diff_cancel</span><span> </span><span>diff_is_0_eq</span><span> </span><span>leI</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n1 &lt; length exec . 
    (∀ n'≥n1 . n' &lt; length trace ⟶ trace ! n' ≠ msg) 
    ∧ enabled (exec ! n1) msg 
    ∧ (n1 = 0 ∨ ¬ enabled (exec ! (n1 - 1)) msg ∨ trace ! (n1 - 1) = msg)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! n0) msg"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf n0) msg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length exec"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀ n'≥n0 . n' &lt; length trace ⟶ trace ! n' ≠ msg)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! n0) msg ∧
      (n0 = 0 ∨ ¬ enabled (exec ! (n0 - 1)) msg ∨ trace ! (n0 - 1) = msg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0</span><span> </span><span>N0'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n1&lt;length exec.
       (∀n'≥n1. n' &lt; length trace ⟶ execMsg n' ≠ msg) 
       ∧ enabled (execConf n1) msg 
       ∧ (n1 = 0 ∨ ¬ enabled (execConf (n1 - 1)) msg 
         ∨ execMsg (n1 - 1) = msg)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NotEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (execConf n0) msg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last exec = exec ! (length exec - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_conv_nth</span><span> </span><span>notEmpty</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>NNotInTrace</span><span> </span><span>length_0_conv</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnabledInLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! (length exec - 1)) msg"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 ≠ length exec - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotEnabled</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N0Small</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length exec - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ k &lt; length exec - 1 - n0  . ¬ enabled (execConf (n0 + k)) msg 
      ∧ enabled (execConf (n0 + k + 1)) msg"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NatPredicateTippingPoint</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec - 1 - n0"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λx.¬(enabled (exec ! (n0 + x)) msg)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NotEnabled</span><span> </span><span>EnabledInLast</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" k &lt; length exec - 1 - n0"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (execConf (n0 + k)) msg"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf (n0 + k + 1)) msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 = k + n0 + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≥ n0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (execConf (n1 - 1)) msg"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf n1) msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &lt; length exec"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n1_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n'≥n1. n' &lt; length trace ⟶ execMsg n' ≠ msg"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>N0</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n1&lt;length exec.
        (∀n'≥n1. n' &lt; length trace ⟶ execMsg n' ≠ msg) 
        ∧ enabled (execConf n1) msg 
        ∧ (n1 = 0 ∨ ¬ enabled (execConf (n1 - 1)) msg 
          ∨ execMsg (n1 - 1) = msg)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &lt; length exec"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ n'≥n1 . n' &lt; length trace ⟶ trace ! n' ≠ msg"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! n1) msg"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"n1 = 0 ∨ ¬ enabled (exec ! (n1 - 1)) msg ∨ trace ! (n1 - 1) = msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"firstOccurrence msg n1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>firstOccurrence_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. firstOccurrence msg n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ReachableInExecution</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length exec"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j ≤ i"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf j) (execConf i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf 0) (execConf 0)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ia</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(j ≤ ia ⟹ reachable (execConf j) (execConf ia))"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Suc ia &lt; length exec"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"j ≤ Suc ia"</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"i &lt; length exec"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"j ≤ i"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf j) (execConf (Suc ia))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"j = Suc ia"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf (Suc ia)) (execConf (Suc ia))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≠ Suc ia"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ ia"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf j) (execConf ia)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf ia) (execConf (Suc ia))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>less_diff_conv</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (execConf j) (execConf (Suc ia))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReachableTrans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LastPoint</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>msg</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length exec"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf n) msg"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ n' ≥ n .
    n' &lt; length trace ⟶ msg ≠ (execMsg n')"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ n0 . 
      n0 &lt; length exec 
    ∧ enabled (execConf n0) msg 
    ∧ (∀ n' ≥ n0 .
        n' &lt; length trace ⟶ msg ≠ (execMsg n'))
    ⟶ n0 ≥ n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="var">?thesis</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>len</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"len = length exec - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"len &lt; length exec"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf len) msg"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ n' ≥ len . n' &lt; length trace ⟶ msg ≠ (execMsg n')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>notEmpty</span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>len_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>last_conv_nth</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n . n &lt; length exec ∧ enabled (execConf n) msg 
    ∧ (∀ n' ≥ n . n' &lt; length trace ⟶ msg ≠ (execMsg n'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MinPredicate</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ExistImpliesMinEnabled</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ msg' . minimalEnabled msg'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgHasMinTime</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ msg . (enabled (last exec) msg 
    ∧ (∃ p . isReceiverOf p msg))
    ⟶ (∃ n .  n &lt; length exec ∧ enabled (execConf n) msg 
        ∧ (∀ n' ≥ n . n' &lt; length trace ⟶ msg ≠ (execMsg n'))
        ∧ (∀ n0 .  n0 &lt; length exec ∧ enabled (execConf n0) msg 
        ∧ (∀ n' ≥ n0 . n' &lt; length trace ⟶ msg ≠ (execMsg n')) 
        ⟶ n0 ≥ n))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>LastPoint</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?enabledTimes</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{n::nat . ∃ msg . (enabled (last exec) msg 
    ∧ (∃ p . isReceiverOf p msg))
    ∧  n &lt; length exec ∧ (enabled (execConf n) msg 
    ∧ (∀ n' ≥ n . n' &lt; length trace ⟶ msg ≠ (execMsg n')))}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotEmpty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"?enabledTimes ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>MsgHasMinTime</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n0 . n0 ∈ ?enabledTimes"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ nMin ∈ ?enabledTimes . ∀ x ∈ ?enabledTimes . x ≥ nMin"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinPredicate</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λn.(n ∈ ?enabledTimes)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nMin</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NMin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMin ∈ ?enabledTimes"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ ?enabledTimes . x ≥ nMin"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ msg . (enabled (last exec) msg ∧ (∃ p . isReceiverOf p msg))
    ∧  nMin &lt; length exec ∧ (enabled (execConf nMin) msg 
    ∧ (∀ n' ≥ nMin . n' &lt; length trace ⟶ msg ≠ (execMsg n'))
    ∧ (∀ n0 .  n0 &lt; length exec ∧ enabled (execConf n0) msg 
      ∧ (∀ n' ≥ n0 . n' &lt; length trace ⟶ msg ≠ (execMsg n')) 
      ⟶ n0 ≥ nMin))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>msg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(enabled (last exec) msg 
    ∧ (∃ p . isReceiverOf p msg))
    ∧ nMin &lt; length exec ∧(enabled (execConf nMin) msg 
    ∧ (∀ n' ≥ nMin . n' &lt; length trace ⟶ msg ≠ (execMsg n'))
    ∧ (∀ n0 .  n0 &lt; length exec ∧ enabled (execConf n0) msg 
      ∧ (∀ n' ≥ n0 . n' &lt; length trace ⟶ msg ≠ (execMsg n')) 
      ⟶ n0 ≥ nMin))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ n' msg' . ((∃ p . isReceiverOf p msg') 
    ∧ (enabled (last exec) msg') 
    ∧ n' &lt; length trace ∧ enabled (execConf n') msg' 
    ∧ (∀ n'' ≥ n' . n'' &lt; length trace ⟶ msg' ≠ (execMsg n''))) 
      ⟶ n' ≥ nMin)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n'</span><span> </span><span>msg'</span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Assms</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"n' &lt; length trace"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf n') msg'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀n'' ≥ n'. (n'' &lt; length trace) ⟶ (msg' ≠ execMsg n'')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' &lt; length exec"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ ?enabledTimes"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMin ≤ n'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NMin</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minimalEnabled msg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minimalEnabled_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StaysEnabledStep</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>En</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Cfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg = exec ! n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; length exec"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! (n + 1)) msg 
  ∨ n = (length exec - 1) 
  ∨ msg = trace ! n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = length exec - 1"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; length exec - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cfg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Step</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg ⊢ trace ! n ↦ (exec ! (n + 1))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (exec ! (n + 1)) msg"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (exec ! (n + 1)) msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>En</span><span> </span><span>enabled_def</span><span> </span><span>Step</span><span> </span><span>N</span><span> </span><span>OnlyOccurenceDisables</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>                          
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StaysEnabledHelp</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"enabled cfg msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg = exec ! n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length exec"</span></span></span><span>    
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ i . i ≥ n ∧ i &lt; (length exec - 1) ∧ enabled (exec ! i) msg 
  ⟶ msg = (trace ! i) ∨ (enabled (exec ! (i+1)) msg)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length exec - 1"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf i) msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (execConf (i + 1)) msg"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg = (trace ! i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>StaysEnabledStep</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.right_neutral</span><span> </span><span>add_strict_mono</span><span> </span><span>le_add_diff_inverse2</span><span>
</span><span>        </span><span>nat_neq_iff</span><span> </span><span>notEmpty</span><span>  </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>StaysEnabled</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>En</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cfg = exec ! n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n &lt; length exec"</span></span></span><span>   
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg ∨ (∃ i . i ≥ n ∧ i &lt; (length exec - 1) 
  ∧ msg = trace ! i )"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NotEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (last exec) msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last exec = exec ! (length exec - 1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_conv_nth</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>notEmpty</span><span> </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ l . l ≥ n ∧ last exec = exec ! l ∧ l = length exec - 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ≥ n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last exec = exec ! l"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"l = length exec - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ i . i ≥ n ∧ i &lt; (length exec - 1) ∧ msg = trace ! i )"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Ass</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬ (∃i≥n. i &lt; length exec - 1 ∧ msg = execMsg i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Not</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. i &lt; n ∨ i ≥ length exec - 1 ∨ msg ≠ execMsg i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>leI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i. i ≥ n ∧ i ≤ length exec - 1 ⟶ enabled (exec ! i) msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ length exec - 1"</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (execConf i) msg"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StaysEnabledHelp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>Ass</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>Suc_le_lessD</span><span> </span><span>le_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NotEnabled</span><span> </span><span>L</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment">― ‹end of locale Execution›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Expanding executions to longer executions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>expandExecutionStep</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>CfgIsReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(last exec') ⊢ msg ↦ cMsg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ExecIsExecution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec' trace'"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ exec'' trace''. (execution trans sends start exec'' trace'') 
  ∧ (prefixList exec' exec'') 
  ∧ (prefixList trace' trace'') 
  ∧ (last exec'') = cMsg 
  ∧ (last trace'' = msg)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>execMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execMsg = exec' @ [cMsg]"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>traceMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"traceMsg = trace' @ [msg]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecMsgEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; ((length execMsg) - 1) . execMsg ! i = exec'!i "</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>TraceMsgEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; ((length traceMsg) - 1) . traceMsg!i = trace'!i"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>traceMsg_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecLen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(length execMsg) ≥ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lessLessExec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i . i &lt; (length exec') ⟶ i &lt; (length execMsg )"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecLenTraceLen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec'- 1 = length trace'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>execution.length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lessLessTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i . i &lt; (length exec' - 1) ⟶ i &lt; (length trace')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecLenTraceLen</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Exec'Len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec' ≥ 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>execution.notEmpty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd exec' = hd execMsg "</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execMsg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>hd_append2</span><span> </span><span>length_0_conv</span><span> </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial (hd exec')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>execution.base</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecInit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial (hd execMsg)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecMsgLen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length execMsg - 1 = length traceMsg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecLenTraceLen</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execMsg_def</span><span> </span><span>traceMsg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span>metis</span><span> </span><span>Exec'Len</span><span> </span><span>Suc_pred</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>       </span><span>not_one_le_zero</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExecSteps</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length exec' - 1 .
    ((exec' ! i)  ⊢ trace' ! i ↦ (exec' ! (i + 1)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>execution.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length execMsg - 1. 
    ((execMsg ! i) ⊢ traceMsg ! i ↦ (execMsg ! (i + 1)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execMsg_def</span><span> </span><span>traceMsg_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IlessLen</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i &lt; (length exec')"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((exec' @ [cMsg]) ! i) ⊢ ((trace' @ [msg]) ! i) 
      ↦ ((exec' @ [cMsg]) ! (Suc i))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i &lt; (length exec') - 1)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IlessLen1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i &lt; (length exec') - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((exec' ! i)  ⊢ trace' ! i ↦ (exec' ! (i + 1)))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecSteps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IlessLen1</span><span> </span><span>ExecMsgEq</span><span> </span><span>lessLessExec</span><span> </span><span>execMsg_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((exec' @ [cMsg]) ! i) ⊢ ((trace') ! i) 
        ↦ ((exec' @ [cMsg]) ! (Suc i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((exec' @ [cMsg]) ! i) ⊢ ((trace' @ [msg]) ! i) 
        ↦ ((exec' @ [cMsg]) ! (Suc i))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IlessLen1</span><span> </span><span>TraceMsgEq</span><span> </span><span>lessLessTrace</span><span> </span><span>traceMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IlessLen</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IEqLen1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i = (length exec') - 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((exec' @ [cMsg]) ! i) ⊢ ((trace' @ [msg]) ! i) 
        ↦ ((exec' @ [cMsg]) ! (Suc i))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>execMsg_def</span><span> </span><span>traceMsg_def</span><span>  </span><span>CfgIsReachable</span><span> </span><span>Exec'Len</span><span> 
</span><span>               </span><span>ExecLenTraceLen</span><span> </span><span>ExecMsgEq</span><span> </span><span>ExecMsgLen</span><span> </span><span>IlessLen</span><span>   
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_eq_plus1_left</span><span> </span><span>last_conv_nth</span><span> 
</span><span>           </span><span>le_add_diff_inverse</span><span> </span><span>length_append</span><span> </span><span>less_nat_zero_code</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>           </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>isExecution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start execMsg traceMsg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecLen</span><span> </span><span>ExecMsgLen</span><span> </span><span>ExecInit</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span> </span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec' execMsg"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execMsg_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>TailIsPrefixList</span><span> </span><span>not_Cons_self2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace' traceMsg"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>traceMsg_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>TailIsPrefixList</span><span> </span><span>not_Cons_self2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execMsg_def</span><span> </span><span>traceMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_snoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>expandExecutionReachable</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cfgLast</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>CfgIsReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (cfgLast) cfg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ExecIsExecution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec trace"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ExecLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfgLast = last exec"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace'. (execution trans sends start exec' trace') 
  ∧ ((prefixList exec exec' 
    ∧ prefixList trace trace') 
    ∨ (exec = exec' ∧ trace = trace')) 
  ∧ (last exec') = cfg"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CfgIsReachable</span><span>  </span><span>ExecIsExecution</span><span> </span><span>ExecLast</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cfgLast</span><span> </span><span>cfg</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg</span><span> </span><span>cfg3</span><span> </span><span>exec'</span><span> </span><span>trace'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(last exec') ⊢ msg ↦ cfg3"</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec' trace'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec'' trace''. (execution trans sends start exec'' trace'') 
    ∧ (prefixList exec' exec'') 
    ∧ (prefixList trace' trace'') ∧ (last exec'') = cfg3 
    ∧ (last trace'') = msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>expandExecutionStep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span>  </span><span>exec''</span><span> </span><span>trace''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>NewExec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec'' trace''"</span></span></span><span> 
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"prefixList exec' exec''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace' trace''"</span></span></span><span> 
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"last exec'' = cfg3"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prefixLists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'"</span></span></span><span> 
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"prefixList trace trace'"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prefixLists</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec''"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>prefixLists</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefixList trace trace''"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec'' trace'' .
          execution trans sends start exec'' trace'' ∧
          ((prefixList exec exec'' ∧ prefixList trace trace'') 
          ∨ (exec = exec'' ∧ trace = trace'')) ∧
          last exec'' = cfg3"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg</span><span> </span><span>cfg3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(last exec) ⊢ msg ↦ cfg3"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec trace"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃exec' trace'. execution trans sends start exec' trace' ∧
       (prefixList exec exec' ∧ prefixList trace trace' 
        ∨ exec = exec' ∧ trace = trace') ∧ last exec' = cfg3"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>expandExecutionStep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>expandExecution</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>cfg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cfgLast</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>CfgIsReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable (last exec) msg cfg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ExecIsExecution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec trace"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace'. (execution trans sends start exec' trace') 
  ∧ (prefixList exec exec') 
  ∧ (prefixList trace trace') ∧ (last exec') = cfg 
  ∧ (msg ∈ set (drop (length trace) trace'))"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CfgIsReachable</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span>c''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last exec) c'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c' ⊢ msg ↦ c''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c'' cfg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stepReachable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ExecIsExecution</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace' .
    execution trans sends start exec' trace' ∧
    ((prefixList exec exec' ∧ prefixList trace trace') 
    ∨ (exec = exec' ∧ trace = trace')) ∧
    last exec' = c'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>expandExecutionReachable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span>  </span><span>exec'</span><span> </span><span>trace'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Exec'</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec' trace'"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(prefixList exec exec' ∧ prefixList trace trace') 
      ∨ (exec = exec' ∧ trace = trace')"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"last exec' = c'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Exec'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Exec'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec'' trace'' . 
    execution trans sends start exec'' trace'' ∧
    prefixList exec' exec'' ∧ prefixList trace' trace'' 
    ∧ last exec'' = c'' ∧ last trace'' = msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>expandExecutionStep</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>exec''</span><span> </span><span>trace''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Exec''</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec'' trace''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"prefixList exec' exec''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace' trace''"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"last exec'' = c''"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last trace'' = msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PrefixLists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'' ∧ prefixList trace trace''"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec = exec' ∧ trace = trace'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Exec''</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'' ∧ prefixList trace trace''"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Exec'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Prefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"prefixList trace trace'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Prefix</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Exec''</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec''"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Prefix</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Exec''</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'' 
      ∧ prefixList trace trace''"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Exec''</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgInTrace''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg ∈ set (drop (length trace) trace'')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>PrefixListMonotonicity</span><span> </span><span>drop_eq_Nil</span><span> </span><span>last_drop</span><span> 
</span><span>      </span><span>last_in_set</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Exec''</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Exec''</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec''' trace''' .
    execution trans sends start exec''' trace''' ∧
    ((prefixList exec'' exec''' ∧ prefixList trace'' trace''') 
    ∨ (exec'' = exec''' ∧ trace'' = trace''')) ∧
    last exec''' = cfg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>expandExecutionReachable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>exec'''</span><span> </span><span>trace'''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Exec'''</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec''' trace'''"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(prefixList exec'' exec''' ∧ prefixList trace'' trace''') 
    ∨ (exec'' = exec''' ∧ trace'' = trace''')"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"last exec''' = cfg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec''' ∧ prefixList trace trace''' 
    ∧ msg ∈ set (drop (length trace) trace''')"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec'' = exec''' ∧ trace'' = trace'''"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PrefixLists</span><span> </span><span>MsgInTrace''</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec''' ∧ prefixList trace trace''' 
    ∧ msg ∈ set (drop (length trace) trace''')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Exec'''</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Prefix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec'' exec'''"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"prefixList trace'' trace'''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Prefix</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>PrefixLists</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'''"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Prefix</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>PrefixLists</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec''' 
      ∧ prefixList trace trace'''"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg ∈ set (drop (length trace) trace''')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Prefix</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>PrefixLists</span><span> </span><span>MsgInTrace''</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>PrefixListHasTail</span><span> </span><span>append_eq_conv_conj</span><span> 
</span><span>         </span><span>drop_take</span><span> </span><span>rev_subsetD</span><span> </span><span>set_take_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Exec'''</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Exec'''</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinite and fair executions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Völzer does not give much attention to the definition of the
  infinite executions. We derive them from finite executions by considering
  infinite executions to be infinite sequence of finite executions increasing
  monotonically w.r.t. the list prefix relation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>infiniteExecution</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ (('p, 'v, 's) configuration list)) 
  ⇒ (nat ⇒ (('p, 'v) message list)) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"infiniteExecution fe ft ≡
    ∀ n . execution trans sends start (fe n) (ft n) ∧ 
      prefixList (fe n) (fe (n+1)) ∧
      prefixList (ft n) (ft (n+1))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>correctInfinite</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ (('p, 'v, 's) configuration list)) 
  ⇒ (nat ⇒ (('p, 'v) message list)) ⇒ 'p ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"correctInfinite fe ft p ≡ 
    infiniteExecution fe ft
    ∧ (∀ n . ∀ n0 &lt; length (fe n). ∀ msg .(enabled ((fe n) ! n0) msg) 
    ∧ isReceiverOf p msg 
    ⟶ (∃ msg' . ∃ n' ≥ n . ∃ n0' ≥ n0 .isReceiverOf p msg' 
    ∧ n0' &lt; length (fe n') ∧ (msg' = ((ft n') ! n0'))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asynchronousSystem</span><span class="delimiter">)</span><span> </span><span>fairInfiniteExecution</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ (('p, 'v, 's) configuration list)) 
  ⇒ (nat ⇒ (('p, 'v) message list)) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fairInfiniteExecution fe ft ≡
    infiniteExecution fe ft
    ∧ (∀ n . ∀ n0 &lt; length (fe n). ∀ p . ∀ msg . 
      ((enabled ((fe n) ! n0) msg) 
        ∧ isReceiverOf p msg ∧ correctInfinite fe ft p ) 
      ⟶ (∃ n' ≥ n . ∃ n0' ≥ n0 . n0' &lt; length (ft n') 
        ∧ (msg = ((ft n') ! n0'))))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FLPSystem">
<div class="head"><h1>Theory FLPSystem</h1>
<span class="command">theory</span> <span class="name">FLPSystem</span><br/>
<span class="keyword">imports</span> <a href="AsynchronousSystem.html"><span class="name">AsynchronousSystem</span></a> <a href="ListUtilities.html"><span class="name">ListUtilities</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹FLPSystem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{FLPSystem} extends \file{AsynchronousSystem} with concepts of consensus
  and decisions. It develops a concept of non-uniformity regarding pending
  decision possibilities, where non-uniform configurations can always
  reach other non-uniform ones.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FLPSystem</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AsynchronousSystem</span><span> </span><span>ListUtilities</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Locale for the FLP consensus setting›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>flpSystem</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>asynchronousSystem</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span>    
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒'s"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sends</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ ('p, 'v) message multiset"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finiteProcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite Proc"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>minimalProcs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card Proc ≥ 2"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finiteSends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {v. v ∈# (sends p s m)}"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>noInSends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sends p s m &lt;p2, inM v&gt; = 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Decidedness and uniformity of configurations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>vDecided</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ ('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vDecided v cfg ≡ initReachable cfg ∧ (&lt;⊥, outM v&gt; ∈# msgs cfg)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>decided</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decided cfg ≡ (∃v . vDecided v cfg)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pSilDecVal</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ 'p ⇒ ('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pSilDecVal v p c ≡ initReachable c ∧ 
    (∃ c'::('p, 'v, 's) configuration . (withoutQReachable c {p} c') 
    ∧ vDecided v c')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>pSilentDecisionValues</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ ('p, 'v, 's) configuration ⇒ bool set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"val[_,_]"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val[p, c] ≡ {v. pSilDecVal v p c}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vUniform</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bool ⇒ ('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vUniform v c ≡ initReachable c ∧ (∀p. val[p,c] = {v})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nonUniform</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonUniform c ≡ initReachable c ∧
    ¬(vUniform False c) ∧ 
    ¬(vUniform True c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agreement, validity, termination›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Völzer defines consensus in terms of the classical notions
  of agreement, validity, and termination. The proof then mostly applies a
  weakened notion of termination, which we refer to as ,,pseudo termination''.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>agreement</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"agreement c ≡ 
    (∀v1. (&lt;⊥, outM v1&gt; ∈# msgs c) 
      ⟶ (∀v2. (&lt;⊥, outM v2&gt; ∈# msgs c) 
        ⟷ v2 = v1))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>agreementInit</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ ('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"agreementInit i c ≡ 
    initial i ∧ reachable i c ⟶ 
      (∀v1. (&lt;⊥, outM v1&gt; ∈# msgs c) 
        ⟶ (∀v2. (&lt;⊥, outM v2&gt; ∈# msgs c) 
          ⟷ v2 = v1))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>validity</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒ ('p, 'v, 's) configuration ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"validity i c ≡
    initial i ∧ reachable i c ⟶ 
      (∀v. (&lt;⊥, outM v&gt; ∈# msgs c) 
        ⟶ (∃p. (&lt;p, inM v&gt; ∈# msgs i)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  The termination concept which is implied by the concept of "pseudo-consensus"
  in the paper.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>terminationPseudo</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p, 'v, 's) configuration ⇒ 'p set ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"terminationPseudo t c Q ≡ ((initReachable c ∧ card Q + t ≥ card Proc) 
    ⟶ (∃c'. qReachable c Q c' ∧ decided c'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositions about decisions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  For every process \var{p} and every configuration that is reachable from an
  initial configuration (i.e. \isb{initReachable} \var{c}) we have
  $\var{val(p,c)} \neq \emptyset$.

  This follows directly from the definition of \var{val} and the definition of
  \isb{terminationPseudo}, which has to be assumed to ensure that there is a
  reachable configuration that is decided.
  
  \voelzer{Proposition 2(a)}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DecisionValuesExist</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Termination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c"</span></span></span><span>      
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val[p,c] ≠ {}"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Termination</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(initReachable c ∧ card Proc ≤ card (UNIV - {p}) + 1) 
      ⟶ (∃c'. qReachable c (UNIV-{p}) c' ∧ initReachable c' 
      ∧ (∃v. 0 &lt; msgs c' &lt;⊥, outM v&gt;))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>terminationPseudo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Reachable</span><span> </span><span>minimalProcs</span><span> </span><span>finiteProcs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c'. qReachable c (UNIV - {p}) c' ∧ initReachable c' 
    ∧ (∃v. 0 &lt; msgs c' &lt;⊥, outM v&gt;)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>terminationPseudo_def</span><span> </span><span>initReachable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pSilDecVal_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Reachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  The lemma \isb{DecidedImpliesUniform} proves that every \isb{vDecided}
  configuration \var{c} is also \isb{vUniform}. Völzer claims that this
  follows directly from the definitions of \isb{vDecided} and \isb{vUniform}.
  But this is not quite enough: One must also assume \isb{terminationPseudo}
  and \isb{agreement} for all reachable configurations.

  \voelzer{Proposition 2(b)}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DecidedImpliesUniform</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>AllAgree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfg . reachable c cfg ⟶ agreement cfg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Termination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>VDec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vDecided v c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vUniform v c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllAgree</span><span> </span><span>VDec</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>agreement_def</span><span> </span><span>vUniform_def</span><span> </span><span>pSilDecVal_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>Agree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀cfg. reachable c cfg ⟶
      (∀v1. 0 &lt; msgs cfg &lt;⊥, outM v1&gt; 
      ⟶ (∀v2. (0 &lt; msgs cfg &lt;⊥, outM v2&gt;) = (v2 = v1)))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>vDec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c ∧ 0 &lt; msgs c &lt;⊥, outM v&gt;"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(∀p. {v. ∃c'. qReachable c (Proc - {p}) c' ∧ initReachable c' ∧ 
      0 &lt; msgs c' &lt;⊥, outM v&gt;} = {v})"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Termination</span><span> </span><span>DecisionValuesExist</span><span> </span><span>vDec</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NotEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{v. ∃c'. qReachable c (UNIV - {p}) c' 
      ∧ initReachable c' ∧ 0 &lt; msgs c' &lt;⊥, outM v&gt;} ≠ {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pSilDecVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ u . u ∈ {v. ∃c'. qReachable c (UNIV - {p}) c' 
      ∧ initReachable c' ∧ 0 &lt; msgs c' &lt;⊥, outM v&gt;} ⟶ (u = v)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span> </span><span>c'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable c (UNIV - {p}) c'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c c'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>QReachImplReach</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>VDec</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Msg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c &lt;⊥, outM v&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Reach</span><span> </span><span>NoOutMessageLoss</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"msgs c &lt;⊥, outM v&gt; ≤ msgs c' &lt;⊥, outM v&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Msg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>VMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c' &lt;⊥, outM v&gt;"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoOutMessageLoss</span><span> </span><span>Reach</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c' &lt;⊥, outM u&gt;"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Agree</span><span> </span><span>VMsg</span><span> </span><span>Reach</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u = v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" {v. ∃c'. qReachable c (UNIV - {p}) c' ∧ initReachable c' ∧ 
      0 &lt; msgs c' &lt;⊥, outM v&gt;} = {v}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotEmpty</span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>NonUniformImpliesNotDecided</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ cfg . reachable c cfg ⟶ agreement cfg"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nonUniform c"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vDecided v c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DecidedImpliesUniform</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>      
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  All three parts of Völzer's Proposition 3 consider a single step from an
  arbitrary \isb{initReachable} configuration \var{c} with a message
  $\var{msg}$ to a succeeding configuration \var{c'}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  The silent decision values of a process which is not active in a step only
  decrease or stay the same.
  
  This follows directly from the definitions and the transitivity of the
  reachability properties \isb{reachable} and \isb{qReachable}.

  \voelzer{Proposition 3(a)}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InactiveProcessSilentDecisionValuesDecrease</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>c</span><span> </span><span>c'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p ≠ q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ⊢ msg ↦ c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initReachable c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val[q,c'] ⊆ val[q,c]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pSilDecVal_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>cfg'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>Msg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs cfg' &lt;⊥, outM x&gt;"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>Cfg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable c' (Proc - {q}) cfg'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>initReachable_def</span><span> </span><span>reachable.simps</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cfg'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg'</span><span> </span><span>initReachable_def</span><span> </span><span>QReachImplReach</span><span class="delimiter">[</span><span>of</span><span> </span><span>c'</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Proc - {q})"</span></span></span><span> </span><span>cfg'</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>ReachableTrans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ Proc - {q}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable c (Proc - {q}) c'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>qReachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable c (Proc - {q}) cfg'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg'</span><span> </span><span>QReachableTrans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Msg</span><span> </span><span>Init</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃c'a. qReachable c (Proc - {q}) c'a 
      ∧ initReachable c'a ∧ 
      0 &lt; msgs c'a &lt;⊥, outM x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  ...while the silent decision values of the process which is active in
  a step may only increase or stay the same.
  
  This follows as stated in \cite{Voelzer} from the \emph{diamond property}
  for a reachable configuration and a single step, i.e. \isb{DiamondTwo},
  and in addition from the fact that output messages cannot get lost, i.e.
  \isb{NoOutMessageLoss}.

  \voelzer{Proposition 3(b)}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ActiveProcessSilentDecisionValuesIncrease</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>c</span><span> </span><span>c'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p = q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ⊢ msg ↦ c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initReachable c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] ⊆ val[q,c']"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pSilDecVal_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>initReachable_def</span><span> </span><span>reachable.simps</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>cv</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Cv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable c (Proc - {q}) cv"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cv"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs cv &lt;⊥, outM x&gt;"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c'a. (cv ⊢ msg ↦ c'a) ∧ qReachable c' (Proc - {q}) c'a"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DiamondTwo</span><span> </span><span>Cv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cv ⊢ msg ↦ c'')"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"qReachable c' (Proc - {q}) c''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cv</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>initReachable_def</span><span> </span><span>reachable.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cv c''"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C''</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>reachable.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cv &lt;⊥, outM x&gt; ≤ msgs c'' &lt;⊥, outM x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoOutMessageLoss</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c'' &lt;⊥, outM x&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c'a. qReachable c' (Proc - {q}) c'a  
    ∧ initReachable c'a ∧ 0 &lt; msgs c'a &lt;⊥, outM x&gt;"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C''</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  As a result from the previous two propositions, the silent decision values
  of a process cannot go from {0} to {1} or vice versa in a step.

  This is a slightly more generic version of Proposition 3 (c) from
  \cite{Voelzer} since it is proven for both values, while Völzer is only
  interested in the situation starting with $\var{val(q,c) = \{0\}}$.

  \voelzer{Proposition 3(c)}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SilentDecisionValueNotInverting</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>p</span><span> </span><span>q</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>c</span><span> </span><span>c'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>Val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] = {v}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Step</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"c ⊢ msg ↦ c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val[q,c'] ≠ {¬ v}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = q"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c'] ⊆ val[q,c]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> </span><span>Rec</span><span> </span><span>InactiveProcessSilentDecisionValuesDecrease</span><span> </span><span>Init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Val</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c'] ≠ {¬ v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] ⊆ val[q,c']"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> </span><span>Rec</span><span> </span><span>ActiveProcessSilentDecisionValuesIncrease</span><span> </span><span>Init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Val</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c'] ≠ {¬ v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Towards a proof of FLP›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  There is an \isb{initial} configuration that is \isb{nonUniform} under
  the assumption of \isb{validity}, \isb{agreement} and \isb{terminationPseudo}.

  The lemma is used in the proof of the main theorem to construct the
  \isb{non\-Uni\-form} and \isb{initial} configuration that leads to the
  final contradiction.

  \voelzer{Lemma 1}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InitialNonUniformCfg</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Termination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Validity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i c . validity i c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Agreement</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i c . agreementInit i c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ cfg . initial cfg ∧ nonUniform cfg"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = card Proc"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ procList::('p list). length procList = n ∧ set procList = Proc 
    ∧ distinct procList"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finiteProcs</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_card</span><span> </span><span>finite_distinct_list</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>procList</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>ProcList</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length procList = n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set procList = Proc"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"distinct procList"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllPInProclist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. ∃i&lt;n. procList ! i = p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ProcList</span><span> </span><span>N</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set procList = Proc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length procList = card Proc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ set procList"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ProcList</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Asm</span><span> </span><span>in_set_conv_nth</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i&lt;card Proc. procList ! i = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NGr0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span> </span><span>finiteProcs</span><span> </span><span>minimalProcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initMsg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p, 'v) message ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initMsg ind m = (if ∃p. m = &lt;p, inM (∃i&lt;ind. procList!i = p)&gt; then 1 else 0)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ind</span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>initCfgList</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initCfgList = map (λind. ⦇states = start, msgs = initMsg ind⦈) [0..&lt;(n+1)]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitCfgLength</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length initCfgList = n + 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitCfgNonEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initCfgList ≠ []"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>InitCfgStart</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀c ∈ set initCfgList. states c = start)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitCfgSet</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set initCfgList = 
    {x. ∃ind &lt; n+1. x = ⦇states = start, msgs = initMsg ind⦈}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ind</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind &lt; n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃inda&lt;Suc n. inda = ind ∧ initMsg ind = initMsg inda"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃inda&lt;Suc n. initMsg ind = initMsg inda"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ind</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Asm</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦇states = start, msgs = initMsg ind⦈ ∉ (λind::nat. ⦇states = start, msgs = initMsg ind⦈) ` {0..&lt;n}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"ind &lt; Suc n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind ≥ n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ind = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initMsg ind = initMsg n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitInitial</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c ∈ set initCfgList . initial c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initial_def</span><span> </span><span>initCfgList_def</span><span> </span><span>initMsg_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitCfgStart</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>InitCfgSet</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitInitReachable</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ c ∈ set initCfgList . initReachable c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initReachable_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c0 = initCfgList ! 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c0 = ⦇ states = start, msgs = initMsg 0 ⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitCfgLength</span><span> </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgC0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs c0 = (λm. if ∃p. m = &lt;p, inM False&gt; then 1 else 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initMsg_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cN</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cN = initCfgList ! n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cN = ⦇ states = start, msgs = initMsg n⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitCfgLength</span><span> </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span class="string"><span class="delete"><span class="delete">"n+1"</span></span></span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgCN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cN = (λm. if ∃p. m = &lt;p, inM True&gt; then 1 else 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initMsg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllPInProclist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C0NotCN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c0 ≠ cN"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c0 = cN"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>StrangeEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λm::('p, 'v) message.
        if ∃p. m = &lt;p, inM False&gt; then 1 else 0 :: nat) =
      (λm. if ∃p. m = &lt;p, inM True&gt; then 1 else 0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitCfgLength</span><span> </span><span>N</span><span> </span><span>minimalProcs</span><span> </span><span>MsgC0</span><span> </span><span>MsgCN</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c0_def</span><span> </span><span>cN_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>message.inject</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C0NAreUniform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ cX . (cX = c0) ∨ (cX = cN) 
                      ⟹ vUniform (cX = cN) cX"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cX</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>xIs0OrN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(cX = c0) ∨ (cX = cN)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xInit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial cX"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitCfgLength</span><span> </span><span>InitCfgSet</span><span> </span><span>set_conv_nth</span><span class="delimiter">[</span><span>of</span><span> </span><span>initCfgList</span><span class="delimiter">]</span><span> </span><span>xIs0OrN</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c0_def</span><span> </span><span>cN_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>InitInitial</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Validity</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>COnlyReachesOneDecision</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀ c . reachable cX c ∧ decided c ⟶ (vDecided (cX = cN) c)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>validity_def</span><span> </span><span>initReachable_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span>cfg0</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>        </span><span>Validity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀i c. ((initial i) ∧ (reachable i c)) ⟶
          (∀v. (0 &lt; msgs c (&lt;⊥, outM v&gt;)) 
          ⟶ (∃p. (0 &lt; msgs i (&lt;p, inM v&gt;)))))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>OutMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c &lt;⊥, outM v&gt;"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>InitCXReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cX c"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c &lt;⊥, outM (cX = cN)&gt;"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xIs0OrN</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (cX = cN)"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ≠ (cX = cN)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vDef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (cX ≠ cN)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Validity</span><span> </span><span>InitCXReachable</span><span> </span><span>OutMsg</span><span> </span><span>xInit</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExistMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. (0 &lt; msgs cX (&lt;p, inM (cX ≠ cN)&gt;))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>initMsg_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xIs0OrN</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>MsgC0</span><span> </span><span>MsgCN</span><span> </span><span>C0NotCN</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs c &lt;⊥, outM cX = cN&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitRInitC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cX"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xInit</span><span> </span><span>InitialIsInitReachable</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NoWrongDecs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ v p cc::('p, 'v, 's) configuration.
      qReachable cX (Proc - {p}) cc ∧ initReachable cc 
      ∧ 0 &lt; msgs cc &lt;⊥, outM v&gt; 
        ⟹ v = (cX = cN)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span>p</span><span> </span><span>cc</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cX (Proc - {p}) cc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cc"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs cc &lt;⊥, outM v&gt;"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cX cc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decided cc"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>QReachImplReach</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(vDecided (cX ≠ cN) cc)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>COnlyReachesOneDecision</span><span> </span><span>Agreement</span><span> </span><span>Asm</span><span> </span><span>C0NotCN</span><span> </span><span>xInit</span><span> </span><span>xIs0OrN</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>agreementInit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Asm</span><span> </span><span>C0NotCN</span><span> </span><span>xIs0OrN</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = (cX = cN)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ExRightDecs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. ∃cc. qReachable (cX) (Proc - {p}) cc
      ∧ initReachable cc ∧ 0 &lt; msgs cc &lt;⊥, outM (cX = cN)&gt;"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cc::('p, 'v, 's) configuration.
           qReachable cX (Proc - {p}) cc ∧ initReachable cc 
           ∧ (0::nat) &lt; msgs cc &lt;⊥, outM cX = cN&gt;"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Termination</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cX"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Proc - {p}"</span></span></span><span class="delimiter">]</span><span> </span><span>finiteProcs</span><span> </span><span>minimalProcs</span><span> 
</span><span>          </span><span>InitRInitC</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>terminationPseudo_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cc</span><span> </span><span>v</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>          </span><span>Asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cX"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable (cX) (Proc - {p}) cc"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"initReachable cc"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs cc &lt;⊥, outM v&gt;"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>COnlyReachesOneDecision</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cc"</span></span></span><span class="delimiter">]</span><span> </span><span>QReachImplReach</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs cc &lt;⊥, outM cX = cN&gt;"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Asm</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cc::('p, 'v, 's) configuration. 
            qReachable cX (Proc - {p}) cc
            ∧ initReachable cc ∧ (0::nat) &lt; msgs cc &lt;⊥, outM cX = cN&gt;"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ZeroinPSilent</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p v . v ∈ val[p, cX] ⟷ v = (cX = cN)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ val[p, cX] ⟷ v = (cX = cN)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pSilDecVal_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitRInitC</span><span> </span><span>xIs0OrN</span><span> </span><span>C0NotCN</span><span> </span><span>NoWrongDecs</span><span> </span><span>ExRightDecs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vUniform (cX = cN) cX"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitRInitC</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vUniform_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>
</span><span>    </span><span>C0Is0Uniform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vUniform False c0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>CNNot0Uniform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ vUniform False cN"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C0NAreUniform</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vUniform_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C0NotCN</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ j &lt; n. vUniform False (initCfgList ! j) 
    ∧ ¬(vUniform False (initCfgList ! Suc j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>c0_def</span><span> </span><span>cN_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NatPredicateTippingPoint</span><span>
</span><span>      </span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. vUniform False (initCfgList ! x)"</span></span></span><span class="delimiter">]</span><span> </span><span>NGr0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>J</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; n"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"vUniform False (initCfgList ! j)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"¬(vUniform False (initCfgList ! Suc j))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pJ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pJ = procList ! j"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cJ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ = initCfgList ! j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>cJDef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ = ⦇ states = start, msgs = initMsg j⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>InitCfgLength</span><span> </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"j- 1"</span></span></span><span> </span><span>1</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n + 1"</span></span></span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgCJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ = (λm::('p, 'v) message.
    if ∃p::'p. m = &lt;p, inM ∃i&lt;j. procList ! i = p&gt; then 1::nat
    else (0::nat))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initMsg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllPInProclist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cJ1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ1 = initCfgList ! (Suc j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>cJ1Def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ1 = ⦇ states = start, msgs = initMsg (Suc j)⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>InitCfgLength</span><span> </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"j"</span></span></span><span> </span><span>1</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>nth_map_upt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"j + 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n + 1"</span></span></span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initCfgList_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgCJ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ1 = (λm::('p, 'v) message.
    if ∃p::'p. m = &lt;p, inM ∃i&lt;(Suc j). procList ! i = p&gt; then 1::nat
    else (0::nat))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>initMsg_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllPInProclist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CJ1Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial cJ1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitInitial</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>cJ1</span><span class="delimiter">]</span><span>  </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>InitCfgLength</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cJ1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>CJ1InitR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cJ1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitialIsInitReachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ValPj0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"False ∈ val[pJ, cJ]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cJ_def</span><span> </span><span>vUniform_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cc. vDecided False cc ∧ withoutQReachable cJ {pJ} cc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pSilDecVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cc</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>CC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vDecided False cc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cJ {pJ} cc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q. qReachable cJ Q cc ∧ Q = Proc - {pJ}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ccQ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>CCQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cJ ccQ cc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ccQ = Proc - {pJ}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>StatescJcJ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"states cJ = states cJ1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>cJ_def</span><span> </span><span>cJ1_def</span><span> </span><span>initCfgList_def</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>InitCfgLength</span><span> </span><span>InitCfgStart</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_mono</span><span> 
</span><span>      </span><span>less_SucI</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i . distinct procList ⟹ i&lt;j 
    ⟹ procList ! i = procList ! j ⟹ False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ProcList</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>distinct_conv_nth</span><span> </span><span>less_trans</span><span> 
</span><span>       </span><span>not_less_iff_gr_or_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ (&lt;pJ ,inM False&gt;) = 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pJ_def</span><span> </span><span>ProcList</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>MsgCJ</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Distinct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ1 (&lt;pJ ,inM True&gt;) = 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pJ_def</span><span> </span><span>ProcList</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>MsgCJ1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ (&lt;pJ ,inM True&gt;) = 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pJ_def</span><span> </span><span>ProcList</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>MsgCJ</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Distinct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ1 (&lt;pJ ,inM False&gt;) = 0"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pJ_def</span><span> </span><span>ProcList</span><span> </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>MsgCJ1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>msgsCJ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"msgsCJ' m = (if m = (&lt;pJ ,inM False&gt;) ∨ m = (&lt;pJ ,inM True&gt;) then 0 else (msgs cJ) m)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgsCJ'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgsCJ' = ((msgs cJ) -# (&lt;pJ ,inM False&gt;))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span>C</span><span> </span><span>msgsCJ'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllOther</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m . msgsCJ' m = ((msgs cJ1) -# (&lt;pJ ,inM True&gt;)) m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>B</span><span> </span><span>D</span><span> </span><span>MsgCJ1</span><span> </span><span>MsgCJ</span><span>  </span><span>J</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>N</span><span> </span><span>ProcList</span><span> </span><span>AllPInProclist</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>msgsCJ'_def</span><span> </span><span>pJ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if m = &lt;procList ! j, inM False&gt; ∨ 
        m = &lt;procList ! j, inM True&gt; then 0 else msgs cJ m) 
      = (msgs cJ1 -# &lt;procList ! j, inM True&gt;) m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = &lt;procList ! j, inM False&gt; ∨ m 
      = &lt;procList ! j, inM True&gt;"</span></span></span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (msgs cJ1 &lt;procList ! j, inM False&gt;)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D</span><span> </span><span>pJ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ1 &lt;procList ! j, inM True&gt; ≤ Suc 0"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>B</span><span> </span><span>One_nat_def</span><span> </span><span>order_refl</span><span> </span><span>pJ_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpMJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ &lt;procList ! j, inM False&gt;"</span></span></span><span> 
</span><span>                       </span><span class="string"><span class="delete"><span class="delete">"m ≠ &lt;procList ! j, inM True&gt;"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(if ∃p. m = &lt;p, inM ∃i&lt;j. procList ! i = p&gt; then 1 else 0)
           = (if ∃p. m = &lt;p, inM ∃i&lt;Suc j. procList ! i = p&gt; then 1 else 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs cJ m = msgs cJ1 m"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MsgCJ</span><span> </span><span>MsgCJ1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="comment">― ‹of AllOther›</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>MsgsCJ'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitMsgs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((msgs cJ) -# (&lt;pJ ,inM False&gt;)) 
    = ((msgs cJ1) -# (&lt;pJ, inM True&gt;))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cJ) -# (&lt;pJ ,inM False&gt;)) ∪# ({#&lt;pJ, inM True&gt;})) =
    (((msgs cJ1) -# (&lt;pJ, inM True&gt;))  ∪# ({#&lt;pJ, inM True&gt;}))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>One</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cJ1) -# (&lt;pJ, inM True&gt;)) 
    ∪# ({#&lt;pJ, inM True&gt;})) &lt;pJ, inM True&gt; = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m :: ('p, 'v) message . (msgs cJ1) m 
    = (((msgs cJ1) -# (&lt;pJ, inM True&gt;))  ∪# 
    ({#&lt;pJ, inM True&gt;})) m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cJ1) -# (&lt;pJ, inM True&gt;))  ∪# ({#&lt;pJ, inM True&gt;})) 
    = (msgs cJ1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>F</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitMsgs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cJ) -# (&lt;pJ ,inM False&gt;)) 
    ∪# ({#&lt;pJ, inM True&gt;})) = (msgs cJ1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cc'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cc' = ⦇states = (states cc),
    msgs = (((msgs cc) -# (&lt;pJ,inM False&gt;)) ∪# {# (&lt;pJ, inM True&gt;)})⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦qReachable cJ ccQ cc; ccQ = Proc - {pJ}; 
    (((msgs cJ) -# (&lt;pJ ,inM False&gt;)) ∪# ({#&lt;pJ, inM True&gt;})) 
      = (msgs cJ1); states cJ = states cJ1⟧ 
      ⟹ withoutQReachable cJ1 {pJ} ⦇states = (states cc), 
      msgs = (((msgs cc) -# (&lt;pJ,inM False&gt;)) ∪# {# (&lt;pJ, inM True&gt;)}) ⦈"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>qReachable.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Q</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>        </span><span>Assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cfg1) -#(&lt;pJ, inM False&gt;)) ∪# {# &lt;pJ, inM True&gt; })
        = msgs cJ1"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"states cfg1 = states cJ1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>CJ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ1 = ⦇states = states cfg1, 
        msgs = ((msgs cfg1) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; }⦈"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cJ1  (Proc - {pJ}) cJ1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qReachable.simps</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Assm</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cJ1 (Proc - {pJ})
        ⦇states = states cfg1, msgs = ((msgs cfg1) -# &lt;pJ, inM False&gt;) 
        ∪# {# &lt;pJ, inM True&gt; }⦈"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CJ1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>cfg3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = (Proc - {pJ})"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(((msgs cfg1) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; }) 
        = (msgs cJ1)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(states cfg1) = (states cJ1)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"Q = (Proc - {pJ}) ⟹
          (((msgs cfg1) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; }) 
            = (msgs cJ1) 
          ⟹ (states cfg1) = (states cJ1) 
          ⟹ qReachable cJ1 (Proc - {pJ})
          ⦇states = (states cfg2),
          msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cfg2</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"qReachable cJ1 (Proc - {pJ}) ⦇states = (states cfg2),
        msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 Q cfg2"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"cfg2 ⊢ msg ↦ cfg3"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∃(p::'p)∈Q. (isReceiverOf p msg)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cfg1 (Proc - {pJ}) cfg2"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"cfg2 ⊢ msg ↦ cfg3"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∃(p::'p)∈(Proc - {pJ}). (isReceiverOf p msg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p∈(Proc - {pJ})"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NotEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pJ ≠ p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UniqueReceiverOf</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pJ"</span></span></span><span class="delimiter">]</span><span> </span><span>P</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notRec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (isReceiverOf pJ msg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgNoIn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"msg ≠  &lt;pJ, inM False&gt; ∧ msg ≠  &lt;pJ, inM True&gt;"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled cfg2 msg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps.simps</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MsgEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled ⦇states = (states cfg2),
        msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) 
        ∪# {# &lt;pJ, inM True&gt; })⦈ msg"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MsgNoIn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enabled_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦇states = (states cfg2),
              msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) 
              ∪# {# &lt;pJ, inM True&gt; })⦈
                ⊢ msg ↦ ⦇states = (states cfg3),
                msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) 
                ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p'</span><span> </span><span>bool</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>MsgIn</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(msg = &lt;p', inM bool&gt;)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noInSends</span><span> </span><span>MsgIn</span><span> </span><span>MsgNoIn</span><span> </span><span>MsgEnabled</span><span> 
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇states = (states cfg2),
          msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈
            ⊢ msg ↦ ⦇states = (states cfg3),
              msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) 
              ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>bool</span><span>   
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(msg = &lt;⊥, outM bool&gt;)"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇states = (states cfg2),
          msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈
            ⊢ msg ↦ ⦇states = (states cfg3),
              msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) 
              ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps_def</span><span> </span><span>Step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>v</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(msg = &lt;p, v&gt;)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>noInSends</span><span> </span><span>MsgNoIn</span><span> </span><span>MsgEnabled</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦇states = (states cfg2),
          msgs = (((msgs cfg2) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈
            ⊢ msg ↦ ⦇states = (states cfg3),
              msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) 
              ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>            
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cfg2</span><span> </span><span>Step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"qReachable cJ1 (Proc - {pJ})
        ⦇states = (states cfg3),
          msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>          </span><span>qReachable.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cJ1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Proc - {pJ})"</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"⦇states = (states cfg3),
          msgs = (((msgs cfg3) -# &lt;pJ, inM False&gt;) 
          ∪# {# &lt;pJ, inM True&gt; })⦈"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CCQ</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CCQ</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>InitMsgs</span><span> </span><span>StatescJcJ1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CC'</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable cJ1 {pJ} ⦇states = (states cc), 
      msgs = (((msgs cc) -# (&lt;pJ,inM False&gt;)) 
      ∪# {# (&lt;pJ, inM True&gt;)}) ⦈"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>QReachImplReach</span><span> </span><span>CJ1InitR</span><span> </span><span>initReachable_def</span><span> </span><span>reachable.simps</span><span> 
</span><span>    </span><span>ReachableTrans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable ⦇states = (states cc), 
      msgs = (((msgs cc) -# (&lt;pJ,inM False&gt;)) 
      ∪# {# (&lt;pJ, inM True&gt;)}) ⦈"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CC'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False ∈ val[pJ, cJ1]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pSilDecVal_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CJ1InitR</span><span> </span><span>CC</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>select_convs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(vUniform True (cJ1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vUniform_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CJ1InitR</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform cJ1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>J</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CJ1InitR</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cJ1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CJ1Init</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  Völzer's Lemma 2 proves that for every process $p$ in the consensus setting 
  \isb{nonUniform} configurations can reach a configuration where the silent
  decision values of $p$ are True and False. This is key to the construction of
  non-deciding executions.

  \voelzer{Lemma 2}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NonUniformCanReachSilentBivalence</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> 
</span><span>  </span><span>p</span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>c</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>NonUni</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>PseudoTermination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Agree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ cfg . reachable c cfg ⟶ agreement cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"∃ c' . reachable c c' ∧ val[p,c'] = {True, False}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] = {True, False}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notEq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] ≠ {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NonUni</span><span> </span><span>PseudoTermination</span><span> </span><span>DecisionValuesExist</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q. val[q,c] ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notEP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valType</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q. val[q,c] ⊆ {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pSilDecVal_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>insertCI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] ⊆ {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>notEq</span><span> </span><span>notEP</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃b:: bool. val[p,c] = {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c] = {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NonUni</span><span> </span><span>vUniform_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>NonUni</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃q. val[q,c] ≠ {True}) ∧ (∃q. val[q,c] ≠ {False})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Bool</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b = True ∨ b = False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NonUni</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃q. val[q,c] ≠ {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] ≠ {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notE</span><span> </span><span>valType</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] = {True} ∨ val[q,c] = {False} ∨ val[q,c] = {True, False}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Bool</span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[q,c] = {¬b} ∨ val[q,c] = {b, ¬b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬b) ∈ val[q,c]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pSilDecVal_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ c'::('p, 'v, 's) configuration . (withoutQReachable c {q} c') ∧
    vDecided (¬b) c'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"withoutQReachable c {q} c'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vDecided (¬b) c'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Reach</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c c'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>QReachImplReach</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfg . reachable c' cfg ⟶ agreement cfg"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c' cfg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Reach</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable c cfg"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReachableTrans</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>c'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Agree</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agreement cfg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PseudoTermination</span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>DecidedImpliesUniform</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vUniform (¬b) c'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,c'] = {¬b}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vUniform_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Reach</span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ cfg. reachable c cfg ∧ val[p,cfg] = {True, False}"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable.induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span> </span><span>cfg3</span><span> </span><span>msg</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>IV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg1] = {b} ⟹
        val[p,cfg2] = {¬ b} ⟹
          ∃cfg::('p, 'v, 's) configuration. reachable cfg1 cfg 
          ∧ val[p,cfg] = {True, False}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>Reach</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg2 ⊢ msg ↦ cfg3"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ValCfg1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg1] = {b}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ValCfg3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg3] = {¬ b}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ValCfg1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitCfg1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cfg1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pSilDecVal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Reach</span><span> </span><span>InitCfg1</span><span> </span><span>initReachable_def</span><span> </span><span>reachable.simps</span><span> </span><span>ReachableTrans</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitCfg2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable cfg2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PseudoTermination</span><span> </span><span>DecisionValuesExist</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q. val[q,cfg2] ≠ {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valType</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀q. val[q,cfg2] ⊆ {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pSilDecVal_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>insertCI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notE</span><span> </span><span>valType</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {True} ∨ val[p,cfg2] = {False} 
        ∨ val[p,cfg2] = {True, False}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Bool</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {b} ∨ val[p,cfg2] = {¬b} 
      ∨ val[p,cfg2] = {True, False}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg::('p, 'v, 's) configuration. reachable cfg1 cfg 
      ∧ val[p,cfg] = {True, False}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {b}"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>RecOrOut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃q. isReceiverOf q msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf q msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span>Step</span><span> </span><span>InitCfg2</span><span> </span><span>SilentDecisionValueNotInverting</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg3] ≠ {¬b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ValCfg3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg::('p, 'v, 's) configuration. reachable cfg1 cfg ∧ 
        val[p,cfg] = {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Val</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {¬b} ∨ val[p,cfg2] = {True, False}"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg::('p, 'v, 's) configuration. reachable cfg1 cfg ∧ 
            val[p,cfg] = {True, False}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {¬b}"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {¬b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ValCfg1</span><span> </span><span>IV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∃cfg::('p, 'v, 's) configuration. 
          reachable cfg1 cfg ∧ val[p,cfg] = {True, False}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Val</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p,cfg2] = {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Reach</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg1 cfg2 ∧ val[p,cfg2] = {True, False}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cfg::('p, 'v, 's) configuration. 
          reachable cfg1 cfg ∧ val[p,cfg] = {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FLPTheorem">
<div class="head"><h1>Theory FLPTheorem</h1>
<span class="command">theory</span> <span class="name">FLPTheorem</span><br/>
<span class="keyword">imports</span> <a href="Execution.html"><span class="name">Execution</span></a> <a href="FLPSystem.html"><span class="name">FLPSystem</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹FLPTheorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  \file{FLPTheorem} combines the results of \file{FLPSystem} with the concept
  of fair infinite executions and culminates in showing the impossibility
  of a consensus algorithm in the proposed setting.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FLPTheorem</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Execution</span><span> </span><span>FLPSystem</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>flpPseudoConsensus</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>flpSystem</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>  </span><span>trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒'s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>sends</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's ⇒ 'v messageValue ⇒ ('p, 'v) message multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'p ⇒ 's"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Agreement</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i c . agreementInit i c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>PseudoTermination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀cc Q . terminationPseudo 1 cc Q"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Obtaining non-uniform executions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Executions which end with a \isb{nonUniform} configuration can be expanded
  to a strictly longer execution consuming a particular message.

  This lemma connects the previous results to the world of executions,
  thereby paving the way to the final contradiction. It covers a big part of
  the original proof of the theorem, i.e.\ finding the expansion to a longer
  execution where the decision for both values is still possible.
  \voelzer{constructing executions using Lemma 2}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NonUniformExecutionsConstructable</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>exec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's ) configuration list "</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>trace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>msg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('p, 'v) message"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'p</span><span>  
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>MsgEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec) msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>PisReceiverOf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>ExecIsExecution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec trace"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>NonUniformLexec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last exec)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Agree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ cfg . reachable (last exec) cfg ⟶ agreement cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace' . (execution trans sends start exec' trace') 
    ∧ nonUniform (last exec')
    ∧ prefixList exec exec' ∧ prefixList trace trace' 
    ∧ (∀ cfg . reachable (last exec') cfg ⟶ agreement cfg)
    ∧ stepReachable (last exec) msg (last exec') 
    ∧ (msg ∈ set (drop (length trace) trace'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NonUniformCanReachSilentBivalence</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NonUniformLexec</span><span> </span><span>PseudoTermination</span><span> </span><span>Agree</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C'</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"reachable (last exec) c'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"val[p,c'] = {True, False}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable (last exec) msg c'"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IsStepReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable (last exec) msg c'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace'. (execution trans sends start exec' trace') 
      ∧ prefixList exec exec' 
      ∧ prefixList trace trace' ∧ (last exec') = c' 
      ∧ msg ∈ set (drop (length trace) trace')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>expandExecution</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>exec'</span><span> </span><span>trace'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NewExec</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(execution trans sends start exec' trace')"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"prefixList exec exec'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(last exec') = c'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace trace'"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"msg ∈ set (drop (length trace) trace')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lastExecExec'Reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last exec) (last exec')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>InitReachLastExec'</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initReachable (last exec')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformLexec</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span> </span><span>initReachable_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nonUniformC'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last exec')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vUniform_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>isAgreementPreventing</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀ cfg . reachable (last exec') cfg ⟶ agreement cfg)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lastExecExec'Reachable</span><span> </span><span>Agree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NewExec</span><span> </span><span>nonUniformC'</span><span> </span><span>IsStepReachable</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NotStepReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (stepReachable (last exec) msg c')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>exec'</span><span> </span><span>trace'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NewExec</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start exec' trace'"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(prefixList exec exec' ∧ prefixList trace trace') 
      ∨ (exec = exec' ∧ trace = trace')"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"last exec' = c'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecIsExecution</span><span> </span><span>expandExecutionReachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastExecExec'Reachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last exec) (last exec')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NonUniformLexec</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitReachLastExec'</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"initReachable (last exec')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span> </span><span>initReachable_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nonUniformC'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last exec')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vUniform_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec1 trace1 . (execution trans sends start exec1 trace1) 
      ∧ nonUniform (last exec1)
      ∧ prefixList exec exec1 ∧ prefixList trace trace1 
      ∧ (∀ cfg . reachable (last exec1) cfg ⟶ agreement cfg)
      ∧ stepReachable (last exec) msg (last exec1) 
      ∧ (msg ∈ set (drop (length trace) trace1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec') msg"</span></span></span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnabledMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last exec') msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ cMsg . ((last exec') ⊢ msg ↦ cMsg )"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>msg</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>InMsg</span><span> </span><span>p'</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PisReceiverOf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgIsInMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(msg = &lt;p, inM b&gt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfgInM</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfgInM = ⦇states = λproc. (
        if proc = p then
          trans p (states (last exec') p) (Bool b)
        else states (last exec') proc),
        msgs = (((sends p (states (last exec') p) (Bool b))
              ∪# (msgs (last exec')-# msg)))⦈ "</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UniqueReceiverOf</span><span> </span><span>MsgIsInMsg</span><span> </span><span>EnabledMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"((last exec') ⊢ msg ↦ cfgInM)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ cMsg . ((last exec') ⊢ msg ↦ cMsg )"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>OutMsg</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ cMsg . ((last exec') ⊢ msg ↦ cMsg )"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PisReceiverOf</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Msg</span><span> </span><span>p'</span><span> </span><span>v'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>PisReceiverOf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MsgIsVMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(msg = &lt;p, v'&gt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>cfgVMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cfgVMsg =
          ⦇states = λproc. (
              if proc = p then
               trans p (states (last exec') p) (Value v')
               else states (last exec') proc),
            msgs = (((sends p (states (last exec') p) (Value v'))
                ∪# (msgs (last exec') -# msg )))⦈ "</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UniqueReceiverOf</span><span> </span><span>MsgIsVMsg</span><span> </span><span>EnabledMsg</span><span> </span><span>noInSends</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"((last exec') ⊢ msg ↦ cfgVMsg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ cMsg . ((last exec') ⊢ msg ↦ cMsg )"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>CMsg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"((last exec') ⊢ msg ↦ cMsg )"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>execMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execMsg = exec' @ [cMsg]"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>traceMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"traceMsg = trace' @ [msg]"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CMsg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>execMsg</span><span> </span><span>traceMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>isExecution</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start execMsg traceMsg"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ExecMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec' execMsg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace' traceMsg"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"last execMsg = cMsg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last traceMsg = msg"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>expandExecutionStep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isPrefixListExec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList exec execMsg"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ExecMsg</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isPrefixListTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList trace traceMsg"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ExecMsg</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cMsgLastReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cMsg (last execMsg)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ExecMsg</span><span> </span><span>reachable.init</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>isStepReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable (last exec) msg (last execMsg)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CMsg</span><span> </span><span>lastExecExec'Reachable</span><span>   
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stepReachable_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>InitReachLastExecMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable (last execMsg)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CMsg</span><span> </span><span>InitReachLastExec'</span><span> </span><span>cMsgLastReachable</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span> </span><span>initReachable_def</span><span> </span><span>step</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val[p, (last exec')] ⊆ val[p, cMsg]"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CMsg</span><span> </span><span>PisReceiverOf</span><span> </span><span>InitReachLastExec'</span><span>
</span><span>          </span><span>ActiveProcessSilentDecisionValuesIncrease</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"last exec'"</span></span></span><span> </span><span>msg</span><span> </span><span>cMsg</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ExecMsg</span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"val[p, (last execMsg)] = {True, False}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>InitReachLastExecMsg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isNonUniform</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last execMsg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vUniform_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last exec) (last execMsg)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lastExecExec'Reachable</span><span> </span><span>cMsgLastReachable</span><span> </span><span>CMsg</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>isAgreementPreventing</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(∀ cfg . reachable (last execMsg) cfg ⟶ agreement cfg)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Agree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ReachableTrans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg ∈ set (drop (length trace) traceMsg)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ExecMsg</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>isPrefixListTrace</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>PrefixListMonotonicity</span><span> </span><span>last_drop</span><span> </span><span>last_in_set</span><span>
</span><span>          </span><span>length_0_conv</span><span> </span><span>length_drop</span><span> </span><span>less_zeroE</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isExecution</span><span> </span><span>isNonUniform</span><span> </span><span>isPrefixListExec</span><span> 
</span><span>        </span><span>isPrefixListTrace</span><span> </span><span>isAgreementPreventing</span><span> </span><span>isStepReachable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>notEnabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (enabled (last exec') msg)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>isStepReachable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stepReachable (last exec) msg (last exec')"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MsgEnabled</span><span> </span><span>notEnabled</span><span> </span><span>lastExecExec'Reachable</span><span> </span><span>StepReachable</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NotStepReachable</span><span> </span><span>NewExec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NonUniformExecutionBase</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Cfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial cfg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start [cfg] [] 
  ∧ nonUniform (last [cfg]) 
  ∧ (∃ cfgList' msgList'.  nonUniform (last cfgList') 
    ∧ prefixList [cfg] cfgList' 
    ∧ prefixList [] msgList'
    ∧ (execution trans sends start cfgList' msgList')
     ∧ (∃ msg'. execution.minimalEnabled [cfg] [] msg' 
         ∧ msg' ∈ set msgList'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NonUniListCfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last [cfg])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AgreeCfg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfg' . 
    reachable (last [cfg]) cfg' ⟶ agreement cfg'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Agreement</span><span> </span><span>Cfg</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>agreementInit_def</span><span> </span><span>reachable.init</span><span> </span><span>agreement_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>StartExec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start [cfg] []"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ msg . execution.minimalEnabled [cfg] [] msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg</span><span> </span><span>execution.ExistImpliesMinEnabled</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enabled_def</span><span> </span><span>initial_def</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>       </span><span>last.simps</span><span> </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>msg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>MinEnabledMsg</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution.minimalEnabled [cfg] [] msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ pMin . isReceiverOf pMin msg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>StartExec</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execution.minimalEnabled_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pMin</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>PMin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf pMin msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last [cfg]) msg ∧ isReceiverOf pMin msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinEnabledMsg</span><span> </span><span>StartExec</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execution.minimalEnabled_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Enabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last [cfg]) msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf pMin msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Enabled</span><span> </span><span>StartExec</span><span> </span><span>NonUniListCfg</span><span> </span><span>PseudoTermination</span><span> </span><span>AgreeCfg'</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace' . (execution trans sends start exec' trace') 
    ∧ nonUniform (last exec')
    ∧ prefixList [cfg] exec' ∧ prefixList [] trace' 
    ∧ (∀ cfg' . reachable (last exec') cfg' ⟶ agreement cfg')
    ∧ stepReachable (last [cfg]) msg (last exec') 
    ∧ (msg ∈ set (drop (length []) trace'))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformExecutionsConstructable</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[cfg]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pMin"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"[]::('p,'v) message list"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>StartExec</span><span> </span><span>NonUniListCfg</span><span> </span><span>MinEnabledMsg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NonUniformExecutionStep</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span> </span><span>cfgList</span><span> </span><span>msgList</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial (hd cfgList)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>NonUni</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last cfgList)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Execution</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start cfgList msgList"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∃ cfgList' msgList' .
      nonUniform (last cfgList') 
      ∧ prefixList cfgList cfgList' 
      ∧ prefixList msgList msgList'
      ∧ (execution trans sends start cfgList' msgList') 
      ∧ (initial (hd cfgList'))
      ∧ (∃ msg'. execution.minimalEnabled cfgList msgList msg' 
        ∧ msg' ∈ (set (drop (length msgList ) msgList')) ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ReachImplAgree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfg . reachable (last cfgList) cfg 
    ⟶ agreement cfg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Agreement</span><span> </span><span>Init</span><span> </span><span>NonUni</span><span> </span><span>ReachableTrans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>agreementInit_def</span><span> </span><span>agreement_def</span><span> </span><span>initReachable_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ msg p. enabled (last cfgList) msg ∧ isReceiverOf p msg"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PseudoTermination</span><span> </span><span>NonUni</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∃c'. qReachable (last cfgList) Proc c' ∧ decided c'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>terminationPseudo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last cfgList) c'"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"decided c'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>QReachImplReach</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NoOut</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"0 = msgs (last cfgList) &lt;⊥, outM False&gt;"</span></span></span><span>  
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"0 = msgs (last cfgList) &lt;⊥, outM True&gt;"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUni</span><span> </span><span>ReachImplAgree</span><span> </span><span>PseudoTermination</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>NonUniformImpliesNotDecided</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(last cfgList) ≠ c'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>less_zeroE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ReachableStepFirst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>msg</span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Enabled</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled (last cfgList) msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ msg . execution.minimalEnabled cfgList msgList msg"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Init</span><span> </span><span>execution.ExistImpliesMinEnabled</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Execution</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>msg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>MinEnabledMsg</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution.minimalEnabled cfgList msgList msg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ p' . isReceiverOf p' msg'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Execution</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execution.minimalEnabled_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p' msg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Enabled'</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enabled (last cfgList) msg'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p' msg'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinEnabledMsg</span><span> </span><span>Execution</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execution.minimalEnabled_def</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ exec' trace' . (execution trans sends start exec' trace') 
    ∧ nonUniform (last exec')
    ∧ prefixList cfgList exec' ∧ prefixList msgList trace' 
    ∧ (∀ cfg . reachable (last exec') cfg ⟶ agreement cfg)
    ∧ stepReachable (last cfgList) msg' (last exec') 
    ∧ (msg' ∈ set (drop (length msgList) trace')) "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformExecutionsConstructable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Enabled'</span><span> </span><span>Execution</span><span>
</span><span>          </span><span>NonUni</span><span class="delimiter">]</span><span> </span><span>ReachImplAgree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinEnabledMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>execution.base</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Non-uniformity even when demanding fairness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Using \isb{NonUniformExecutionBase} and \isb{NonUniformExecutionStep} one can obtain
  non-uniform executions which are fair.

  Proving the fairness turned out quite cumbersome.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  These two functions construct infinite series of configurations lists
  and message lists from two extension functions. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>infiniteExecutionCfg</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒
   (('p, 'v, 's) configuration list ⇒ ('p, 'v) message list 
    ⇒ ('p, 'v, 's) configuration list) ⇒
   (('p, 'v, 's) configuration list ⇒ ('p, 'v) message list 
    ⇒('p, 'v) message list) 
  ⇒ nat
  ⇒ (('p, 'v, 's) configuration list)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>infiniteExecutionMsg</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('p, 'v, 's) configuration ⇒
   (('p, 'v, 's) configuration list ⇒ ('p, 'v) message list 
    ⇒ ('p, 'v, 's) configuration list) ⇒
   (('p, 'v, 's) configuration list ⇒ ('p, 'v) message list 
    ⇒('p, 'v) message list) 
  ⇒ nat
  ⇒ ('p, 'v) message list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"infiniteExecutionCfg cfg fStepCfg fStepMsg 0 = [cfg]"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"infiniteExecutionCfg cfg fStepCfg fStepMsg (Suc n) =
    fStepCfg (infiniteExecutionCfg cfg fStepCfg fStepMsg n) 
             (infiniteExecutionMsg cfg fStepCfg fStepMsg n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"infiniteExecutionMsg cfg fStepCfg fStepMsg 0 = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"infiniteExecutionMsg cfg fStepCfg fStepMsg (Suc n) =
    fStepMsg (infiniteExecutionCfg cfg fStepCfg fStepMsg n) 
             (infiniteExecutionMsg cfg fStepCfg fStepMsg n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FairNonUniformExecution</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>  </span><span>cfg</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>Cfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial cfg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform cfg"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ fe ft.
  (fe 0) = [cfg]
  ∧ fairInfiniteExecution fe ft
  ∧ (∀ n . nonUniform (last (fe n))
       ∧ prefixList (fe n) (fe (n+1)) 
       ∧ prefixList (ft n) (ft (n+1))
       ∧ (execution trans sends start (fe n) (ft n)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BC</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start [cfg] [] 
    ∧ nonUniform (last [cfg]) 
    ∧ (∃ cfgList' msgList'.  nonUniform (last cfgList') 
    ∧ prefixList [cfg] cfgList' 
    ∧ prefixList [] msgList'
    ∧ (execution trans sends start cfgList' msgList')
    ∧ (∃ msg'. execution.minimalEnabled [cfg] [] msg' 
       ∧ msg' ∈ set msgList'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformExecutionBase</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="comment">― ‹fStep ... a step leading to a fair execution.›</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fStepCfg</span><span> </span><span>fStepMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>FStep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfgList msgList . ∃cfgList' msgList' .
          fStepCfg cfgList msgList = cfgList' ∧
          fStepMsg cfgList msgList = msgList' ∧
          (initial (hd cfgList) ∧
          nonUniform (last cfgList) ∧
          execution trans sends start cfgList msgList ⟶ 
          (nonUniform (last (fStepCfg cfgList msgList)) 
          ∧ prefixList cfgList (fStepCfg cfgList msgList) 
          ∧ prefixList msgList (fStepMsg cfgList msgList) 
          ∧ execution trans sends start (fStepCfg cfgList msgList) 
              (fStepMsg cfgList msgList) 
          ∧ (initial (hd (fStepCfg cfgList msgList)))
          ∧ (∃ msg'. execution.minimalEnabled cfgList msgList msg' 
            ∧ msg' ∈ (set (drop (length msgList) 
                                (fStepMsg cfgList msgList))))))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformExecutionStep</span><span>
</span><span>      </span><span>PredicatePairFunctions2</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"λ cfgList msgList cfgList' msgList'. 
          (initial (hd cfgList) 
          ∧ nonUniform (last cfgList) 
          ∧ execution trans sends start cfgList msgList 
            ⟶ (nonUniform (last cfgList') 
            ∧ prefixList cfgList cfgList' 
            ∧ prefixList msgList msgList' 
            ∧ execution trans sends start cfgList' msgList'
            ∧ (initial (hd cfgList'))
            ∧ (∃ msg'. execution.minimalEnabled cfgList msgList msg' 
              ∧ msg' ∈ (set (drop (length msgList ) msgList')))))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>fe</span><span> </span><span>ft</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe = infiniteExecutionCfg cfg fStepCfg fStepMsg"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft = infiniteExecutionMsg cfg fStepCfg fStepMsg"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BasicProperties</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀n. nonUniform (last (fe n)) 
    ∧ prefixList (fe n) (fe (n + 1)) ∧ prefixList (ft n) (ft (n + 1)) 
    ∧ execution trans sends start (fe n) (ft n) 
    ∧ initial (hd (fe (n + 1))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last (fe n)) ∧
          prefixList (fe n) (fe (n + (1::nat))) 
          ∧ prefixList (ft n) (ft (n + (1::nat))) 
          ∧ execution trans sends start (fe n) (ft n) 
          ∧ initial (hd (fe (n + 1)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe 0 = [cfg]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft 0 = []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe 1 = fStepCfg (fe 0) (ft 0)"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"ft 1 = fStepMsg (fe 0) (ft 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fe_def</span><span> </span><span>ft_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BC</span><span> </span><span>FStep</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>execution.base</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fe_def</span><span> </span><span>ft_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FStep</span><span> </span><span>execution.base</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Fair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fairInfiniteExecution fe ft"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fairInfiniteExecution_def</span><span> </span><span>infiniteExecution_def</span><span> 
</span><span>      </span><span>execution_def</span><span> </span><span>flpSystem_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finiteProcs</span><span> </span><span>minimalProcs</span><span> </span><span>finiteSends</span><span> </span><span>noInSends</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>n0</span><span> </span><span>p</span><span> </span><span>msg</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n. initReachable (last (fe n)) ∧
       ¬ vUniform False (last (fe n)) ∧
       ¬ vUniform True (last (fe n)) ∧
       prefixList (fe n) (fe (Suc n)) ∧
       prefixList (ft n) (ft (Suc n)) ∧
       Suc 0 ≤ length (fe n) ∧
       length (fe n) - Suc 0 = length (ft n) ∧
       initial (hd (fe n)) ∧ 
       (∀i&lt;length (fe n) - Suc 0. ((fe n ! i) ⊢ (ft n ! i) 
       ↦ (fe n ! Suc i))) ∧ initial (hd (fe (Suc n)))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length (fe n)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enabled (fe n ! n0) msg"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p msg"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"correctInfinite fe ft p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MessageStaysOrConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ n n1 n2 msg. 
      (n1 ≤ n2 ∧ n2 &lt; length (fe n) ∧ (enabled (fe n ! n1) msg)) 
      ⟶ (enabled (fe n ! n2) msg) 
          ∨ (∃ n0' ≥ n1. n0' &lt; length (ft n) ∧ ft n ! n0' = msg)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>n1</span><span> </span><span>n2</span><span> </span><span>msg</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Ass</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≤ n2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n2 &lt; length (fe n)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe n ! n1) msg"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀index&lt;length (ft n). n1 ≤ index ⟶ ft n ! index ≠ msg"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ k ≤ n2 - n1 . 
        msgs (fe n ! n1) msg ≤ msgs (fe n ! (n1 + k)) msg"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ n2 - n1 ⟹ 
          msgs (fe n ! n1) msg ≤ msgs (fe n ! (n1 + k)) msg"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs (fe n ! n1) msg ≤ msgs (fe n ! (n1 + k)) msg"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"Suc k ≤ n2 - n1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Exec</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start (fe n) (ft n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n2 ≤ length (ft n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exec</span><span> </span><span>Ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>            </span><span>execution.length</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft n"</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>RightIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 + k ≥ n1 ∧ n1 + k &lt; length (ft n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IV</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>Step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe n ! (n1 + k)) ⊢ (ft n ! (n1 + k)) 
                      ↦ (fe n ! Suc (n1 + k))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Exec</span><span> </span><span>execution.step</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft n"</span></span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"n1 + k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n ! (n1 + k)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n ! (n1 + k + 1)"</span></span></span><span class="delimiter">]</span><span> </span><span>IV</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>Ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg ≠ (ft n ! (n1 + k))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ass</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Ass</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>IV</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>RightIndex</span><span> </span><span>Exec</span><span> 
</span><span>            </span><span>execution.length</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft n"</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs (fe n ! n1) msg ≤ msgs (fe n ! Suc (n1 + k)) msg"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Step</span><span> </span><span>OtherMessagesOnlyGrowing</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe n ! (n1 + k))"</span></span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"(ft n ! (n1 + k))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe n ! Suc (n1 + k))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span class="delimiter">]</span><span> </span><span>IV</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs (fe n ! n1) msg ≤ msgs (fe n ! n2) msg"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Ass</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe n ! n2) msg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ass</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>enabled_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gr0I</span><span> </span><span>leD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EnabledOrConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe n ! (length (fe n) - 1)) msg 
      ∨ (∃n0'≥n0. n0' &lt; length (ft n) ∧ ft n ! n0' = msg)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>MessageStaysOrConsumed</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe n) - 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EnabledOrConsumedAtLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe n)) msg ∨ 
      (∃ n0' . n0' ≥ n0 ∧ n0' &lt; length (ft n) ∧ (ft n) ! n0' = msg )"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EnabledOrConsumed</span><span> </span><span>last_conv_nth</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_0_conv</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Case2ImplThesis</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ n0' . n0' ≥ n0 ∧ n0' &lt; length (ft n) 
      ∧ ft n ! n0' = msg) 
      ⟹ (∃n'≥n. ∃n0'≥n0. n0' &lt; length (ft n') ∧ msg = ft n' ! n0')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Case1ImplThesis'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe n)) msg 
      ⟶ (∃n'≥n. ∃n0'≥ (length (ft n)). n0' &lt; length (ft n') 
          ∧ msg = ft n' ! n0')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumptionCase1ImplThesis'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe n)) msg"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n'≥n. ∃n0'≥length (ft n). n0' &lt; length (ft n') 
        ∧ msg = ft n' ! n0'"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumptionFairContr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n'≥n. ∀n0'&lt;length (ft n'). 
          length (ft n) ≤ n0' ⟶ msg ≠ ft n' ! n0'"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>firstOccSet</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"firstOccSet n = { msg1 . ∃ nMsg . 
          ∃ n1 ≤ nMsg . 
          execution.firstOccurrence (fe n) (ft n) msg1 n1 
          ∧ execution.firstOccurrence (fe n) (ft n) msg nMsg }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>AssumptionFair</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_nat_zero_code</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FirstToLast'</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ n . reachable ((fe n) ! 0) ((fe n) ! (length (fe n) - 1))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.ReachableInExecution</span><span> </span><span>BasicProperties</span><span> </span><span>execution.notEmpty</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_less</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>not_gr0</span><span> </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstToLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . reachable (hd (fe n)) (last (fe n))"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotEmpty</span><span> </span><span>hd_conv_nth</span><span> </span><span>last_conv_nth</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>length_0_conv</span><span> 
</span><span>            </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>InitToLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . initReachable (last (fe n))"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ msg n0 . ∀ n . 
          (execution.firstOccurrence (fe n) (ft n) msg n0) 
          ⟶  0 &lt; msgs (last (fe n)) msg"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span>execution.firstOccurrence_def</span><span> 
</span><span>            </span><span>enabled_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . ∀ msg' ∈ (firstOccSet n) . 
          0 &lt; msgs (last (fe n)) msg'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>firstOccSet_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . firstOccSet n ⊆ {msg. 0 &lt; msgs (last (fe n)) msg}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">,</span><span> </span><span>full_types</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FiniteMsgs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . finite (firstOccSet n)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FiniteMessages</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finiteProcs</span><span> </span><span>finiteSends</span><span class="delimiter">]</span><span> </span><span>InitToLast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FirstOccSetDecrOrConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ index . 
          (enabled (last (fe index)) msg) 
          ⟶ (firstOccSet (Suc index) ⊂ firstOccSet index 
          ∧ (enabled (last (fe (Suc index))) msg)
            ∨ msg ∈ (set (drop (length (ft index)) (ft (Suc index)))))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>index</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumptionFirstOccSetDecrOrConsumed</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe index)) msg"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"msg ∉ set (drop (length (ft index)) (ft (Suc index)))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index) ≠ []"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index ≠ []"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>not_one_le_zero</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LengthStep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft (Suc index)) &gt; length (ft index)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>PrefixListMonotonicity</span><span class="delimiter">)</span><span>              
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IPrefixList</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"∀ i::nat . prefixList (ft i) (ft (Suc i))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IPrefixListEx</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"∀ i::nat . prefixList (fe i) (fe (Suc i))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LastOfIndex</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"(fe (Suc index) ! (length (fe index) - Suc 0)) 
            = (last (fe index))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixSameOnLow</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>IPrefixListEx</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>index</span><span class="delimiter">]</span><span>
</span><span>              </span><span>NotEmpty</span><span> </span><span>LengthStep</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotConsumedIntermediate</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"∀ i::nat &lt; length (ft (Suc index)) . 
              (i ≥ length (ft index)
              ⟶ ft (Suc index) ! i ≠ msg)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFirstOccSetDecrOrConsumed</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ListLenDrop</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"¬(∃i. i &lt; length (ft (Suc index)) ∧ i ≥ length (ft index)
            ∧ msg = (ft (Suc index)) ! i)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.length</span><span> </span><span>BasicProperties</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃i. i &lt; length (fe (Suc index)) - 1 
            ∧ i ≥ length (fe index) - 1 
            ∧ msg = (ft (Suc index)) ! i)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc index"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"index"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>execution.length</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnabledIntermediate</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length (fe (Suc index)) . (i ≥ length (fe index) - 1
              ⟶ enabled (fe (Suc index) ! i) msg)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc index"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"index"</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>execution.StaysEnabled</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (fe index)"</span></span></span><span> </span><span>msg</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"length (fe index) - 1 "</span></span></span><span class="delimiter">]</span><span>
</span><span>              </span><span>AssumptionFirstOccSetDecrOrConsumed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>LastOfIndex</span><span> 
</span><span>              </span><span>MessageStaysOrConsumed</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe (Suc index)) - 1 ≥ length (fe index) - 1"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListMonotonicity</span><span> </span><span>NotEmpty</span><span> </span><span>BasicProperties</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_le_mono</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe (Suc index) 
            ! (length (fe (Suc index)) - 1)) msg"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EnabledIntermediate</span><span> </span><span>NotEmpty</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_less</span><span> </span><span>length_greater_0_conv</span><span> </span><span>zero_less_one</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>EnabledInSuc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe (Suc index))) msg"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotEmpty</span><span> </span><span>last_conv_nth</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IndexIsExec</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start (fe index) (ft index)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SucIndexIsExec</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start (fe (Suc index)) 
              (ft (Suc index))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SameCfgOnLow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length (fe index) . (fe index) ! i
            = (fe (Suc index)) ! i"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span>PrefixSameOnLow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SameMsgOnLow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i &lt; length (ft index) . (ft index) ! i
            = (ft (Suc index)) ! i"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span>PrefixSameOnLow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SmallIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ nMsg . execution.firstOccurrence
            (fe (Suc index)) (ft (Suc index)) msg nMsg 
            ⟹ nMsg &lt; length (fe index)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>-</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nMsg</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe (Suc index)) 
              (ft (Suc index)) msg nMsg"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"∃p. isReceiverOf p msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe (Suc index))) msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"nMsg &lt; length (fe (Suc index))"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (fe (Suc index) ! nMsg) msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"∀n'≥nMsg. n' &lt; length (ft (Suc index)) 
                ⟶ msg ≠ ft (Suc index) ! n'"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"nMsg ≠ 0 ⟶ ¬ enabled (fe (Suc index) ! (nMsg - 1)) 
                msg ∨ msg = ft (Suc index) ! (nMsg - 1)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>SucIndexIsExec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg &lt; length (fe index)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpSmallIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ nMsg &lt; length (fe index)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> 
</span><span>                </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_one_le_zero</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe index) &gt; 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_greater_0_conv</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nMsgNotZero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg ≠ 0"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpSmallIndex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SucCases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled ((fe (Suc index)) ! (nMsg - 1))
                msg ∨ msg = (ft (Suc index)) ! (nMsg - 1)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cond1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg - 1 ≥ length (fe index) - 1"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpSmallIndex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_le_mono</span><span> </span><span>leI</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Enabled</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe (Suc index) ! (nMsg - 1)) msg"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EnabledIntermediate</span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cond2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg - 1 ≥ length (ft index) ∧ nMsg - 1
                &lt; length (ft (Suc index))"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cond1</span><span> </span><span>execution.length</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft index"</span></span></span><span class="delimiter">]</span><span>
</span><span>                  </span><span>IndexIsExec</span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_diff_1</span><span> 
</span><span>                    </span><span>Suc_eq_plus1</span><span> </span><span>less_diff_conv</span><span> </span><span>nMsgNotZero</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NotConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index) ! (nMsg - 1) ≠ msg"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotConsumedIntermediate</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SucCases</span><span> </span><span>Enabled</span><span> </span><span>NotConsumed</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ msgInSet . msgInSet ∈ firstOccSet (Suc index)
            ⟹ msgInSet ∈ firstOccSet index"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>firstOccSet_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msgInSet</span><span> </span><span>nMsg</span><span> </span><span>n1</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumptionSubset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≤ nMsg"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe (Suc index)) 
                (ft (Suc index)) msgInSet n1"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe (Suc index)) 
                (ft (Suc index)) msg nMsg"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AssumptionSubset2</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"∃p. isReceiverOf p msgInSet"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe (Suc index))) msgInSet"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"n1 &lt; length (fe (Suc index))"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (fe (Suc index) ! n1) msgInSet"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"∀n'≥n1. n' &lt; length (ft (Suc index)) 
                  ⟶ msgInSet ≠ ft (Suc index) ! n'"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"n1 ≠ 0 ⟶ ¬ enabled (fe (Suc index) ! (n1 - 1)) 
                  msgInSet ∨ msgInSet = ft (Suc index) ! (n1 - 1)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgInSet"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"n1"</span></span></span><span class="delimiter">]</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SucIndexIsExec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"∃p. isReceiverOf p msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe (Suc index))) msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"nMsg &lt; length (fe (Suc index))"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (fe (Suc index) ! nMsg) msg"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"∀n'≥nMsg. n' &lt; length (ft (Suc index)) 
                  ⟶ msg ≠ ft (Suc index) ! n'"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"nMsg ≠ 0 ⟶ ¬ enabled (fe (Suc index) ! (nMsg - 1)) 
                  msg ∨ msg = ft (Suc index) ! (nMsg - 1)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>SucIndexIsExec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ShorterTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft index) 
                                &lt; length (ft (Suc index))"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListMonotonicity</span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FirstOccurrenceMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence 
              (fe index) (ft index) msg nMsg"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ p . isReceiverOf p msg"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe index)) msg"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFirstOccSetDecrOrConsumed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe index) ! nMsg = (fe (Suc index)) ! nMsg"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallIndex</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span>PrefixSameOnLow</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>                  </span><span>BasicProperties</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Occ4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled ((fe index) ! nMsg) msg"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OccSameMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n' ≥ nMsg . n' &lt; length (ft index) 
                ⟶ (ft index) ! n' = (ft (Suc index)) ! n'"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixSameOnLow</span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Occ5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n' ≥ nMsg . n' &lt; length (ft index) 
                ⟶ msg ≠ ((ft index) ! n')"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>ShorterTrace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg ≠ 0 ⟶ (¬ enabled ((fe index) ! 
                (nMsg - 1)) msg ∨ msg = (ft index ) ! (nMsg - 1))"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpOcc6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; nMsg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg ≠ ft index ! 
                  (nMsg - 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe index ! (nMsg - 1)) msg"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg - (Suc 0) &lt; length (fe index) - (Suc 0)"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallIndex</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>AssumpOcc6</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_eq</span><span> </span><span>diff_less_mono</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SmallIndexTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg - 1 &lt; length (ft index)"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IndexIsExec</span><span> </span><span>execution.length</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (fe (Suc index) ! (nMsg - 1)) msg 
                  ∨ msg = ft (Suc index) ! (nMsg - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>AssumpOcc6</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index) ! (nMsg - 1) 
                  = fe index ! (nMsg - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SameCfgOnLow</span><span> </span><span>SmallIndex</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index) ! (nMsg - 1) 
                  = ft index ! (nMsg - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SameMsgOnLow</span><span> </span><span>SmallIndexTrace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (fe index ! (nMsg - 1)) msg 
                  ∨ msg = ft index ! (nMsg - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpOcc6</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IndexIsExec</span><span> </span><span>Occ1</span><span> </span><span>Occ2</span><span> </span><span>SmallIndex</span><span> 
</span><span>                </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Occ4</span><span> </span><span>Occ5</span><span> </span><span>Occ6</span><span>
</span><span>                </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft index"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe index) (ft index) 
              msgInSet n1"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset2</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ1'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. isReceiverOf p msgInSet"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                 
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ3'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &lt; length (fe index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallIndex</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe index) ! n1 = (fe (Suc index)) ! n1"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Occ3'</span><span> </span><span>PrefixSameOnLow</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span class="delimiter">]</span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Occ4'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe index ! n1) msgInSet"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset2</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>OccSameMsg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n' ≥ n1 . n' &lt; length (ft index) 
                ⟶ (ft index) ! n' = (ft (Suc index)) ! n'"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixSameOnLow</span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Occ5'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n' ≥ n1. n' &lt; length (ft index) 
                ⟶ msgInSet ≠ ft index ! n'"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>ShorterTrace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe index) &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotEmpty</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_greater_0_conv</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe index) - 1 &lt; length (fe index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>diff_Suc_less</span><span class="delimiter">)</span><span>                  
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled (fe index ! (length (fe index) - 1)) msgInSet
                ∨ (∃n0'≥n1. n0' &lt; length (ft index) ∧ ft index ! n0'
                  = msgInSet)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Occ4'</span><span> </span><span>Occ3'</span><span> </span><span>MessageStaysOrConsumed</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"length (fe index) - 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgInSet"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred'</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0 &lt; length (fe index)›</span></span></span><span> 
</span><span>                  </span><span>not_le</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled ((fe index) ! (length (fe index) - 1)) 
                msgInSet"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Occ5'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Occ2'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe index)) msgInSet"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_conv_nth</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span class="delimiter">]</span><span> </span><span>NotEmpty</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Occ6'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≠ 0 ⟶ ¬ enabled (fe index ! (n1 - 1)) 
                msgInSet ∨ msgInSet = ft index ! (n1 - 1)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpOcc6'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgInSet ≠ ft index ! 
                  (n1 - 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (fe index ! (n1 - 1)) msgInSet"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 - (Suc 0) &lt; length (fe index) - (Suc 0)"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Occ3'</span><span> </span><span>AssumpOcc6'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_eq</span><span> </span><span>diff_less_mono</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>SmallIndexTrace'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 - 1 &lt; length (ft index)"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IndexIsExec</span><span> </span><span>execution.length</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (fe (Suc index) ! (n1 - 1)) msgInSet 
                  ∨ msgInSet = ft (Suc index) ! (n1 - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionSubset2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>AssumpOcc6'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index) ! (n1 - 1) 
                  = fe index ! (n1 - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SameCfgOnLow</span><span> </span><span>Occ3'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index) ! (n1 - 1) 
                  = ft index ! (n1 - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SameMsgOnLow</span><span> </span><span>SmallIndexTrace'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ enabled (fe index ! 
                  (n1 - 1)) msgInSet ∨ msgInSet = ft index ! (n1 - 1)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpOcc6'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IndexIsExec</span><span> </span><span>Occ1'</span><span> </span><span>Occ2'</span><span> </span><span>Occ3'</span><span> </span><span>Occ4'</span><span> 
</span><span>                </span><span>Occ5'</span><span> </span><span>Occ6'</span><span>
</span><span>                </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe index"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft index"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃nMsg' n1'. n1' ≤ nMsg' 
              ∧ execution.firstOccurrence (fe index) (ft index) 
                msgInSet n1' 
              ∧ execution.firstOccurrence (fe index) (ft index) 
                msg nMsg'"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FirstOccurrenceMsg</span><span> </span><span>AssumptionSubset</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ProperSubset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ msg' .msg' ∈ firstOccSet index 
            ∧ msg' ∉ firstOccSet (Suc index)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>               
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initial (hd (fe index))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃msg'. execution.minimalEnabled (fe index) (ft index)
              msg' ∧  msg' ∈ set (drop (length (ft index)) 
                (fStepMsg (fe index) (ft index)))"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FStep</span><span> </span><span>fe_def</span><span> </span><span>ft_def</span><span>
</span><span>                </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>consumedMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ConsumedMsg</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"execution.minimalEnabled (fe index) (ft index) 
                consumedMsg"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"consumedMsg ∈ set (drop (length (ft index)) 
                (fStepMsg (fe index) (ft index)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ConsumedIsInDrop</span><span class="delimiter">:</span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"consumedMsg ∈ set (drop (length (ft index)) (ft (Suc index)))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fe_def</span><span> </span><span>ft_def</span><span> </span><span>FStep</span><span>
</span><span>                </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>index</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MinImplAllBigger</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ msg' . execution.minimalEnabled
            (fe index) (ft index) msg' 
             ⟶ (∃ OccM' . (execution.firstOccurrence (fe index) 
              (ft index) msg' OccM' )
                ∧ (∀ msg . ∀ OccM . execution.firstOccurrence (fe index)
                  (ft index) msg OccM 
                ⟶ OccM' ≤ OccM))"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg'</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpMinImplAllBigger</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.minimalEnabled 
                (fe index) (ft index) msg'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IsExecIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start 
                (fe index) (ft index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>BasicProperties</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>index</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ p . isReceiverOf p msg') ∧ 
                (enabled (last (fe index)) msg')
                ∧ (∃ n .  n &lt; length (fe index) 
                  ∧ enabled ( (fe index) ! n) msg' 
                  ∧ (∀ n' ≥ n . n' &lt; length (ft index) 
                  ⟶ msg' ≠ ((ft index)! n'))
                  ∧ (∀ n' msg' . ((∃ p . isReceiverOf p msg') 
                    ∧ (enabled (last (fe index)) msg') 
                    ∧ n' &lt; length (ft index) 
                    ∧ enabled ((fe index)! n') msg' 
                    ∧ (∀ n'' ≥ n' . n'' &lt; length (ft index) 
                    ⟶ msg' ≠ ((ft index) ! n''))) ⟶ n' ≥ n))"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.minimalEnabled_def</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(fe index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ft index)"</span></span></span><span> </span><span>msg'</span><span class="delimiter">]</span><span> 
</span><span>                </span><span>AssumpMinImplAllBigger</span><span> </span><span>IsExecIndex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>OccM'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>OccM'</span><span class="delimiter">:</span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(∃ p . isReceiverOf p msg')"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(enabled (last (fe index)) msg')"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"OccM' &lt; length (fe index)"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"enabled ( (fe index) ! OccM') msg'"</span></span></span><span>  
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(∀ n' ≥ OccM' . n' &lt; length (ft index) 
                ⟶ msg' ≠ ((ft index)! n'))"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(∀ n' msg' . ((∃ p . isReceiverOf p msg') 
                  ∧ (enabled (last (fe index)) msg') 
                  ∧ n' &lt; length (ft index) 
                  ∧ enabled ((fe index)! n') msg' 
                  ∧ (∀ n'' ≥ n' . n'' &lt; length (ft index) 
                  ⟶ msg' ≠ ((ft index) ! n''))) ⟶ n' ≥ OccM')"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                  
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; OccM' ⟹ enabled (fe index ! (OccM' - Suc 0)) msg' 
                      ⟹ msg' ≠ ft index ! (OccM' - Suc 0) ⟹ False"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>-</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpContr</span><span class="delimiter">:</span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"0 &lt; OccM'"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"enabled (fe index ! (OccM' - Suc 0)) msg'"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"msg' ≠ ft index ! (OccM' - Suc 0)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LengthOccM'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(OccM' - 1) &lt; length (ft index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>IndexIsExec</span><span> </span><span>AssumpContr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>   
</span><span>                  </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>One_nat_def</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_eq_plus1_left</span><span> 
</span><span>                    </span><span>Suc_less_eq</span><span> </span><span>le_add_diff_inverse</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>BiggerIndices</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀n''≥(OccM' - 1). 
                  n'' &lt; length (ft index) ⟶ msg' ≠ ft index ! n'')"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssumpContr</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> 
</span><span>                      </span><span>Suc_eq_plus1</span><span> </span><span>diff_Suc_1</span><span> </span><span>le_SucE</span><span> </span><span>le_diff_conv</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃p. isReceiverOf p msg') ∧ enabled (last 
                  (fe index)) msg' ∧ (OccM' - 1) &lt; length (ft index)
                    ∧ enabled (fe index ! (OccM' - 1)) msg' 
                    ∧ (∀n''≥(OccM' - 1). n'' &lt; length (ft index) 
                      ⟶ msg' ≠ ft index ! n'')"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span> </span><span>LengthOccM'</span><span> </span><span>AssumpContr</span><span> </span><span>BiggerIndices</span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM' ≤ OccM' - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpContr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>diff_less</span><span> </span><span>leD</span><span> </span><span>zero_less_one</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstOccMsg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe index)
                  (ft index) msg' OccM'"</span></span></span><span>   
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>execution_def</span><span>
</span><span>                  </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IsExecIndex</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>msg'</span><span> </span><span>OccM'</span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀msg OccM. execution.firstOccurrence (fe index) 
                (ft index) msg OccM ⟶ OccM' ≤ OccM"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg</span><span> </span><span>OccM</span><span>
</span><span>                </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe index) 
                  (ft index) msg OccM"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>AssumpOccMFirstOccurrence</span><span class="delimiter">:</span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"∃ p . isReceiverOf p msg"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe index)) msg"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"OccM &lt; (length (fe index))"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"enabled ((fe index) ! OccM) msg"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"(∀ n' ≥ OccM . n' &lt; length (ft index) 
                  ⟶ msg ≠ ((ft index) ! n'))"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"(OccM ≠ 0 ⟶ (¬ enabled ((fe index) ! (OccM - 1)) 
                  msg ∨ msg = (ft index)!(OccM - 1)))"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>                      </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ft index)"</span></span></span><span> 
</span><span>                      </span><span>msg</span><span> </span><span>OccM</span><span class="delimiter">]</span><span> </span><span>IsExecIndex</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃p. isReceiverOf p msg) ∧
                  enabled (last (fe index)) msg ∧
                  enabled (fe index ! OccM) msg ∧ 
                  (∀n''≥ OccM. n'' &lt; length (ft index) 
                    ⟶ msg ≠ ft index ! n'')"</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM' ≤ OccM"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM &lt; length (ft index)"</span></span></span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ OccM &lt; length (ft index)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM ≥ length (fe index) - 1"</span></span></span><span> 
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>leI</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM = length (fe index) - 1"</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpOccMFirstOccurrence</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM' ≤ OccM"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>FirstOccMsg'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃OccM'. 
                execution.firstOccurrence (fe index) (ft index) 
                  msg' OccM' 
                ∧ (∀msg OccM. execution.firstOccurrence (fe index) 
                  (ft index) msg OccM ⟶ OccM' ≤ OccM)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MinImplFirstOcc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ msg' . execution.minimalEnabled 
              (fe index) (ft index) msg' 
              ⟹ msg' ∈ firstOccSet index"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>msg'</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpMinImplFirstOcc</span><span class="delimiter">:</span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"execution.minimalEnabled (fe index) (ft index) msg'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>OccM'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>OccM'</span><span class="delimiter">:</span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe index) (ft index) 
                  msg' OccM'"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"∀ msg . ∀ OccM . execution.firstOccurrence 
                (fe index) (ft index) msg OccM 
              ⟶ OccM' ≤ OccM"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MinImplAllBigger</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msg' ∈ firstOccSet index"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>firstOccSet_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe index)) msg"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFirstOccSetDecrOrConsumed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃nMsg .  execution.firstOccurrence (fe index) 
                  (ft index) msg nMsg"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.FirstOccurrenceExists</span><span> </span><span>IndexIsExec</span><span> 
</span><span>                  </span><span>AssumptionFair</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nMsg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>NMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence
                  (fe index) (ft index) msg nMsg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"OccM' ≤ nMsg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃nMsg . OccM' ≤ nMsg ∧
                  execution.firstOccurrence (fe index) (ft index) msg'
                    OccM' ∧
                  execution.firstOccurrence (fe index) (ft index) msg 
                    nMsg"</span></span></span><span> 
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OccM'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃nMsg n1 . n1 ≤ nMsg ∧
                  execution.firstOccurrence (fe index) (ft index) 
                    msg' n1 ∧
                  execution.firstOccurrence (fe index) (ft index) 
                    msg nMsg"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ConsumedInSet</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consumedMsg ∈ firstOccSet index"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ConsumedMsg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>GreaterOccurrence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ nMsg n1 . 
                execution.firstOccurrence (fe (Suc index)) 
                  (ft (Suc index)) consumedMsg n1 ∧ 
                execution.firstOccurrence (fe (Suc index)) 
                  (ft (Suc index)) msg nMsg 
                ⟹ nMsg &lt; n1"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nMsg</span><span> </span><span>n1</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpGreaterOccurrence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ nMsg &lt; n1"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe (Suc index)) 
                  (ft (Suc index)) consumedMsg n1"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"execution.firstOccurrence (fe (Suc index)) 
                  (ft (Suc index)) msg nMsg"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nMsg &lt; length (fe index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallIndex</span><span> </span><span>AssumpGreaterOccurrence</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &lt; length (fe index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpGreaterOccurrence</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_trans</span><span> </span><span>nat_neq_iff</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N1Small</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≤ length (ft index)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IndexIsExec</span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>le_diff_conv2</span><span> 
</span><span>                  </span><span>not_le</span><span> </span><span>not_less_eq_eq</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i ≥ n1 . i &lt; length (ft (Suc index))
                ⟶ consumedMsg ≠ (ft (Suc index)) ! i"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.firstOccurrence_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends"</span></span></span><span>
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"start"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe (Suc index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span> 
</span><span>                  </span><span class="string"><span class="delete"><span class="delete">"consumedMsg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1"</span></span></span><span class="delimiter">]</span><span>
</span><span>                  </span><span>AssumpGreaterOccurrence</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SucIndexIsExec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ i ≥ length (ft index) . 
                i &lt; length (ft (Suc index)) 
                ∧ consumedMsg = (ft (Suc index)) ! i"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DropToIndex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"consumedMsg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft index)"</span></span></span><span class="delimiter">]</span><span>
</span><span>                </span><span>ConsumedIsInDrop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IDef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ length (ft index)"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (ft (Suc index))"</span></span></span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"consumedMsg = (ft (Suc index)) ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NotConsumed</span><span> </span><span>N1Small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consumedMsg ∉ firstOccSet (Suc index)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpConsumedInSucSet</span><span class="delimiter">:</span><span> 
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"consumedMsg ∈ firstOccSet (Suc index)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃nMsg n1. n1 ≤ nMsg ∧
                  execution.firstOccurrence (fe (Suc index)) 
                    (ft (Suc index)) consumedMsg n1 ∧ 
                  execution.firstOccurrence (fe (Suc index)) 
                    (ft (Suc index)) msg nMsg"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>firstOccSet_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>GreaterOccurrence</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_le_trans</span><span> </span><span>less_not_refl3</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ConsumedInSet</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"firstOccSet (Suc index) ⊂ firstOccSet index"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"firstOccSet (Suc index) ⊂ firstOccSet index 
            ∧ enabled (last (fe (Suc index))) msg"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>EnabledInSuc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NotConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ index ≥ n . ¬ msg ∈ 
          (set (drop (length (ft index)) (ft (Suc index))))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>index</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpMsgNotConsumed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ index"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"msg ∈ set (drop (length (ft index)) (ft (Suc index)))"</span></span></span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ n0' ≥ length (ft index) . 
            n0' &lt; length (ft (Suc index)) 
            ∧ msg = (ft (Suc index)) ! n0'"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpMsgNotConsumed</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>DropToIndex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg"</span></span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"length (ft index)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft (Suc index)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n0'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>MessageIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0' ≥ length (ft index)"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"n0' &lt; length (ft (Suc index))"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"msg = (ft (Suc index)) ! n0'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LengthIncreasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft n) ≤ length (ft index)"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpMsgNotConsumed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>index</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>indexa</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssumpLengthIncreasing</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"n ≤ indexa ⟹ length (ft n) ≤ length (ft indexa)"</span></span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"n ≤ Suc indexa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ index"</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft n) ≤ length (ft (Suc indexa))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Suc indexa"</span></span></span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≠ Suc indexa"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ indexa"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpLengthIncreasing</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_SucE</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>LengthNA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft n) ≤ length (ft indexa)"</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumpLengthIncreasing</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PrefixIndexA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft indexa) (ft (Suc indexa))"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft n) ≤ length (ft (Suc indexa))"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LengthNA</span><span> </span><span>PrefixListMonotonicity</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PrefixIndexA</span><span class="delimiter">]</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>antisym</span><span> </span><span>le_cases</span><span> 
</span><span>                  </span><span>less_imp_le</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFairContr</span><span> </span><span>MessageIndex</span><span> 
</span><span>            </span><span>AssumpMsgNotConsumed</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length (ft index) ≤ n0'›</span></span></span><span> </span><span>le_SucI</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstOccSetDecrImpl</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ index ≥ n . (enabled (last (fe index)) msg) 
          ⟶ firstOccSet (Suc index) ⊂ firstOccSet index 
            ∧ (enabled (last (fe (Suc index))) msg)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FirstOccSetDecrOrConsumed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstOccSetDecrImpl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ index ≥ n . firstOccSet 
          (Suc index) ⊂ firstOccSet index"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KeepProperty</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx.(enabled (last (fe x)) msg)"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"λx.(firstOccSet (Suc x) ⊂ firstOccSet x)"</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>AssumptionCase1ImplThesis'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstOccSetDecr'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ index ≥ n . 
          card (firstOccSet (Suc index)) &lt; card (firstOccSet index)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FiniteMsgs</span><span> </span><span>psubset_card_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (firstOccSet (n + (card (firstOccSet n) + 1))) 
          ≤ card (firstOccSet n) - (card (firstOccSet n) + 1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallerMultipleStepsWithLimit</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"λx. card (firstOccSet x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (firstOccSet n) + 1"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IsNegative</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"card (firstOccSet (n + (card 
          (firstOccSet n) + 1))) &lt; 0"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FirstOccSetDecr'</span><span> </span><span>diff_add_zero</span><span> </span><span>leD</span><span> </span><span>le_add1</span><span> 
</span><span>            </span><span>less_nat_zero_code</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_nat_zero_code</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Case1ImplThesis</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enabled (last (fe n)) msg 
      ⟹ (∃n'≥n. ∃n0'≥n0. n0' &lt; length (ft n') ∧ msg = ft n' ! n0')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssumptionFair</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>execution.length</span><span class="delimiter">[</span><span>of</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft n"</span></span></span><span class="delimiter">]</span><span> </span><span>BasicProperties</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_lessI</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span> 
</span><span>        </span><span>less_asym</span><span> </span><span>less_diff_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n'≥n. ∃n0'≥n0. n0' &lt; length (ft n') ∧ msg = ft n' ! n0'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EnabledOrConsumedAtLast</span><span> </span><span>Case1ImplThesis</span><span> </span><span>Case2ImplThesis</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>fe</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ft</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fe 0 = [cfg] ∧ fairInfiniteExecution fe ft 
      ∧ (∀n. nonUniform (last (fe n)) ∧ prefixList (fe n) (fe (n + 1)) 
          ∧ prefixList (ft n) (ft (n + 1))
          ∧ execution trans sends start (fe n) (ft n))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Fair</span><span> </span><span>fe_def</span><span> </span><span>FStep</span><span> </span><span>BasicProperties</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Contradiction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  An infinite execution is said to be a terminating FLP execution if each process
  at some point sends a decision message or if it stops, which is expressed
  by the process not processing any further messages.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>flpSystem</span><span class="delimiter">)</span><span> </span><span>terminationFLP</span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ ('p, 'v, 's) configuration list) 
  ⇒ (nat ⇒ ('p, 'v) message list) ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"terminationFLP fe ft ≡ infiniteExecution fe ft ⟶ 
  (∀ p . ∃ n .
     (∃ i0 &lt; length (ft n). ∃ b . 
      (&lt;⊥, outM b&gt; ∈# sends p (states ((fe n) ! i0) p) (unpackMessage ((ft n) ! i0)))
      ∧ isReceiverOf p ((ft n) ! i0))
  ∨ (∀ n1 &gt; n . ∀ m ∈ set (drop (length (ft n)) (ft n1)) . ¬ isReceiverOf p m))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ConsensusFails</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>Termination</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀ fe ft . (fairInfiniteExecution fe ft ⟹ terminationFLP fe ft)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Validity</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i c . validity i c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Agreement</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ i c . agreementInit i c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Cfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initial cfg"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform cfg"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InitialNonUniformCfg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PseudoTermination</span><span> </span><span>Validity</span><span> </span><span>Agreement</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fe</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p, 'v, 's) configuration list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>ft</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('p, 'v) message list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>FE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe 0) = [cfg]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fairInfiniteExecution fe ft"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(∀(n::nat) . nonUniform (last (fe n)) 
          ∧ prefixList (fe n) (fe (n+1)) 
          ∧ prefixList (ft n) (ft (n+1))
          ∧ (execution trans sends start (fe n) (ft n)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FairNonUniformExecution</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cfg</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllArePrefixesExec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m . ∀ n &gt; m . prefixList (fe m) (fe n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>MLessN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe m) (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MLessN</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m &lt; n) ⟹ (prefixList (fe m) (fe n))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; (Suc n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n ∨ m &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IA</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_SucE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe m) (fe (Suc n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe n) (fe (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IA2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe m) (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IA</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe n) (fe (n+1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe m) (fe (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> 
</span><span>          </span><span>IA2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe m) (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllArePrefixesTrace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m . ∀ n &gt; m . prefixList (ft m) (ft n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>MLessN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft m) (ft n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MLessN</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m &lt; n) ⟹ (prefixList (ft m) (ft n))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; (Suc n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n ∨ m &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IA</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_SucE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft m) (ft (Suc n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft n) (ft (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IA2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft m) (ft n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IA</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft n) (ft (n+1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft m) (ft (Suc n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListTransitive</span><span> 
</span><span>          </span><span>IA2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft m) (ft n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . length (fe n) ≥ n + 1"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe n) ≥ n + 1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n + (1::nat)) ≤ (length (fe n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe (n+1)) ≥ length (fe n) + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>        </span><span>PrefixListMonotonicity</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>Suc_le_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Suc n) + (1::nat) ≤ (length (fe (Suc n)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllExecsFromInit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n . ∀ n0 &lt; length (fe n) . 
    reachable cfg ((fe n) ! n0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n0</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length (fe n)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg ((fe n) ! n0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 = n"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>N0Less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length (fe 0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NoStep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg cfg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reachable.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe 0) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N0Zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N0Less</span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe 0) ! n0 = cfg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg ((fe 0) ! n0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>NoStep</span><span> </span><span>N0Zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NNotZero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; (length (fe n))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ZeroCfg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe 0) = [cfg]"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (fe 0) (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllArePrefixesExec</span><span> </span><span>NNotZero</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>PrList</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList [cfg] (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ZeroCfg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CfgFirst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cfg = (fe n) ! 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prefixList.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PrList</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>ZeroCfg</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_Cons_0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable ((fe n) ! 0) ((fe n) ! n0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.ReachableInExecution</span><span> </span><span>FE</span><span> </span><span>NNotZero</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le0</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(reachable cfg ((fe n) ! n0))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>CfgFirst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NoDecided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀ n n0 v . (n0 &lt; length (fe n)) 
                  ⟶ ¬ vDecided v ((fe n) ! n0))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>n0</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>AssmNoDecided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 &lt; length (fe n)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"initReachable ((fe n) ! n0)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (msgs ((fe n) ! n0) &lt;⊥, outM v&gt;)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LastNonUniform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last (fe n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LastIsLastIndex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ l . l ≠ [] ⟶ last l = l ! ((length l) - 1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Fou</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n0 ≤ length (fe n) - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AssmNoDecided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FeNNotEmpty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fe n ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>AllArePrefixesExec</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AssmNoDecided</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>less_nat_zero_code</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Fou2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe n) - 1 &lt; length (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (fe n) = (fe n) ! (length (fe n) - 1)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LastIsLastIndex</span><span> </span><span>FeNNotEmpty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>LastNonUniform</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nonUniform (last (fe n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable ((fe n) ! n0) ((fe n) ! (length (fe n) - 1))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span>execution.ReachableInExecution</span><span> </span><span>Fou</span><span> </span><span>Fou2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>N0ToLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable ((fe n) ! n0) (last (fe n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LastIsLastIndex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span class="delimiter">]</span><span> </span><span>FeNNotEmpty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>LastVDecided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vDecided v (last (fe n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoOutMessageLoss</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"((fe n) ! n0)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(last (fe n))"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span>AssmNoDecided</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>
</span><span>        </span><span>metis</span><span> </span><span>LastNonUniform</span><span> </span><span>le_neq_implies_less</span><span> </span><span>less_nat_zero_code</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AllAgree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ cfg' . reachable (last (fe n)) cfg' 
      ⟶ agreement cfg'"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>cfg'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>LastToNext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable (last (fe n)) cfg'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg  ((fe n) ! (length (fe n) - 1))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllExecsFromInit</span><span> </span><span>AssmNoDecided</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg (last (fe n))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LastIsLastIndex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fe n"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span>FeNNotEmpty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FirstToLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reachable cfg cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>initReachable_def</span><span> </span><span>Cfg</span><span> 
</span><span>        </span><span>LastToNext</span><span> </span><span>ReachableTrans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agreementInit cfg cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Agreement</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v1. (&lt;⊥, outM v1&gt; ∈# msgs cfg') ⟶ (∀v2. (&lt;⊥, outM v2&gt; ∈# 
        msgs cfg') ⟷ v2 = v1)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cfg</span><span> </span><span>FirstToLast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>agreementInit_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"agreement cfg'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>agreement_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NonUniformImpliesNotDecided</span><span> </span><span>LastNonUniform</span><span> 
</span><span>      </span><span>PseudoTermination</span><span> </span><span>LastVDecided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Termination</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"terminationFLP fe ft"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>AllDecideOrCrash</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀p. ∃n . 
       (∃ i0 &lt; length (ft n) . ∃b. 
          (&lt;⊥, outM b&gt; ∈# 
            sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) 
          ∧ isReceiverOf p (ft n ! i0)) 
      ∨ (∀ n1 &gt; n . ∀ m ∈ (set (drop (length (ft n)) (ft n1))) .
          ¬ isReceiverOf p m)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>terminationFLP_def</span><span> </span><span>fairInfiniteExecution_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p . ∃ n . (∀ n1 &gt; n . ∀ m ∈ (set (drop (length (ft n)) (ft n1))) .
    ¬ isReceiverOf p m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AllDecideOrCrash</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃ n . 
       (∃ i0 &lt; length (ft n) . ∃b. 
        (&lt;⊥, outM b&gt; ∈# sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) 
       ∧ isReceiverOf p (ft n ! i0)) 
      ∨ (∀ n1 &gt; n . ∀ m ∈ (set (drop (length (ft n)) (ft n1))). 
        ¬ isReceiverOf p m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃ n . ∃ i0 &lt; length (ft n) . 
         (∃b. (&lt;⊥, outM b&gt; ∈# 
            sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) 
          ∧ isReceiverOf p (ft n ! i0)))
         ∨ (∃ n .∀ n1 &gt; n . ∀ m ∈ (set (drop (length (ft n)) (ft n1))) .
           ¬ isReceiverOf p m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. (∀n1&gt;n. (∀ m ∈ (set (drop (length (ft n)) (ft n1))).
      (¬ (isReceiverOf p m))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>i0</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>DecidingPoint</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"i0 &lt; length (ft n)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p (ft n ! i0)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"&lt;⊥, outM b&gt; ∈# sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 &lt; length (fe n) - 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DecidingPoint</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>FE</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>execution.length</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>StepN0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((fe n) ! i0) ⊢ ((ft n) ! i0) ↦ ((fe n) ! (i0 + 1))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>execution.step</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"msgs ((fe n) ! (i0 + 1)) &lt;⊥, outM b&gt; 
        = (msgs ((fe n) ! i0) &lt;⊥, outM b&gt;) +
        (sends p (states ((fe n) ! i0) p) 
        (unpackMessage ((ft n) ! i0)) &lt;⊥, outM b&gt;)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DecidingPoint</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>OutOnlyGrowing</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fe n) ! i0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ft n) ! i0"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(fe n) ! (i0 + 1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(sends p (states ((fe n) ! i0) p) 
        (unpackMessage ((ft n) ! i0)) &lt;⊥, outM b&gt;) 
        ≤ msgs ((fe n) ! (i0 + 1)) &lt;⊥, outM b&gt;"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asynchronousSystem.steps_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>OutMsgEx</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; msgs ((fe n) ! (i0 + 1)) &lt;⊥, outM b&gt;"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asynchronousSystem.steps_def</span><span> </span><span>DecidingPoint</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i0 + 1) &lt; length (fe n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DecidingPoint</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i0 &lt; length (fe n) - 1›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"initReachable ((fe n) ! (i0 + 1))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllExecsFromInit</span><span> </span><span>Cfg</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>asynchronousSystem.initReachable_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Decided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vDecided b ((fe n) ! (i0 + 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>OutMsgEx</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i0 + 1 &lt; length (fe n)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DecidingPoint</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(((i0::nat) + (1::nat)) &lt; (length (
          (fe::(nat ⇒ ('p, 'v, 's) configuration list)) (n::nat))))›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ vDecided b ((fe n) ! (i0 + 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoDecided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n. (∀n1&gt;n. (∀ m ∈ (set (drop (length (ft n)) (ft n1))). 
        (¬ (isReceiverOf p m))))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ (crashPoint::'p ⇒ nat) . 
    ∀ p . ∃  n . crashPoint p = n ∧ (∀ n1 &gt; n . ∀ m ∈ (set (drop 
    (length (ft n)) (ft n1))) . (¬ isReceiverOf p m))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>crashPoint</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>CrashPoint</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ p . (∀ n1 &gt; (crashPoint p) . ∀ m ∈ (set (drop (length 
    (ft (crashPoint p))) (ft n1))) . (¬ isReceiverOf p m))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>limitSet</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"limitSet = {crashPoint p | p . p ∈ Proc}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {p. p ∈ Proc}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finiteProcs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite limitSet"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>limitSet_def</span><span> </span><span>finite_image_set</span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ limit . ∀ l ∈ limitSet . l &lt; limit"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>    </span><span>finite_nat_set_iff_bounded</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ limit . ∀ p . (crashPoint p) &lt; limit"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>limitSet_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>limit</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Limit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ p . (crashPoint p) &lt; limit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lengthLimit</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lengthLimit = length (ft limit) - 1"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>lateMessage</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage = last (ft limit)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage = (ft limit) ! (length (ft limit) - 1)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>AllArePrefixesTrace</span><span> </span><span>Limit</span><span> </span><span>last_conv_nth</span><span> </span><span>less_nat_zero_code</span><span> 
</span><span>      </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>PrefixListMonotonicity</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>LateIsLast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage = (ft limit) ! lengthLimit"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lateMessage_def</span><span> </span><span>lengthLimit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ p . isReceiverOf p lateMessage"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃(p::'p). (isReceiverOf p lateMessage))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>IsOutMsg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ v . lateMessage = &lt;⊥, outM v&gt;"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>isReceiverOf.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>message.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"execution trans sends start (fe limit) (ft limit)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (fe limit) - 1 = length (ft limit)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>execution.length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lengthLimit &lt; length (fe limit) - 1"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lengthLimit_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>hide_lams</span><span class="delimiter">,</span><span> </span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Length</span><span> </span><span>Limit</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_eq_plus1</span><span>
</span><span>        </span><span>Suc_le_eq</span><span> </span><span>diff_less</span><span> 
</span><span>        </span><span>diffs0_imp_equal</span><span> </span><span>gr_implies_not0</span><span> </span><span>less_Suc0</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((fe limit) ! lengthLimit) ⊢ ((ft limit) ! lengthLimit) 
      ↦ ((fe limit) ! (lengthLimit + 1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>execution.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((fe limit) ! lengthLimit) ⊢ lateMessage ↦ ((fe limit) ! 
      (lengthLimit + 1))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LateIsLast</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IsOutMsg</span><span> </span><span>steps_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ReceiverOfLate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isReceiverOf p lateMessage"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ n1 &gt; (crashPoint p) . 
    ∀ m ∈ (set (drop (length (ft (crashPoint p))) (ft n1))) . 
      (¬ isReceiverOf p m)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CrashPoint</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>NoMsgAfterLimit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ m ∈ (set (drop (length (ft (crashPoint p))) 
    (ft limit))) . (¬ isReceiverOf p m)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage ∈ set (drop (length(ft (crashPoint p))) (ft limit))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"crashPoint p &lt; limit"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prefixList (ft (crashPoint p)) (ft limit)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AllArePrefixesTrace</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>CrashShorterLimit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ft (crashPoint p)) 
      &lt; length (ft limit)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PrefixListMonotonicity</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"last (drop (length (ft (crashPoint p))) (ft limit)) 
      = last (ft limit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_drop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage = last (drop (length (ft (crashPoint p))) 
      (ft limit))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lateMessage_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lateMessage ∈ set (drop (length(ft (crashPoint p))) (ft limit))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CrashShorterLimit</span><span> </span><span>drop_eq_Nil</span><span> </span><span>last_in_set</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ isReceiverOf p lateMessage"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoMsgAfterLimit</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ReceiverOfLate</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FLPExistingSystem">
<div class="head"><h1>Theory FLPExistingSystem</h1>
<span class="command">theory</span> <span class="name">FLPExistingSystem</span><br/>
<span class="keyword">imports</span> <a href="FLPTheorem.html"><span class="name">FLPTheorem</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An Existing FLPSystem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FLPExistingSystem</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>FLPTheorem</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We define an example FLPSystem with some example execution to show that the
  locales employed are not void. (If they were, the consensus impossibility
  result would be trivial.)
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹System definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>proc</span><span> </span><span class="delimiter">=</span><span> </span><span>p0</span><span> </span><span class="delimiter">|</span><span> </span><span>p1</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>s0</span><span> </span><span class="delimiter">|</span><span> </span><span>s1</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>val</span><span> </span><span class="delimiter">=</span><span> </span><span>v0</span><span> </span><span class="delimiter">|</span><span> </span><span>v1</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc ⇒ state ⇒ val messageValue ⇒ state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"trans p s0 v = s1"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"trans p s1 v = s0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sends</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"proc ⇒ state ⇒ val messageValue ⇒ (proc, val) message multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sends p s0 v = {# &lt;p0, v1&gt; }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"sends p s1 v = {# &lt;p1, v0&gt; }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"proc ⇒ state"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"start p  ≡ s0"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹An example execution›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exec</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(proc, val, state ) configuration list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>exec_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec ≡ [ ⦇ 
    states = (λp. s0),
    msgs = ({# &lt;p0, inM True&gt; } ∪# {# &lt;p1, inM True&gt; }) ⦈ ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcUniv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(UNIV :: proc set) = {p0, p1}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_eq_I</span><span> </span><span>insert_iff</span><span> </span><span>proc.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interpretation as FLP Locale›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>FLPSys</span><span class="delimiter">:</span><span> </span><span>flpSystem</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="comment">― ‹finiteProcs›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (UNIV :: proc set)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ProcUniv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹minimalProcs›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (UNIV :: proc set) = 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ProcUniv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ card (UNIV :: proc set)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹finiteSends›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>s</span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FinExplSends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {&lt;p0, v1&gt;, &lt;p1, v0&gt;}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{v. 0 &lt; sends p s m v} ⊆ {&lt;p0, v1&gt;, &lt;p1, v0&gt;}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≠ &lt;p0, v1&gt;"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; sends p s m x"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = &lt;p1, v0&gt;"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>neq0_conv</span><span> </span><span>sends.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>state.exhaust</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {v. 0 &lt; sends p s m v}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FinExplSends</span><span> </span><span>finite_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹noInSends›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>s</span><span> </span><span>m</span><span> </span><span>p2</span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sends p s m &lt;p2, inM v&gt; = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>FLPExec</span><span class="delimiter">:</span><span> </span><span>execution</span><span> </span><span>trans</span><span> </span><span>sends</span><span> </span><span>start</span><span> </span><span>exec</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="comment">― ‹notEmpty›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ length exec"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>exec_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹length›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length exec - 1 = length []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>exec_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹base›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"asynchronousSystem.initial start (hd exec)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asynchronousSystem.initial_def</span><span> </span><span>isReceiverOf_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>start_def</span><span> </span><span>exec_def</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>proc.exhaust</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹step›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span>cfg1</span><span> </span><span>cfg2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length exec - 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>exec_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"asynchronousSystem.steps FLPExistingSystem.trans sends cfg1 ([] ! i) cfg2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>