<div id="Huffman">
<div class="head"><h1>Theory Huffman</h1>
<span class="command">theory</span> <span class="name">Huffman</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       An Isabelle/HOL Formalization of the Textbook Proof of Huffman's Algorithm
    Author:      Jasmin Christian Blanchette &lt;blanchette at in.tum.de&gt;, 2008
    Maintainer:  Jasmin Christian Blanchette &lt;blanchette at in.tum.de&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Huffman</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Introduction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binary Codes \label{binary-codes}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Suppose we want to encode strings over a finite source alphabet to sequences
of bits. The approach used by ASCII and most other charsets is to map each
source symbol to a distinct $k$-bit code word, where $k$ is fixed and is
typically 8 or 16. To encode a string of symbols, we simply encode each symbol
in turn. Decoding involves mapping each $k$-bit block back to the symbol it
represents.

Fixed-length codes are simple and fast, but they generally waste space. If
we know the frequency $w_a$ of each source symbol $a$, we can save space
by using shorter code words for the most frequent symbols. We
say that a (variable-length) code is {\sl optimum\/} if it minimizes the sum
$\sum_a w_a \vthinspace\delta_a$, where $\delta_a$ is the length of the binary
code word for $a$. Information theory tells us that a code is optimum if
for each source symbol $c$ the code word representing $c$ has length
$$\textstyle \delta_c = \log_2 {1 \over p_c}, \qquad
  \hbox{where}\enskip p_c = {w_c \over \sum_a w_a}.$$
This number is generally not an integer, so we cannot use it directly.
Nonetheless, the above criterion is a useful yardstick and paves the way for
arithmetic coding \cite{rissanen-1976}, a generalization of the method
presented here.

\def\xabacabad{\xa\xb\xa\xc\xa\xb\xa\xd}%
As an example, consider the source string `$\xabacabad$'. We have
$$p_{\xa} = \tfrac{1}{2},\,\; p_{\xb} = \tfrac{1}{4},\,\;
  p_{\xc} = \tfrac{1}{8},\,\; p_{\xd} = \tfrac{1}{8}.$$
The optimum lengths for the binary code words are all integers, namely
$$\delta_{\xa} = 1,\,\; \delta_{\xb} = 2,\,\; \delta_{\xc} = 3,\,\;
  \delta_{\xd} = 3,$$
and they are realized by the code
$$C_1 = \{ \xa \mapsto 0,\, \xb \mapsto 10,\, \xc \mapsto 110,\,
           \xd \mapsto 111 \}.$$
Encoding `$\xabacabad$' produces the 14-bit code word 01001100100111. The code
$C_1$ is optimum: No code that unambiguously encodes source symbols one at a
time could do better than $C_1$ on the input `$\xa\xb\xa\xc\xa\xb\xa\xd$'. In
particular, with a fixed-length code such as
$$C_2 = \{ \xa \mapsto 00,\, \xb \mapsto 01,\, \xc \mapsto 10,\,
           \xd \mapsto 11 \}$$
we need at least 16~bits to encode `$\xabacabad$'.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Binary Trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Inside a program, binary codes can be represented by binary trees. For example,
the trees\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-abcd-unbalanced.pdf}}}
  \qquad \hbox{and} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-abcd-balanced.pdf}}}$$
correspond to $C_1$ and $C_2$. The code word for a given
symbol can be obtained as follows: Start at the root and descend toward the leaf
node associated with the symbol one node at a time; generate a 0 whenever the
left child of the current node is chosen and a 1 whenever the right child is
chosen. The generated sequence of 0s and 1s is the code word.

To avoid ambiguities, we require that only leaf nodes are labeled with symbols.
This ensures that no code word is a prefix of another, thereby eliminating the
source of all ambiguities.%
\footnote{Strictly speaking, there is another potential source of ambiguity.
If the alphabet consists of a single symbol $a$, that symbol could be mapped
to the empty code word, and then any string $aa\ldots a$ would map to the
empty bit sequence, giving the decoder no way to recover the original string's
length. This scenario can be ruled out by requiring that the alphabet has
cardinality 2 or more.}
Codes that have this property are called {\sl prefix codes}. As an example of a
code that does not have this property, consider the code associated with the
tree\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-abcd-non-prefix.pdf}}}$$
and observe that `$\xb\xb\xb$', `$\xb\xd$', and `$\xd\xb$' all map to the
code word 111.

Each node in a code tree is assigned a {\sl weight}. For a leaf node, the
weight is the frequency of its symbol; for an inner node, it is the sum of the
weights of its subtrees. Code trees can be annotated with their weights:\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]%
    {tree-abcd-unbalanced-weighted.pdf}}}
  \qquad\qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]%
    {tree-abcd-balanced-weighted.pdf}}}$$
For our purposes, it is sufficient to consider only full binary trees (trees
whose inner nodes all have two children). This is because any inner node with
only one child can advantageously be eliminated; for example,\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-abc-non-full.pdf}}}
  \qquad \hbox{becomes} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-abc-full.pdf}}}$$
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Huffman's Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
David Huffman \cite{huffman-1952} discovered a simple algorithm for
constructing an optimum code tree for specified symbol frequencies:
Create a forest consisting of only leaf nodes, one for each symbol in the
alphabet, taking the given symbol frequencies as initial weights for the nodes.
Then pick the two trees
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1.pdf}}}
  \qquad \hbox{and} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-w2.pdf}}}$$

\noindent\strut
with the lowest weights and replace them with the tree
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-w2.pdf}}}$$
Repeat this process until only one tree is left.

As an illustration, executing the algorithm for the frequencies
$$f_{\xd} = 3,\,\; f_{\xe} = 11,\,\; f_{\xf} = 5,\,\; f_{\xs} = 7,\,\;
  f_{\xz} = 2$$
gives rise to the following sequence of states:\strut

\def\myscale{1}%
\setbox\myboxi=\hbox{(9)\strut}%
\setbox\myboxii=\hbox{\includegraphics[scale=\myscale]{tree-prime-step1.pdf}}%
\setbox\myboxiii=\hbox{\includegraphics[scale=\myscale]{tree-prime-step2.pdf}}%
$$(1)\quad\lower\ht\myboxii\hbox{\raise\ht\myboxi\box\myboxii} \qquad\qquad
  (2)\enskip\lower\ht\myboxiii\hbox{\raise\ht\myboxi\box\myboxiii}$$

\vskip.5\smallskipamount

\noindent
\setbox\myboxii=\hbox{\includegraphics[scale=\myscale]{tree-prime-step3.pdf}}%
\setbox\myboxiii=\hbox{\includegraphics[scale=\myscale]{tree-prime-step4.pdf}}%
\setbox\myboxiv=\hbox{\includegraphics[scale=\myscale]{tree-prime-step5.pdf}}%
(3)\quad\lower\ht\myboxii\hbox{\raise\ht\myboxi\box\myboxii}\hfill\quad
  (4)\quad\lower\ht\myboxiii\hbox{\raise\ht\myboxi\box\myboxiii}\hfill
  (5)\enskip\lower\ht\myboxiv\hbox{\raise\ht\myboxi\box\myboxiv\,}

\smallskip
\noindent
Tree~(5) is an optimum tree for the given frequencies.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Textbook Proof›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Why does the algorithm work? In his article, Huffman gave some motivation but
no real proof. For a proof sketch, we turn to Donald Knuth
\cite[p.~403--404]{knuth-1997}:

\begin{quote}
It is not hard to prove that this method does in fact minimize the weighted
path length (i.e., $\sum_a w_a \vthinspace\delta_a$), by induction on $m$.
Suppose we have $w_1 \le w_2 \le w_3 \le \cdots \le w_m$, where $m \ge 2$, and
suppose that we are given a tree that minimizes the weighted path length.
(Such a tree certainly exists, since only finitely many binary trees with $m$
terminal nodes are possible.) Let $V$ be an internal node of maximum distance
from the root. If $w_1$ and $w_2$ are not the weights already attached to the
children of $V$, we can interchange them with the values that are already
there; such an interchange does not increase the weighted path length. Thus
there is a tree that minimizes the weighted path length and contains the
subtree\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-w2-leaves.pdf}}}$$
Now it is easy to prove that the weighted path length of such a tree is
minimized if and only if the tree with
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-w2-leaves.pdf}}}
  \qquad \hbox{replaced by} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-plus-w2.pdf}}}$$
has minimum path length for the weights $w_1 + w_2$, $w_3$, $\ldots\,$, $w_m$.
\end{quote}

\noindent
There is, however, a small oddity in this proof: It is not clear why we must
assert the existence of an optimum tree that contains the subtree
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-w2-leaves.pdf}}}$$
Indeed, the formalization works without it.

Cormen et al.\ \cite[p.~385--391]{cormen-et-al-2001} provide a very similar
proof, articulated around the following propositions:

\begin{quote}
\textsl{\textbf{Lemma 16.2}} \\
Let $C$ be an alphabet in which each character $c \in C$ has frequency $f[c]$.
Let $x$ and $y$ be two characters in $C$ having the lowest frequencies. Then
there exists an optimal prefix code for $C$ in which the codewords for $x$ and
$y$ have the same length and differ only in the last bit.

\medskip

\textsl{\textbf{Lemma 16.3}} \\
Let $C$ be a given alphabet with frequency $f[c]$ defined for each character
$c \in C$. Let $x$ and $y$ be two characters in $C$ with minimum frequency. Let
$C'$ be the alphabet $C$ with characters $x$, $y$ removed and (new) character
$z$ added, so that $C' = C - \{x, y\} \cup {\{z\}}$; define $f$ for $C'$ as for
$C$, except that $f[z] = f[x] + f[y]$. Let $T'$ be any tree representing an
optimal prefix code for the alphabet $C'$. Then the tree $T$, obtained from
$T'$ by replacing the leaf node for $z$ with an internal node having $x$ and
$y$ as children, represents an optimal prefix code for the alphabet $C$.

\medskip

\textsl{\textbf{Theorem 16.4}} \\
Procedure \textsc{Huffman} produces an optimal prefix code.
\end{quote}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Overview of the Formalization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This document presents a formalization of the proof of Huffman's algorithm
written using Isabelle/HOL \cite{nipkow-et-al-2008}. Our proof is based on the
informal proofs given by Knuth and Cormen et al. The development was done
independently of Laurent Th\'ery's Coq proof \cite{thery-2003,thery-2004},
which through its ``cover'' concept represents a considerable departure from
the textbook proof.

The development consists of a little under 100 lemmas and theorems. Most of
them have very short proofs thanks to the extensive use of simplification
rules and custom induction rules. The remaining proofs are written using the
structured proof format Isar \cite{wenzel-2008}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Head of the Theory File›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The Isabelle theory starts in the standard way.

\myskip

\noindent
\isacommand{theory} ‹Huffman› \\
\isacommand{imports} ‹Main› \\
\isacommand{begin}

\myskip

\noindent
We attach the ‹simp› attribute to some predefined lemmas to add them to
the default set of simplification rules.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span>
</span><span>  </span><span>Int_Un_distrib</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span>Int_Un_distrib2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span>max.absorb1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span>max.absorb2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Prefix Code Trees and Forests \label{trees-and-forests}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree Type›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A {\sl prefix code tree\/} is a full binary tree in which leaf nodes are of the
form @{term "Leaf w a"}, where @{term a} is a symbol and @{term w} is the
frequency associated with @{term a}, and inner nodes are of the form
@{term "Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"}, where @{term t<span class="hidden">⇩</span><sub>1</sub>} and @{term t<span class="hidden">⇩</span><sub>2</sub>} are the left and
right subtrees and @{term w} caches the sum of the weights of @{term t<span class="hidden">⇩</span><sub>1</sub>} and
@{term t<span class="hidden">⇩</span><sub>2</sub>}. Prefix code trees are polymorphic on the symbol datatype~@{typ 'a}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>tree</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Leaf</span><span> </span><span>nat</span><span> </span><span class="tfree">'a</span><span>
</span><span class="delimiter">|</span><span> </span><span>Node</span><span> </span><span>nat</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a tree)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('a tree)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Forest Type›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The intermediate steps of Huffman's algorithm involve a list of prefix code
trees, or {\sl prefix code forest}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>forest</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Alphabet›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl alphabet\/} of a code tree is the set of symbols appearing in the
tree's leaf nodes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>alphabet</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet (Leaf w a) = {a}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = alphabet t<span class="hidden">⇩</span><sub>1</sub> ∪ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
For sets and predicates, Isabelle gives us the choice between inductive
definitions (\isakeyword{inductive\_set} and \isakeyword{inductive}) and
recursive functions (\isakeyword{primrec}, \isakeyword{fun}, and
\isakeyword{function}). In this development, we consistently favor recursion
over induction, for two reasons:

\begin{myitemize}
\item Recursion gives rise to simplification rules that greatly help automatic
proof tactics. In contrast, reasoning about inductively defined sets and
predicates involves introduction and elimination rules, which are more clumsy
than simplification rules.

\item Isabelle's counterexample generator \isakeyword{quickcheck}
\cite{berghofer-nipkow-2004}, which we used extensively during the top-down
development of the proof (together with \isakeyword{sorry}), has better support
for recursive definitions.
\end{myitemize}

The alphabet of a forest is defined as the union of the alphabets of the trees
that compose it. Although Isabelle supports overloading for non-overlapping
types, we avoid many type inference problems by attaching an
`\raise.3ex\hbox{‹<span class="hidden">⇩</span><sub>F</sub>›}' subscript to the forest generalizations of
functions defined on trees.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>alphabet<span class="hidden">⇩</span><sub>F</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ 'a set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet<span class="hidden">⇩</span><sub>F</sub> [] = {}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet<span class="hidden">⇩</span><sub>F</sub> (t # ts) = alphabet t ∪ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Alphabets are central to our proofs, and we need the following basic facts
about them.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_alphabet</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"finite (alphabet t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_in_alphabet</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"∃a. a ∈ alphabet t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Consistency›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A tree is {\sl consistent\/} if for each inner node the alphabets of the two
subtrees are disjoint. Intuitively, this means that every symbol in the
alphabet occurs in exactly one leaf node. Consistency is a sufficient condition
for $\delta_a$ (the length of the {\sl unique\/} code word for $a$) to be
defined. Although this well\-formed\-ness property is not mentioned in algorithms
textbooks \cite{aho-et-al-1983,cormen-et-al-2001,knuth-1997}, it is essential
and appears as an assumption in many of our lemmas.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>consistent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent (Leaf w a) = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) =
 (consistent t<span class="hidden">⇩</span><sub>1</sub> ∧ consistent t<span class="hidden">⇩</span><sub>2</sub> ∧ alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>consistent<span class="hidden">⇩</span><sub>F</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent<span class="hidden">⇩</span><sub>F</sub> [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent<span class="hidden">⇩</span><sub>F</sub> (t # ts) =
 (consistent t ∧ consistent<span class="hidden">⇩</span><sub>F</sub> ts ∧ alphabet t ∩ alphabet<span class="hidden">⇩</span><sub>F</sub> ts = {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Several of our proofs are by structural induction on consistent trees $t$ and
involve one symbol $a$. These proofs typically distinguish the following cases.

\begin{myitemize}
\item[] {\sc Base case:}\enspace $t = @{term "Leaf w b"}$.
\item[] {\sc Induction step:}\enspace $t = @{term "Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"}$.
\item[] \noindent\kern\leftmargin {\sc Subcase 1:}\enspace $a$ belongs to
        @{term t<span class="hidden">⇩</span><sub>1</sub>} but not to @{term t<span class="hidden">⇩</span><sub>2</sub>}.
\item[] \noindent\kern\leftmargin {\sc Subcase 2:}\enspace $a$ belongs to
        @{term t<span class="hidden">⇩</span><sub>2</sub>} but not to @{term t<span class="hidden">⇩</span><sub>1</sub>}.
\item[] \noindent\kern\leftmargin {\sc Subcase 3:}\enspace $a$ belongs to
        neither @{term t<span class="hidden">⇩</span><sub>1</sub>} nor @{term t<span class="hidden">⇩</span><sub>2</sub>}.
\end{myitemize}

\noindent
Thanks to the consistency assumption, we can rule out the subcase where $a$
belongs to both subtrees.

Instead of performing the above case distinction manually, we encode it in a
custom induction rule. This saves us from writing repetitive proof scripts and
helps Isabelle's automatic proof tactics.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_induct_consistent</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>base</span><span> </span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>step<span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t;
  ⋀w<span class="hidden">⇩</span><sub>b</sub> b a. P (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>; P t<span class="hidden">⇩</span><sub>1</sub> a; P t<span class="hidden">⇩</span><sub>2</sub> a⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>; P t<span class="hidden">⇩</span><sub>1</sub> a; P t<span class="hidden">⇩</span><sub>2</sub> a⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>; P t<span class="hidden">⇩</span><sub>1</sub> a; P t<span class="hidden">⇩</span><sub>2</sub> a⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a⟧ ⟹
 P t a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The proof relies on the \textit{induction\_schema} and
\textit{lexicographic\_order} tactics, which automate the most tedious
aspects of deriving induction rules. The alternative would have been to perform
a standard structural induction on @{term t} and proceed by cases, which is
straightforward but long-winded.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rotate_tac</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction_schema</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The \textit{induction\_schema} tactic reduces the putative induction rule to
simpler proof obligations.
Internally, it reuses the machinery that constructs the default induction
rules. The resulting proof obligations concern (a)~case completeness,
(b)~invariant preservation (in our case, tree consistency), and
(c)~wellfoundedness. For @{thm [source] tree_induct_consistent}, the obligations
(a)~and (b) can be discharged using
Isabelle's simplifier and classical reasoner, whereas (c) requires a single
invocation of \textit{lexicographic\_order}, a tactic that was originally
designed to prove termination of recursive functions
\cite{bulwahn-et-al-2007,krauss-2007,krauss-2009}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Symbol Depths›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl depth\/} of a symbol (which we denoted by $\delta_a$ in
Section~\ref{binary-codes}) is the length of the path from the root to the
leaf node labeled with that symbol, or equivalently the length of the code word
for the symbol. Symbols that do not occur in the tree or that occur at the root
of a one-node tree have depth 0. If a symbol occurs in several leaf nodes (which
may happen with inconsistent trees), the depth is arbitrarily defined in terms
of the leftmost node labeled with that symbol.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>depth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"depth (Leaf w b) a = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"depth (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
 (if a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then depth t<span class="hidden">⇩</span><sub>1</sub> a + 1
  else if a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub> then depth t<span class="hidden">⇩</span><sub>2</sub> a + 1
  else 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The definition may seem very inefficient from a functional programming
point of view, but it does not matter, because unlike Huffman's algorithm, the
@{const depth} function is merely a reasoning tool and is never actually
executed.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Height›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl height\/} of a tree is the length of the longest path from the root to
a leaf node, or equivalently the length of the longest code word. This is
readily generalized to forests by taking the maximum of the trees' heights. Note
that a tree has height 0 if and only if it is a leaf node, and that a forest has
height 0 if and only if all its trees are leaf nodes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>height</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"height (Leaf w a) = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = max (height t<span class="hidden">⇩</span><sub>1</sub>) (height t<span class="hidden">⇩</span><sub>2</sub>) + 1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>height<span class="hidden">⇩</span><sub>F</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"height<span class="hidden">⇩</span><sub>F</sub> [] = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height<span class="hidden">⇩</span><sub>F</sub> (t # ts) = max (height t) (height<span class="hidden">⇩</span><sub>F</sub> ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The depth of any symbol in the tree is bounded by the tree's height, and there
exists a symbol with a depth equal to the height.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_le_height</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"depth t a ≤ height t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_at_height</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ ∃a ∈ alphabet t. depth t a = height t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"depth t<span class="hidden">⇩</span><sub>1</sub> b = height t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyps</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"depth t<span class="hidden">⇩</span><sub>2</sub> c = height t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"if height t<span class="hidden">⇩</span><sub>1</sub> ≥ height t<span class="hidden">⇩</span><sub>2</sub> then b else c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?a ∈ alphabet ?t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"depth ?t ?a = height ?t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹consistent ?t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a ∈ alphabet ?t. depth ?t a = height ?t"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following elimination rules help Isabelle's classical prover, notably the
\textit{auto} tactic. They are easy consequences of the inequation
@{thm depth_le_height[no_vars]}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_max_heightE_left</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦depth t<span class="hidden">⇩</span><sub>1</sub> a = max (height t<span class="hidden">⇩</span><sub>1</sub>) (height t<span class="hidden">⇩</span><sub>2</sub>);
  ⟦depth t<span class="hidden">⇩</span><sub>1</sub> a = height t<span class="hidden">⇩</span><sub>1</sub>; height t<span class="hidden">⇩</span><sub>1</sub> ≥ height t<span class="hidden">⇩</span><sub>2</sub>⟧ ⟹ P⟧ ⟹
 P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cut_tac</span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>depth_le_height</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_max_heightE_right</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦depth t<span class="hidden">⇩</span><sub>2</sub> a = max (height t<span class="hidden">⇩</span><sub>1</sub>) (height t<span class="hidden">⇩</span><sub>2</sub>);
  ⟦depth t<span class="hidden">⇩</span><sub>2</sub> a = height t<span class="hidden">⇩</span><sub>2</sub>; height t<span class="hidden">⇩</span><sub>2</sub> ≥ height t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹ P⟧ ⟹
 P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cut_tac</span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>depth_le_height</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We also need the following lemma.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_alphabet_eq_imp_height_gt_0</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"height t &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet t = alphabet u"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"height u &gt; 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>exists_in_alphabet</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>exists_in_alphabet</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹consistent t›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>bc</span><span> </span><span>t</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Symbol Frequencies›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl frequency\/} of a symbol (which we denoted by $w_a$ in
Section~\ref{binary-codes}) is the sum of the weights attached to the
leaf nodes labeled with that symbol. If the tree is consistent, the sum
comprises at most one nonzero term. The frequency is then the weight of the leaf
node labeled with the symbol, or 0 if there is no such node. The generalization
to forests is straightforward.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>freq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq (Leaf w a) b = (if b = a then w else 0)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) b = freq t<span class="hidden">⇩</span><sub>1</sub> b + freq t<span class="hidden">⇩</span><sub>2</sub> b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>freq<span class="hidden">⇩</span><sub>F</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ 'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq<span class="hidden">⇩</span><sub>F</sub> [] b = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq<span class="hidden">⇩</span><sub>F</sub> (t # ts) b = freq t b + freq<span class="hidden">⇩</span><sub>F</sub> ts b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Alphabet and symbol frequencies are intimately related. Simplification rules
ensure that sums of the form @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a + freq t<span class="hidden">⇩</span><sub>2</sub> a"} collapse to a
single term when we know which tree @{term a} belongs to.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet_imp_freq_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t ⟹ freq t a = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet<span class="hidden">⇩</span><sub>F</sub>_imp_freq<span class="hidden">⇩</span><sub>F</sub>_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts ⟹ freq<span class="hidden">⇩</span><sub>F</sub> ts a = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_0_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {}; a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹ freq t<span class="hidden">⇩</span><sub>2</sub> a = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>notin_alphabet_imp_freq_0</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_iff_not_equal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_0_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {}; a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>⟧ ⟹ freq t<span class="hidden">⇩</span><sub>1</sub> a = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>disjoint_iff_not_equal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Two trees are {\em comparable} if they have the same alphabet and symbol
frequencies. This is an important concept, because it allows us to state not
only that the tree constructed by Huffman's algorithm is optimal but also that
it has the expected alphabet and frequencies.

We close this section with a more technical lemma.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height<span class="hidden">⇩</span><sub>F</sub>_0_imp_Leaf_freq<span class="hidden">⇩</span><sub>F</sub>_in_set</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent<span class="hidden">⇩</span><sub>F</sub> ts; height<span class="hidden">⇩</span><sub>F</sub> ts = 0; a ∈ alphabet<span class="hidden">⇩</span><sub>F</sub> ts⟧ ⟹
 Leaf (freq<span class="hidden">⇩</span><sub>F</sub> ts a) a ∈ set ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weight›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The @{term weight} function returns the weight of a tree. In the
@{const Node} case, we ignore the weight cached in the node and instead
compute the tree's weight recursively. This makes reasoning simpler because we
can then avoid specifying cache correctness as an assumption in our lemmas.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"weight (Leaf w a) = w"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"weight (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = weight t<span class="hidden">⇩</span><sub>1</sub> + weight t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The weight of a tree is the sum of the frequencies of its symbols.

\myskip

\noindent
\isacommand{lemma} ‹weight_eq_Sum_freq›: \\
{\isachardoublequoteopen}$\displaystyle ‹consistent t ⟹ weight t› =
\!\!\sum_{a\in @{term "alphabet t"}}^{\phantom{.}}\!\! @{term "freq t a"}$%
{\isachardoublequoteclose}

\vskip-\myskipamount
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_eq_Sum_freq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ weight t = (∑a ∈ alphabet t. freq t a)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The assumption @{term "consistent t"} is not necessary, but it simplifies the
proof by letting us invoke the lemma @{thm [source] sum.union_disjoint}:
$$‹⟦finite A; finite B; A ∩ B = {}⟧ ⟹›~\!\sum_{x\in A} @{term "g x"}
\vthinspace \mathrel{+} \sum_{x\in B} @{term "g x"}\vthinspace = %
 \!\!\sum_{x\in A \cup B}\! @{term "g x"}.$$
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cost›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl cost\/} of a consistent tree, sometimes called the {\sl weighted path
length}, is given by the sum $\sum_{a \in @{term "alphabet t"}\,}
@{term "freq t a"} \mathbin{‹*›} @{term "depth t a"}$
(which we denoted by $\sum_a w_a \vthinspace\delta_a$ in
Section~\ref{binary-codes}). It obeys a simple recursive law.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>cost</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"cost (Leaf w a) = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cost (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = weight t<span class="hidden">⇩</span><sub>1</sub> + cost t<span class="hidden">⇩</span><sub>1</sub> + weight t<span class="hidden">⇩</span><sub>2</sub> + cost t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
One interpretation of this recursive law is that the cost of a tree is the sum
of the weights of its inner nodes \cite[p.~405]{knuth-1997}. (Recall that
$@{term "weight (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>)"} = @{term "weight t<span class="hidden">⇩</span><sub>1</sub> + weight t<span class="hidden">⇩</span><sub>2</sub>"}$.) Since
the cost of a tree is such a fundamental concept, it seems necessary to prove
that the above function definition is correct.

\myskip

\noindent
\isacommand{theorem} ‹cost_eq_Sum_freq_mult_depth›: \\
{\isachardoublequoteopen}$\displaystyle ‹consistent t ⟹ cost t› =
\!\!\sum_{a\in @{term "alphabet t"}}^{\phantom{.}}\!\!
@{term "freq t a * depth t a"}$%
{\isachardoublequoteclose}

\myskip

\noindent
The proof is by structural induction on $t$. If $t = @{term "Leaf w b"}$, both
sides of the equation simplify to 0. This leaves the case $@{term t} =
@{term "Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"}$. Let $A$, $A_1$, and $A_2$ stand for
@{term "alphabet t"}, @{term "alphabet t<span class="hidden">⇩</span><sub>1</sub>"}, and @{term "alphabet t<span class="hidden">⇩</span><sub>2</sub>"},
respectively. We have
%
$$\begin{tabularx}{\textwidth}{@%
{\hskip\leftmargin}cX@%
{}}
    &amp; @{term "cost t"} \\
\eq &amp; \justif{definition of @{const cost}} \\
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>1</sub> + cost t<span class="hidden">⇩</span><sub>1</sub> + weight t<span class="hidden">⇩</span><sub>2</sub> + cost t<span class="hidden">⇩</span><sub>2</sub>"}$ \\
\eq &amp; \justif{induction hypothesis} \\
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>1</sub>"} \mathrel{+}
       \sum_{a\in A_1\,} @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a * depth t<span class="hidden">⇩</span><sub>1</sub> a"} \mathrel{+} {}$ \\
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>2</sub>"} \mathrel{+}
       \sum_{a\in A_2\,} @{term "freq t<span class="hidden">⇩</span><sub>2</sub> a * depth t<span class="hidden">⇩</span><sub>2</sub> a"}$ \\
\eq &amp; \justif{definition of @{const depth}, consistency} \\[\extrah]
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>1</sub>"} \mathrel{+}
       \sum_{a\in A_1\,} @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a * (depth t a - 1)"} \mathrel{+}
       {}$ \\
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>2</sub>"} \mathrel{+}
       \sum_{a\in A_2\,} @{term "freq t<span class="hidden">⇩</span><sub>2</sub> a * (depth t a - 1)"}$ \\[\extrah]
\eq &amp; \justif{distributivity of ‹*› and $\sum$ over $-$} \\[\extrah]
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>1</sub>"} \mathrel{+}
       \sum_{a\in A_1\,} @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a * depth t a"} \mathrel{-}
       \sum_{a\in A_1\,} @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a"} \mathrel{+} {}$ \\
    &amp; $@{term "weight t<span class="hidden">⇩</span><sub>2</sub>"} \mathrel{+}
       \sum_{a\in A_2\,} @{term "freq t<span class="hidden">⇩</span><sub>2</sub> a * depth t a"} \mathrel{-}
       \sum_{a\in A_2\,} @{term "freq t<span class="hidden">⇩</span><sub>2</sub> a"}$ \\[\extrah]
\eq &amp; \justif{@{thm [source] weight_eq_Sum_freq}} \\[\extrah]
    &amp; $\sum_{a\in A_1\,} @{term "freq t<span class="hidden">⇩</span><sub>1</sub> a * depth t a"} \mathrel{+}
       \sum_{a\in A_2\,} @{term "freq t<span class="hidden">⇩</span><sub>2</sub> a * depth t a"}$ \\[\extrah]
\eq &amp; \justif{definition of @{const freq}, consistency} \\[\extrah]
    &amp; $\sum_{a\in A_1\,} @{term "freq t a * depth t a"} \mathrel{+}
       \sum_{a\in A_2\,} @{term "freq t a * depth t a"}$ \\[\extrah]
\eq &amp; \justif{@{thm [source] sum.union_disjoint}, consistency} \\
    &amp; $\sum_{a\in A_1\cup A_2\,} @{term "freq t a * depth t a"}$ \\
\eq &amp; \justif{definition of @{const alphabet}} \\
    &amp; $\sum_{a\in A\,} @{term "freq t a * depth t a"}$.
\end{tabularx}$$

\noindent
The structured proof closely follows this argument.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cost_eq_Sum_freq_mult_depth</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ cost t = (∑a ∈ alphabet t. freq t a * depth t a)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet ?t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?A<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?A<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹consistent ?t›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a. ⟦?A<span class="hidden">⇩</span><sub>1</sub> ∩ ?A<span class="hidden">⇩</span><sub>2</sub> = {}; a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>⟧ ⟹ depth ?t a = depth t<span class="hidden">⇩</span><sub>2</sub> a + 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost ?t = weight t<span class="hidden">⇩</span><sub>1</sub> + cost t<span class="hidden">⇩</span><sub>1</sub> + weight t<span class="hidden">⇩</span><sub>2</sub> + cost t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = weight t<span class="hidden">⇩</span><sub>1</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq t<span class="hidden">⇩</span><sub>1</sub> a * depth t<span class="hidden">⇩</span><sub>1</sub> a)
    + weight t<span class="hidden">⇩</span><sub>2</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq t<span class="hidden">⇩</span><sub>2</sub> a * depth t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = weight t<span class="hidden">⇩</span><sub>1</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq t<span class="hidden">⇩</span><sub>1</sub> a * (depth ?t a - 1))
    + weight t<span class="hidden">⇩</span><sub>2</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq t<span class="hidden">⇩</span><sub>2</sub> a * (depth ?t a - 1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>d<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = weight t<span class="hidden">⇩</span><sub>1</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq t<span class="hidden">⇩</span><sub>1</sub> a * depth ?t a)
    - (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq t<span class="hidden">⇩</span><sub>1</sub> a)
    + weight t<span class="hidden">⇩</span><sub>2</sub> + (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq t<span class="hidden">⇩</span><sub>2</sub> a * depth ?t a)
    - (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span>d<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq t<span class="hidden">⇩</span><sub>1</sub> a * depth ?t a)
    + (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq t<span class="hidden">⇩</span><sub>2</sub> a * depth ?t a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>weight_eq_Sum_freq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub>. freq ?t a * depth ?t a)
    + (∑a ∈ ?A<span class="hidden">⇩</span><sub>2</sub>. freq ?t a * depth ?t a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑a ∈ ?A<span class="hidden">⇩</span><sub>1</sub> ∪ ?A<span class="hidden">⇩</span><sub>2</sub>. freq ?t a * depth ?t a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.union_disjoint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = (∑a ∈ ?A. freq ?t a * depth ?t a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Finally, it should come as no surprise that trees with height 0 have cost 0.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_0_imp_cost_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t = 0 ⟹ cost t = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Optimality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A tree is optimum if and only if its cost is not greater than that of any
comparable tree. We can ignore inconsistent trees without loss of generality.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>optimum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"optimum t =
 (∀u. consistent u ⟶ alphabet t = alphabet u ⟶ freq t = freq u ⟶
  cost t ≤ cost u)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Functional Implementation of Huffman's Algorithm \label{implementation}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cached Weight›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl cached weight\/} of a node is the weight stored directly in the node.
Our arguments rely on the computed weight (embodied by the @{const weight}
function) rather than the cached weight, but the implementation of Huffman's
algorithm uses the cached weight for performance reasons.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>cachedWeight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"cachedWeight (Leaf w a) = w"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cachedWeight (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = w"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The cached weight of a leaf node is identical to its computed weight.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_0_imp_cachedWeight_eq_weight</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t = 0 ⟹ cachedWeight t = weight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Tree Union›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The implementation of Huffman's algorithm builds on two additional auxiliary
functions. The first one, ‹uniteTrees›, takes two trees
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1.pdf}}}
  \qquad \hbox{and} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-w2.pdf}}}$$

\noindent
and returns the tree\strut
$$\includegraphics[scale=1.25]{tree-w1-w2.pdf}$$

\vskip-.5\myskipamount
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uniteTrees</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a tree ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"uniteTrees t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> = Node (cachedWeight t<span class="hidden">⇩</span><sub>1</sub> + cachedWeight t<span class="hidden">⇩</span><sub>2</sub>) t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The alphabet, consistency, and symbol frequencies of a united tree are easy to
connect to the homologous properties of the subtrees.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_uniteTrees</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet (uniteTrees t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) = alphabet t<span class="hidden">⇩</span><sub>1</sub> ∪ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_uniteTrees</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {}⟧ ⟹
 consistent (uniteTrees t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_uniteTrees</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq (uniteTrees t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a = freq t<span class="hidden">⇩</span><sub>1</sub> a + freq t<span class="hidden">⇩</span><sub>2</sub> a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ordered Tree Insertion›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The auxiliary function ‹insortTree› inserts a tree into a forest sorted
by cached weight, preserving the sort order.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>insortTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a forest ⇒ 'a forest"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"insortTree u [] = [u]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"insortTree u (t # ts) =
 (if cachedWeight u ≤ cachedWeight t then u # t # ts else t # insortTree u ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The resulting forest contains one more tree than the original forest. Clearly,
it cannot be empty.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_insortTree</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"length (insortTree t ts) = length ts + 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insortTree_ne_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"insortTree t ts ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The alphabet, consistency, symbol frequencies, and height of a forest after
insertion are easy to relate to the homologous properties of the original
forest and the inserted tree.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet<span class="hidden">⇩</span><sub>F</sub>_insortTree</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) = alphabet t ∪ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent<span class="hidden">⇩</span><sub>F</sub>_insortTree</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) = consistent<span class="hidden">⇩</span><sub>F</sub> (t # ts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq<span class="hidden">⇩</span><sub>F</sub>_insortTree</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"freq<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) = (λa. freq t a + freq<span class="hidden">⇩</span><sub>F</sub> ts a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height<span class="hidden">⇩</span><sub>F</sub>_insortTree</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) = max (height t) (height<span class="hidden">⇩</span><sub>F</sub> ts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Main Algorithm›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Huffman's algorithm repeatedly unites the first two trees of the forest it
receives as argument until a single tree is left. It should initially be
invoked with a list of leaf nodes sorted by weight. Note that it is not defined
for the empty list.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>huffman</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"huffman [t] = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"huffman (t<span class="hidden">⇩</span><sub>1</sub> # t<span class="hidden">⇩</span><sub>2</sub> # ts) = huffman (insortTree (uniteTrees t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The time complexity of the algorithm is quadratic in the size of the forest.
If we eliminated the inner node's cached weight component, and instead
recomputed the weight each time it is needed, the complexity would remain
quadratic, but with a larger constant. Using a binary search in @{const
insortTree}, the corresponding imperative algorithm is $O(n \log n)$ if we keep
the weight cache and $O(n^2)$ if we drop it. An $O(n)$ imperative implementation
is possible by maintaining two queues, one containing the unprocessed leaf nodes
and the other containing the combined trees \cite[p.~404]{knuth-1997}.

The tree returned by the algorithm preserves the alphabet, consistency, and
symbol frequencies of the original forest.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>alphabet_huffman</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"ts ≠ [] ⟹ alphabet (huffman ts) = alphabet<span class="hidden">⇩</span><sub>F</sub> ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>huffman.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>consistent_huffman</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent<span class="hidden">⇩</span><sub>F</sub> ts; ts ≠ []⟧ ⟹ consistent (huffman ts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>huffman.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>freq_huffman</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"ts ≠ [] ⟹ freq (huffman ts) a = freq<span class="hidden">⇩</span><sub>F</sub> ts a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>huffman.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Auxiliary Functions Used in the Proof \label{auxiliary}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sibling of a Symbol›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The {\sl sibling\/} of a symbol $a$ in a tree $t$ is the label of the node that
is the (left or right) sibling of the node labeled with $a$ in $t$. If the
symbol $a$ is not in $t$'s alphabet or it occurs in a node with no sibling
leaf, we define the sibling as being $a$ itself; this gives us the nice property
that if $t$ is consistent, then $@{term "sibling t a"} \not= a$ if and only if
$a$ has a sibling. As an illustration, we have
$@{term "sibling t a"} = b$,\vthinspace{} $@{term "sibling t b"} = a$,
and $@{term "sibling t c"} = c$ for the tree\strut
$$t \,= \vcenter{\hbox{\includegraphics[scale=1.25]{tree-sibling.pdf}}}$$
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>sibling</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"sibling (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) a = a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sibling (Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c)) a =
     (if a = b then c else if a = c then b else a)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     (if a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then sibling t<span class="hidden">⇩</span><sub>1</sub> a
      else if a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub> then sibling t<span class="hidden">⇩</span><sub>2</sub> a
      else a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Because @{const sibling} is defined using sequential pattern matching
\cite{krauss-2007,krauss-2009}, reasoning about it can become tedious.
Simplification rules therefore play an important role.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet_imp_sibling_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t ⟹ sibling t a = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sibling.cases</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(t, a)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_0_imp_sibling_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t = 0 ⟹ sibling t a = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_in_alphabet_imp_sibling_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0; a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹
 sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a = sibling t<span class="hidden">⇩</span><sub>1</sub> a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_in_alphabet_imp_sibling_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0; a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹
 sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a = sibling t<span class="hidden">⇩</span><sub>1</sub> a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_notin_alphabet_imp_sibling_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0; a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹
 sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a = sibling t<span class="hidden">⇩</span><sub>2</sub> a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_notin_alphabet_imp_sibling_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0; a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>⟧ ⟹
 sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a = sibling t<span class="hidden">⇩</span><sub>2</sub> a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>either_height_gt_0_imp_sibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ∨ height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0 ⟹
 sibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     (if a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then sibling t<span class="hidden">⇩</span><sub>1</sub> a else sibling t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The following rules are also useful for reasoning about siblings and alphabets.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_alphabet_imp_sibling_in_alphabet</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t ⟹ sibling t a ∈ alphabet t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sibling.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_ne_imp_sibling_in_alphabet</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sibling t a ≠ a ⟹ sibling t a ∈ alphabet t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>notin_alphabet_imp_sibling_id</span><span> </span><span>in_alphabet_imp_sibling_in_alphabet</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The default induction rule for @{const sibling} distinguishes four cases.

\begin{myitemize}
\item[] {\sc Base case:}\enskip $t = @{term "Leaf w b"}$.
\item[] {\sc Induction step 1:}\enskip
        $t = @{term "Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c)"}$.
\item[] {\sc Induction step 2:}\enskip
        $t = @{term "Node w (Node w<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>1</sub><span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>1</sub><span class="hidden">⇩</span><sub>2</sub>) t<span class="hidden">⇩</span><sub>2</sub>"}$.
\item[] {\sc Induction step 3:}\enskip
        $t = @{term "Node w t<span class="hidden">⇩</span><sub>1</sub> (Node w<span class="hidden">⇩</span><sub>2</sub> t<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>2</sub>)"}$.
\end{myitemize}

\noindent
This rule leaves much to be desired. First, the last two cases overlap and
can normally be handled the same way, so they should be combined. Second, the
nested ‹Node› constructors in the last two cases reduce readability.
Third, under the assumption that $t$ is consistent, we would like to perform
the same case distinction on $a$ as we did for
@{thm [source] tree_induct_consistent}, with the same benefits for automation.
These observations lead us to develop a custom induction rule that
distinguishes the following cases.

\begin{myitemize}
\item[] {\sc Base case:}\enskip $t = @{term "Leaf w b"}$.
\item[] {\sc Induction step 1:}\enskip
        $t = @{term "Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c)"}$ with
        @{prop "b ≠ c"}.
\item[] \begin{flushleft}
        {\sc Induction step 2:}\enskip
        $t = @{term "Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"}$ and either @{term t<span class="hidden">⇩</span><sub>1</sub>} or @{term t<span class="hidden">⇩</span><sub>2</sub>}
        has nonzero height.
        \end{flushleft}
\item[] \noindent\kern\leftmargin {\sc Subcase 1:}\enspace $a$ belongs to
        @{term t<span class="hidden">⇩</span><sub>1</sub>} but not to @{term t<span class="hidden">⇩</span><sub>2</sub>}.
\item[] \noindent\kern\leftmargin {\sc Subcase 2:}\enspace $a$ belongs to
        @{term t<span class="hidden">⇩</span><sub>2</sub>} but not to @{term t<span class="hidden">⇩</span><sub>1</sub>}.
\item[] \noindent\kern\leftmargin {\sc Subcase 3:}\enspace $a$ belongs to
        neither @{term t<span class="hidden">⇩</span><sub>1</sub>} nor @{term t<span class="hidden">⇩</span><sub>2</sub>}.
\end{myitemize}

The statement of the rule and its proof are similar to what we did for
consistent trees, the main difference being that we now have two induction
steps instead of one.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_induct_consistent</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span>
</span><span>  </span><span>case_names</span><span> </span><span>base</span><span> </span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub><span class="hidden">⇩</span><sub>3</sub></span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t;
  ⋀w b a. P (Leaf w b) a;
  ⋀w w<span class="hidden">⇩</span><sub>b</sub> b w<span class="hidden">⇩</span><sub>c</sub> c a. b ≠ c ⟹ P (Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c)) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ∨ height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0; a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>;
      sibling t<span class="hidden">⇩</span><sub>1</sub> a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>;
      sibling t<span class="hidden">⇩</span><sub>1</sub> a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>; P t<span class="hidden">⇩</span><sub>1</sub> a⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ∨ height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0; a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>;
      sibling t<span class="hidden">⇩</span><sub>2</sub> a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>;
      sibling t<span class="hidden">⇩</span><sub>2</sub> a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>; P t<span class="hidden">⇩</span><sub>2</sub> a⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a;
  ⋀w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub> a.
     ⟦consistent t<span class="hidden">⇩</span><sub>1</sub>; consistent t<span class="hidden">⇩</span><sub>2</sub>; alphabet t<span class="hidden">⇩</span><sub>1</sub> ∩ alphabet t<span class="hidden">⇩</span><sub>2</sub> = {};
      height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ∨ height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0; a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>; a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>⟧ ⟹
     P (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a⟧ ⟹
 P t a"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rotate_tac</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction_schema</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>1</sub> = 0 ∧ height t<span class="hidden">⇩</span><sub>2</sub> = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_alphabet_imp_sibling_in_alphabet</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>lexicographic_order</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The custom induction rule allows us to prove new properties of @{const sibling}
with little effort.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_sibling_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ sibling t (sibling t a) = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_reciprocal</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; sibling t a = b⟧ ⟹ sibling t b = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_height_imp_sibling_ne</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; depth t a = height t; height t &gt; 0; a ∈ alphabet t⟧ ⟹
 sibling t a ≠ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_sibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ depth t (sibling t a) = depth t a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Leaf Interchange›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹swapLeaves› function takes a tree $t$ together with two symbols
$a$, $b$ and their frequencies $@{term w<span class="hidden">⇩</span><sub>a</sub>}$, $@{term w<span class="hidden">⇩</span><sub>b</sub>}$, and returns the tree
$t$ in which the leaf nodes labeled with $a$ and $b$ are exchanged. When
invoking ‹swapLeaves›, we normally pass @{term "freq t a"} and
@{term "freq t b"} for @{term w<span class="hidden">⇩</span><sub>a</sub>} and @{term w<span class="hidden">⇩</span><sub>b</sub>}.

Note that we do not bother updating the cached weight of the ancestor nodes
when performing the interchange. The cached weight is used only in the
implementation of Huffman's algorithm, which does not invoke ‹swapLeaves›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>swapLeaves</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat ⇒ 'a ⇒ nat ⇒ 'a ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"swapLeaves (Leaf w<span class="hidden">⇩</span><sub>c</sub> c) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
     (if c = a then Leaf w<span class="hidden">⇩</span><sub>b</sub> b else if c = b then Leaf w<span class="hidden">⇩</span><sub>a</sub> a else Leaf w<span class="hidden">⇩</span><sub>c</sub> c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"swapLeaves (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
     Node w (swapLeaves t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) (swapLeaves t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Swapping a symbol~$a$ with itself leaves the tree $t$ unchanged if $a$ does not
belong to it or if the specified frequencies @{term w<span class="hidden">⇩</span><sub>a</sub>} and @{term w<span class="hidden">⇩</span><sub>b</sub>} equal
@{term "freq t a"}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swapLeaves_id_when_notin_alphabet</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t ⟹ swapLeaves t w a w' a = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swapLeaves_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ swapLeaves t (freq t a) a (freq t a) a = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The alphabet, consistency, symbol depths, height, and symbol frequencies of the
tree @{term "swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"} can be related to the homologous
properties of $t$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_swapLeaves</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) =
     (if a ∈ alphabet t then
        if b ∈ alphabet t then alphabet t else (alphabet t - {a}) ∪ {b}
      else
        if b ∈ alphabet t then (alphabet t - {b}) ∪ {a} else alphabet t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_swapLeaves</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ consistent (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alphabet_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_swapLeaves_neither</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; c ≠ a; c ≠ b⟧ ⟹ depth (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) c = depth t c"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alphabet_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_swapLeaves</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = height t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_swapLeaves</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ≠ b⟧ ⟹
 freq (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) =
     (λc. if c = a then if b ∈ alphabet t then w<span class="hidden">⇩</span><sub>a</sub> else 0
          else if c = b then if a ∈ alphabet t then w<span class="hidden">⇩</span><sub>b</sub> else 0
          else freq t c)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
For the lemmas concerned with the resulting tree's weight and cost, we avoid
subtraction on natural numbers by rearranging terms. For example, we write
$$@{prop "weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t a = weight t + w<span class="hidden">⇩</span><sub>b</sub>"}$$
\noindent
rather than the more conventional
$$@{prop "weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = weight t + w<span class="hidden">⇩</span><sub>b</sub> - freq t a"}.$$
In Isabelle/HOL, these two equations are not equivalent, because by definition
$m - n = 0$ if $n &gt; m$. We could use the second equation and additionally
assert that @{prop "weight t ≥ freq t a"} (an easy consequence of
@{thm [source] weight_eq_Sum_freq}), and then apply the \textit{arith}
tactic, but it is much simpler to use the first equation and stay with
\textit{simp} and \textit{auto}. Another option would be to use
integers instead of natural numbers.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_swapLeaves</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ≠ b⟧ ⟹
 if a ∈ alphabet t then
   if b ∈ alphabet t then
     weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t a + freq t b =
         weight t + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>
   else
     weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t a = weight t + w<span class="hidden">⇩</span><sub>b</sub>
 else
   if b ∈ alphabet t then
     weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t b = weight t + w<span class="hidden">⇩</span><sub>a</sub>
   else
     weight (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = weight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹{\sc Base case:}\enspace $t = @{term "Leaf w b"}$›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹{\sc Induction step:}\enspace $t = @{term "Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>"}$›</span><span>
</span><span>  </span><span class="comment">― ‹{\sc Subcase 1:}\enspace $a$ belongs to @{term t<span class="hidden">⇩</span><sub>1</sub>} but not to
        @{term t<span class="hidden">⇩</span><sub>2</sub>}›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹{\sc Subcase 2:}\enspace $a$ belongs to @{term t<span class="hidden">⇩</span><sub>2</sub>} but not to
        @{term t<span class="hidden">⇩</span><sub>1</sub>}›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment">― ‹{\sc Subcase 3:}\enspace $a$ belongs to neither @{term t<span class="hidden">⇩</span><sub>1</sub>} nor
        @{term t<span class="hidden">⇩</span><sub>2</sub>}›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b</span><span> </span><span>step<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step<span class="hidden">⇩</span><sub>3</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_swapLeaves</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ≠ b⟧ ⟹
 if a ∈ alphabet t then
   if b ∈ alphabet t then
     cost (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t a * depth t a
     + freq t b * depth t b =
         cost t + w<span class="hidden">⇩</span><sub>a</sub> * depth t b + w<span class="hidden">⇩</span><sub>b</sub> * depth t a
   else
     cost (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t a * depth t a =
         cost t + w<span class="hidden">⇩</span><sub>b</sub> * depth t a
 else
   if b ∈ alphabet t then
     cost (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t b * depth t b =
         cost t + w<span class="hidden">⇩</span><sub>a</sub> * depth t b
   else
     cost (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = cost t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹consistent (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"if a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then
              if b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then
                weight (swapLeaves t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>1</sub> a + freq t<span class="hidden">⇩</span><sub>1</sub> b =
                    weight t<span class="hidden">⇩</span><sub>1</sub> + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>
                  else
                weight (swapLeaves t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>1</sub> a = weight t<span class="hidden">⇩</span><sub>1</sub> + w<span class="hidden">⇩</span><sub>b</sub>
            else
              if b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub> then
                weight (swapLeaves t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>1</sub> b = weight t<span class="hidden">⇩</span><sub>1</sub> + w<span class="hidden">⇩</span><sub>a</sub>
              else
                weight (swapLeaves t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = weight t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>weight_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"if a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub> then
              if b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub> then
                weight (swapLeaves t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>2</sub> a + freq t<span class="hidden">⇩</span><sub>2</sub> b =
                    weight t<span class="hidden">⇩</span><sub>2</sub> + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>
              else
                weight (swapLeaves t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>2</sub> a = weight t<span class="hidden">⇩</span><sub>2</sub> + w<span class="hidden">⇩</span><sub>b</sub>
            else
              if b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub> then
                weight (swapLeaves t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) + freq t<span class="hidden">⇩</span><sub>2</sub> b = weight t<span class="hidden">⇩</span><sub>2</sub> + w<span class="hidden">⇩</span><sub>a</sub>
              else
                weight (swapLeaves t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = weight t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>weight_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>w<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Common sense tells us that the following statement is valid: ``If Astrid
exchanges her house with Bernard's neighbor, Bernard becomes Astrid's new
neighbor.'' A similar property holds for binary trees.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_swapLeaves_sibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; sibling t b ≠ b; a ≠ b⟧ ⟹
 sibling (swapLeaves t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>s</sub> (sibling t b)) a = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Node</span><span> </span><span>w</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>1</sub> = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>w<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Leaf</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>2</sub> = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Leaf</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = b"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ b"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling t<span class="hidden">⇩</span><sub>2</sub> b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c ≠ b›</span></span></span><span> </span><span>l<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sibling_ne_imp_sibling_in_alphabet</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c ≠ b›</span></span></span><span> </span><span>l<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>2</sub> = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>w<span class="hidden">⇩</span><sub>d</sub></span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Leaf</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d = b"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>l<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≠ b"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling t<span class="hidden">⇩</span><sub>1</sub> b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d ≠ b›</span></span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>l<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sibling_ne_imp_sibling_in_alphabet</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d ≠ b›</span></span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>l<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alphabet_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d ≠ b›</span></span></span><span> </span><span>l<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_alphabet_imp_sibling_in_alphabet</span><span>
</span><span>                           </span><span>alphabet_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Symbol Interchange›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹swapSyms› function provides a simpler interface to
@{const swapLeaves}, with @{term "freq t a"} and @{term "freq t b"} in place of
@{term "w<span class="hidden">⇩</span><sub>a</sub>"} and @{term "w<span class="hidden">⇩</span><sub>b</sub>"}. Most lemmas about ‹swapSyms› are directly
adapted from the homologous results about @{const swapLeaves}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>swapSyms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ 'a ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"swapSyms t a b = swapLeaves t (freq t a) a (freq t b) b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swapSyms_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ swapSyms t a a = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_swapSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦a ∈ alphabet t; b ∈ alphabet t⟧ ⟹ alphabet (swapSyms t a b) = alphabet t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span> </span><span>alphabet_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_swapSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ consistent (swapSyms t a b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>depth_swapSyms_neither</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; c ≠ a; c ≠ b⟧ ⟹
 depth (swapSyms t a b) c = depth t c"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_swapSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t; b ∈ alphabet t⟧ ⟹
 freq (swapSyms t a b) = freq t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span> </span><span>ext</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_swapSyms</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =
           cost t + freq t a * depth t b + freq t b * depth t a"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapLeaves t (freq t a) a (freq t b) b)
    + freq t a * depth t a + freq t b * depth t b =
    cost t + freq t a * depth t b + freq t b * depth t a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cost_swapLeaves</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
If $a$'s frequency is lower than or equal to $b$'s, and $a$ is higher up in the
tree than $b$ or at the same level, then interchanging $a$ and $b$ does not
increase the tree's cost.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_le_imp_sum_mult_le_sum_mult</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≤ (n::nat)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i * n + j * m ≤ i * m + j * n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i * m + i * (n - m) + j * m ≤ i * m + j * m + j * (n - m)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_mult_distrib2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_swapSyms_le</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"freq t a ≤ freq t b"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"depth t a ≤ depth t b"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapSyms t a b) ≤ cost t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?aabb</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"freq t a * depth t a + freq t b * depth t b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?abba</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"freq t a * depth t b + freq t b * depth t a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?abba ≤ ?aabb"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span>-</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_le_imp_sum_mult_le_sum_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapSyms t a b) + ?aabb = cost t + ?abba"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cost_swapSyms</span><span> </span><span>add.assoc</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ cost t + ?aabb"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?abba ≤ ?aabb›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span>-</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
As stated earlier, ``If Astrid exchanges her house with Bernard's neighbor,
Bernard becomes Astrid's new neighbor.''
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_swapSyms_sibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; sibling t b ≠ b; a ≠ b⟧ ⟹
 sibling (swapSyms t a (sibling t b)) a = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
``If Astrid exchanges her house with Bernard, Astrid becomes Bernard's old
neighbor's new neighbor.''
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_swapSyms_other_sibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; sibling t b ≠ a; sibling t b ≠ b; a ≠ b⟧ ⟹
 sibling (swapSyms t a b) (sibling t b) = a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>consistent_swapSyms</span><span> </span><span>sibling_swapSyms_sibling</span><span> </span><span>sibling_reciprocal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Four-Way Symbol Interchange \label{four-way-symbol-interchange}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The @{const swapSyms} function exchanges two symbols $a$ and $b$. We use it
to define the four-way symbol interchange function ‹swapFourSyms›, which
takes four symbols $a$, $b$, $c$, $d$ with $a \ne b$ and $c \ne d$, and
exchanges them so that $a$ and $b$ occupy $c$~and~$d$'s positions.

A naive definition of this function would be
$$@{prop "swapFourSyms t a b c d = swapSyms (swapSyms t a c) b d"}.$$
This definition fails in the face of aliasing: If $a = d$, but
$b \ne c$, then ‹swapFourSyms a b c d› would leave $a$ in $b$'s
position.%
\footnote{Cormen et al.\ \cite[p.~390]{cormen-et-al-2001} forgot to consider
this case in their proof. Thomas Cormen indicated in a personal communication
that this will be corrected in the next edition of the book.}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>swapFourSyms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ 'a ⇒ 'a ⇒ 'a ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"swapFourSyms t a b c d =
 (if a = d then swapSyms t b c
  else if b = c then swapSyms t a d
  else swapSyms (swapSyms t a c) b d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Lemmas about @{const swapFourSyms} are easy to prove by expanding its
definition.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_swapFourSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦a ∈ alphabet t; b ∈ alphabet t; c ∈ alphabet t; d ∈ alphabet t⟧ ⟹
 alphabet (swapFourSyms t a b c d) = alphabet t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapFourSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_swapFourSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ consistent (swapFourSyms t a b c d)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>swapFourSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_swapFourSyms</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t; b ∈ alphabet t; c ∈ alphabet t;
  d ∈ alphabet t⟧ ⟹
 freq (swapFourSyms t a b c d) = freq t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swapFourSyms_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
``If Astrid and Bernard exchange their houses with Carmen and her neighbor,
Astrid and Bernard will now be neighbors.''
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sibling_swapFourSyms_when_4th_is_sibling</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ alphabet t"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"a ≠ b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling t c ≠ c"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling (swapFourSyms t a b c (sibling t c)) a = b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ sibling t c ∧ b ≠ c"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling t c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t<span class="hidden">⇩</span><sub>s</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"swapFourSyms t a b c ?d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>abba</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(sibling ?t<span class="hidden">⇩</span><sub>s</sub> a = b) = (sibling ?t<span class="hidden">⇩</span><sub>s</sub> b = a)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹consistent t›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>consistent_swapFourSyms</span><span> </span><span>sibling_reciprocal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling t c = sibling (swapSyms t a c) a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sibling_reciprocal</span><span> </span><span>sibling_swapSyms_sibling</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling ?t<span class="hidden">⇩</span><sub>s</sub> b = sibling (swapSyms t a c) ?d"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swapFourSyms_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>sibling_reciprocal</span><span> </span><span>sibling_swapSyms_other_sibling</span><span> </span><span>swapLeaves_id</span><span> </span><span>swapSyms_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling ?t<span class="hidden">⇩</span><sub>s</sub> b = a"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>abba</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sibling_reciprocal</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swapFourSyms_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sibling Merge›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Given a symbol $a$, the ‹mergeSibling› function transforms the tree
%
\setbox\myboxi=\hbox{\includegraphics[scale=1.25]{tree-splitLeaf-a.pdf}}%
\setbox\myboxii=\hbox{\includegraphics[scale=1.25]{tree-splitLeaf-ab.pdf}}%
\mydimeni=\ht\myboxii
$$\vcenter{\box\myboxii}
  \qquad \hbox{into} \qquad
  \smash{\lower\ht\myboxi\hbox{\raise.5\mydimeni\box\myboxi}}$$
The frequency of $a$ in the result is the sum of the original frequencies of
$a$ and $b$, so as not to alter the tree's weight.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mergeSibling</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"mergeSibling (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) a = Leaf w<span class="hidden">⇩</span><sub>b</sub> b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mergeSibling (Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c)) a =
     (if a = b ∨ a = c then Leaf (w<span class="hidden">⇩</span><sub>b</sub> + w<span class="hidden">⇩</span><sub>c</sub>) a
      else Node w (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) (Leaf w<span class="hidden">⇩</span><sub>c</sub> c))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mergeSibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     Node w (mergeSibling t<span class="hidden">⇩</span><sub>1</sub> a) (mergeSibling t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The definition of @{const mergeSibling} has essentially the same structure as
that of @{const sibling}. As a result, the custom induction rule that we
derived for @{const sibling} works equally well for reasoning about
@{const mergeSibling}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mergeSibling_induct_consistent</span><span> </span><span class="delimiter">=</span><span> </span><span>sibling_induct_consistent</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The properties of @{const mergeSibling} echo those of @{const sibling}. Like
with @{const sibling}, simplification rules are crucial.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet_imp_mergeSibling_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t ⟹ mergeSibling t a = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_imp_mergeSibling_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ⟹
 mergeSibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     Node w (mergeSibling t<span class="hidden">⇩</span><sub>1</sub> a) (mergeSibling t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>height_gt_0_imp_mergeSibling_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0 ⟹
 mergeSibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     Node w (mergeSibling t<span class="hidden">⇩</span><sub>1</sub> a) (mergeSibling t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>either_height_gt_0_imp_mergeSibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"height t<span class="hidden">⇩</span><sub>1</sub> &gt; 0 ∨ height t<span class="hidden">⇩</span><sub>2</sub> &gt; 0 ⟹
 mergeSibling (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) a =
     Node w (mergeSibling t<span class="hidden">⇩</span><sub>1</sub> a) (mergeSibling t<span class="hidden">⇩</span><sub>2</sub> a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_mergeSibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t⟧ ⟹
 alphabet (mergeSibling t a) = (alphabet t - {sibling t a}) ∪ {a}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_mergeSibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"consistent t ⟹ consistent (mergeSibling t a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_mergeSibling</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t; sibling t a ≠ a⟧ ⟹
 freq (mergeSibling t a) =
     (λc. if c = a then freq t a + freq t (sibling t a)
          else if c = sibling t a then 0
          else freq t c)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_mergeSibling</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"weight (mergeSibling t a) = weight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling.induct</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
If $a$ has a sibling, merging $a$ and its sibling reduces $t$'s cost by
@{term "freq t a + freq t (sibling t a)"}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_mergeSibling</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; sibling t a ≠ a⟧ ⟹
 cost (mergeSibling t a) + freq t a + freq t (sibling t a) = cost t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mergeSibling_induct_consistent</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Leaf Split›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹splitLeaf› function undoes the merging performed by
@{const mergeSibling}: Given two symbols $a$, $b$ and two frequencies
$@{term w<span class="hidden">⇩</span><sub>a</sub>}$, $@{term w<span class="hidden">⇩</span><sub>b</sub>}$, it transforms
\setbox\myboxi=\hbox{\includegraphics[scale=1.25]{tree-splitLeaf-a.pdf}}%
\setbox\myboxii=\hbox{\includegraphics[scale=1.25]{tree-splitLeaf-ab.pdf}}%
$$\smash{\lower\ht\myboxi\hbox{\raise.5\ht\myboxii\box\myboxi}}
  \qquad \hbox{into} \qquad
  \vcenter{\box\myboxii}$$
In the resulting tree, $a$ has frequency @{term w<span class="hidden">⇩</span><sub>a</sub>} and $b$ has frequency
@{term w<span class="hidden">⇩</span><sub>b</sub>}. We normally invoke it with @{term w<span class="hidden">⇩</span><sub>a</sub>}~and @{term w<span class="hidden">⇩</span><sub>b</sub>} such that
@{prop "freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>splitLeaf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ nat ⇒ 'a ⇒ nat ⇒ 'a ⇒ 'a tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"splitLeaf (Leaf w<span class="hidden">⇩</span><sub>c</sub> c) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
 (if c = a then Node w<span class="hidden">⇩</span><sub>c</sub> (Leaf w<span class="hidden">⇩</span><sub>a</sub> a) (Leaf w<span class="hidden">⇩</span><sub>b</sub> b) else Leaf w<span class="hidden">⇩</span><sub>c</sub> c)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"splitLeaf (Node w t<span class="hidden">⇩</span><sub>1</sub> t<span class="hidden">⇩</span><sub>2</sub>) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
 Node w (splitLeaf t<span class="hidden">⇩</span><sub>1</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) (splitLeaf t<span class="hidden">⇩</span><sub>2</sub> w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>splitLeaf<span class="hidden">⇩</span><sub>F</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ nat ⇒ 'a ⇒ nat ⇒ 'a ⇒ 'a forest"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"splitLeaf<span class="hidden">⇩</span><sub>F</sub> [] w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"splitLeaf<span class="hidden">⇩</span><sub>F</sub> (t # ts) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
     splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b # splitLeaf<span class="hidden">⇩</span><sub>F</sub> ts w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Splitting leaf nodes affects the alphabet, consistency, symbol frequencies,
weight, and cost in unsurprising ways.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet_imp_splitLeaf_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t ⟹ splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b = t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>notin_alphabet<span class="hidden">⇩</span><sub>F</sub>_imp_splitLeaf<span class="hidden">⇩</span><sub>F</sub>_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts ⟹ splitLeaf<span class="hidden">⇩</span><sub>F</sub> ts w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b = ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alphabet_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"alphabet (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) =
 (if a ∈ alphabet t then alphabet t ∪ {b} else alphabet t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>consistent_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; b ∉ alphabet t⟧ ⟹ consistent (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>freq_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; b ∉ alphabet t⟧ ⟹
 freq (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) =
 (if a ∈ alphabet t then (λc. if c = a then w<span class="hidden">⇩</span><sub>a</sub> else if c = b then w<span class="hidden">⇩</span><sub>b</sub> else freq t c)
  else freq t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t; freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>⟧ ⟹
 weight (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = weight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent t; a ∈ alphabet t; freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>⟧ ⟹
 cost (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = cost t + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_induct_consistent</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weight Sort Order›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
An invariant of Huffman's algorithm is that the forest is sorted by weight.
This is expressed by the ‹sortedByWeight› function.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>sortedByWeight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a forest ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"sortedByWeight [] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sortedByWeight [t] = True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sortedByWeight (t<span class="hidden">⇩</span><sub>1</sub> # t<span class="hidden">⇩</span><sub>2</sub> # ts) =
 (weight t<span class="hidden">⇩</span><sub>1</sub> ≤ weight t<span class="hidden">⇩</span><sub>2</sub> ∧ sortedByWeight (t<span class="hidden">⇩</span><sub>2</sub> # ts))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The function obeys the following fairly obvious laws.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sortedByWeight_Cons_imp_sortedByWeight</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sortedByWeight (t # ts) ⟹ sortedByWeight ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sortedByWeight_Cons_imp_forall_weight_ge</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"sortedByWeight (t # ts) ⟹ ∀u ∈ set ts. weight u ≥ weight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sortedByWeight_insortTree</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦sortedByWeight ts; height t = 0; height<span class="hidden">⇩</span><sub>F</sub> ts = 0⟧ ⟹
 sortedByWeight (insortTree t ts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>sortedByWeight.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pair of Minimal Symbols›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹minima› predicate expresses that two symbols
$a$, $b \in @{term "alphabet t"}$ have the lowest frequencies in the tree $t$.
Minimal symbols need not be uniquely defined.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>minima</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a tree ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"minima t a b =
 (a ∈ alphabet t ∧ b ∈ alphabet t ∧ a ≠ b
  ∧ (∀c ∈ alphabet t. c ≠ a ⟶ c ≠ b ⟶
    freq t c ≥ freq t a ∧ freq t c ≥ freq t b))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Formalization of the Textbook Proof \label{formalization}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Four-Way Symbol Interchange Cost Lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
If $a$ and $b$ are minima, and $c$ and $d$ are at the very bottom of the tree,
then exchanging $a$ and $b$ with $c$ and $d$ does not increase the cost.
Graphically, we have\strut
%
$${\it cost\/}
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-minima-abcd.pdf}}}
  \,\mathop{\le}\;\;\;
  {\it cost\/}
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-minima.pdf}}}$$

\noindent
This cost property is part of Knuth's proof:

\begin{quote}
Let $V$ be an internal node of maximum distance from the root. If $w_1$ and
$w_2$ are not the weights already attached to the children of $V$, we can
interchange them with the values that are already there; such an interchange
does not increase the weighted path length.
\end{quote}

\noindent
Lemma~16.2 in Cormen et al.~\cite[p.~389]{cormen-et-al-2001} expresses a
similar property, which turns out to be a corollary of our cost property:

\begin{quote}
Let $C$ be an alphabet in which each character $c \in C$ has frequency $f[c]$.
Let $x$ and $y$ be two characters in $C$ having the lowest frequencies. Then
there exists an optimal prefix code for $C$ in which the codewords for $x$ and
$y$ have the same length and differ only in the last bit.
\end{quote}

\vskip-.75\myskipamount
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cost_swapFourSyms_le</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minima t a b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ∈ alphabet t"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"depth t c = height t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"depth t d = height t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ≠ d"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapFourSyms t a b c d) ≤ cost t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lems</span><span> </span><span class="delimiter">=</span><span> </span><span>swapFourSyms_def</span><span> </span><span>minima_def</span><span> </span><span>cost_swapSyms_le</span><span> </span><span>depth_le_height</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ d ∧ b ≠ c"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = c"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = d"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = c›</span></span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ d"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = c›</span></span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ c"</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b = d"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ c›</span></span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ d"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost (swapFourSyms t a b c d) ≤ cost (swapSyms t a c)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b ≠ d›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ c›</span></span></span><span> </span><span>True</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ cost t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b ≠ d›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ≠ c›</span></span></span><span> </span><span>True</span><span> </span><span>assms</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lems</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Leaf Split Optimality Lemma \label{leaf-split-optimality}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The tree @{term "splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"} is optimum if $t$ is optimum, under a
few assumptions, notably that $a$ and $b$ are minima of the new tree and
that @{prop "freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"}.
Graphically:\strut
%
\setbox\myboxi=\hbox{\includegraphics[scale=1.2]{tree-splitLeaf-a.pdf}}%
\setbox\myboxii=\hbox{\includegraphics[scale=1.2]{tree-splitLeaf-ab.pdf}}%
$${\it optimum\/} \smash{\lower\ht\myboxi\hbox{\raise.5\ht\myboxii\box\myboxi}}
  \,\mathop{\Longrightarrow}\;\;\;
  {\it optimum\/} \vcenter{\box\myboxii}$$
%
This corresponds to the following fragment of Knuth's proof:

\begin{quote}
Now it is easy to prove that the weighted path length of such a tree is
minimized if and only if the tree with
$$\vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-w2-leaves.pdf}}}
  \qquad \hbox{replaced by} \qquad
  \vcenter{\hbox{\includegraphics[scale=1.25]{tree-w1-plus-w2.pdf}}}$$
has minimum path length for the weights $w_1 + w_2$, $w_3$, $\ldots\,$, $w_m$.
\end{quote}

\noindent
We only need the ``if'' direction of Knuth's equivalence. Lemma~16.3 in
Cormen et al.~\cite[p.~391]{cormen-et-al-2001} expresses essentially the same
property:

\begin{quote}
Let $C$ be a given alphabet with frequency $f[c]$ defined for each character
$c \in C$. Let $x$ and $y$ be two characters in $C$ with minimum frequency. Let
$C'$ be the alphabet $C$ with characters $x$, $y$ removed and (new) character
$z$ added, so that $C' = C - \{x, y\} \cup {\{z\}}$; define $f$ for $C'$ as for
$C$, except that $f[z] = f[x] + f[y]$. Let $T'$ be any tree representing an
optimal prefix code for the alphabet $C'$. Then the tree $T$, obtained from
$T'$ by replacing the leaf node for $z$ with an internal node having $x$ and
$y$ as children, represents an optimal prefix code for the alphabet $C$.
\end{quote}

\noindent
The proof is as follows: We assume that $t$ has a cost less than or equal to
that of any other comparable tree~$v$ and show that
@{term "splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"} has a cost less than or equal to that of any
other comparable tree $u$. By @{thm [source] exists_at_height} and
@{thm [source] depth_height_imp_sibling_ne}, we know that some symbols $c$ and
$d$ appear in sibling nodes at the very bottom of~$u$:
$$\includegraphics[scale=1.25]{tree-splitLeaf-cd.pdf}$$
(The question mark is there to remind us that we know nothing specific about
$u$'s structure.) From $u$ we construct a new tree
@{term "swapFourSyms u a b c d"} in which the minima $a$ and $b$ are siblings:
$$\includegraphics[scale=1.25]{tree-splitLeaf-abcd.pdf}$$
Merging $a$ and $b$ gives a tree comparable with $t$, which we can use to
instantiate $v$ in the assumption:
$$\includegraphics[scale=1.25]{tree-splitLeaf-abcd-aba.pdf}$$
With this instantiation, the proof is easy:
$$\begin{tabularx}{\textwidth}{@%
{\hskip\leftmargin}cX@%
{}}
    &amp; @{term "cost (splitLeaf t a w<span class="hidden">⇩</span><sub>a</sub> b w<span class="hidden">⇩</span><sub>b</sub>)"} \\
\eq &amp; \justif{@{thm [source] cost_splitLeaf}} \\
    &amp; @{term "cost t + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"} \\
\kern-1em$\leq$\kern-1em &amp; \justif{assumption} \\[-2ex]
    &amp; $‹cost (›
       \overbrace{\strut\!@{term "mergeSibling (swapFourSyms u a b c d) a"}\!}
       ^{\smash{\hbox{$v$}}}‹) + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>›$ \\[\extrah]
\eq &amp; \justif{@{thm [source] cost_mergeSibling}} \\
    &amp; @{term "cost (swapFourSyms u a b c d)"} \\
\kern-1em$\leq$\kern-1em &amp; \justif{@{thm [source] cost_swapFourSyms_le}} \\
    &amp; @{term "cost u"}. \\
\end{tabularx}$$

\noindent
In contrast, the proof in Cormen et al.\ is by contradiction: Essentially, they
assume that there exists a tree $u$ with a lower cost than
@{term "splitLeaf t a w<span class="hidden">⇩</span><sub>a</sub> b w<span class="hidden">⇩</span><sub>b</sub>"} and show that there exists a tree~$v$
with a lower cost than~$t$, contradicting the hypothesis that $t$ is optimum. In
place of @{thm [source] cost_swapFourSyms_le}, they invoke their lemma~16.2,
which is questionable since $u$ is not necessarily optimum.%
\footnote{Thomas Cormen commented that this step will be clarified in the
next edition of the book.}

Our proof relies on the following lemma, which asserts that $a$ and $b$ are
minima of $u$.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>twice_freq_le_imp_minima</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦∀c ∈ alphabet t. w<span class="hidden">⇩</span><sub>a</sub> ≤ freq t c ∧ w<span class="hidden">⇩</span><sub>b</sub> ≤ freq t c;
  alphabet u = alphabet t ∪ {b}; a ∈ alphabet u; a ≠ b;
  freq u = (λc. if c = a then w<span class="hidden">⇩</span><sub>a</sub> else if c = b then w<span class="hidden">⇩</span><sub>b</sub> else freq t c)⟧ ⟹
 minima u a b"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>minima_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Now comes the key lemma.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>optimum_splitLeaf</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimum t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∉ alphabet t"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c ∈ alphabet t. freq t c ≥ w<span class="hidden">⇩</span><sub>a</sub> ∧ freq t c ≥ w<span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimum (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>optimum_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet ?t' = alphabet u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>f<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"freq ?t' = freq u"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost ?t' ≤ cost u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"height ?t' = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"height u &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>height_gt_0_alphabet_eq_imp_height_gt_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>a</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>b</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ alphabet u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>exists_at_height</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ alphabet u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>c</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"depth u c = height u"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling u c"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d ≠ c"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>h<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>depth_height_imp_sibling_ne</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>d</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?d ∈ alphabet u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sibling_ne_imp_sibling_in_alphabet</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>d</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"depth u ?d = height u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?u'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"swapFourSyms u a b c ?d"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent ?u'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet ?u' = alphabet u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>d</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"freq ?u' = freq u"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>d</sub></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>a</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sibling ?u' a = b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>ab</span><span> </span><span>dc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sibling_swapFourSyms_when_4th_is_sibling</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?v</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"mergeSibling ?u' a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>v</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"consistent ?v"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>v</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"alphabet ?v = alphabet t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f<span class="hidden">⇩</span><sub>v</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"freq ?v = freq t"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>ab</span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>freq_mergeSibling</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost ?t' = cost t + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ cost ?v + w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>v</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>v</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>v</sub></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹optimum t›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>optimum_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = cost ?u'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cost ?v + freq ?u' a + freq ?u' (sibling ?u' a) = cost ?u'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>s<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>cost_mergeSibling</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w<span class="hidden">⇩</span><sub>a</sub> = freq ?u' a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w<span class="hidden">⇩</span><sub>b</sub> = freq ?u' b"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub><span class="hidden">⇩</span><sub>'</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ cost u"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"minima u a b"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>f<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span>assms</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>twice_freq_le_imp_minima</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c<span class="hidden">⇩</span><sub>u</sub></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>a<span class="hidden">⇩</span><sub>d</sub></span><span> </span><span>d<span class="hidden">⇩</span><sub>c</sub></span><span> </span><span>d<span class="hidden">⇩</span><sub>d</sub></span><span> </span><span>dc</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cost_swapFourSyms_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Leaf Split Commutativity Lemma \label{leaf-split-commutativity}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
A key property of Huffman's algorithm is that once it has combined two
lowest-weight trees using @{const uniteTrees}, it does not visit these trees
ever again. This suggests that splitting a leaf node before applying the
algorithm should give the same result as applying the algorithm first and
splitting the leaf node afterward. The diagram below illustrates the
situation:\strut

\def\myscale{1.05}%
\setbox\myboxi=\hbox{(9)\strut}%
\setbox\myboxii=\hbox{\includegraphics[scale=\myscale]{forest-a.pdf}}%
$$(1)\,\lower\ht\myboxii\hbox{\raise\ht\myboxi\box\myboxii}$$

\smallskip

\setbox\myboxii=\hbox{\includegraphics[scale=\myscale]{tree-splitLeaf-a.pdf}}%
\setbox\myboxiii=\hbox{\includegraphics[scale=\myscale]%
  {forest-splitLeaf-ab.pdf}}%
\mydimeni=\wd\myboxii

\noindent
(2a)\,\lower\ht\myboxii\hbox{\raise\ht\myboxi\box\myboxii}%
  \qquad\qquad\quad
  (2b)\,\lower\ht\myboxiii\hbox{\raise\ht\myboxi\box\myboxiii}\quad{}

\setbox\myboxiii=\hbox{\includegraphics[scale=\myscale]%
  {tree-splitLeaf-ab.pdf}}%
\setbox\myboxiv=\hbox{\includegraphics[scale=\myscale]%
  {tree-huffman-splitLeaf-ab.pdf}}%
\mydimenii=\wd\myboxiii
\vskip1.5\smallskipamount
\noindent
(3a)\,\lower\ht\myboxiii\hbox{\raise\ht\myboxi\box\myboxiii}%
  \qquad\qquad\quad
  (3b)\,\hfill\lower\ht\myboxiv\hbox{\raise\ht\myboxi\box\myboxiv}%
  \quad\hfill{}

\noindent
From the original forest (1), we can either run the algorithm (2a) and then
split $a$ (3a) or split $a$ (2b) and then run the algorithm (3b). Our goal is
to show that trees (3a) and (3b) are identical. Formally, we prove that
$$@{term "splitLeaf (huffman ts) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"} =
  @{term "huffman (splitLeaf<span class="hidden">⇩</span><sub>F</sub> ts w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"}$$
when @{term ts} is consistent, @{term "a ∈ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"}, @{term
"b ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"}, and $@{term "freq<span class="hidden">⇩</span><sub>F</sub> ts a"} = @{term w<span class="hidden">⇩</span><sub>a</sub>}
\mathbin{‹+›} @{term "w<span class="hidden">⇩</span><sub>b</sub>"}$. But before we can prove this
commutativity lemma, we need to introduce a few simple lemmas.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cachedWeight_splitLeaf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cachedWeight (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) = cachedWeight t"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitLeaf<span class="hidden">⇩</span><sub>F</sub>_insortTree_when_in_alphabet_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦a ∈ alphabet t; consistent t; a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts; freq t a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>⟧ ⟹
 splitLeaf<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b = insortTree (splitLeaf t w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b) ts"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitLeaf<span class="hidden">⇩</span><sub>F</sub>_insortTree_when_in_alphabet<span class="hidden">⇩</span><sub>F</sub>_tail</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦a ∈ alphabet<span class="hidden">⇩</span><sub>F</sub> ts; consistent<span class="hidden">⇩</span><sub>F</sub> ts; a ∉ alphabet t; freq<span class="hidden">⇩</span><sub>F</sub> ts a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>⟧ ⟹
 splitLeaf<span class="hidden">⇩</span><sub>F</sub> (insortTree t ts) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b =
 insortTree t (splitLeaf<span class="hidden">⇩</span><sub>F</sub> ts w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>u</span><span> </span><span>us</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet u"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> us"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We are now ready to prove the commutativity lemma.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitLeaf_huffman_commute</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent<span class="hidden">⇩</span><sub>F</sub> ts; ts ≠ []; a ∈ alphabet<span class="hidden">⇩</span><sub>F</sub> ts; freq<span class="hidden">⇩</span><sub>F</sub> ts a = w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>⟧ ⟹
 splitLeaf (huffman ts) w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b = huffman (splitLeaf<span class="hidden">⇩</span><sub>F</sub> ts w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>huffman.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>t<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>t<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ alphabet t<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∉ alphabet<span class="hidden">⇩</span><sub>F</sub> ts"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
An important consequence of the commutativity lemma is that applying Huffman's
algorithm on a forest of the form
$$\vcenter{\hbox{\includegraphics[scale=1.25]{forest-uniteTrees.pdf}}}$$
gives the same result as applying the algorithm on the ``flat'' forest
$$\vcenter{\hbox{\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}$$
followed by splitting the leaf node $a$ into two nodes $a$, $b$ with
frequencies $@{term w<span class="hidden">⇩</span><sub>a</sub>}$, $@{term w<span class="hidden">⇩</span><sub>b</sub>}$. The lemma effectively
provides a way to flatten the forest at each step of the algorithm. Its
invocation is implicit in the textbook proof.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Optimality Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
We are one lemma away from our main result.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_0_imp_0</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(max x y = (0::nat)) = (x = 0 ∧ y = 0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>optimum_huffman</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦consistent<span class="hidden">⇩</span><sub>F</sub> ts; height<span class="hidden">⇩</span><sub>F</sub> ts = 0; sortedByWeight ts; ts ≠ []⟧ ⟹
 optimum (huffman ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The input @{term ts} is assumed to be a nonempty consistent list of leaf nodes
sorted by weight. The proof is by induction on the length of the forest
@{term ts}. Let @{term ts} be
$$\vcenter{\hbox{\includegraphics[scale=1.25]{forest-flat.pdf}}}$$
with $w_a \le w_b \le w_c \le w_d \le \cdots \le w_z$. If @{term ts} consists
of a single leaf node, the node has cost 0 and is therefore optimum. If
@{term ts} has length 2 or more, the first step of the algorithm leaves us with
the term
$${\it huffman\/}\enskip\; \vcenter{\hbox{\includegraphics[scale=1.25]%
    {forest-uniteTrees.pdf}}}$$
In the diagram, we put the newly created tree at position 2 in the forest; in
general, it could be anywhere. By @{thm [source] splitLeaf_huffman_commute},
the above tree equals\strut
$${\it splitLeaf\/}\;\left({\it huffman\/}\enskip\;
  \vcenter{\hbox{\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}
  \;\right)\,‹w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b›.$$
To prove that this tree is optimum, it suffices by
@{thm [source] optimum_splitLeaf} to show that\strut
$${\it huffman\/}\enskip\;
  \vcenter{\hbox{\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}$$
is optimum, which follows from the induction hypothesis.\strut
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹\sc Complete induction step›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyps</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ts ≠ []›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>ts'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ts</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ts'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts</span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>optimum_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>t<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>ts''</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ts'</span><span> </span><span class="delimiter">=</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">⇩</span><sub>a</sub></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>w<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Leaf</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">⇩</span><sub>b</sub></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>w<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Leaf</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?us</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"insortTree (uniteTrees t<span class="hidden">⇩</span><sub>a</sub> t<span class="hidden">⇩</span><sub>b</sub>) ts''"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?us'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"insortTree (Leaf (w<span class="hidden">⇩</span><sub>a</sub> + w<span class="hidden">⇩</span><sub>b</sub>) a) ts''"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?t<span class="hidden">⇩</span><sub>s</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitLeaf (huffman ?us') w<span class="hidden">⇩</span><sub>a</sub> a w<span class="hidden">⇩</span><sub>b</sub> b"</span></span></span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"huffman ts = huffman ?us"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"huffman ?us = ?t<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>l<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span>hyps</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>splitLeaf_huffman_commute</span><span> </span><span>uniteTrees_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimum (huffman ?us')"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span>hyps</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="var">?us'</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>                 </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sortedByWeight_Cons_imp_sortedByWeight</span><span>
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sortedByWeight_insortTree</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimum ?t<span class="hidden">⇩</span><sub>s</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l<span class="hidden">⇩</span><sub>a</sub></span><span> </span><span>l<span class="hidden">⇩</span><sub>b</sub></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span>hyps</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>optimum_splitLeaf</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>height<span class="hidden">⇩</span><sub>F</sub>_0_imp_Leaf_freq<span class="hidden">⇩</span><sub>F</sub>_in_set</span><span>
</span><span>                  </span><span>sortedByWeight_Cons_imp_forall_weight_ge</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"optimum (huffman ts)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>e<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Node</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts'</span><span> </span><span>ts</span><span> </span><span>hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
\isakeyword{end}

\myskip

\noindent
So what have we achieved? Assuming that our definitions really mean what we
intend them to mean, we established that our functional implementation of
Huffman's algorithm, when invoked properly, constructs a binary tree that
represents an optimal prefix code for the specified alphabet and frequencies.
Using Isabelle's code generator \cite{haftmann-nipkow-2007}, we can convert the
Isabelle code into Standard ML, OCaml, or Haskell and use it in a real
application.

As a side note, the @{thm [source] optimum_huffman} theorem assumes that the
forest @{term ts} passed to @{const huffman} consists exclusively of leaf nodes.
It is tempting to relax this restriction, by requiring instead that the forest
@{term ts} has the lowest cost among forests of the same size. We would define
optimality of a forest as follows:
$$\begin{aligned}[t]
  @{prop "optimum<span class="hidden">⇩</span><sub>F</sub> ts"}\,\;‹=›\;\,
  (‹∀us.›\
    &amp; ‹length ts = length us ⟶ consistent<span class="hidden">⇩</span><sub>F</sub> us ⟶› \\[-2.5pt]
    &amp; ‹alphabet<span class="hidden">⇩</span><sub>F</sub> ts = alphabet<span class="hidden">⇩</span><sub>F</sub> us ⟶ freq<span class="hidden">⇩</span><sub>F</sub> ts = freq<span class="hidden">⇩</span><sub>F</sub> us ⟶›
\\[-2.5pt]
    &amp; @{prop "cost<span class="hidden">⇩</span><sub>F</sub> ts ≤ cost<span class="hidden">⇩</span><sub>F</sub> us"})\end{aligned}$$
with $‹cost<span class="hidden">⇩</span><sub>F</sub> [] = 0›$ and
$@{prop "cost<span class="hidden">⇩</span><sub>F</sub> (t # ts) = cost t + cost<span class="hidden">⇩</span><sub>F</sub> ts"}$. However, the modified
proposition does not hold. A counterexample is the optimum forest
$$\includegraphics{forest-optimal.pdf}$$
for which the algorithm constructs the tree
$$\vcenter{\hbox{\includegraphics{tree-suboptimal.pdf}}}
  \qquad \hbox{of greater cost than} \qquad
  \vcenter{\hbox{\includegraphics{tree-optimal.pdf}}}$$
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Related Work \label{related-work}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Laurent Th\'ery's Coq formalization of Huffman's algorithm \cite{thery-2003,%
thery-2004} is an obvious yardstick for our work. It has a somewhat wider
scope, proving among others the isomorphism between prefix codes and full binary
trees. With 291 theorems, it is also much larger.

Th\'ery identified the following difficulties in formalizing the textbook
proof:

\begin{enumerate}
\item The leaf interchange process that brings the two minimal symbols together
      is tedious to formalize.

\item The sibling merging process requires introducing a new symbol for the
      merged node, which complicates the formalization.

\item The algorithm constructs the tree in a bottom-up fashion. While top-down
      procedures can usually be proved by structural induction, bottom-up
      procedures often require more sophisticated induction principles and
      larger invariants.

\item The informal proof relies on the notion of depth of a node. Defining this
      notion formally is problematic, because the depth can only be seen as a
      function if the tree is composed of distinct nodes.
\end{enumerate}

To circumvent these difficulties, Th\'ery introduced the ingenious concept of
cover. A forest @{term ts} is a {\em cover\/} of a tree~$t$ if $t$ can be built
from @{term ts} by adding inner nodes on top of the trees in @{term ts}. The
term ``cover'' is easier to understand if the binary trees are drawn with the
root at the bottom of the page, like natural trees. Huffman's algorithm is
a refinement of the cover concept. The main proof consists in showing that
the cost of @{term "huffman ts"} is less than or equal to that of any other
tree for which @{term ts} is a cover. It relies on a few auxiliary definitions,
notably an ``ordered cover'' concept that facilitates structural induction
and a four-argument depth predicate (confusingly called @{term height}).
Permutations also play a central role.

Incidentally, our experience suggests that the potential problems identified
by Th\'ery can be overcome more directly without too much work, leading to a
simpler proof:

\begin{enumerate}
\item Formalizing the leaf interchange did not prove overly tedious. Among our
      95~lemmas and theorems, 24 concern @{const swapLeaves},
      @{const swapSyms}, and @{const swapFourSyms}.

\item The generation of a new symbol for the resulting node when merging two
      sibling nodes in @{const mergeSibling} was trivially solved by reusing
      one of the two merged symbols.

\item The bottom-up nature of the tree construction process was addressed by
      using the length of the forest as the induction measure and by merging
      the two minimal symbols, as in Knuth's proof.

\item By restricting our attention to consistent trees, we were able to define
      the @{const depth} function simply and meaningfully.
\end{enumerate}
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conclusion \label{conclusion}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The goal of most formal proofs is to increase our confidence in a result. In
the case of Huffman's algorithm, however, the chances that a bug would have
gone unnoticed for the 56 years since its publication, under the scrutiny of
leading computer scientists, seem extremely low; and the existence of a Coq
proof should be sufficient to remove any remaining doubts.

The main contribution of this document has been to demonstrate that the
textbook proof of Huffman's algorithm can be elegantly formalized using
a state-of-the-art theorem prover such as Isabelle/HOL. In the process, we
uncovered a few minor snags in the proof given in Cormen et
al.~\cite{cormen-et-al-2001}.

We also found that custom induction rules, in combination with suitable
simplification rules, greatly help the automatic proof tactics, sometimes
reducing 30-line proof scripts to one-liners. We successfully applied this
approach for handling both the ubiquitous ``datatype + well\-formed\-ness
predicate'' combination (@{typ "'a tree"} + @{const consistent}) and functions
defined by sequential pattern matching (@{const sibling} and
@{const mergeSibling}). Our experience suggests that such rules, which are
uncommon in formalizations, are highly valuable and versatile. Moreover,
Isabelle's \textit{induction\_schema} and \textit{lexicographic\_order} tactics
make these easy to prove.

Formalizing the proof of Huffman's algorithm also led to a deeper
understanding of this classic algorithm. Many of the lemmas, notably the leaf
split commutativity lemma of Section~\ref{leaf-split-commutativity}, have not
been found in the literature and express fundamental properties of the
algorithm. Other discoveries did not find their way into the final proof. In
particular, each step of the algorithm appears to preserve the invariant that
the nodes in a forest are ordered by weight from left to right, bottom to top,
as in the example below:\strut
$$\vcenter{\hbox{\includegraphics[scale=1.25]{forest-zigzag.pdf}}}$$
It is not hard to prove formally that a tree exhibiting this property is
optimum. On the other hand, proving that the algorithm preserves this invariant
seems difficult---more difficult than formalizing the textbook proof---and
remains a suggestion for future work.

A few other directions for future work suggest themselves. First, we could
formalize some of our hypotheses, notably our restriction to full and
consistent binary trees. The current formalization says nothing about the
algorithm's application for data compression, so the next step could be to
extend the proof's scope to cover @{term encode}/@{term decode} functions
and show that full binary trees are isomorphic to prefix codes, as done in the
Coq development. Independently, we could generalize the development to $n$-ary
trees.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>