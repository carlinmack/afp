<div id="Auxiliary">
<div class="head"><h1>Theory Auxiliary</h1>
<span class="command">theory</span> <span class="name">Auxiliary</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Analysis/Extended_Nonnegative_Real.html"><span class="name">Extended_Nonnegative_Real</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Auxiliary</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Extended_Nonnegative_Real"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Auxiliary Materialâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_image_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(MAX x âˆˆ S. MAX y âˆˆ S. f x y) = (MAX y âˆˆ S. MAX x âˆˆ S. f x y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_eq_if</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a âˆˆ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Max_in</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f a"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (f a ` S) âˆˆ f a ` S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b = Max (f a ` S)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b âˆˆ S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹a âˆˆ Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b â‰¤ (MAX a âˆˆ S. f a b)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_ge</span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹f a b = _â€º</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹b âˆˆ Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆƒbâˆˆS. Max (f a ` S) â‰¤ (MAX a âˆˆ S. f a b)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>4</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b âˆˆ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Max_in</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» a. f a b"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(MAX a âˆˆ S. f a b) âˆˆ (Î»a. f a b) ` S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b = (MAX a âˆˆ S. f a b)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a âˆˆ S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹b âˆˆ Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f a b â‰¤ Max (f a ` S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_ge</span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹f a b = _â€º</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹a âˆˆ Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆƒaâˆˆS. (MAX a âˆˆ S. f a b) â‰¤ Max (f a ` S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_image_left_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(MAX x âˆˆ S. c * f x) = (c :: ennreal) * (MAX x âˆˆ S. f x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S â‰  {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>mult_left_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_in</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Sâ€º</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹S â‰  {}â€º</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Finite set *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_to_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max {f t | t. t âˆˆ S} = Max (f ` S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Max</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_to_image2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max {f t | t. P t} = Max (f ` {t. P t})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Max</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_image_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max (f ` S) = Max (g ` T)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â‹€x. x âˆˆ T âŸ¹ f x = g x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Max</span><span class="delimiter">]</span><span> </span><span>image_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_image_cong_simp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max (f ` S) = Max (g ` T)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S = T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â‹€x. x âˆˆ T =simp=&gt; f x = g x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_image_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>simp_implies_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_eq_image_if</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€x âˆˆ S. âˆƒy âˆˆ T. f x â‰¤ g y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€x âˆˆ T. âˆƒy âˆˆ S. g x â‰¤ f y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (f ` S) = Max (g ` T)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_eq_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Max_in_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A â‰  {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x âˆˆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (f ` A) = f x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Max_in</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` A"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (f ` A) âˆˆ f ` A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_ge_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max (f ` S) â‰¥ f x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x âˆˆ S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_ge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_image_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite T"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T â‰  {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(MAX s âˆˆ S. MAX t âˆˆ T. f s t) = (MAX (s, t) âˆˆ S Ã— T. f s t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_eq_image_if</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">?</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Tâ€º</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹T â‰  {}â€º</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y âˆˆ T"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max (f x ` T) = f x y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_in_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹x âˆˆ Sâ€º</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹finite Tâ€º</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>argmax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"argmax f (x # xs) =
    List.fold (Î» a (b, v). let w = f a in if w &gt; v then (a, w) else (b, v)) xs (x, f x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = [] âŸ¹ P []"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â‹€ x. xs = [x] âŸ¹ P [x]"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â‹€ x y ys. xs = (x # y # ys) âŸ¹ P (x # y # ys)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span> </span><span>ys</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>argmax</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs â‰  []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"fst (argmax f xs) âˆˆ set xs"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f (fst (argmax f xs)) = snd (argmax f xs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?B"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd (argmax f xs) = (MAX x âˆˆ set xs. f x)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» a (b, v). let w = f a in if w &gt; v then (a, w) else (b, v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (List.fold ?f xs (x, f x)) âˆˆ {x} âˆª set xs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs â‰  []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_nonempty_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹xs â‰  []â€º</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_cases</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f (fst (List.fold ?f xs (x, f x))) = snd (List.fold ?f xs (x, f x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs â‰  []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_nonempty_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹xs â‰  []â€º</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_cases</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (List.fold ?f xs (x, f x)) = (MAX x âˆˆ {x} âˆª set xs. f x)"</span></span></span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs â‰  []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_nonempty_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹xs â‰  []â€º</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_cases</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theory *)</span></span></span></span></span></pre>
</div>
</div><div id="Hidden_Markov_Model">
<div class="head"><h1>Theory Hidden_Markov_Model</h1>
<span class="command">theory</span> <span class="name">Hidden_Markov_Model</span><br/>
<span class="keyword">imports</span> <a href="../Markov_Models/Discrete_Time_Markov_Chain.html"><span class="name">Discrete_Time_Markov_Chain</span></a> <a href="Auxiliary.html"><span class="name">Auxiliary</span></a> <a href="../Markov_Models/IArray.html"><span class="name">IArray</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Hidden Markov Modelsâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Hidden_Markov_Model</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Markov_Models.Discrete_Time_Markov_Chain</span><span> </span><span>Auxiliary</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.IArray"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Definitionsâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Definition of Markov Kernels that are closed w.r.t. to a set of states.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Closed_Kernel</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 't pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>wellformed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S â‰  {}"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ s. K s âŠ† S"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  An HMM is parameterized by a Markov kernel for the transition probabilites between internal states,
  a Markov kernel for the output probabilities of observations,
  and a fixed set of observations.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 's pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’ª</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 't pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>HMM_defs</span><span> </span><span class="delimiter">+</span><span> </span><span>O</span><span class="delimiter">:</span><span> </span><span>Closed_Kernel</span><span> </span><span>ğ’ª</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>observations_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>observations_wellformed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ğ’ª<span class="hidden">â‡©</span><sub>s</sub> â‰  {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>observations_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ s. ğ’ª s âŠ† ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>O.finite</span><span> </span><span>O.wellformed</span><span> </span><span>O.closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Fixed set of internal states.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM2_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM_defs</span><span> </span><span>ğ’¦</span><span> </span><span>ğ’ª</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 's pmf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’ª</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 't pmf"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ğ’®</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM2</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM2_defs</span><span> </span><span class="delimiter">+</span><span> </span><span>HMM</span><span> </span><span class="delimiter">+</span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span>Closed_Kernel</span><span> </span><span>ğ’¦</span><span> </span><span>ğ’®</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>states_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>states_wellformed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ğ’® â‰  {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>states_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ s. ğ’¦ s âŠ† ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K.finite</span><span> </span><span>K.wellformed</span><span> </span><span>K.closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  The set of internal states is now given as a list to iterate over.
  This is needed for the computations on HMMs.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM3_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM2_defs</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span>ğ’¦</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 's pmf"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>state_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM3</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM3_defs</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">+</span><span> </span><span>HMM2</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span>ğ’¦</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 's pmf"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>state_list_ğ’®</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set state_list = ğ’®"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM_defs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span> </span><span>comp</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"o"</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The ``default'' observation.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obs â‰¡ SOME x. x âˆˆ ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM</span><span class="delimiter">)</span><span> </span><span>obs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"obs âˆˆ ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>obs_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>observations_wellformed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  The HMM is encoded as a Markov chain over pairs of states and observations.
  This is the Markov chain's defining Markov kernel.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"K â‰¡ Î» (s<span class="hidden">â‡©</span><sub>1</sub>, o<span class="hidden">â‡©</span><sub>1</sub> :: 't). bind_pmf (ğ’¦ s<span class="hidden">â‡©</span><sub>1</sub>) (Î» s<span class="hidden">â‡©</span><sub>2</sub>. map_pmf (Î» o<span class="hidden">â‡©</span><sub>2</sub>. (s<span class="hidden">â‡©</span><sub>2</sub>, o<span class="hidden">â‡©</span><sub>2</sub>)) (ğ’ª s<span class="hidden">â‡©</span><sub>2</sub>))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>MC_syntax</span><span> </span><span>K</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  Uniform distribution of the pairs â€¹(s, o)â€º for a fixed state â€¹sâ€º.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I (s :: 's) = map_pmf (Î» x. (s, x)) (pmf_of_set ğ’ª<span class="hidden">â‡©</span><sub>s</sub>)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  The likelihood of an observation sequence given a starting state â€¹sâ€º is defined in terms of
  the trace space of the Markov kernel given the uniform distribution of pairs for â€¹sâ€º.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood s os = T' (I s) {Ï‰ âˆˆ space S. âˆƒ o<span class="hidden">â‡©</span><sub>0</sub> xs Ï‰'. Ï‰ = (s, o<span class="hidden">â‡©</span><sub>0</sub>) ## xs @- Ï‰' âˆ§ map snd xs = os}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"L os Ï‰ â‰¡ âˆƒ xs Ï‰'. Ï‰ = xs @- Ï‰' âˆ§ map snd xs = os"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>likelihood_alt_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"likelihood s os = T' (I s) {(s, o) ## xs @- Ï‰' |o xs Ï‰'. map snd xs = os}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>likelihood_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_S</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Iteration Rule For Likelihoodâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_Nil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L [] Ï‰ = True"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emeasure_T_observation_Nil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o<span class="hidden">â‡©</span><sub>0</sub>) {Ï‰ âˆˆ space S. L [] Ï‰} = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_Cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L (o # os) Ï‰ âŸ· snd (shd Ï‰) = o âˆ§ L os (stl Ï‰)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ï‰</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"shd Ï‰"</span></span></span><span class="delimiter">;</span><span> </span><span>safe</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>Ï‰'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, o) # xs"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>L_measurable</span><span class="delimiter">[</span><span>measurable</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S (L os)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>o</span><span> </span><span>os</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>L_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Measurable.pred_intros_logic</span><span>
</span><span>        </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_shd</span><span class="delimiter">]</span><span> </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_stl</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span>measurable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_measurable</span><span class="delimiter">[</span><span>measurable</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S (Î»x. âˆƒo<span class="hidden">â‡©</span><sub>0</sub> xs Ï‰'. x = (s, o<span class="hidden">â‡©</span><sub>0</sub>) ## xs @- Ï‰' âˆ§ map snd xs = os)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S ?f"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?f Ï‰ âŸ· fst (shd Ï‰) = s âˆ§ L os (stl Ï‰)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ï‰</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ï‰</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Measurable.pred_intros_logic</span><span> </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_shd</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>measurable</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_init_observation_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o) {Ï‰ âˆˆ space S. L os Ï‰} = T (s, o') {Ï‰ âˆˆ space S. L os Ï‰}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>measurable</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>measurable</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  Shows that it is equivalent to define likelihood in terms of the trace space starting at a single
  pair of an internal state â€¹sâ€º and the default observation @{term obs}.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM</span><span class="delimiter">)</span><span> </span><span>likelihood_init</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood s os = T (s, obs) {Ï‰ âˆˆ space S. L os Ï‰}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(âˆ‘oâˆˆğ’ª<span class="hidden">â‡©</span><sub>s</sub>. emeasure (T (s, o)) {Ï‰ âˆˆ space S. L os Ï‰}) =
    of_nat (card ğ’ª<span class="hidden">â‡©</span><sub>s</sub>) * emeasure (T (s, obs)) {Ï‰ âˆˆ space S. L os Ï‰}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_constant</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum.cong</span><span> </span><span>T_init_observation_eq</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>likelihood_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>emeasure_T'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>measurable</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_def</span><span> </span><span>in_S</span><span> </span><span>observations_finite</span><span> </span><span>observations_wellformed</span><span> </span><span>nn_integral_pmf_of_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>observations_finite</span><span> </span><span>observations_wellformed</span><span> </span><span>mult_divide_eq_ennreal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emeasure_T_observation_Cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o<span class="hidden">â‡©</span><sub>0</sub>) {Ï‰ âˆˆ space S. L (o<span class="hidden">â‡©</span><sub>1</sub> # os) Ï‰} =
   (âˆ«<span class="hidden">â‡§</span><sup>+</sup> t. ennreal (pmf (ğ’ª t) o<span class="hidden">â‡©</span><sub>1</sub>) * T (t, o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. L os Ï‰} âˆ‚(ğ’¦ s))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"âˆ«<span class="hidden">â‡§</span><sup>+</sup> y. T (s', y) {x âˆˆ space S. âˆƒxs. (âˆƒÏ‰'. (s', y) ## x = xs @- Ï‰') âˆ§ map snd xs = o<span class="hidden">â‡©</span><sub>1</sub> # os}
       âˆ‚measure_pmf (ğ’ª s') =
    ennreal (pmf (ğ’ª s') o<span class="hidden">â‡©</span><sub>1</sub>) * T (s', o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. âˆƒxs. (âˆƒÏ‰'. Ï‰ = xs @- Ï‰') âˆ§ map snd xs = os}"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = âˆ«<span class="hidden">â‡§</span><sup>+</sup> x. ennreal (pmf (ğ’ª s') x) *
            T (s', x) {Ï‰ âˆˆ space S. âˆƒxs. (âˆƒÏ‰'. (s', x) ## Ï‰ = xs @- Ï‰') âˆ§ map snd xs = o<span class="hidden">â‡©</span><sub>1</sub> # os}
          âˆ‚count_space UNIV"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nn_integral_measure_pmf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ =
      âˆ«<span class="hidden">â‡§</span><sup>+</sup> o<span class="hidden">â‡©</span><sub>2</sub>. (if o<span class="hidden">â‡©</span><sub>2</sub> = o<span class="hidden">â‡©</span><sub>1</sub>
              then ennreal (pmf (ğ’ª s') o<span class="hidden">â‡©</span><sub>1</sub>) * T (s', o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. L os Ï‰}
              else 0)
       âˆ‚count_space UNIV"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nn_integral_cong_AE</span><span>
</span><span>          </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» o<span class="hidden">â‡©</span><sub>2</sub>. if o<span class="hidden">â‡©</span><sub>2</sub> = o<span class="hidden">â‡©</span><sub>1</sub>
            then ennreal (pmf (ğ’ª s') o<span class="hidden">â‡©</span><sub>1</sub>) * T (s', o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. L os Ï‰} else 0"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AE_I2</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>split</span><span> </span><span>if_split</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>times</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>HOL.refl</span><span class="delimiter">]</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>emeasure</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>            </span><span>metis</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>shift.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span>
</span><span>           </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>emeasure</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>HOL.refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = âˆ«<span class="hidden">â‡§</span><sup>+</sup>o<span class="hidden">â‡©</span><sub>2</sub>âˆˆ{o<span class="hidden">â‡©</span><sub>1</sub>}.
       (ennreal (pmf (ğ’ª s') o<span class="hidden">â‡©</span><sub>1</sub>) * T (s', o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. L os Ï‰})
      âˆ‚count_space UNIV"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nn_integral_cong_AE</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = ?R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = âˆ«<span class="hidden">â‡§</span><sup>+</sup> t. T t {x âˆˆ space S. âˆƒxs Ï‰'. t ## x = xs @- Ï‰' âˆ§ map snd xs = o<span class="hidden">â‡©</span><sub>1</sub> # os} âˆ‚ (K (s, o<span class="hidden">â‡©</span><sub>0</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>measurable</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = ?r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Computation of Likelihoodâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>backward</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"backward s [] = 1"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"backward s (o # os) = (âˆ«<span class="hidden">â‡§</span><sup>+</sup> t. ennreal (pmf (ğ’ª t) o) * backward t os âˆ‚measure_pmf (ğ’¦ s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emeasure_T_observation_backward</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"emeasure (T (s, o)) {Ï‰ âˆˆ space S. L os Ï‰} = backward s os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emeasure_T_observation_Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>o</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM</span><span class="delimiter">)</span><span> </span><span>likelihood_backward</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood s os = backward s os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>likelihood_init</span><span> </span><span>emeasure_T_observation_backward</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* HMM Defs *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM2</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM2_defs</span><span class="delimiter">)</span><span> </span><span>forward</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward s t_end [] = indicator {t_end} s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward s t_end (o # os) =
    (âˆ‘t âˆˆ ğ’®. ennreal (pmf (ğ’ª t) o) * ennreal (pmf (ğ’¦ s) t) * forward t t_end os)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forward_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward s t (os1 @ os2) = (âˆ‘t' âˆˆ ğ’®. forward s t' os1 * forward t' t os2)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_indicator_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>states_finite</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>os1</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_distrib_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.swap</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_distrib_left</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(âˆ‘t âˆˆ S. f t) = f t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ S"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ s âˆˆ S - {t}. f s = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>sum.empty</span><span> </span><span>sum.insert</span><span> </span><span>sum.mono_neutral_right</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t}"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.mono_neutral_right</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"{t}"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  oops
  by (metis add.right_neutral empty_iff finite.intros(1) insert_iff subsetI sum.empty sum.insert sum.mono_neutral_right that)

  using that
  apply auto
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forward_backward</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(âˆ‘t âˆˆ ğ’®. forward s t os) = backward s os"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹s âˆˆ ğ’®â€º</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.mono_neutral_right</span><span class="delimiter">[</span><span>of</span><span> </span><span>ğ’®</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s}"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>states_finite</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>indicator_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>os</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.swap</span><span> </span><span>sum_distrib_left</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>nn_integral_measure_pmf_support</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span> </span><span class="delimiter">=</span><span> </span><span>ğ’®</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>states_finite</span><span> </span><span>states_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>likelihood_forward</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood s os = (âˆ‘t âˆˆ ğ’®. forward s t os)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹s âˆˆ ğ’®â€º</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>likelihood_backward</span><span> </span><span>forward_backward</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹s âˆˆ ğ’®â€º</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Definition of Maximum Probabilitiesâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"V os as Ï‰ â‰¡ (âˆƒ Ï‰'. Ï‰ = zip as os @- Ï‰')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_prob s os =
  Max {T' (I s) {Ï‰ âˆˆ space S. âˆƒo Ï‰'. Ï‰ = (s, o) ## zip as os @- Ï‰'}
       | as. length as = length os âˆ§ set as âŠ† ğ’®}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>viterbi_prob</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_prob s t_end [] = indicator {t_end} s"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_prob s t_end (o # os) =
    (MAX t âˆˆ ğ’®. ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * viterbi_prob t t_end os)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_decoding s os as â‰¡
    T' (I s) {Ï‰ âˆˆ space S. âˆƒo Ï‰'. Ï‰ = (s, o) ## zip as os @- Ï‰'} = max_prob s os âˆ§
    length as = length os âˆ§ set as âŠ† ğ’®"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Iteration Rule For Maximum Probabilitiesâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emeasure_T_state_Nil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o<span class="hidden">â‡©</span><sub>0</sub>) {Ï‰ âˆˆ space S. V [] as Ï‰} = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_prob_T_state_Nil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max {T (s, o) {Ï‰ âˆˆ space S. V [] as Ï‰} | as. length as = length [] âˆ§ set as âŠ† ğ’®} = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emeasure_T_state_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>V_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V (o # os) (a # as) Ï‰ âŸ· fst (shd Ï‰) = a âˆ§ snd (shd Ï‰) = o âˆ§ V os as (stl Ï‰)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ï‰</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>measurable_V</span><span class="delimiter">[</span><span>measurable</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S (Î»Ï‰. V os as Ï‰)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>as</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>V_Cons</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Measurable.pred_intros_logic</span><span>
</span><span>          </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_shd</span><span class="delimiter">]</span><span> </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_stl</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span>measurable</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_V_measurable</span><span class="delimiter">[</span><span>measurable</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S (Î»x. âˆƒo Ï‰'. x = (s, o) ## zip as os @- Ï‰')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Measurable.pred S ?f"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?f Ï‰ âŸ· fst (shd Ï‰) = s âˆ§ V os as (stl Ï‰)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ï‰</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ï‰</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Measurable.pred_intros_logic</span><span> </span><span>measurable_compose</span><span class="delimiter">[</span><span>OF</span><span> </span><span>measurable_shd</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>measurable</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_prob_Cons'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Max {T (s, o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. V (o # os) as Ï‰} | as. length as = length (o # os) âˆ§ set as âŠ† ğ’®} =
  (
    MAX t âˆˆ ğ’®. ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) *
      (MAX as âˆˆ {as. length as = length os âˆ§ set as âŠ† ğ’®}. T (t, o) {Ï‰ âˆˆ space S. V os as Ï‰})
  )"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T_V_Cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. V (o # os) (t # as) Ï‰}
  = ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * T (t, o) {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l' = ?r'"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = length os"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» os. {as. length as = length os âˆ§ set as âŠ† ğ’®}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (?S os)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>os</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t list"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_lists_length_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>states_finite</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?S os â‰  {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>os</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"SOME a. a âˆˆ ğ’®"</span></span></span><span> </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?as</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"replicate (length os) ?a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>states_wellformed</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?a âˆˆ ğ’®"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?as âˆˆ ?S os"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î»t as os. T t {Ï‰ âˆˆ space S. V os as (t ## Ï‰)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î»t as os. T t {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?f t as (o # os) = ?g t (tl as) os * indicator {(hd as, o)} t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = Suc n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>as</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>indicator_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K (s, o<span class="hidden">â‡©</span><sub>1</sub>) {(t, o)} = pmf (ğ’ª t) o * pmf (ğ’¦ s) t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>nn_integral</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>d</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» x. ğ’ª x {xa. xa = o âˆ§ x = t} * indicator {t} x"</span></span></span><span class="delimiter">,</span><span>
</span><span>          </span><span>OF</span><span> </span><span>HOL.refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>indicator_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emeasure_pmf_single</span><span> </span><span>ennreal_mult'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = (MAX as âˆˆ ?S (o # os). âˆ«<span class="hidden">â‡§</span><sup>+</sup> t. ?f t as (o # os) âˆ‚K (s, o<span class="hidden">â‡©</span><sub>1</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Max_to_image2</span><span class="delimiter">;</span><span> </span><span>subst</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>measurable_V</span><span> </span><span>HOL.refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = (MAX as âˆˆ ?S (o # os). âˆ«<span class="hidden">â‡§</span><sup>+</sup> t. ?g t (tl as) os * indicator {(hd as,o)} t âˆ‚K (s,o<span class="hidden">â‡©</span><sub>1</sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>Max_image_cong_simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = (MAX(t, as)âˆˆ ğ’® Ã— ?S os. ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * ?g (t, o) as os)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_eq_image_if</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">?</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>S_finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"o # os"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>states_finite</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>S_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd as"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>as</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"x # as"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>**</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = ?r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Max_image_left_mult</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>fact</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Max_image_pair</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>states_finite</span><span class="delimiter">,</span><span> </span><span>fact</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l = ?r"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l' = âˆ«<span class="hidden">â‡§</span><sup>+</sup> t'. ?f t' (t # as) (o # os) âˆ‚K (s, o<span class="hidden">â‡©</span><sub>1</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>measurable_V</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = âˆ«<span class="hidden">â‡§</span><sup>+</sup> t'. ?g t' as os * indicator {(t,o)} t' âˆ‚K (s,o<span class="hidden">â‡©</span><sub>1</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>*</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"length as"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"â€¦ = ?r'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>**</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?l' = ?r'"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>max_prob_Cons</span><span> </span><span class="delimiter">=</span><span> </span><span>max_prob_Cons'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>length_replicate</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Computation of Maximum Probabilitiesâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T_init_V_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T (s, o) {Ï‰ âˆˆ space S. V os as Ï‰} = T (s, o') {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>measurable</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>emeasure_Collect_T</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>space_T</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>measurable</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>T'_I_T</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"T' (I s) {Ï‰ âˆˆ space S. âˆƒo Ï‰'. Ï‰ = (s, o) ## zip as os @- Ï‰'} = T (s,o) {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(âˆ‘oâˆˆğ’ª<span class="hidden">â‡©</span><sub>s</sub>. T (s, o) {Ï‰ âˆˆ space S. V os as Ï‰}) =
    of_nat (card ğ’ª<span class="hidden">â‡©</span><sub>s</sub>) * T (s, o) {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>as</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_constant</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum.cong</span><span> </span><span>T_init_V_eq</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_prob_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>emeasure_T'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>measurable</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I_def</span><span> </span><span>in_S</span><span> </span><span>observations_finite</span><span> </span><span>observations_wellformed</span><span> </span><span>nn_integral_pmf_of_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>observations_finite</span><span> </span><span>observations_wellformed</span><span> </span><span>mult_divide_eq_ennreal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_prob_init</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_prob s os = Max {T (s,o) {Ï‰ âˆˆ space S. V os as Ï‰} | as. length as = length os âˆ§ set as âŠ† ğ’®}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_prob_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T'_I_T</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_prob_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"max_prob s [] = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_prob_init</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>o</span><span> </span><span class="delimiter">=</span><span> </span><span>obs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_start</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(MAX tâˆˆğ’®. (indicator {t} s :: ennreal)) = 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>states_finite</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>indicator_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Max_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_V_viterbi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(MAX t âˆˆ ğ’®. viterbi_prob s t os) =
   Max {T (s, o) {Ï‰ âˆˆ space S. V os as Ï‰} | as. length as = length os âˆ§ set as âŠ† ğ’®}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>states_finite</span><span> </span><span>states_wellformed</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>o</span><span class="delimiter">;</span><span> </span><span>simp</span><span>
</span><span>        </span><span>add</span><span class="delimiter">:</span><span> </span><span>Max_start</span><span> </span><span>max_prob_Cons</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>Max_image_commute</span><span> </span><span>Max_image_left_mult</span><span> </span><span>Max_to_image2</span><span>
</span><span>        </span><span>cong</span><span class="delimiter">:</span><span> </span><span>Max_image_cong</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>max_prob_viterbi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(MAX t âˆˆ ğ’®. viterbi_prob s t os) = max_prob s os"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_prob_init</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>os</span><span class="delimiter">]</span><span> </span><span>Max_V_viterbi</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹s âˆˆ ğ’®â€º</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Decoding the Most Probable Hidden State Sequenceâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM3</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>viterbi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi s t_end [] = ([], indicator {t_end} s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi s t_end (o # os) = fst (
    argmax snd (map
      (Î»t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * v))
    state_list))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_list_nonempty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"state_list â‰  []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_list_ğ’®</span><span> </span><span>states_wellformed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_viterbi_prob</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"snd (viterbi s t_end os) = viterbi_prob s t_end os"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>o</span><span> </span><span>os</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Î»t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map ?f state_list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>state_list_nonempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map ?f state_list â‰  []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>argmax</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>snd</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd (fst (argmax snd ?xs)) = snd (argmax snd ?xs)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd (argmax snd ?xs) = (MAX x âˆˆ set ?xs. snd x)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_list_ğ’®</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Max_eq_image_if</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>finite_imageI</span><span> </span><span>states_finite</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>finite_imageI</span><span> </span><span>states_finite</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>val_of</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val_of s [] [] = 1"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val_of s (t # xs) (o # os) = ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * val_of t xs os"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_of_T</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"val_of s as os = T (s, o<span class="hidden">â‡©</span><sub>1</sub>) {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = length os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>o<span class="hidden">â‡©</span><sub>1</sub></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>val_of.induct</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>T_V_Cons</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_sequence</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"snd (viterbi s t_end os) = val_of s (fst (viterbi s t_end os)) os"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (viterbi s t_end os) &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>indicator_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>o</span><span> </span><span>os</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map
    (Î»t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * v))
    state_list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>state_list_nonempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?xs â‰  []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>argmax</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>snd</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ set state_list"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"fst (argmax snd ?xs) =
    (t # fst (viterbi t t_end os), ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * snd (viterbi t t_end os))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ennreal_zero_less_mult_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_valid_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"length as = length os âˆ§ set as âŠ† ğ’®"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi s t_end os = (as, v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>as</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>o</span><span> </span><span>os</span><span> </span><span>s</span><span> </span><span>as</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"map
    (Î»t. let (xs, v) = viterbi t t_end os in (t # xs, ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * v))
    state_list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>state_list_nonempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?xs â‰  []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>argmax</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>snd</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ ğ’®"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"fst (argmax snd ?xs) =
    (t # fst (viterbi t t_end os), ennreal (pmf (ğ’ª t) o * pmf (ğ’¦ s) t) * snd (viterbi t t_end os))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_list_ğ’®</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi t t_end os"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = fst (argmax snd (map (Î» t. viterbi s t os) state_list))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_finalE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ ğ’®"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = viterbi s t os"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd (viterbi s t os) = Max ((Î»t. snd (viterbi s t os)) ` ğ’®)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>state_list_nonempty</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map (Î» t. viterbi s t os) state_list â‰  []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>argmax</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>snd</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_list_ğ’®</span><span> </span><span>image_comp</span><span> </span><span>comp_def</span><span> </span><span>viterbi_final_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>viterbi_final_max_prob</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = (as, v)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v = max_prob s os"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ ğ’®"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = viterbi s t os"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd (viterbi s t os) = Max ((Î»t. snd (viterbi s t os)) ` ğ’®)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>viterbi_finalE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viterbi_viterbi_prob</span><span> </span><span>max_prob_viterbi</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>viterbi_final_is_decoding</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = (as, v)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v &gt; 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s âˆˆ ğ’®"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_decoding s os as"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>viterbi_valid_path</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>_</span><span> </span><span>os</span><span> </span><span>as</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length as = length os"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set as âŠ† ğ’®"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>viterbi_finalE</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>os</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t âˆˆ ğ’®"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final s os = viterbi s t os"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>viterbi_finalE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>viterbi_sequence</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>os</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val_of s as os = v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi s t os"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snd_def</span><span> </span><span>split</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>val_of_T</span><span> </span><span>as</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"max_prob s os = T (s, obs) {Ï‰ âˆˆ space S. V os as Ï‰}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viterbi_final_max_prob</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>as</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_decoding_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>T'_I_T</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Anonymous context *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* HMM 3 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Theory *)</span></span></span></span></span></pre>
</div>
</div><div id="HMM_Implementation">
<div class="head"><h1>Theory HMM_Implementation</h1>
<span class="command">theory</span> <span class="name">HMM_Implementation</span><br/>
<span class="keyword">imports</span> <a href="Hidden_Markov_Model.html"><span class="name">Hidden_Markov_Model</span></a> <a href="State_Main.html"><span class="name">State_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Implementationâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HMM_Implementation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Hidden_Markov_Model</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Monad_Memo_DP.State_Main"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The Forward Algorithmâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>HMM4</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM3</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span>ğ’¦</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s â‡’ 's pmf"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>states_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct state_list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM3_defs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>os</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t iarray"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  Alternative definition using indices into the list of states.
  The list of states is implemented as an immutable array for better performance.
â€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>forward_ix_rec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward_ix_rec s t_end n = (if n â‰¥ IArray.length os then indicator {t_end} s else
    (âˆ‘t â† state_list.
      ennreal (pmf (ğ’ª t) (os !! n)) * ennreal (pmf (ğ’¦ s) t) * forward_ix_rec t t_end (n + 1)))
  "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"Wellfounded.measure (Î»(_,_,n). IArray.length os - n)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Memoizationâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">memoize_fun</span></span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span>forward_ix_rec</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">with_memory</span></span><span> </span><span>dp_consistency_mapping</span><span>
</span><span>  </span><span class="keyword1"><span class="command">monadifies</span></span><span> </span><span class="delimiter">(</span><span>state</span><span class="delimiter">)</span><span> </span><span>forward_ix_rec.simps</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Let_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub>'</span><span>
</span><span class="keyword1"><span class="command">memoize_correct</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>memoize_prover</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The main theorems generated by memoization.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>state_monad_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub>'.simps</span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub>_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub>.memoized_correct</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Fixed IArray *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward_ix os = forward_ix_rec (IArray os)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood_compute s os â‰¡
    if s âˆˆ set state_list then Some (âˆ‘t â† state_list. forward s t os) else None"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* HMM3 Defs *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Correctness of the alternative definition.â€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM3</span><span class="delimiter">)</span><span> </span><span>forward_ix_drop_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward_ix (o # os) s t (n + 1) = forward_ix os s t n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"length os - n"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>n</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>forward_ix_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM4</span><span class="delimiter">)</span><span> </span><span>forward_ix_forward</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward_ix os s t 0 = forward s t os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>forward_ix_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>o</span><span> </span><span>os</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forward_ix_drop_one</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>forward_ix_def</span><span class="delimiter">]</span><span> </span><span>states_distinct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>forward.simps</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>forward_ix_rec.simps</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>state_list_ğ’®</span><span> </span><span>sum_list_distinct_conv_sum_set</span><span>
</span><span>             </span><span>del</span><span class="delimiter">:</span><span> </span><span>forward_ix_rec.simps</span><span> </span><span>forward.simps</span><span>
</span><span>       </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  Instructs the code generator to use this equation instead to execute â€¹forwardâ€º.
  Uses the memoized version of â€¹forward_ixâ€º.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM4</span><span class="delimiter">)</span><span> </span><span>forward_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"forward s t os = fst (run_state (forward_ix<span class="hidden">â‡©</span><sub>m</sub>' (IArray os) s t 0) Mapping.empty)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>
</span><span>      </span><span>forward_ix_def</span><span> </span><span>forward_ix<span class="hidden">â‡©</span><sub>m</sub>.memoized_correct</span><span> </span><span>forward_ix_forward</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>states_distinct</span><span>
</span><span>     </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HMM4</span><span class="delimiter">)</span><span> </span><span>likelihood_compute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"likelihood_compute s os = Some x âŸ· s âˆˆ ğ’® âˆ§ x = likelihood s os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>likelihood_compute_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>states_distinct</span><span> </span><span>state_list_ğ’®</span><span> </span><span>sum_list_distinct_conv_sum_set</span><span> </span><span>likelihood_forward</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The Viterbi Algorithmâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM3_defs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>os</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t iarray"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  Alternative definition using indices into the list of states.
  The list of states is implemented as an immutable array for better performance.
â€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>viterbi_ix_rec</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_ix_rec s t_end n = (if n â‰¥ IArray.length os then ([], indicator {t_end} s) else
  fst (
    argmax snd (map
      (Î»t. let (xs, v) = viterbi_ix_rec t t_end (n + 1) in
        (t # xs, ennreal (pmf (ğ’ª t) (os !! n) * pmf (ğ’¦ s) t) * v))
    state_list)))
  "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"Wellfounded.measure (Î»(_,_,n). IArray.length os - n)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Memoizationâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">memoize_fun</span></span><span> </span><span>viterbi_ix<span class="hidden">â‡©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span>viterbi_ix_rec</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">with_memory</span></span><span> </span><span>dp_consistency_mapping</span><span>
</span><span>  </span><span class="keyword1"><span class="command">monadifies</span></span><span> </span><span class="delimiter">(</span><span>state</span><span class="delimiter">)</span><span> </span><span>viterbi_ix_rec.simps</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Let_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">memoize_correct</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>memoize_prover</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The main theorems generated by memoization.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>state_monad_syntax</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>'.simps</span><span> </span><span>viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>_def</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>.memoized_correct</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Fixed IArray *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_ix os = viterbi_ix_rec (IArray os)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* HMM3 Defs *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>HMM3</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_ix_drop_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_ix (o # os) s t (n + 1) = viterbi_ix os s t n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"length os - n"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>n</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viterbi_ix_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_ix_viterbi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi_ix os s t 0 = viterbi s t os"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>viterbi_ix_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>os</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>o</span><span> </span><span>os</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>viterbi_ix_drop_one</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>viterbi_ix_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>viterbi.simps</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>viterbi_ix_rec.simps</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>viterbi_ix_rec.simps</span><span> </span><span>viterbi.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viterbi_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viterbi s t os = fst (run_state (viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>' (IArray os) s t 0) Mapping.empty)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>viterbi_ix_def</span><span> </span><span>viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>.memoized_correct</span><span> </span><span>viterbi_ix_viterbi</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Hidden Markov Model 3 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Miscâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pmf_of_alist_support_aux_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0 :: real) â‰¤ (case map_of Î¼ x of None â‡’ 0 | Some p â‡’ p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pmf_of_alist_support_aux_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map snd Î¼) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst Î¼)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ«<span class="hidden">â‡§</span><sup>+</sup> x. ennreal (case map_of Î¼ x of None â‡’ 0 | Some p â‡’ p) âˆ‚count_space UNIV = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>nn_integral_count_space</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set Î¼"</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum.mono_neutral_left</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set Î¼"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>ennreal_less_zero_iff</span><span> </span><span>map_of_eq_None_iff</span><span> </span><span>mem_Collect_eq</span><span> </span><span>option.case</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(âˆ‘x = 0..&lt;length Î¼. snd (Î¼ ! x))
      = sum (Î» x. case map_of Î¼ x of None â‡’ 0 | Some v â‡’ v) (fst ` set Î¼)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum.reindex_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î» i. fst (Î¼ ! i)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>inj_onI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_conv_nth</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_of_eq_None_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_of_eq_Some_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>nth_mem</span><span> </span><span>option.inject</span><span> </span><span>prod_eqI</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>pmf_of_alist_support_aux_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>atLeastLessThan_iff</span><span> </span><span>ennreal_1</span><span>
</span><span>          </span><span>length_map</span><span> </span><span>nth_map</span><span> </span><span>sum.cong</span><span> </span><span>sum_ennreal</span><span> </span><span>sum_list_sum_nth</span><span>
</span><span>          </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pmf_of_alist_support</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sum_list (map snd Î¼) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst Î¼)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_pmf (pmf_of_alist Î¼) âŠ† fst ` set Î¼"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pmf_of_alist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>set_embed_pmf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pmf_of_alist_support_aux_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Defining a Markov kernel from an association list.â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Closed_Kernel_From</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s Ã— ('t Ã— real) list) list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wellformed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S â‰  []"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set K. âˆ€ (t, _) âˆˆ set Î¼. t âˆˆ set S"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_pmf</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set K. âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set K. distinct (map fst Î¼)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set K. sum_list (map snd Î¼) = 1"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_unique</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst K)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"K' s â‰¡ case map_of (map (Î» (s, Î¼). (s, PMF_Impl.pmf_of_alist Î¼)) K) s of
  None â‡’ return_pmf (hd S) |
  Some s â‡’ s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>Closed_Kernel</span><span> </span><span>K'</span><span> </span><span class="string"><span class="delete"><span class="delete">"set S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wellformed</span><span> </span><span>closed</span><span> </span><span>is_pmf</span><span> </span><span>pmf_of_alist_support</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">;</span><span> </span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"K1 = map_of (map (Î» (s, Î¼). (s, map_of Î¼)) K)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pmf_of_alist_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, Î¼) âˆˆ set K"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pmf (pmf_of_alist Î¼) t = (case map_of Î¼ t of
      None â‡’ 0
    | Some p â‡’ p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>is_pmf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pmf_of_alist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>pmf_embed_pmf</span><span> </span><span>pmf_of_alist_support_aux_2</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>map_of_SomeD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Î¼ = Î¼'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, Î¼) âˆˆ set K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, Î¼') âˆˆ set K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>is_unique</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Pair_inject</span><span> </span><span>distinct_conv_nth</span><span> </span><span>fst_conv</span><span> </span><span>in_set_conv_nth</span><span> </span><span>length_map</span><span> </span><span>nth_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>map_of_NoneD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x âˆ‰ fst ` set M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_of M x = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>weak_map_of_SomeI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>K'_code</span><span> </span><span class="delimiter">[</span><span>code_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pmf (K' s) t = (case K1 s of
      None â‡’ (if t = hd S then 1 else 0)
    | Some Î¼ â‡’ case Î¼ t of
        None â‡’ 0
      | Some p â‡’ p
  )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K'_def</span><span> </span><span>K1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>                 </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>map_of_SomeD</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>map_of_NoneD</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>unique</span><span> </span><span>map_of_SomeD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pmf_of_alist_aux</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Executing Concrete HMMsâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Concrete_HMM_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ğ’¦</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s Ã— ('s Ã— real) list) list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’ª</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s Ã— ('t Ã— real) list) list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ğ’¦<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ğ’¦' s â‰¡ case map_of (map (Î» (s, Î¼). (s, PMF_Impl.pmf_of_alist Î¼)) ğ’¦) s of
    None â‡’ return_pmf (hd ğ’¦<span class="hidden">â‡©</span><sub>s</sub>) |
    Some s â‡’ s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ğ’ª' s â‰¡ case map_of (map (Î» (s, Î¼). (s, PMF_Impl.pmf_of_alist Î¼)) ğ’ª) s of
    None â‡’ return_pmf (hd ğ’ª<span class="hidden">â‡©</span><sub>s</sub>) |
    Some s â‡’ s"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Concrete_HMM</span><span> </span><span class="delimiter">=</span><span> </span><span>Concrete_HMM_defs</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>observations_wellformed'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ğ’ª<span class="hidden">â‡©</span><sub>s</sub> â‰  []"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>observations_closed'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set ğ’ª. âˆ€ (t, _) âˆˆ set Î¼. t âˆˆ set ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>observations_form_pmf'</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set ğ’ª. âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set ğ’ª. distinct (map fst Î¼)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set ğ’ª. sum_list (map snd Î¼) = 1"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>observations_unique</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst ğ’ª)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>states_wellformed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ğ’¦<span class="hidden">â‡©</span><sub>s</sub> â‰  []"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>states_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set ğ’¦. âˆ€ (t, _) âˆˆ set Î¼. t âˆˆ set ğ’¦<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>states_form_pmf</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set ğ’¦. âˆ€ (_, p) âˆˆ set Î¼. p â‰¥ 0"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (_, Î¼) âˆˆ set ğ’¦. distinct (map fst Î¼)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"âˆ€ (s, Î¼) âˆˆ set ğ’¦. sum_list (map snd Î¼) = 1"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>states_unique</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"distinct (map fst ğ’¦)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct ğ’¦<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>O</span><span class="delimiter">:</span><span> </span><span>Closed_Kernel_From</span><span> </span><span>ğ’ª</span><span> </span><span>ğ’ª<span class="hidden">â‡©</span><sub>s</sub></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"O.K' = ğ’ª'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From ğ’ª ğ’ª<span class="hidden">â‡©</span><sub>s</sub>â€º</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>observations_wellformed'</span><span> </span><span>observations_closed'</span><span> </span><span>observations_form_pmf'</span><span> </span><span>observations_unique</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From.K' ğ’ª ğ’ª<span class="hidden">â‡©</span><sub>s</sub> = ğ’ª'â€º</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Closed_Kernel_From.K'_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From ğ’ª ğ’ª<span class="hidden">â‡©</span><sub>s</sub>â€º</span></span></span><span class="delimiter">]</span><span> </span><span>ğ’ª'_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span>Closed_Kernel_From</span><span> </span><span>ğ’¦</span><span> </span><span>ğ’¦<span class="hidden">â‡©</span><sub>s</sub></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K.K' = ğ’¦'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From ğ’¦ ğ’¦<span class="hidden">â‡©</span><sub>s</sub>â€º</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>states_wellformed</span><span> </span><span>states_closed</span><span> </span><span>states_form_pmf</span><span> </span><span>states_unique</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From.K' ğ’¦ ğ’¦<span class="hidden">â‡©</span><sub>s</sub> = ğ’¦'â€º</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Closed_Kernel_From.K'_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Closed_Kernel_From ğ’¦ ğ’¦<span class="hidden">â‡©</span><sub>s</sub>â€º</span></span></span><span class="delimiter">]</span><span> </span><span>ğ’¦'_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>O_code</span><span> </span><span class="delimiter">=</span><span> </span><span>O.K'_code</span><span> </span><span>O.K1_def</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>K_code</span><span> </span><span class="delimiter">=</span><span> </span><span>K.K'_code</span><span> </span><span>K.K1_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>HMM_interp</span><span class="delimiter">:</span><span> </span><span>HMM4</span><span> </span><span>ğ’ª'</span><span> </span><span class="string"><span class="delete"><span class="delete">"set ğ’¦<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span> </span><span>ğ’¦<span class="hidden">â‡©</span><sub>s</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"set ğ’ª<span class="hidden">â‡©</span><sub>s</sub>"</span></span></span><span> </span><span>ğ’¦'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>O.Closed_Kernel_axioms</span><span> </span><span>K.Closed_Kernel_axioms</span><span> </span><span>states_unique</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro_locales</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>HMM4_axioms.intro</span><span> </span><span>HMM3_axioms.intro</span><span> </span><span>HOL.refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Concrete HMM *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HMM_Example">
<div class="head"><h1>Theory HMM_Example</h1>
<span class="command">theory</span> <span class="name">HMM_Example</span><br/>
<span class="keyword">imports</span> <a href="HMM_Implementation.html"><span class="name">HMM_Implementation</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹Exampleâ€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HMM_Example</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>HMM_Implementation</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.AList_Mapping"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  We would like to implement mappings as red-black trees
  but they require the key type to be linearly ordered.
  Unfortunately, â€¹HOL-Analysisâ€º fixes the product order to the element-wise order
  and thus we cannot restore a linear order,
  and the red-black tree implementation (from â€¹HOL-Libraryâ€º) cannot be used.
â€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹The ice cream example from Jurafsky and Martin \cite{Jurafsky}.â€º</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"states = [''start'', ''hot'', ''cold'', ''end'']"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>observations</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"int list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"observations = [0, 1, 2, 3]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"kernel =
    [
      (''start'', [(''hot'',0.8 :: real), (''cold'',0.2)]),
      (''hot'',   [(''hot'',0.6 :: real), (''cold'',0.3), (''end'', 0.1)]),
      (''cold'',  [(''hot'',0.4 :: real), (''cold'',0.5), (''end'', 0.1)]),
      (''end'',   [(''end'', 1)])
    ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"emissions =
    [
      (''hot'',   [(1, 0.2), (2, 0.4), (3, 0.4)]),
      (''cold'',  [(1, 0.5), (2, 0.4), (3, 0.1)]),
      (''end'',   [(0, 1)])
    ]
  "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">global_interpretation</span></span><span> </span><span>Concrete_HMM</span><span> </span><span>kernel</span><span> </span><span>emissions</span><span> </span><span>observations</span><span> </span><span>states</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>      </span><span>viterbi_rec</span><span>   </span><span class="delimiter">=</span><span> </span><span>HMM_interp.viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>'</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>viterbi</span><span>       </span><span class="delimiter">=</span><span> </span><span>HMM_interp.viterbi</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>viterbi_final</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM_interp.viterbi_final</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>forward_rec</span><span>   </span><span class="delimiter">=</span><span> </span><span>HMM_interp.forward_ix<span class="hidden">â‡©</span><sub>m</sub>'</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>forward</span><span>       </span><span class="delimiter">=</span><span> </span><span>HMM_interp.forward</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>likelihood</span><span>    </span><span class="delimiter">=</span><span> </span><span>HMM_interp.likelihood_compute</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">;</span><span> </span><span>eval</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM_interp.viterbi_ix<span class="hidden">â‡©</span><sub>m</sub>'.simps</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>O_code</span><span> </span><span>K_code</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>HMM_interp.forward_ix<span class="hidden">â‡©</span><sub>m</sub>'.simps</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>O_code</span><span> </span><span>K_code</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"likelihood ''start'' [1, 1, 1]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  If we enforce the last observation to correspond to @{term â€¹''end''â€º},
  then @{term forward} and @{term likelihood} yield the same result.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"likelihood ''start'' [1, 1, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"forward ''start'' ''end'' [1, 1, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"forward ''start'' ''end'' [3, 3, 3, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"forward ''start'' ''end'' [3, 1, 3, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"forward ''start'' ''end'' [3, 1, 3, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi ''start'' ''end'' [1, 1, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi ''start'' ''end'' [3, 3, 3, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi ''start'' ''end'' [3, 1, 3, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi ''start'' ''end'' [3, 1, 3, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">â€¹
  If we enforce the last observation to correspond to @{term â€¹''end''â€º},
  then @{term viterbi} and @{term viterbi_final} yield the same result.
â€º</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final ''start'' [3, 1, 3, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final ''start'' [1, 1, 1, 1, 1, 1, 1, 0]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viterbi_final ''start'' [1, 1, 1, 1, 1, 1, 1, 1]"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>