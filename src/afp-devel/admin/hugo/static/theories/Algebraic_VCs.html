<div id="VC_KAT_scratch">
<div class="head"><h1>Theory VC_KAT_scratch</h1>
<span class="command">theory</span> <span class="name">VC_KAT_scratch</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Program Correctness Component Based on Kleene Algebra with Tests
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two Standalone Components›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAT_scratch</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Component Based on Kleene Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification and step-wise refinement of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KAT: Definition and Basic Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>times</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">=</span><span> </span><span>plus</span><span> </span><span class="delimiter">+</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>less_eq_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟷ x + y = y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>less_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y ⟷ x ≤ y ∧ x ≠ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>dioid</span><span> </span><span class="delimiter">=</span><span> </span><span>semiring</span><span> </span><span class="delimiter">+</span><span> </span><span>one</span><span> </span><span class="delimiter">+</span><span> </span><span>zero</span><span> </span><span class="delimiter">+</span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>add_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mult_onel</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⋅ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mult_oner</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ 1 = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_zerol</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ⋅ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annir</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ 0 = 0"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>monoid_mult</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>order</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_def</span><span> </span><span>less_eq_def</span><span> </span><span>add_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ z ⋅ x ≤ z ⋅ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_left</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_isor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ x ⋅ z ≤ y ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>                                         
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ x + z ≤ y + z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>abel_semigroup.commute</span><span> </span><span>add.abel_semigroup_axioms</span><span> </span><span>add.semigroup_axioms</span><span> </span><span>add_idem</span><span> </span><span>less_eq_def</span><span> </span><span>semigroup.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_lub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y ≤ z ⟷ x ≤ z ∧ y ≤ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc</span><span> </span><span>add_commute</span><span> </span><span>less_eq_def</span><span> </span><span>order.ordering_axioms</span><span> </span><span>ordering.refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>dioid</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>star_unfoldl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_unfoldr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x ≤ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ y"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_sim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ y ≤ z ⋅ x ⟹ x ⋅ y<span class="hidden">⇧</span><sup>⋆</sup> ≤ z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ y ≤ z ⋅ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x ⋅ y ≤ x + z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ z ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lub</span><span> </span><span>distrib_left</span><span> </span><span>eq_refl</span><span> </span><span>less_eq_def</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"... ≤ z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_lub</span><span> </span><span>mult_isor</span><span> </span><span>star_unfoldr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_inductr</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kat</span><span> </span><span class="delimiter">=</span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>test_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"at (at 1) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_mult</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"at (at (at (at x) ⋅ at (at y))) = at (at y) ⋅ at (at x)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_mult_comp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"at x ⋅ at (at x) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>test_de_morgan</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"at x + at y = at (at (at x) ⋅ at (at y))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>t_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"t_"</span></span></span><span> </span><span class="delimiter">[</span><span>100</span><span class="delimiter">]</span><span> </span><span>101</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t x = at (at x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_n</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t (at x) = at x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_idem</span><span> </span><span>test_de_morgan</span><span> </span><span>test_mult</span><span> </span><span>t_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ t y = t y ⋅ t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>test_de_morgan</span><span> </span><span>test_mult</span><span> </span><span>t_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t x ⋅ t x = t x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_idem</span><span> </span><span>test_de_morgan</span><span> </span><span>test_mult</span><span> </span><span>t_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_mult_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t (t x ⋅ t y) = t x ⋅ t y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_comm</span><span> </span><span>t_op_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Hoare Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ t p ⋅ x ≤ x ⋅ t q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_then_else</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = t p ⋅ x + at p ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p do x od = (t p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ at p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ inv _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p inv i do x od = while p do x od"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p 1 p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p' ⟹ t q' ≤ t q ⟹ H p' x q' ⟹ H p x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>H_def</span><span> </span><span>mult_isol</span><span> </span><span>mult_isor</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H r y q ⟹ H p x r  ⟹ H p (x ⋅ y) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H r y q"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ x ≤ x ⋅ t r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t r ⋅ y ≤ y ⋅ t q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>h2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ x ⋅ y ≤ x ⋅ t r ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_isor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ x ⋅ y ⋅ t q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h4</span><span> </span><span>mult_isol</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x q ⟹ H (t p ⋅ at r) y q ⟹ H p (if r then x else y fi) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ at r) y q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t r ⋅ t p ⋅ t r ⋅ x ≤ t r ⋅ x ⋅ t q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"at r ⋅ t p ⋅ at r ⋅ y ≤ at r ⋅ y ⋅ t q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>mult_isol</span><span> </span><span>mult_assoc</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>H_def</span><span> </span><span>h2</span><span> </span><span>mult_isol</span><span> </span><span>mult_assoc</span><span> </span><span>t_mult_closed</span><span> </span><span>t_n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ t r ⋅ x ≤ t r ⋅ x ⋅ t q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>h6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ at r ⋅ y ≤ at r ⋅ y ⋅ t q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>t_comm</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>h4</span><span> </span><span>mult_assoc</span><span> </span><span>t_comm</span><span> </span><span>t_idem</span><span> </span><span>t_n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ (t r ⋅ x + at r ⋅ y) = t p ⋅ t r ⋅ x + t p ⋅ at r ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ t r ⋅ x ⋅ t q + t p ⋅ at r ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h5</span><span> </span><span>add_iso</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ t r ⋅ x ⋅ t q + at r ⋅ y ⋅ t q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_commute</span><span> </span><span>h6</span><span> </span><span>add_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>if_then_else_def</span><span> </span><span>distrib_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x p ⟹ H p (while r do x od) (t p ⋅ at r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t r ⋅ t p ⋅ t r ⋅ x ≤ t r ⋅ x ⋅ t p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>distrib_left</span><span> </span><span>less_eq_def</span><span> </span><span>mult_assoc</span><span> </span><span>t_mult_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ t r ⋅ x ≤ t r ⋅ x ⋅ t p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>t_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ (t r ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ at r ≤ (t r ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ t p ⋅ at r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isor</span><span> </span><span>star_sim</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ (t r ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ at r ≤ (t r ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ at r ⋅ t p ⋅ at r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_assoc</span><span> </span><span>t_comm</span><span> </span><span>t_idem</span><span> </span><span>t_n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>mult_assoc</span><span> </span><span>t_mult_closed</span><span> </span><span>t_n</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_while_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t i ⟹ t i ⋅ at r ≤ t q ⟹ H (t i ⋅ t r) x i ⟹ H p (while r inv i do x od) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_cons</span><span> </span><span>H_loop</span><span> </span><span>t_mult_closed</span><span> </span><span>t_n</span><span> </span><span>while_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness and Relation KAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_d</span><span class="delimiter">:</span><span> </span><span>dioid</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid</span><span class="delimiter">)</span><span> </span><span>power_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ x ^ i ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_lub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.mult_isol</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid</span><span class="delimiter">)</span><span> </span><span>power_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x ^ i ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_lub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ i ≤ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ x ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ⋅ x ^ i) ⋅ x ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.mult_isor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ (x ⋅ x ^ i) ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>local.power_commutes</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_is_relpow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_d.power X i = X ^^ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>relpow_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* = (⋃i. rel_d.power X i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_is_relpow</span><span> </span><span>rtrancl_is_UN_relpow</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ; Y^* = (⋃i. X ; rel_d.power Y i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* ; Y = (⋃i. (rel_d.power X i) ; Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_at X = Id ∩ - X"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_kat</span><span class="delimiter">:</span><span> </span><span>kat</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span>rel_at</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_star_contr</span><span> </span><span>rel_d.power_inductl</span><span> </span><span>rel_star_contl</span><span>  </span><span>SUP_least</span><span> </span><span>rel_d.power_inductr</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding Predicates in Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≡ {(s,s) |s. P s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.t_op ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.t_op_def</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_neg_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_at ⌈P⌉ = ⌈λs. ¬ P s⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ∩ ⌈Q⌉ = ⌈λs.  P s ∧ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ; ⌈Q⌉ = ⌈λs. P s ∧ Q s⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_disj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ∪ ⌈Q⌉ = ⌈λs. P s ∨ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_prop</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ⊆ ⌈Q⌉ ⟷ (∀s. P s ⟶  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Store and Assignment›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>store</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"string  ⇒ 'a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a store ⇒ 'a) ⇒ 'a store rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v ::= e = {(s, s(v := e s)) |s. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈λs. P (s (v := e s))⌉ (v ::= e) ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gets_def</span><span> </span><span>rel_kat.H_def</span><span> </span><span>rel_kat.t_op_def</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ rel_kat.H ⌈P⌉ (v ::= e) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gets_def</span><span> </span><span>rel_kat.H_def</span><span> </span><span>rel_kat.t_op_def</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>H_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE P X POST Q ≡ rel_kat.H ⌈P⌉ X ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>if_then_else_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y FI ≡ rel_kat.if_then_else ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while_inv_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a pred ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P INV I DO X OD ≡ rel_kat.while_inv ⌈P⌉ ⌈I⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_while_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>H_assign</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_assign_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Refinement KAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>rkat</span><span> </span><span class="delimiter">=</span><span> </span><span>kat</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (R p q) q"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟹ x ≤ R p q"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Refinement Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ R p p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_skip</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p' ⟹ t q' ≤ t q ⟹ R p' q' ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_cons</span><span> </span><span>R2</span><span> </span><span>R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(R p r) ⋅ (R r q) ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_seq</span><span> </span><span>R2</span><span> </span><span>R1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"if v then (R (t v ⋅ t p) q) else (R (at v ⋅ t p) q) fi ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_cond</span><span> </span><span>R1</span><span> </span><span>R2</span><span> </span><span>t_comm</span><span> </span><span>t_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"while q do (R (t p ⋅ t q) p) od  ≤ R p (t p ⋅ at q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_loop</span><span> </span><span>R2</span><span> </span><span>R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness and Relation RKAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R P Q = ⋃{X. rel_kat.H P X Q}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_rkat</span><span class="delimiter">:</span><span> </span><span>rkat</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span>rel_at</span><span> </span><span>rel_R</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_R_def</span><span> </span><span>rel_kat.H_def</span><span> </span><span>rel_kat.t_op_def</span><span> </span><span>rel_at_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assignment Laws›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_assign_var</span><span> </span><span>rel_rkat.R2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. Q' s ⟶ Q (s (v := e s))) ⟹ (rel_R ⌈P⌉ ⌈Q'⌉) ; (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. Q' s ⟶ Q (s(v := e s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p pa cs f. ∃fa. (p fa ∨ cs ::= f ⊆ rel_R ⌈p⌉ ⌈pa⌉) ∧ (¬ pa (fa(cs := f fa::'a)) ∨ cs ::= f ⊆ rel_R ⌈p⌉ ⌈pa⌉)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R_assign</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ::= e ⊆ rel_R ⌈Q'⌉ ⌈Q⌉"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>rel_d.mult_isol</span><span> </span><span>rel_rkat.R_seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ P' (s (v := e s))) ⟹ (v ::= e) ; (rel_R ⌈P'⌉ ⌈Q⌉) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ P' (s(v := e s))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p pa cs f. ∃fa. (p fa ∨ cs ::= f ⊆ rel_R ⌈p⌉ ⌈pa⌉) ∧ (¬ pa (fa(cs := f fa::'a)) ∨ cs ::= f ⊆ rel_R ⌈p⌉ ⌈pa⌉)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R_assign</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ::= e ⊆ rel_R ⌈P⌉ ⌈P'⌉"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>rel_d.mult_isor</span><span> </span><span>rel_rkat.R_seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''z'' ::= (λs. s ''x'')); rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''x'' ::= (λs. s ''y'')); rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref3</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''y'' ::= (λs. s ''z'')); rel_R ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref_var</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''z'' ::= (λs. s ''x'')); (''x'' ::= (λs. s ''y'')); (''y'' ::= (λs. s ''z''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>var_swap_ref1</span><span> </span><span>var_swap_ref2</span><span> </span><span>var_swap_ref3</span><span> </span><span>rel_rkat.R_skip</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="VC_KAD_scratch">
<div class="head"><h1>Theory VC_KAD_scratch</h1>
<span class="command">theory</span> <span class="name">VC_KAD_scratch</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Program Correctness Component Based on Kleene Algebra with Domain
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Component Based on Kleene Algebra with Domain›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification and step-wise refinement of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_scratch</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KAD: Definitions and Basic Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>times</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">=</span><span> </span><span>plus</span><span> </span><span class="delimiter">+</span><span> </span><span>ord</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>less_eq_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟷ x + y = y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>less_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x &lt; y ⟷ x ≤ y ∧ x ≠ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>dioid</span><span> </span><span class="delimiter">=</span><span> </span><span>semiring</span><span> </span><span class="delimiter">+</span><span> </span><span>one</span><span> </span><span class="delimiter">+</span><span> </span><span>zero</span><span> </span><span class="delimiter">+</span><span> </span><span>plus_ord</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>add_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mult_onel</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⋅ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mult_oner</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ 1 = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>add_zerol</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + x = x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ⋅ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>annir</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ 0 = 0"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>monoid_mult</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>order</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_def</span><span> </span><span>less_eq_def</span><span> </span><span>add_commute</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>add_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_isor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ x ⋅ z ≤ y ⋅ z"</span></span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_isol</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ z ⋅ x ≤ z ⋅ y"</span></span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_left</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_iso</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ z + x ≤ z + y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.semigroup_axioms</span><span> </span><span>add_idem</span><span> </span><span>less_eq_def</span><span> </span><span>semigroup.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_ub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ x + y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc</span><span> </span><span>add_idem</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_lub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y ≤ z ⟷ x ≤ z ∧ y ≤ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_assoc</span><span> </span><span>add_commute</span><span> </span><span>less_eq_def</span><span> </span><span>order.ordering_axioms</span><span> </span><span>ordering.refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>kleene_algebra</span><span>  </span><span class="delimiter">=</span><span> </span><span>dioid</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>101</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>star_unfoldl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_unfoldr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 + x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x ≤ x<span class="hidden">⇧</span><sup>⋆</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>star_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x<span class="hidden">⇧</span><sup>⋆</sup> ≤ y"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_sim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ y ≤ z ⋅ x ⟹ x ⋅ y<span class="hidden">⇧</span><sup>⋆</sup> ≤ z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ y ≤ z ⋅ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x ⋅ y ≤ x + z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ z ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lub</span><span> </span><span>distrib_left</span><span> </span><span>eq_refl</span><span> </span><span>less_eq_def</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"... ≤ z<span class="hidden">⇧</span><sup>⋆</sup> ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_lub</span><span> </span><span>mult_isor</span><span> </span><span>star_unfoldr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_inductr</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>antidomain_kleene_algebra</span><span> </span><span class="delimiter">=</span><span> </span><span>kleene_algebra</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ad</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ad"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>as1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x ⋅ y) + ad (x ⋅ ad (ad y)) = ad (x ⋅ ad (ad y))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>as3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x) + ad x = 1"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dom_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"d"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"d x = ad (ad x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_subid_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ y ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>add_ub</span><span> </span><span>as3</span><span> </span><span>mult_1_left</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d1_a</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ x = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>dom_op_def</span><span> </span><span>add_zerol</span><span> </span><span>as1</span><span> </span><span>as3</span><span> </span><span>distrib_right</span><span> </span><span>mult_1_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_mul_d</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ d x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>dom_op_def</span><span> </span><span>add_zerol</span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span>distrib_right</span><span> </span><span>mult_1_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_d_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d (ad x) = ad x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>d1_a</span><span> </span><span>dom_op_def</span><span> </span><span>add_zerol</span><span> </span><span>as1</span><span> </span><span>as3</span><span> </span><span>distrib_left</span><span> </span><span>mult_1_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad x = ad x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_d_closed</span><span> </span><span>d1_a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>meet_ord</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ≤ ad y ⟷ ad x ⋅ ad y = ad x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_d_closed</span><span> </span><span>a_subid_aux</span><span> </span><span>d1_a</span><span> </span><span>antisym</span><span> </span><span>mult_1_right</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d_wloc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ y = 0 ⟷ x ⋅ d y = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_subid_aux</span><span> </span><span>d1_a</span><span> </span><span>dom_op_def</span><span> </span><span>add_ub</span><span> </span><span>antisym</span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span>mult_1_right</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gla_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ y = 0 ⟹ ad x ≤ ad y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_subid_aux</span><span> </span><span>d_wloc</span><span> </span><span>dom_op_def</span><span> </span><span>add_zerol</span><span> </span><span>as3</span><span> </span><span>distrib_left</span><span> </span><span>mult_1_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a2_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x ⋅ d y) = ad (x ⋅ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_mul_d</span><span> </span><span>d1_a</span><span> </span><span>dom_op_def</span><span> </span><span>gla_1</span><span> </span><span>add_ub</span><span> </span><span>antisym</span><span> </span><span>as1</span><span> </span><span>as2</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_supdist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x + y) ≤ ad x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>gla_1</span><span> </span><span>add_ub</span><span> </span><span>add_zerol</span><span> </span><span>as1</span><span> </span><span>distrib_left</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_antitone</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ y ⟹ ad y ≤ ad x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_supdist</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad y = ad y ⋅ ad x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad y = d (ad x ⋅ ad y) ⋅ ad x ⋅ ad y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ d (ad y) ⋅ ad x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_antitone</span><span> </span><span>a_d_closed</span><span> </span><span>a_subid_aux</span><span> </span><span>mult_oner</span><span> </span><span>a_subid_aux</span><span> </span><span>dom_op_def</span><span> </span><span>mult_isol</span><span> </span><span>mult_isor</span><span> </span><span>meet_ord</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad y ≤ ad y ⋅ ad x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d (ad x ⋅ ad y) = ad x ⋅ ad y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. ad x ≤ ad (ad y ⋅ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_antitone</span><span> </span><span>a_subid_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. d (ad x ⋅ y) ≤ ad x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a2_eq</span><span> </span><span>a_antitone</span><span> </span><span>a_comm</span><span> </span><span>a_d_closed</span><span> </span><span>dom_op_def</span><span> </span><span>f1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. d (ad x ⋅ y) ⋅ y = ad x ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>d1_a</span><span> </span><span>dom_op_def</span><span> </span><span>meet_ord</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_comm</span><span> </span><span>a_idem</span><span> </span><span>dom_op_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_exp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x ⋅ y) = d x + ad y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x ⋅ y) ⋅ ad x ⋅ d y = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d_wloc</span><span> </span><span>mult_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x ⋅ y) ⋅ d y ≤ d x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_closed</span><span> </span><span>a_comm</span><span> </span><span>dom_op_def</span><span> </span><span>gla_1</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x ⋅ y) = ad (ad x ⋅ y) ⋅ d y + ad (ad x ⋅ y) ⋅ ad y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dom_op_def</span><span> </span><span>as3</span><span> </span><span>distrib_left</span><span> </span><span>mult_oner</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ d x +  ad (ad x ⋅ y) ⋅ ad y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>add_lub</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad x ⋅ y) ≤ d x + ad y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_antitone</span><span> </span><span>a_comm</span><span> </span><span>a_subid_aux</span><span> </span><span>meet_ord</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad y ≤ ad (ad x ⋅ y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_antitone</span><span> </span><span>a_subid_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d x + ad y ≤ ad (ad x ⋅ y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a2_eq</span><span> </span><span>a_antitone</span><span> </span><span>a_comm</span><span> </span><span>a_subid_aux</span><span> </span><span>dom_op_def</span><span> </span><span>add_lub</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d1_sum_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y ≤ (d x + d y) ⋅ (x + y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y = d x ⋅ x + d y ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (d x + d y) ⋅ x + (d x + d y) ⋅ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>add_lub</span><span> </span><span>add_ub</span><span> </span><span>combine_common_factor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x + y) = ad x ⋅ ad y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (x + y) ≤ ad x ⋅ ad y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_supdist</span><span> </span><span>add_commute</span><span> </span><span>mult_isor</span><span> </span><span>meet_ord</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad y = ad x ⋅ ad y + ad (x + y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_eq_def</span><span> </span><span>add_commute</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ad (ad (ad x ⋅ ad y) ⋅ (x + y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_closed</span><span> </span><span>a_exp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ ad y ≤ ad (x + y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_antitone</span><span> </span><span>d1_sum_var</span><span> </span><span>dom_op_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>kat_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ y ≤ y ⋅ d z ⟷ d x ⋅ y ⋅ ad z = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ y ≤ y ⋅ d z ⟹ d x ⋅ y ⋅ ad z = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>dom_op_def</span><span> </span><span>add_zerol</span><span> </span><span>annir</span><span> </span><span>as1</span><span> </span><span>less_eq_def</span><span> </span><span>mult_isor</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ y ⋅ ad z = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ y = d x ⋅ y ⋅ d z + d x ⋅ y ⋅ ad z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dom_op_def</span><span> </span><span>as3</span><span> </span><span>distrib_left</span><span> </span><span>mult_1_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"d x ⋅ y ≤ y ⋅ d z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_subid_aux</span><span> </span><span>add_commute</span><span> </span><span>dom_op_def</span><span> </span><span>h</span><span> </span><span>add_zerol</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shunt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ≤ ad y + ad z ⟷ ad x ⋅ d y ≤ ad z"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ≤ ad y + ad z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ d y ≤ ad y ⋅ d y + ad z ⋅ d y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distrib_right</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ad x ⋅ d y ≤ ad z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_closed</span><span> </span><span>a_d_closed</span><span> </span><span>a_exp</span><span> </span><span>a_mul_d</span><span> </span><span>a_supdist</span><span> </span><span>dom_op_def</span><span> </span><span>dual_order.trans</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ⋅ d y ≤ ad z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x = ad x ⋅ ad y + ad x ⋅ d y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_commute</span><span> </span><span>dom_op_def</span><span> </span><span>as3</span><span> </span><span>distrib_left</span><span> </span><span>mult_1_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ ad x ⋅ ad y + ad z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h</span><span> </span><span>add_lub</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ ad y + ad z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_subid_aux</span><span> </span><span>add_commute</span><span> </span><span>add_lub</span><span> </span><span>add_ub</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad x ≤ ad y + ad z"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹wp Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_then_else</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = d p ⋅ x + ad p ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p do x od = (d p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ ad p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ inv _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p inv i do x od = while p do x od"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wp x p = ad (x ⋅ ad p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>demod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" d p ≤ wp x q ⟷ d p ⋅ x ≤ x ⋅ d q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>as1</span><span> </span><span>dom_op_def</span><span> </span><span>gla_1</span><span> </span><span>kat_prop</span><span> </span><span>meet_ord</span><span> </span><span>mult_assoc</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_weaken</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp x p ≤ wp (x ⋅ ad q) (d p ⋅ ad q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a4</span><span> </span><span>a_antitone</span><span> </span><span>a_d_closed</span><span> </span><span>a_mul_d</span><span> </span><span>dom_op_def</span><span> </span><span>gla_1</span><span> </span><span>mult_isol</span><span> </span><span>mult_assoc</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_seq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (x ⋅ y) q = wp x (wp y q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2_eq</span><span> </span><span>dom_op_def</span><span> </span><span>mult_assoc</span><span> </span><span>wp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_seq_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ wp x r ⟹ r ≤ wp y q ⟹ p ≤ wp (x ⋅ y) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ wp x r"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ wp y q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. ¬ wp x r ≤ z ∨ p ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a_antitone</span><span> </span><span>mult_isol</span><span> </span><span>wp_def</span><span> </span><span>wp_seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_cond_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (if p then x else y fi) q = (ad p + wp x q) ⋅ (d p + wp y q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a4</span><span> </span><span>a_d_closed</span><span> </span><span>dom_op_def</span><span> </span><span>if_then_else_def</span><span> </span><span>distrib_right</span><span> </span><span>mult_assoc</span><span> </span><span>wp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_cond_aux1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ wp (if p then x else y fi) q = d p ⋅ wp x q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ wp (if p then x else y fi) q = ad (ad p) ⋅ (ad p + wp x q) ⋅ (d p + wp y q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom_op_def</span><span> </span><span>mult.semigroup_axioms</span><span> </span><span>semigroup.assoc</span><span> </span><span>wp_cond_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = wp x q ⋅ d p ⋅ (d p + d (wp y q))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_comm</span><span> </span><span>a_d_closed</span><span> </span><span>dom_op_def</span><span> </span><span>distrib_left</span><span> </span><span>wp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = wp x q ⋅ d p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_exp</span><span> </span><span>dom_op_def</span><span> </span><span>add_ub</span><span> </span><span>meet_ord</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_comm</span><span> </span><span>dom_op_def</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_cond_aux2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p ⋅ wp (if p then x else y fi) q = ad p ⋅ wp y q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>abel_semigroup.commute</span><span> </span><span>if_then_else_def</span><span> </span><span>a_d_closed</span><span> </span><span>add.abel_semigroup_axioms</span><span> </span><span>dom_op_def</span><span> </span><span>wp_cond_aux1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_cond</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (if p then x else y fi) q = (d p ⋅ wp x q) + (ad p ⋅ wp y q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>as3</span><span> </span><span>distrib_right</span><span> </span><span>dom_op_def</span><span> </span><span>mult_1_left</span><span> </span><span>wp_cond_aux2</span><span> </span><span>wp_cond_aux1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_star_induct_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d q ≤ wp x q ⟹ d q ≤ wp (x<span class="hidden">⇧</span><sup>⋆</sup>) q"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>demod</span><span> </span><span>star_sim</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d r ≤ wp x p ⟹ d p ≤ wp (while r do x od) (d p ⋅ ad r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d r ≤ wp x p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ wp (d r ⋅ x) p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom_op_def</span><span> </span><span>mult.semigroup_axioms</span><span> </span><span>semigroup.assoc</span><span> </span><span>shunt</span><span> </span><span>wp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ wp ((d r ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>) p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wp_star_induct_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order.ordering_axioms</span><span> </span><span>ordering.trans</span><span> </span><span>while_def</span><span> </span><span>wp_weaken</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_while_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ⋅ ad r ≤ d q ⟹ d i ⋅ d r ≤ wp x i ⟹ d p ≤ wp (while r inv i do x od) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ⋅ ad r ≤ d q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ⋅ d r ≤ wp x i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ≤ wp (while r inv i do x od) (d i ⋅ ad r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_inv_def</span><span> </span><span>wp_while</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤  wp (while r inv i do x od) q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a2</span><span> </span><span>a_antitone</span><span> </span><span>a_d_closed</span><span> </span><span>dom_op_def</span><span> </span><span>mult_isol</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_while_inv_break</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ wp y i ⟹ d i ⋅ ad r ≤ d q ⟹ d i ⋅ d r ≤ wp x i ⟹ d p ≤ wp (y ⋅ (while r inv i do x od)) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dom_op_def</span><span> </span><span>eq_refl</span><span> </span><span>mult_1_left</span><span> </span><span>mult_1_right</span><span> </span><span>wp_def</span><span> </span><span>wp_seq</span><span> </span><span>wp_seq_var</span><span> </span><span>wp_while_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness and Relation KAD›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_d</span><span class="delimiter">:</span><span> </span><span>dioid</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid</span><span class="delimiter">)</span><span> </span><span>pow_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ x ^ i ⋅ z ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_lub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.mult_isol</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid</span><span class="delimiter">)</span><span> </span><span>pow_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x ^ i ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_lub</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ i ≤ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ≤ y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ x ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ⋅ x ^ i) ⋅ x ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.dual_order.trans</span><span> </span><span>local.mult_isor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ (x ⋅ x ^ i) ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>local.power_commutes</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>power_is_relpow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_d.power X i = X ^^ i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>relpow_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* = (⋃i. rel_d.power X i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_is_relpow</span><span> </span><span>rtrancl_is_UN_relpow</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ; Y^* = (⋃i. X ; rel_d.power Y i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_star_contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X^* ; Y = (⋃i. (rel_d.power X i) ; Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_star_def</span><span> </span><span>relcomp_UNION_distrib2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_ad</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_ad R = {(x,x) | x. ¬ (∃y. (x,y) ∈ R)}"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_aka</span><span class="delimiter">:</span><span> </span><span>antidomain_kleene_algebra</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span>rel_ad</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_star_contr</span><span> </span><span>rel_d.pow_inductl</span><span> </span><span>rel_star_contl</span><span> </span><span>SUP_least</span><span> </span><span>rel_d.pow_inductr</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Embedding Predicates in Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ≡ {(s,s) |s. P s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_aka.dom_op ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_aka.dom_op_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_neg_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_ad ⌈P⌉ = ⌈λs. ¬P s⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ∩ ⌈Q⌉ = ⌈λs. P s ∧ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ; ⌈Q⌉ = ⌈λs. P s ∧ Q s⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_disj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ∪ ⌈Q⌉ = ⌈λs. P s ∨ Q s⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Store and Assignment›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>store</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"string  ⇒ 'a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a store ⇒ 'a) ⇒ 'a store rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v ::= e = {(s,s (v := e s)) |s. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_aka.wp (v ::= e) ⌈Q⌉ = ⌈λs. Q (s (v := e s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_aka.wp_def</span><span> </span><span>gets_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>spec_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE P X POST Q ≡ rel_aka.dom_op ⌈P⌉ ⊆ rel_aka.wp X ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>if_then_else_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y FI ≡ rel_aka.if_then_else ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while_inv_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a pred ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P INV I DO X OD ≡ rel_aka.while_inv ⌈P⌉ ⌈I⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_aka.wp_while_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Hoare Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ d p ≤ wp x q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p 1 p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>dom_op_def</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d p' ⟹ d q' ≤ d q ⟹ H p' x q' ⟹ H p x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>H_def</span><span> </span><span>demod</span><span> </span><span>mult_isol</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x r ⟹ H r y q ⟹ H p (x ⋅ y) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>a_d_closed</span><span> </span><span>demod</span><span> </span><span>dom_op_def</span><span> </span><span>wp_seq_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (d p ⋅ d r) x q ⟹ H (d p ⋅ ad r) y q ⟹ H p (if r then x else y fi) q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (d p ⋅ d r) x q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (d p ⋅ ad r) y q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d r ≤ wp x q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ ad r ≤ wp y q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>a_closed</span><span> </span><span>dom_op_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>h2</span><span> </span><span>a_closed</span><span> </span><span>dom_op_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>h5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p  ≤ ad r + wp x q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p  ≤ d r + wp y q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dom_op_def</span><span> </span><span>shunt</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h4</span><span> </span><span>a_d_closed</span><span> </span><span>dom_op_def</span><span> </span><span>shunt</span><span> </span><span>wp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d p  ⋅ (d r + wp y q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_idem</span><span> </span><span>distrib_left</span><span> </span><span>dom_op_def</span><span> </span><span>less_eq_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"... ≤ (ad r + wp x q) ⋅ (d r + wp y q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h5</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (d p ⋅ d r) x p ⟹ H p (while r do x od) (d p ⋅ ad r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>H_def</span><span> </span><span>a_closed</span><span> </span><span>dom_op_def</span><span> </span><span>wp_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_while_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ⋅ ad r ≤ d q ⟹ H (d i ⋅ d r) x i ⟹ H p (while r inv i do x od) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>a_closed</span><span> </span><span>dom_op_def</span><span> </span><span>wp_while_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Refinement KAD›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>rkad</span><span> </span><span class="delimiter">=</span><span> </span><span>antidomain_kleene_algebra</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ R p q ⟷ d p ≤ wp x q"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Refinement Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ x ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>R_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ wp (R p q) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ R (wp x q) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R_def</span><span> </span><span>wp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_R3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ wp x q ⟹ x ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (R p q) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HR</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟹ x ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HR</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ R p p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_R2</span><span> </span><span>H_skip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d p' ⟹ d q' ≤ d q ⟹ R p' q' ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_R1</span><span> </span><span>H_R2</span><span> </span><span>H_cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(R p r) ⋅ (R r q) ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_R1</span><span> </span><span>H_R2</span><span> </span><span>H_seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"if v then (R (d v ⋅ d p) q) else (R (ad v ⋅ d p) q) fi ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_R1</span><span> </span><span>H_R2</span><span> </span><span>H_cond</span><span> </span><span>a_comm</span><span> </span><span>dom_op_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"while q do (R (d p ⋅ d q) p) od ≤ R p (d p ⋅ ad q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_R1</span><span> </span><span>H_R2</span><span> </span><span>H_loop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Soundness and Relation RKAD›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R P Q = ⋃{X. rel_aka.dom_op P ⊆ rel_aka.wp X Q}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_rkad</span><span class="delimiter">:</span><span> </span><span>rkad</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span>rel_ad</span><span> </span><span>rel_R</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_R_def</span><span> </span><span>rel_aka.dom_op_def</span><span> </span><span>rel_ad_def</span><span> </span><span>rel_aka.wp_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assignment Laws›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_rkad.R_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ rel_aka.H ⌈P⌉ (v ::= e) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_aka.H_def</span><span> </span><span>rel_aka.dom_op_def</span><span> </span><span>rel_ad_def</span><span> </span><span>gets_def</span><span> </span><span>rel_aka.wp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. Q' s ⟶ Q (s (v := e s))) ⟹ (rel_R ⌈P⌉ ⌈Q'⌉) ; (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rel_rkad.HR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>rel_aka.H_seq</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>H_assign_var</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_rkad.H_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ P' (s (v := e s))) ⟹ (v ::= e) ; (rel_R ⌈P'⌉ ⌈Q⌉) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rel_rkad.HR</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>rel_aka.H_seq</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>H_assign_var</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_rkad.H_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''z'' ::= (λs. s ''x'')); rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''x'' ::= (λs. s ''y'')); rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref3</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''y'' ::= (λs. s ''z'')); rel_R ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref_var</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''z'' ::= (λs. s ''x'')); (''x'' ::= (λs. s ''y'')); (''y'' ::= (λs. s ''z''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>var_swap_ref1</span><span> </span><span>var_swap_ref2</span><span> </span><span>var_swap_ref3</span><span> </span><span>rel_rkad.R_skip</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="P2S2R">
<div class="head"><h1>Theory P2S2R</h1>
<span class="command">theory</span> <span class="name">P2S2R</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Isomorphisms Betweeen Predicates, Sets and Relations *}
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isomorphisms Between Predicates, Sets and Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>P2S2R</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>inf</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊓"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>sup</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊔"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Id_on</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"s2r"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Domain</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"r2s"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Collect</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"p2s"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_n</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_n  ≡ (λX. Id ∩ - X)"</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subid_meet</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ R ∩ S = R ; S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Isomorphism Between Sets and Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>srs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r2s ∘ s2r = id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rsr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ s2r (r2s R) = R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Id_def</span><span> </span><span>Id_on_def</span><span> </span><span>Domain_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj s2r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Domain_Id_on</span><span> </span><span>injI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2s R = r2s S ⟹ R = S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rsr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_surj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀R ⊆ Id. ∃A. R = s2r A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rsr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_surj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A. ∃R ⊆ Id. A = r2s R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Domain_Id_on</span><span> </span><span>Id_onE</span><span> </span><span>pair_in_Id_conv</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_union_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r (A ∪ B) = s2r A ∪ s2r B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Id_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_inter_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r (A ∩ B) = s2r A ∩ s2r B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Id_on_def</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_inter_hom_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r (A ∩ B) = s2r A ; s2r B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Id_on_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2r_compl_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r (- A) = rel_n (s2r A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_n_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_union_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r2s (R ∪ S) = r2s R ∪ r2s S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_inter_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2s (R ∩ S) = r2s R ∩ r2s S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_inter_hom_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2s (R ; S) = r2s R ∩ r2s S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>r2s_inter_hom</span><span> </span><span>subid_meet</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s_ad_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ r2s (rel_n R) = - r2s R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>r2s_surj</span><span> </span><span>rsr</span><span> </span><span>s2r_compl_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isomorphism Between Predicates and Sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>s2p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ⇒ 'a pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s2p S = (λx. x ∈ S)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2p ∘ p2s = id"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>psp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2s ∘ s2p = id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2p_bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij s2p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o_bij</span><span> </span><span>psp</span><span> </span><span>sps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2s_bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bij p2s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o_bij</span><span> </span><span>psp</span><span> </span><span>sps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2p_compl_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2p (- A) = - (s2p A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Collect_mem_eq</span><span> </span><span>comp_eq_dest_lhs</span><span> </span><span>id_apply</span><span> </span><span>sps</span><span> </span><span>uminus_set_def</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2p_inter_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2p (A ∩ B) = (s2p A) ⊓ (s2p B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Collect_mem_eq</span><span> </span><span>comp_eq_dest_lhs</span><span> </span><span>id_apply</span><span> </span><span>inf_set_def</span><span> </span><span>sps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>s2p_union_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2p (A ∪ B) = (s2p A) ⊔ (s2p B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>s2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2s_neg_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2s (- P) = - (p2s P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2s_conj_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2s (P ⊓ Q) = p2s P ∩ p2s Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2s_disj_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2s (P ⊔ Q) = p2s P ∪ p2s Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Isomorphism Between Predicates and Relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p2r P = {(s,s) |s. P s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>r2p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"r2p R = (λx. x ∈ Domain R)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_subid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r P ⊆ Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2s2r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r = s2r ∘ p2s"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(a, a) |a. P a} = {(b, a). b = a ∧ P b}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r P = (s2r ∘ p2s) P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Id_on_def'</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2s2p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r2p = s2p ∘ r2s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r2p_def</span><span> </span><span>s2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r2p ∘ p2r = id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2s2r</span><span> </span><span>r2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rpr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ p2r (r2p R) = R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_apply</span><span> </span><span>id_apply</span><span> </span><span>p2s2r</span><span> </span><span>psp</span><span> </span><span>r2s2p</span><span> </span><span>rsr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj p2r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_eq_dest_lhs</span><span> </span><span>id_apply</span><span> </span><span>injI</span><span> </span><span>prp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2p_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2p R = r2p S ⟹ R = S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rpr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_surj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ R ⊆ Id. ∃P. R = p2r P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rpr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2p_surj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀P. ∃R ⊆ Id. P = r2p R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_apply</span><span> </span><span>id_apply</span><span> </span><span>p2r_subid</span><span> </span><span>prp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_neg_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r (- P) = rel_n (p2r P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2s2r</span><span> </span><span>p2s_neg_hom</span><span> </span><span>s2r_compl_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r P ∩ p2r Q = p2r (P ⊓ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2s2r</span><span> </span><span>p2s_conj_hom</span><span> </span><span>s2r_inter_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r P ; p2r Q = p2r (P ⊓ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2s2r</span><span> </span><span>p2s_conj_hom</span><span> </span><span>s2r_inter_hom_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_id_neg</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∩ - p2r p = p2r (-p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r bot = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_disj_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2r P ∪ p2r Q = p2r (P ⊔ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2s2r</span><span> </span><span>p2s_disj_hom</span><span> </span><span>s2r_union_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2p_ad_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ r2p (rel_n R) = - (r2p R)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r2s2p</span><span> </span><span>r2s_ad_hom</span><span> </span><span>s2p_compl_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2p_inter_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2p (R ∩ S) = (r2p R) ⊓ (r2p S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r2s2p</span><span> </span><span>r2s_inter_hom</span><span> </span><span>s2p_inter_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r2p_inter_hom_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2p (R ; S) = (r2p R) ⊓ (r2p S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r2s2p</span><span> </span><span>r2s_inter_hom_var</span><span> </span><span>s2p_inter_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_to_pred_union_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ⊆ Id ⟹ S ⊆ Id ⟹ r2p (R ∪ S) = (r2p R) ⊔ (r2p S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Domain_Un_eq</span><span> </span><span>r2s2p</span><span> </span><span>s2p_union_hom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAT">
<div class="head"><h1>Theory VC_KAT</h1>
<span class="command">theory</span> <span class="name">VC_KAT</span><br/>
<span class="keyword">imports</span> <a href="P2S2R.html"><span class="name">P2S2R</span></a> <a href="../KAT_and_DRA/PHL_KAT.html"><span class="name">PHL_KAT</span></a> <a href="../KAT_and_DRA/KAT_Models.html"><span class="name">KAT_Models</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAT
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Components Based on Kleene Algebra with Tests›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Component›</span></span></span><span>      
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAT</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../P2S2R"</span></span></span><span>
</span><span>        </span><span>KAT_and_DRA.PHL_KAT</span><span> 
</span><span>        </span><span>KAT_and_DRA.KAT_Models</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This first part changes some of the facts from the AFP KAT theories. It should be added to KAT in the next AFP version. 
Currently these facts provide an interface between the KAT theories and the verification component.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>if_then_else</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>while</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Archimedean_Field.ceiling</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>               
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>kat</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions of Hoare Triple›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ t p ⋅ x ≤ x ⋅ t q"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_var1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ t p ⋅ x ⋅ n q = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>n_kat_3</span><span> </span><span>t_n_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_var2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ t p ⋅ x = t p ⋅ x ⋅ t q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>n_kat_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax for Conditionals and Loops›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ifthenelse</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = (t p ⋅ x + n p ⋅ y)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while b do x od = (t b ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ n b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ inv _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p inv i do x od = while p do x od"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Hoare Logic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_skip</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"H p 1 p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cons_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p' ⟹ H p' x q ⟹ H p x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>phl_cons1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cons_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t q' ≤ t q ⟹ H p x q' ⟹ H p x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>phl_cons2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>          
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p' ⟹ t q' ≤ t q ⟹ H p' x q' ⟹ H p x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_cons_1</span><span> </span><span>H_cons_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_seq_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x r ⟹ H r y q ⟹ H p (x ⋅ y) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>phl_seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H r y q ⟹ H p x r ⟹ H p (x ⋅ y) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_seq_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_exp1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x q ⟹ H p (t r ⋅ x) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>n_de_morgan_var2</span><span> </span><span>phl.ht_at_phl_export1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_exp2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟹ H p (x ⋅ t r) (t q ⋅ t r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>phl.ht_at_phl_export2</span><span> </span><span>test_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cond_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (if r then x else y fi) q ⟷ H (t p ⋅ t r) x q ∧ H (t p ⋅ n r) y q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (if r then x else y fi) q ⟷ t p ⋅ (t r ⋅ x + n r ⋅ y) ⋅ n q = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_var1</span><span> </span><span>ifthenelse_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ t p ⋅ t r ⋅ x ⋅ n q + t p ⋅ n r ⋅ y ⋅ n q = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span> </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⟷ t p ⋅ t r ⋅ x ⋅ n q = 0 ∧ t p ⋅ n r ⋅ y ⋅ n q = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_0_left</span><span> </span><span>no_trivial_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_var1</span><span> </span><span>test_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x q ⟹ H (t p ⋅ n r) y q ⟹ H p (if r then x else y fi) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_cond_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x p ⟹ H p (while r do x od) (t p ⋅ n r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t r) x p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t (t p ⋅ n r) = n r ⋅ t p ⋅ n r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_preserve</span><span> </span><span>test_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>H_def</span><span> </span><span>H_exp1</span><span> </span><span>conway.phl.it_simr</span><span> </span><span>phl_export2</span><span> </span><span>while_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_while_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t i ⟹ t i ⋅ n r ≤ t q ⟹ H (t i ⋅ t r) x i ⟹ H p (while r inv i do x od) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_cons</span><span> </span><span>H_loop</span><span> </span><span>test_mult</span><span> </span><span>while_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we prove a frame rule.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x p ⟹ H q x r ⟹ H (t p ⋅ t q) x (t p ⋅ t r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H q x r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ x ≤ x ⋅ t p"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t q ⋅ x ≤ x ⋅ t r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ⋅ t q ⋅ x ≤ t p ⋅ x ⋅ t r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_assoc</span><span> </span><span>mult_isol</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ x ⋅ t p ⋅ t r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_def</span><span> </span><span>mult_assoc</span><span> </span><span>test_mult</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Store and Assignment›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The proper verification component starts here.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>store</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"string  ⇒ 'a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>t_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_dioid_tests.t ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_prop</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ⊆ ⌈Q⌉ ⟷ (∀s. P s ⟶  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Id_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∩ (- Id ∪ X) = Id ∩ X"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Id_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∩ ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Id_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Id_p2r_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Id ∩ (- Id ∪ ⌈P⌉) = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we derive the assignment command and assignment rules.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a store ⇒ 'a) ⇒ 'a store rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v ::= e = {(s,s (v := e s)) |s. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈λs. P (s (v := e s))⌉ ; (v ::= e) = (v ::= e) ; ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>gets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈λs. P (s (v := e s))⌉ (v ::= e) ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_def</span><span> </span><span>gets_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ rel_kat.H ⌈P⌉ (v ::= e) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>gets_def</span><span> </span><span>rel_kat.H_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈P⌉ (v ::= e) ⌈Q⌉ ⟷ (∀s. P s ⟶ Q (s (v := e s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>gets_def</span><span> </span><span>rel_kat.H_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_assign_floyd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" rel_kat.H ⌈P⌉ (v ::= e) ⌈λs. ∃w. s v = e (s(v := w)) ∧ P (s(v := w))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_assign_var</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>fun_upd_same</span><span> </span><span>fun_upd_triv</span><span> </span><span>fun_upd_upd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simplified Hoare Rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_cons_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ P' s ⟹ rel_kat.H ⌈P'⌉ X ⌈Q⌉ ⟹ rel_kat.H ⌈P⌉ X ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_cons_1</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_cons_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. Q' s ⟶ Q s ⟹ rel_kat.H ⌈P⌉ X ⌈Q'⌉ ⟹ rel_kat.H ⌈P⌉ X ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_cons_2</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ P' s ⟹ ∀s. Q' s ⟶ Q s ⟹ rel_kat.H ⌈P'⌉ X ⌈Q'⌉ ⟹ rel_kat.H ⌈P⌉ X ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sH_cons_1</span><span> </span><span>sH_cons_2</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈P ⊓ T⌉ X ⌈Q⌉ ⟹ rel_kat.H ⌈P ⊓ - T⌉ Y ⌈Q⌉  ⟹ rel_kat.H ⌈P⌉ (rel_kat.ifthenelse ⌈T⌉ X Y) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_cond</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_def</span><span> </span><span>p2r_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_cond_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈P⌉ (rel_kat.ifthenelse ⌈T⌉ X Y) ⌈Q⌉ ⟷ (rel_kat.H ⌈P ⊓ T⌉ X ⌈Q⌉ ∧ rel_kat.H ⌈P ⊓ - T⌉ Y ⌈Q⌉)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_cond_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_while_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s. P s ⟶ I s ⟹ ∀s. I s ∧ ¬ R s ⟶ Q s ⟹ rel_kat.H ⌈I ⊓ R⌉ X ⌈I⌉ 
                     ⟹ rel_kat.H ⌈P⌉ (rel_kat.while_inv ⌈R⌉ ⌈I⌉ X) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_while_inv</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>rel_kat.H_def</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sH_H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈P⌉ X ⌈Q⌉ ⟷ (∀s s'. P s ⟶ (s,s') ∈ X ⟶ Q s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we provide additional syntax for specifications and commands.›</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>H_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE P X POST Q ≡ rel_kat.H ⌈P⌉ X ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>if_then_else_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y FI ≡ rel_kat.ifthenelse ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P  DO X OD ≡ rel_kat.while ⌈P⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>while_inv_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a pred ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P INV I DO X OD ≡ rel_kat.while_inv ⌈P⌉ ⌈I⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_cond_iff2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PRE p (IF r THEN x ELSE y FI) POST q ⟷ (PRE (p ⊓ r) x POST q) ∧ (PRE (p ⊓ - r) y POST q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_cond_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAT_Examples">
<div class="head"><h1>Theory VC_KAT_Examples</h1>
<span class="command">theory</span> <span class="name">VC_KAT_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_KAT.html"><span class="name">VC_KAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAT: Examples
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAT_Examples</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sH_while_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>H_assign</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>H_assign_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True)
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. s ''x''));
    (WHILE (λs. s ''y'' ≤ s ''r'') INV (λs. s ''x'' = s ''q'' * s ''y'' + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - s ''y''))
      OD)
   POST (λs. s ''x'' = s ''q'' * s ''y'' + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; s ''y'')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>sH_while_inv</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>H_assign</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>sH_while_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_kat.H_seq</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>H_assign_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_assign_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>append.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>append.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>append_assoc</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAT_Examples2">
<div class="head"><h1>Theory VC_KAT_Examples2</h1>
<span class="command">theory</span> <span class="name">VC_KAT_Examples2</span><br/>
<span class="keyword">imports</span> <a href="VC_KAT.html"><span class="name">VC_KAT</span></a> <a href="Eisbach.html"><span class="name">Eisbach</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAT: Examples with Automated VCG
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples with Automated VCG›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAT_Examples2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAT</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Eisbach.Eisbach"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following simple tactic for verification condition generation has been 
implemented with the Eisbach proof methods language.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>hl_intro</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>sH_while_inv</span><span> </span><span class="delimiter">[</span><span>hl_intro</span><span class="delimiter">]</span><span>
</span><span>  </span><span>rel_kat.H_seq</span><span> </span><span class="delimiter">[</span><span>hl_intro</span><span class="delimiter">]</span><span>
</span><span>  </span><span>H_assign_var</span><span> </span><span class="delimiter">[</span><span>hl_intro</span><span class="delimiter">]</span><span>
</span><span>  </span><span>rel_kat.H_cond</span><span> </span><span class="delimiter">[</span><span>hl_intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>hoare</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hl_intro</span><span class="delimiter">;</span><span> </span><span>hoare</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. s ''x''));
    (WHILE (λs. s ''y'' ≤ s ''r'') INV (λs. s ''x'' = s ''q'' * s ''y'' + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - s ''y''))
      OD)
   POST (λs. s ''x'' = s ''q'' * s ''y'' + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; s ''y'')"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons_eq_appendI</span><span> </span><span>append_eq_append_conv2</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>self_append_conv</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RKAT">
<div class="head"><h1>Theory RKAT</h1>
<span class="command">theory</span> <span class="name">RKAT</span><br/>
<span class="keyword">imports</span> <a href="VC_KAT.html"><span class="name">VC_KAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Refinement KAT
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Component›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RKAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AVC_KAT/VC_KAT"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹RKAT: Definition and Basic Properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A refinement KAT is a KAT expanded by Morgan's specification statement.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>rkat</span><span> </span><span class="delimiter">=</span><span> </span><span>kat</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec_def</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ≤ R p q ⟷ H p x q"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (R p q) q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟹ x ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spec_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Propositional Refinement Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ R p p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p 1 p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_skip</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p' ⟹ t q' ≤ t q ⟹ R p' q' ≤ R p q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t p ≤ t p'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t q' ≤ t q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p' (R p' q') q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (R p' q') q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h1</span><span> </span><span>h2</span><span> </span><span>H_cons_1</span><span> </span><span>H_cons_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(R p r) ⋅ (R r q) ≤ R p q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (R p r) r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H r (R r q) q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p ((R p r) ⋅ (R r q)) q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_seq_swap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"if v then (R (t v ⋅ t p) q) else (R (n v ⋅ t p) q) fi ≤ R p q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t v ⋅ t p) (R (t v ⋅ t p) q) q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H (n v ⋅ t p) (R (n v ⋅ t p) q) q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R1</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (if v then (R (t v ⋅ t p) q) else (R (n v ⋅ t p) q) fi) q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_cond</span><span> </span><span>n_mult_comm</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"while q do (R (t p ⋅ t q) p) od ≤ R p (t p ⋅ n q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H (t p ⋅ t q) (R (t p ⋅ t q) p)  p"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H p (while q do (R (t p ⋅ t q) p) od) (t p ⋅ n q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_loop</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_zero_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ R 0 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H 0 x 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_one_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R 1 0 = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H 1 (R 1 0) 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H_def</span><span> </span><span>join.le_bot</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RKAT_Models">
<div class="head"><h1>Theory RKAT_Models</h1>
<span class="command">theory</span> <span class="name">RKAT_Models</span><br/>
<span class="keyword">imports</span> <a href="RKAT.html"><span class="name">RKAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Models of Refinement KAT
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Models of Refinement KAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RKAT_Models</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>RKAT</span><span>
</span><span>   
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹So far only the relational model is developed.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R P Q = ⋃{X. rel_kat.H P X Q}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_rkat</span><span class="delimiter">:</span><span> </span><span>rkat</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(;)"</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λX. Id ∩ - X)"</span></span></span><span> </span><span>rel_R</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_R_def</span><span> </span><span>rel_kat.H_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="VC_RKAT">
<div class="head"><h1>Theory VC_RKAT</h1>
<span class="command">theory</span> <span class="name">VC_RKAT</span><br/>
<span class="keyword">imports</span> <a href="RKAT_Models.html"><span class="name">RKAT_Models</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Refinement Component Based on KAT
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_RKAT</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"../RKAT_Models"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the step-wise refinement of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assignment Laws›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The store model is taken from KAT›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s))) ⟹ (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ Q (s (v := e s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.H ⌈P⌉ (v ::= e) ⌈Q⌉"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H_assign_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_rkat.R2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. Q' s ⟶ Q (s (v := e s))) ⟹ (rel_R ⌈P⌉ ⌈Q'⌉) ; (v ::= e) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_assign_var</span><span> </span><span>rel_kat.H_seq</span><span> </span><span>rel_rkat.R1</span><span> </span><span>rel_rkat.R2</span><span class="delimiter">)</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_assignl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ P' (s (v := e s))) ⟹ (v ::= e) ; (rel_R ⌈P'⌉ ⌈Q⌉) ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>H_assign_var</span><span> </span><span>rel_kat.H_seq</span><span> </span><span>rel_rkat.R1</span><span> </span><span>rel_rkat.R2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simplified Refinement Laws›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ P' s) ⟹ (∀s. Q' s ⟶ Q s) ⟹ rel_R ⌈P'⌉ ⌈Q'⌉ ⊆ rel_R ⌈P⌉ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_rkat.R1</span><span> </span><span>rel_rkat.R2</span><span> </span><span>sH_cons_1</span><span> </span><span>sH_cons_2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_then_else_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ X' ⟹ Y ⊆ Y' ⟹ IF P THEN X ELSE Y FI ⊆ IF P THEN X' ELSE Y' FI"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_kat.ifthenelse_def</span><span class="delimiter">)</span><span>
</span><span>                                     
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>while_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ X' ⟹ WHILE P DO X OD ⊆ WHILE P DO X' OD"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.while_def</span><span> </span><span>rel_dioid.mult_isol</span><span> </span><span>rel_dioid.mult_isor</span><span> </span><span>rel_kleene_algebra.star_iso</span><span class="delimiter">)</span><span>
</span><span>                                                               
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="VC_RKAT_Examples">
<div class="head"><h1>Theory VC_RKAT_Examples</h1>
<span class="command">theory</span> <span class="name">VC_RKAT_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_RKAT.html"><span class="name">VC_RKAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Refinement Component Based on KAT: Examples
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_RKAT_Examples</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_RKAT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Currently  there is only one example, and no tactic for automating refinement proofs is provided.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉
   ⊇ (''z'' ::= (λs. s ''x'')); rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ 
   ⊇ (''x'' ::= (λs. s ''y'')); rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref3</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''z'' = a ∧ s ''x'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉
   ⊇ (''y'' ::= (λs. s ''z'')); rel_R ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R_assignl</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_swap_ref_var</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_R ⌈λs. s ''x'' = a ∧ s ''y'' = b⌉ ⌈λs. s ''x'' = b ∧ s ''y'' = a⌉
   ⊇ (''z'' ::= (λs. s ''x'')); (''x'' ::= (λs. s ''y'')); (''y'' ::= (λs. s ''z''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>var_swap_ref1</span><span> </span><span>var_swap_ref2</span><span> </span><span>var_swap_ref3</span><span> </span><span>rel_rkat.R_skip</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="VC_KAD">
<div class="head"><h1>Theory VC_KAD</h1>
<span class="command">theory</span> <span class="name">VC_KAD</span><br/>
<span class="keyword">imports</span> <a href="Modal_Kleene_Algebra_Models.html"><span class="name">Modal_Kleene_Algebra_Models</span></a> <a href="P2S2R.html"><span class="name">P2S2R</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Components Based on Kleene Algebra with Domain›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>KAD.Modal_Kleene_Algebra_Models</span><span> </span><span class="string"><span class="delete"><span class="delete">"../P2S2R"</span></span></span><span>      
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Component for Backward Reasoning›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Archimedean_Field.ceiling</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Archimedean_Field.floor</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌊_⌋"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>r2p</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌊_⌋"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Additional Facts for KAD›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_shunt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d q ≤ |x] t ⟷ d p ≤ ad q + |x] t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_6</span><span> </span><span>a_antitone'</span><span> </span><span>a_loc</span><span> </span><span>add_commute</span><span> </span><span>addual.ars_r_def</span><span> </span><span>am_d_def</span><span> </span><span>da_shunt2</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax for Conditionals and Loops›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"if _ then _ else _ fi"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"if p then x else y fi = d p ⋅ x + ad p ⋅ y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>while</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p do x od = (d p ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup> ⋅ ad p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>whilei</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"while _ inv _ do _ od"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"while p inv i do x od = while p do x od"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Weakest (Liberal) Precondition Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In the setting of Kleene algebra with domain, the wlp operator is the forward modal box operator 
of antidomain Kleene algebra.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p + |x] q = |d p ⋅ x] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_add_closure</span><span> </span><span>addual.ars_r_def</span><span> </span><span>fbox_def</span><span> </span><span>fbox_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_export2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x] p ≤ |x ⋅ ad q] (d p ⋅ ad q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d t ⋅ x ≤ x ⋅ d p ⟹ d t ⋅ x ⋅ ad q ≤ x ⋅ ad q ⋅ d p ⋅ ad q"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>a_comm_var</span><span> </span><span>a_mult_idem</span><span> </span><span>ads_d_def</span><span> </span><span>am2</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>phl_export2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d t ≤ |x] p ⟹ d t ≤ |x ⋅ ad q] (d p ⋅ ad q)"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_closure'</span><span> </span><span>addual.ars_r_def</span><span> </span><span>ans_d_def</span><span> </span><span>dka.dsg3</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>fbox_def</span><span> </span><span>fbox_demodalisation3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_closure'</span><span> </span><span>addual.ars_r_def</span><span> </span><span>ans_d_def</span><span> </span><span>fbox_def</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_export3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x ⋅ ad p] q = |x] (d p + d q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_de_morgan_var_3</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>fbox_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_seq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|x ⋅ y] q = |x] |y] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_mult</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_seq_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p' ≤ |y] q ⟹ p ≤ |x] p' ⟹ p ≤ |x ⋅ y] q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ≤ |x] p'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p' ≤ |y] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x] p' ≤ |x] |y] q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dka.dom_iso</span><span> </span><span>fbox_iso</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>h1</span><span> </span><span>dual_order.trans</span><span> </span><span>fbox_seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = (ad p + |x] q) ⋅ (d p + |y] q)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cond_def</span><span> </span><span>a_closure'</span><span> </span><span>ads_d_def</span><span> </span><span>ans_d_def</span><span> </span><span>fbox_add2</span><span> </span><span>fbox_export1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_aux1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ |if p then x else y fi] q = d p ⋅ |x] q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ |if p then x else y fi] q = d p ⋅ |x] q ⋅ (d p + d ( |y] q))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_add_closure</span><span> </span><span>addual.ars_r_def</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>fbox_def</span><span> </span><span>fbox_cond_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>addual.ars_r_def</span><span> </span><span>am2</span><span> </span><span>dka.dns5</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_aux2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p ⋅ |if p then x else y fi] q = ad p ⋅ |y] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cond_def</span><span> </span><span>a_closure'</span><span> </span><span>add_commute</span><span> </span><span>addual.ars_r_def</span><span> </span><span>ans_d_def</span><span> </span><span>fbox_cond_aux1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = (d p ⋅ |x] q) + (ad p ⋅ |y] q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = (d p + ad p) ⋅ |if p then x else y fi] q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>addual.ars_r_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span>  </span><span>distrib_right'</span><span> </span><span>fbox_cond_aux1</span><span> </span><span>fbox_cond_aux2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_cond_var2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|if p then x else y fi] q = if p then |x] q else |y] q fi"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cond_def</span><span> </span><span>fbox_cond</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_while_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|while t do x od] p = (d t + d p) ⋅ (ad t + |x] |while t do x od] p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fbox_export1</span><span> </span><span>fbox_export3</span><span> </span><span>dka.dom_add_closed</span><span> </span><span>fbox_star_unfold_var</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_while_var1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d t ⋅ |while t do x od] p = d t ⋅ |x] |while t do x od] p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fbox_while_unfold</span><span> </span><span>a_mult_add</span><span> </span><span>ads_d_def</span><span> </span><span>dka.dns5</span><span> </span><span>ds.ddual.mult_assoc</span><span> </span><span>join.sup_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_while_var2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad t ⋅ |while t do x od] p ≤ d p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad t ⋅ |while t do x od] p = ad t ⋅ (d t + d p) ⋅ (ad t + |x] |while t do x od] p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fbox_while_unfold</span><span> </span><span>ds.ddual.mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... =  ad t ⋅ d p ⋅ (ad t + |x] |while t do x od] p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_de_morgan_var_3</span><span> </span><span>addual.ars_r_def</span><span> </span><span>dka.dom_add_closed</span><span> </span><span>s4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ d p ⋅ (ad t + |x] |while t do x od] p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_subid_aux1'</span><span> </span><span>mult_isor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_de_morgan_var_3</span><span> </span><span>a_mult_idem</span><span> </span><span>addual.ars_r_def</span><span> </span><span>ans4</span><span> </span><span>dka.dsr5</span><span> </span><span>dpdz.domain_1''</span><span> </span><span>dual_order.trans</span><span> </span><span>fbox_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d t ≤ |x] p ⟹ d p ≤ |while t do x od] (d p ⋅ ad t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ d t ≤ |x] p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ |d t ⋅ x] p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_export1</span><span> </span><span>fbox_shunt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ |(d t ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>] p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_star_induct_var</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order_trans</span><span> </span><span>while_def</span><span> </span><span>fbox_export2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_while_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p = |d t ⋅ x] p ⟹ d p ≤ |while t do x od] (d p ⋅ ad t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eq_refl</span><span> </span><span>fbox_export1</span><span> </span><span>fbox_shunt</span><span> </span><span>fbox_while</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_whilei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i ⟹ d i ⋅ ad t ≤ d q ⟹ d i ⋅ d t ≤ |x] i ⟹ d p ≤ |while t inv i do x od] q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ⋅ ad t ≤ d q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ⋅ d t ≤ |x] i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d i ≤ |while t inv i do x od] (d i ⋅ ad t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_while</span><span> </span><span>whilei_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ |while t inv i do x od] q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>dka.dom_iso</span><span> </span><span>fbox_iso</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next rule is used for dealing with while loops after a series of sequential steps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_whilei_break</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ |y] i ⟹ d i ⋅ ad t ≤ d q ⟹ d i ⋅ d t ≤ |x] i ⟹ d p ≤ |y ⋅ (while t inv i do x od)] q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fbox_seq_var</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fbox_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we derive a frame rule.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_frame</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ x ≤ x ⋅ d p ⟹ d q ≤ |x] t ⟹ d p ⋅ d q ≤ |x] (d p ⋅ d t)"</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual.mult_isol_var</span><span> </span><span>fbox_add1</span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_frame_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ |x] p ⟹ d q ≤ |x] t ⟹ d p ⋅ d q ≤ |x] (d p ⋅ d t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_frame</span><span> </span><span>fbox_demodalisation3</span><span> </span><span>fbox_simp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Store and Assignment›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>store</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"string  ⇒ 'a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>rel_antidomain_kleene_algebra.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"wp"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel_antidomain_kleene_algebra.fdia</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"relfdia"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a store ⇒ 'a) ⇒ 'a store rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"v ::= e = {(s,s (v := e s)) |s. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assign_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈λs. P (s (v := e s))⌉ ; (v ::= e) = (v ::= e) ; ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>gets_def</span><span class="delimiter">)</span><span>
</span><span>                                                                                 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (v ::= e) ⌈Q⌉ = ⌈λs. Q (s (v := e s))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_def</span><span> </span><span>gets_def</span><span> </span><span>rel_ad_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌊wp (v ::= e) ⌈Q⌉⌋ = (λs. Q (s (v := e s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>r2p_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_assign_det</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp (v ::= e) ⌈Q⌉ = relfdia (v ::= e) ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>gets_def</span><span> </span><span>p2r_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Simplifications›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>rel_antidomain_kleene_algebra.ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"rdom"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>spec_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE P X POST Q ≡ rdom ⌈P⌉ ⊆ wp X ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cond_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y FI ≡ rel_antidomain_kleene_algebra.cond ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>whilei_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a pred ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P INV I DO X OD ≡ rel_antidomain_kleene_algebra.whilei ⌈P⌉ ⌈I⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_conj_hom_var_symm</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ; ⌈Q⌉ = ⌈P ⊓ Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_conj_hom_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_neg_hom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_ad ⌈P⌉ = ⌈- P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_ad_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_trafo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌊wp X ⌈Q⌉⌋ = (λs. ∀s'. (s,s') ∈ X ⟶ Q s')"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_def</span><span> </span><span>rel_ad_def</span><span> </span><span>p2r_def</span><span> </span><span>r2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_trafo_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌊wp X ⌈Q⌉⌋ s = (∀s'. (s,s') ∈ X ⟶ Q s')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wp_trafo</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom ⌈⌊wp X Q⌋⌉ = wp X Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>d_p2r</span><span> </span><span>rel_antidomain_kleene_algebra.a_subid'</span><span> </span><span>rel_antidomain_kleene_algebra.addual.bbox_def</span><span> </span><span>rpr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_simp_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wp ⌈P⌉ ⌈Q⌉ = ⌈- P ⊔ Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_prop</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ ⊆ ⌈Q⌉ ⟷ (∀s. P s ⟶  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_eq_prop</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⌈P⌉ = ⌈Q⌉ ⟷ (∀s. P s ⟷  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_prop_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom ⌈P⌉ ⊆ rdom ⌈Q⌉ ⟷ (∀s. P s ⟶  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>     
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2r_eq_prop_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom ⌈P⌉ = rdom ⌈Q⌉ ⟷ (∀s. P s ⟷  Q s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>                                                     
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_whilei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀s. P s ⟶ I s) ⟹ (∀s. (I ⊓ -T) s ⟶ Q s) ⟹ (∀s. (I ⊓ T) s ⟶ ⌊wp X ⌈I⌉⌋ s) 
                  ⟹ (∀s. P s ⟶ ⌊wp (WHILE T INV I DO X OD) ⌈Q⌉⌋ s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>impl_prop_var</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>wp_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_Examples">
<div class="head"><h1>Theory VC_KAD_Examples</h1>
<span class="command">theory</span> <span class="name">VC_KAD_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD: Examples
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_Examples</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gcd_non_0_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid_diff</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y ∧ x &gt; 0 ∧ y &gt; 0)
    (WHILE (λs. s ''x''≠ s ''y'') INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
     DO
        (IF (λs. s ''x'' &gt;  s ''y'')
         THEN (''x'' ::= (λs. s ''x'' - s ''y''))
         ELSE (''y'' ::= (λs. s ''y'' - s ''x''))
         FI)
    OD)
    POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gcd.commute</span><span> </span><span>gcd_diff1_nat</span><span> </span><span>le_cases</span><span> </span><span>nat_less_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>varible_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs. s ''x'' = a ∧ s ''y'' = b)   
    (''z'' ::= (λs. s ''x''));
    (''x'' ::= (λs. s ''y''));
    (''y'' ::= (λs. s ''z''))
   POST (λs. s ''x'' = b ∧ s ''y'' = a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True) 
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. x ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. x));
    (WHILE (λs. y ≤ s ''r'') INV (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - y))
      OD)
   POST (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factorial</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. True)
   (''x'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''x'' ≠ x0) INV (λs. s ''y'' = fact (s ''x''))
   DO
     (''x'' ::= (λs. s ''x'' + 1));
     (''y'' ::= (λs. s ''y'' ⋅ s ''x''))
   OD)
   POST (λs. s ''y'' = fact x0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>my_power</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. True)
   (''i'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''i'' &lt; n) INV (λs. s ''y'' = x ^ (s ''i'') ∧ s ''i'' ≤ n)
     DO
       (''y'' ::= (λs. (s ''y'') * x));
       (''i'' ::= (λs. s ''i'' + 1))
     OD)
   POST (λs. s ''y'' = x ^ n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei_break</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>append.simps</span><span> </span><span>append_assoc</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_Examples2">
<div class="head"><h1>Theory VC_KAD_Examples2</h1>
<span class="command">theory</span> <span class="name">VC_KAD_Examples2</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a> <a href="Eisbach.html"><span class="name">Eisbach</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD: Examples with Automated VCG
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples with Automated VCG›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_Examples2</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Eisbach.Eisbach"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We have provide a simple tactic in the Eisbach proof method language. Additional simplification
steps are sometimes needed to bring the resulting verification conditions into shape for first-order automated
theorem proving.›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>ht</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>rel_antidomain_kleene_algebra.fbox_whilei</span><span> </span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>  </span><span>rel_antidomain_kleene_algebra.fbox_seq_var</span><span> </span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>  </span><span>subset_refl</span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>hoare</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ht</span><span class="delimiter">;</span><span> </span><span>hoare</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid_diff2</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y ∧ x &gt; 0 ∧ y &gt; 0)
    (WHILE (λs. s ''x''≠ s ''y'') INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
     DO
        (IF (λs. s ''x'' &gt;  s ''y'')
         THEN (''x'' ::= (λs. s ''x'' - s ''y''))
         ELSE (''y'' ::= (λs. s ''y'' - s ''x''))
         FI)
    OD)
    POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>hoare</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gcd.commute</span><span> </span><span>gcd_diff1_nat</span><span> </span><span>le_cases</span><span> </span><span>nat_less_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. x ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. x));
    (WHILE (λs. y ≤ s ''r'') INV (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - y))
      OD)
   POST (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; y)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factorial2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. True)
   (''x'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''x'' ≠ x0) INV (λs. s ''y'' = fact (s ''x''))
   DO
     (''x'' ::= (λs. s ''x'' + 1));
     (''y'' ::= (λs. s ''y'' ⋅ s ''x''))
   OD)
   POST (λs. s ''y'' = fact x0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>my_power2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. True)
   (''i'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''i'' &lt; n) INV (λs. s ''y'' = x ^ (s ''i'') ∧ s ''i'' ≤ n)
     DO
       (''y'' ::= (λs. (s ''y'') * x));
       (''i'' ::= (λs. s ''i'' + 1))
     OD)
   POST (λs. s ''y'' = x ^ n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>hoare</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>append.simps</span><span> </span><span>append_assoc</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_dual">
<div class="head"><h1>Theory VC_KAD_dual</h1>
<span class="command">theory</span> <span class="name">VC_KAD_dual</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD for Forward Reasoning
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Component for Forward Reasoning›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_dual</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>modal_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic Strongest Postcondition Calculus›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In modal Kleene algebra, strongest postconditions are backward diamond operators. These
are linked with forward boxes aka weakest preconditions by a Galois connection.  This duality has been
implemented in the AFP entry for Kleene algebra with domain and is picked up automatically in
the following proofs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_ad</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r (ad p) = ad p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_closure</span><span> </span><span>addual.ars_r_def</span><span> </span><span>am_d_def</span><span> </span><span>domrangefix</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_export1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x| (r p ⋅ r t) = ⟨r t ⋅ x| p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ardual.ads_d_def</span><span> </span><span>ardual.ds.ddual.rsr2</span><span> </span><span>ardual.ds.fdia_mult</span><span> </span><span>bdia_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_export2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r p ⋅ ⟨x| q = ⟨x ⋅ r p| q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ardual.ads_d_def</span><span> </span><span>ardual.am2</span><span> </span><span>ardual.fdia_export_2</span><span> </span><span>bdia_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_seq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x ⋅ y| q = ⟨y| ⟨x| q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ardual.ds.fdia_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_seq_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x| p ≤ p' ⟹ ⟨y| p' ≤ q ⟹ ⟨x ⋅ y| p ≤ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ardual.ds.fd_subdist_1</span><span> </span><span>ardual.ds.fdia_mult</span><span> </span><span>dual_order.trans</span><span> </span><span>join.sup_absorb2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_cond_var</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨if p then x else y fi| q = ⟨x| (d p ⋅ r q) + ⟨y| (ad p ⋅ r q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bdia_export1</span><span> </span><span>a4'</span><span> </span><span>a_de_morgan</span><span> </span><span>a_de_morgan_var_3</span><span> </span><span>a_subid_aux1'</span><span> </span><span>ardual.ds.fdia_add2</span><span> </span><span>dka.dnso1</span><span> </span><span>dka.dsg4</span><span> </span><span>domrange</span><span> </span><span>dpdz.dnso1</span><span> </span><span>cond_def</span><span> </span><span>join.sup.absorb_iff1</span><span> </span><span>rangedom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_while</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x| (d t ⋅ r p) ≤ r p  ⟹ ⟨while t do x od| p ≤ r p ⋅ ad t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x| (d t ⋅ r p) ≤ r p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨d t ⋅ x| p ≤ r p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bdia_export1</span><span> </span><span>dka.dsg4</span><span> </span><span>domrange</span><span> </span><span>rangedom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨(d t ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>| p ≤ r p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>ardual.fdemodalisation22</span><span> </span><span>ardual.kat_2_equiv_opp</span><span> </span><span>star_sim1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r (ad t) ⋅ ⟨(d t ⋅ x)<span class="hidden">⇧</span><sup>⋆</sup>| p ≤ r p ⋅ ad t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ardual.dpdz.dsg4</span><span> </span><span>ars_r_def</span><span> </span><span>mult_isol</span><span> </span><span>r_ad</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bdia_export2</span><span> </span><span>while_def</span><span> </span><span>r_ad</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_whilei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r p ≤ r i ⟹ r i ⋅ ad t ≤ r q ⟹ ⟨x| (d t ⋅ r i) ≤ r i ⟹ ⟨while t inv i do x od| p ≤ r q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r p ≤ r i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r i ⋅ ad t ≤ r q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x| (d t ⋅ r i) ≤ r i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨while t inv i do x od| i ≤ r i ⋅ ad t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bdia_while</span><span> </span><span>whilei_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨while t inv i do x od| i ≤ r q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r i ≤ |while t inv i do x od] r q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ars_r_def</span><span> </span><span>box_diamond_galois_1</span><span> </span><span>domrange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r p ≤ |while t inv i do x od] r q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ars_r_def</span><span> </span><span>box_diamond_galois_1</span><span> </span><span>domrange</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_whilei_break</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨y| p ≤ r i ⟹ r i ⋅ ad t ≤ r q ⟹ ⟨x| (d t ⋅ r i) ≤ r i ⟹ ⟨y ⋅ (while t inv i do x od)| p ≤ r q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bdia_whilei</span><span> </span><span>ardual.ads_d_def</span><span> </span><span>ardual.ds.fdia_mult</span><span> </span><span>bdia_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> 
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Floyd's Assignment Rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bdia_assign</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antirange_kleene_algebra.bdia (v ::= e) ⌈P⌉ = ⌈λs. ∃w. s v = e (s(v := w)) ∧ P (s(v:=w))⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_antirange_kleene_algebra.bdia_def</span><span> </span><span>gets_def</span><span> </span><span>p2r_def</span><span> </span><span>rel_ar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fun_upd_apply</span><span> </span><span>fun_upd_triv</span><span> </span><span>fun_upd_upd</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>d_p2r</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antirange_kleene_algebra.ars_r  ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span> </span><span>rel_antirange_kleene_algebra.ars_r_def</span><span> </span><span>rel_ar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fspec_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a rel ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"FPRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE P X POST Q ≡ rel_antirange_kleene_algebra.bdia X ⌈P⌉ ⊆ rel_antirange_kleene_algebra.ars_r ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_dual_Examples">
<div class="head"><h1>Theory VC_KAD_dual_Examples</h1>
<span class="command">theory</span> <span class="name">VC_KAD_dual_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD_dual.html"><span class="name">VC_KAD_dual</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD for Forward Reasoning: Examples
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_dual_Examples</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD_dual</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The proofs are essentially the same as with forward boxes.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gcd_non_0_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid_diff</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y ∧ x &gt; 0 ∧ y &gt; 0)
    (WHILE (λs. s ''x''≠ s ''y'') INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
     DO
        (IF (λs. s ''x'' &gt;  s ''y'')
         THEN (''x'' ::= (λs. s ''x'' - s ''y''))
         ELSE (''y'' ::= (λs. s ''y'' - s ''x''))
         FI)
    OD)
    POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gcd.commute</span><span> </span><span>gcd_diff1_nat</span><span> </span><span>le_cases</span><span> </span><span>nat_less_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>varible_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs. s ''x'' = a ∧ s ''y'' = b)   
    (''z'' ::= (λs. s ''x''));
    (''x'' ::= (λs. s ''y''));
    (''y'' ::= (λs. s ''z''))
   POST (λs. s ''x'' = b ∧ s ''y'' = a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs:: nat store. True) 
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs::nat store. x ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. x));
    (WHILE (λs. y ≤ s ''r'') INV (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - y))
      OD)
   POST (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factorial</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs::nat store. True)
   (''x'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''x'' ≠ x0) INV (λs. s ''y'' = fact (s ''x''))
   DO
     (''x'' ::= (λs. s ''x'' + 1));
     (''y'' ::= (λs. s ''y'' ⋅ s ''x''))
   OD)
   POST (λs. s ''y'' = fact x0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>my_power</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs::nat store. True)
   (''i'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''i'' &lt; n) INV (λs. s ''y'' = x ^ (s ''i'') ∧ s ''i'' ≤ n)
     DO
       (''y'' ::= (λs. (s ''y'') * x));
       (''i'' ::= (λs. s ''i'' + 1))
     OD)
   POST (λs. s ''y'' = x ^ n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FPRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rel_modal_kleene_algebra.bdia_whilei_break</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>append.simps</span><span> </span><span>append_assoc</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_wf">
<div class="head"><h1>Theory VC_KAD_wf</h1>
<span class="command">theory</span> <span class="name">VC_KAD_wf</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a> <a href="Modal_Kleene_Algebra_Applications.html"><span class="name">Modal_Kleene_Algebra_Applications</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on Divergence Kleene Algebra for Total Correctness
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Component for Total Correctness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_wf</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD</span><span> </span><span>KAD.Modal_Kleene_Algebra_Applications</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
in a total correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relation Divergence Kleene Algebras›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Divergence Kleene algebras have been formalised in the AFP entry for Kleene algebra with domain.
The nabla or divergence operation models those states of a relation from which infinitely ascending chains
may start.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_nabla</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_nabla X = ⋃ {P. P ⊆ relfdia X P}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_nabla_bin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel ⇒ 'a rel ⇒ 'a rel"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_nabla_bin X Q = ⋃ {P. P ⊆ relfdia X P ∪ rdom Q}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_d_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rdom (rel_nabla x) = rel_nabla x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_nabla_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_bin_d_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rdom (rel_nabla_bin x q) = rel_nabla_bin x q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_nabla_bin_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla X ⊆ relfdia X (rel_nabla X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_def</span><span> </span><span>rel_ad_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_bin_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla_bin X Q ⊆ relfdia X (rel_nabla_bin X Q) ∪ rdom Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_bin_def</span><span> </span><span>rel_ad_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_coinduct_var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⊆ relfdia X P ⟹ P ⊆ rel_nabla X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_bin_coinduct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⊆ relfdia X P ∪ rdom Q ⟹ P ⊆ rel_nabla_bin X Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_bin_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The two fusion lemmas are, in fact, hard-coded fixpoint fusion proofs. They might be replaced
by more generic fusion proofs eventually.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nabla_fusion1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla X ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q ⊆ rel_nabla_bin X Q"</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla X ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q ⊆ relfdia X (rel_nabla X) ∪ relfdia X (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ rdom Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_mono</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>order_refl</span><span> </span><span>rel_antidomain_kleene_algebra.dka.fdia_star_unfold_var</span><span> </span><span>rel_nabla_unfold</span><span> </span><span>sup.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = relfdia X (rel_nabla X ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ rdom Q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.dka.fdia_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel_nabla_bin_coinduct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_ad_inter_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_ad X ∩ rel_ad Y = rel_ad X ; rel_ad Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fusion2_aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom (rel_nabla_bin X Q) ⊆ rdom (rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>pair_in_Id_conv</span><span> </span><span>r_into_rtrancl</span><span> </span><span>rel_antidomain_kleene_algebra.a_one</span><span> </span><span>rel_antidomain_kleene_algebra.a_star</span><span> </span><span>rel_antidomain_kleene_algebra.addual.ars_r_def</span><span> </span><span>rel_antidomain_kleene_algebra.dka.dns1''</span><span> </span><span>rel_antidomain_kleene_algebra.dpdz.dom_one</span><span> </span><span>rel_antidomain_kleene_algebra.ds.ddual.rsr5</span><span> </span><span>rel_antidomain_kleene_algebra.dual.conway.dagger_unfoldr_eq</span><span> </span><span>rel_antidomain_kleene_algebra.dual.tc_eq</span><span> </span><span>rel_nabla_bin_d_closed</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nabla_fusion2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla_bin X Q ⊆ rel_nabla X ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)  ⊆ (relfdia X (rel_nabla_bin X Q) ∪ rdom Q) ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Int_mono</span><span> </span><span>equalityD1</span><span> </span><span>rel_nabla_bin_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ⊆ (relfdia X (rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ rdom Q) ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)"</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fusion2_aux2</span><span> </span><span>rel_antidomain_kleene_algebra.dka.fd_iso1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (relfdia X (rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)) ∪ relfdia X (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∪ rdom Q) ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.dka.fdia_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (relfdia X (rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)) ∪ relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel_antidomain_kleene_algebra.dka.fdia_star_unfold_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla_bin X Q ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ⊆ relfdia X ((rel_nabla_bin X Q) ∩ rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>inf_commute</span><span> </span><span>order_trans_rules</span><span class="delimiter">(</span><span>23</span><span class="delimiter">)</span><span> </span><span>rel_ad_inter_seq</span><span> </span><span>rel_antidomain_kleene_algebra.a_mult_add</span><span> </span><span>rel_antidomain_kleene_algebra.a_subid_aux1'</span><span> </span><span>rel_antidomain_kleene_algebra.addual.bdia_def</span><span> </span><span>rel_antidomain_kleene_algebra.ds.ddual.rsr5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom (rel_nabla_bin X Q) ; rel_ad (relfdia (X<span class="hidden">⇧</span><sup>*</sup>) Q) ⊆ rdom (rel_nabla X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_ad_inter_seq</span><span> </span><span>rel_antidomain_kleene_algebra.addual.ars_r_def</span><span> </span><span>rel_nabla_bin_d_closed</span><span> </span><span>rel_nabla_coinduct_var</span><span> </span><span>rel_nabla_d_closed</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rel_antidomain_kleene_algebra.addual.ars_r_def</span><span> </span><span>rel_antidomain_kleene_algebra.addual.bdia_def</span><span> </span><span>rel_antidomain_kleene_algebra.d_a_galois1</span><span> </span><span>rel_antidomain_kleene_algebra.dpdz.domain_invol</span><span> </span><span>rel_nabla_bin_d_closed</span><span> </span><span>rel_nabla_d_closed</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_coinduct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⊆ relfdia X P ∪ rdom Q ⟹ P ⊆ rel_nabla X ∪ relfdia (rtrancl X) Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>nabla_fusion2</span><span> </span><span>order_trans</span><span> </span><span>rel_nabla_bin_coinduct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_fdivka</span><span class="delimiter">:</span><span> </span><span>fdivergence_kleene_algebra</span><span> </span><span>rel_ad</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(;) "</span></span></span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>rtrancl</span><span> </span><span>rel_nabla</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rel"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom (rel_nabla x) = rel_nabla x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla x ⊆ relfdia x (rel_nabla x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom y ⊆ relfdia x y ∪ rdom z ⟹ rdom y ⊆ rel_nabla x ∪ relfdia (x<span class="hidden">⇧</span><sup>*</sup>) z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_nabla_coinduct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Meta-Equational Loop  Rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>fdivergence_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The rule below is inspired by Arden' rule from language theory. It can be used in total correctness proofs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_arden</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ d p ≤ d q + |x⟩ p ⟹ d p ≤ |x<span class="hidden">⇧</span><sup>⋆</sup>⟩ q"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = zero_class.zero"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ d q + |x⟩ p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad (ad p) ≤ zero_class.zero + ad (ad (x<span class="hidden">⇧</span><sup>⋆</sup> ⋅ q))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>add_commute</span><span> </span><span>ads_d_def</span><span> </span><span>dka.fd_def</span><span> </span><span>nabla_coinduction</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ads_d_def</span><span> </span><span>dka.fd_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_arden_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ d p = d q + |x⟩ p ⟹ d p = |x<span class="hidden">⇧</span><sup>⋆</sup>⟩ q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fdia_arden</span><span> </span><span>dka.fdia_star_induct_eq</span><span> </span><span>eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_arden_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ (d p = d q + |x⟩ p ⟷ d p = |x<span class="hidden">⇧</span><sup>⋆</sup>⟩ q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fdia_arden_eq</span><span> </span><span>dka.fdia_d_simp</span><span> </span><span>dka.fdia_star_unfold_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|x<span class="hidden">⇧</span><sup>⋆</sup>] p ≤ |x] p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_antitone_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ d q ⋅ |x] p ≤ d p ⟹ |x<span class="hidden">⇧</span><sup>⋆</sup>] q ≤ d p"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d q ⋅ |x] p ≤ d p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p ≤ ad (d q ⋅ |x] p)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_antitone'</span><span> </span><span>a_subid</span><span> </span><span>addual.ars_r_def</span><span> </span><span>dpdz.domain_subid</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p ≤ ad q + |x⟩ ad p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_6</span><span> </span><span>addual.bbox_def</span><span> </span><span>ds.fd_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad p ≤ |x<span class="hidden">⇧</span><sup>⋆</sup>⟩ ad q"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fdia_arden</span><span> </span><span>h1</span><span> </span><span>a_4</span><span> </span><span>ads_d_def</span><span> </span><span>dpdz.dsg1</span><span>  </span><span>fdia_def</span><span> </span><span>meet_ord_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_antitone'</span><span> </span><span>ads_d_def</span><span> </span><span>fbox_simp</span><span> </span><span>fdia_fbox_de_morgan_2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ d q ⋅ |x] p = d p ⟹ |x<span class="hidden">⇧</span><sup>⋆</sup>] q = d p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fbox_arden</span><span> </span><span>antisym</span><span> </span><span>fbox_star_induct_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇x = 0 ⟹ (d p = d q ⋅ |x] p ⟷ d p = |x<span class="hidden">⇧</span><sup>⋆</sup>] q)"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fbox_arden_eq</span><span> </span><span>fbox_simp</span><span> </span><span>fbox_star_unfold_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden_while_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ (d t ⋅ x) = 0 ⟹ (d p = (d t + d q) ⋅ |d t ⋅ x] p ⟷ d p = |while t do x od] q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fbox_arden_iff</span><span> </span><span>dka.dom_add_closed</span><span> </span><span>fbox_export3</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden_whilei</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ (d t ⋅ x) = 0 ⟹ (d i = (d t + d q) ⋅ |d t ⋅ x] i ⟹ d i = |while t inv i do x od] q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_arden_while_iff</span><span> </span><span>whilei_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_arden_whilei_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ (d t ⋅ x) = 0 ⟹ (d i = (d t + d q) ⋅ |d t ⋅ x] i ⟷ d i = |while t inv i do x od] q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fbox_arden_while_iff</span><span> </span><span>whilei_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Noethericity and Absence of Divergence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Noetherian elements have been defined in the AFP entry for Kleene algebra with domain. First we show 
that noethericity and absence of divergence coincide. Then we turn to the relational model and 
show that noetherian relations model terminating programs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noether_nabla</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Noetherian x ⟹ ∇ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nabla_closure</span><span> </span><span>nabla_unfold</span><span> </span><span>noetherian_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nabla_noether_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Noetherian x ⟷ ∇ x = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nabla_noether</span><span> </span><span>noether_nabla</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nabla_preloeb_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∇ x = 0 ⟷ PreLoebian x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Noetherian_iff_PreLoebian</span><span> </span><span>nabla_noether</span><span> </span><span>noether_nabla</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_nabla_prop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_nabla R = {} ⟷ (∀P. P ⊆ relfdia R P ⟶ P = {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot.extremum_uniqueI</span><span> </span><span>rel_nabla_coinduct_var</span><span> </span><span>rel_nabla_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_rel_im1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r ((converse R) `` P) = relfdia R (s2r P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Id_on_def</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span> </span><span>rel_antidomain_kleene_algebra.fdia_def</span><span> </span><span>Image_def</span><span> </span><span>converse_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_rel_im2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s2r ((converse R) `` (r2s (rdom P))) = relfdia R P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fdia_rel_im1</span><span> </span><span>rsr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_nabla_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ⊆ (converse R) `` P ⟶ P = {}) ⟷ (s2r P ⊆ relfdia R (s2r P) ⟶ s2r P = {})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>Domain_Id_on</span><span> </span><span>Domain_mono</span><span> </span><span>Id_on_empty</span><span> </span><span>fdia_rel_im1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fdia_rel_im1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A relation is noeterian if its converse is wellfounded. Hence a relation is noetherian if and only if its 
divergence is empty. In the relational program semantics, noetherian programs terminate.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_nabla</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (converse R) ⟷ rel_nabla R = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fdia_rel_im2</span><span> </span><span>rel_fdivka.nabla_unfold_eq</span><span> </span><span>rel_nabla_prop</span><span> </span><span>rel_nabla_unfold</span><span> </span><span>wfE_pf</span><span> </span><span>wfI_pf</span><span> </span><span>wf_nabla_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="VC_KAD_wf_Examples">
<div class="head"><h1>Theory VC_KAD_wf_Examples</h1>
<span class="command">theory</span> <span class="name">VC_KAD_wf_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD_wf.html"><span class="name">VC_KAD_wf</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on Divergence Kleene Algebra for Total Correctness: Examples
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Verification Examples›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>VC_KAD_wf_Examples</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD_wf</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The example should be taken with a grain of salt. More work is needed to make 
the while rule cooperate with simplification.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rel_nabla (
    ⌈λs::nat store. 0 &lt; s ''y''⌉ ; 
      ((''z'' ::= (λs. s ''y'')) ; 
      (''y'' ::= (λs. s ''x'' mod s ''y'')) ;
      (''x'' ::= (λs. s ''z'')))) 
    = {}
    ⟹
  PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rel_fdivka.fbox_arden_whilei</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span>gr0I</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The termination assumption is now explicit in the verification proof. Here it is left 
untouched. Means beyond these components are required for discharging it.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Path_Model_Example">
<div class="head"><h1>Theory Path_Model_Example</h1>
<span class="command">theory</span> <span class="name">Path_Model_Example</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a> <a href="Eisbach.html"><span class="name">Eisbach</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD: Trace Semantics
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two Extensions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹KAD Component with Trace Semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Path_Model_Example</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Eisbach.Eisbach"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
in a partial correctness setting based on a program trace semantics.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Program traces are modelled as non-empty paths or state sequences. The non-empty path model 
of Kleene algebra is taken from the AFP entry for Kleene algebra. Here we show that sets of paths form
antidomain Kleene Algebras.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pp_a</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'a ppath set ⇒ 'a ppath set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pp_a X = {(Node u) |u. ¬ (∃v ∈ X. u = pp_first v)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>ppath_aka</span><span class="delimiter">:</span><span> </span><span>antidomain_kleene_algebra</span><span> </span><span>pp_a</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span>pp_prod</span><span> </span><span>pp_one</span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span>pp_star</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pp_prod_def</span><span> </span><span>pp_a_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pp_prod_def</span><span> </span><span>pp_a_def</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>pp_first.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pp_first_pp_fusion</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pp_a_def</span><span> </span><span>pp_one_def</span><span class="delimiter">)</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A verification component can then be built with little effort, by and large reusing
parts of the relational components that are generic with respect to the store.›</span></span></span><span>      
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pp_gets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"string ⇒ ('a store ⇒ 'a) ⇒ 'a store ppath set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"v ::= e = {Cons s (Node (s (v := e s))) | s. True}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p2pp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a ppath set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"p2pp P = {Node s |s. P s}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pp_a_neg</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pp_a (p2pp Q) = p2pp (-Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pp_a_def</span><span> </span><span>p2pp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ppath_assign</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ppath_aka.fbox (v ::= e) (p2pp Q) = p2pp (λs. Q (s(v := e s)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ppath_aka.fbox_def</span><span> </span><span>pp_a_def</span><span> </span><span>p2pp_def</span><span> </span><span>pp_prod_def</span><span> </span><span>pp_gets_def</span><span class="delimiter">)</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>spec_sugar</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>relcomp</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cond_sugar</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>whilei_sugar</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gets</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel_antidomain_kleene_algebra.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"wp"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel_antidomain_kleene_algebra.ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"rdom"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>ppath_aka.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"wp"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ppath_aka.ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"rdom"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2pp</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⌈_⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pp_prod</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>spec_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a ppath set ⇒ 'a pred ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE P X POST Q ≡ rdom ⌈P⌉ ⊆ wp X ⌈Q⌉"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cond_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a ppath set ⇒ 'a ppath set ⇒ 'a ppath set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"IF P THEN X ELSE Y FI ≡ ppath_aka.cond ⌈P⌉ X Y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>whilei_sugar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a pred ⇒ 'a pred ⇒ 'a ppath set ⇒ 'a ppath set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"WHILE _ INV _ DO _ OD"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"WHILE P INV I DO X OD ≡ ppath_aka.whilei ⌈P⌉ ⌈I⌉ X"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2pp P ∪ p2pp Q = p2pp (P ⊔ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2pp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p2pp P; p2pp Q = p2pp (P ⊓ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2pp_def</span><span> </span><span>pp_prod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P ≤ Q ⟹ ⌈P⌉ ⊆ ⌈Q⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2pp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rdom ⌈P⌉ = ⌈P⌉"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ppath_aka.addual.ars_r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ppath_aka.fbox_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2pp_def</span><span> </span><span>rel_ad_def</span><span> </span><span>gcd_non_0_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid_diff</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y ∧ x &gt; 0 ∧ y &gt; 0)
    (WHILE (λs. s ''x''≠ s ''y'') INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
     DO
        (IF (λs. s ''x'' &gt;  s ''y'')
         THEN (''x'' ::= (λs. s ''x'' - s ''y''))
         ELSE (''y'' ::= (λs. s ''y'' - s ''x''))
         FI)
    OD)
    POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ppath_aka.fbox_whilei</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2pp_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>gcd.commute</span><span> </span><span>gcd_diff1_nat</span><span> </span><span>le_cases</span><span> </span><span>nat_less_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>varible_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs. s ''x'' = a ∧ s ''y'' = b)   
    (''z'' ::= (λs. s ''x''));
    (''x'' ::= (λs. s ''y''));
    (''y'' ::= (λs. s ''z''))
   POST (λs. s ''x'' = b ∧ s ''y'' = a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True) 
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. x ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. x));
    (WHILE (λs. y ≤ s ''r'') INV (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - y))
      OD)
   POST (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ppath_aka.fbox_whilei_break</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now reconsider these examples with an Eisbach tactic.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>ht</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ppath_aka.fbox_whilei</span><span> </span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>  </span><span>ppath_aka.fbox_seq_var</span><span> </span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>  </span><span>subset_refl</span><span class="delimiter">[</span><span>ht</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>hoare</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ht</span><span class="delimiter">;</span><span> </span><span>hoare</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y)
   (WHILE (λs. s ''y'' ≠ 0) INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
    DO
     (''z'' ::= (λs. s ''y''));
     (''y'' ::= (λs. s ''x'' mod s ''y''));
     (''x'' ::= (λs. s ''z''))
    OD)
   POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gcd_red_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>euclid_diff2</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. s ''x'' = x ∧ s ''y'' = y ∧ x &gt; 0 ∧ y &gt; 0)
    (WHILE (λs. s ''x''≠ s ''y'') INV (λs. gcd (s ''x'') (s ''y'') = gcd x y) 
     DO
        (IF (λs. s ''x'' &gt;  s ''y'')
         THEN (''x'' ::= (λs. s ''x'' - s ''y''))
         ELSE (''y'' ::= (λs. s ''y'' - s ''x''))
         FI)
    OD)
    POST (λs. s ''x'' = gcd x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>hoare</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>gcd.commute</span><span> </span><span>gcd_diff1_nat</span><span> </span><span>le_cases</span><span> </span><span>nat_less_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>varible_swap2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs. s ''x'' = a ∧ s ''y'' = b)   
    (''z'' ::= (λs. s ''x''));
    (''x'' ::= (λs. s ''y''));
    (''y'' ::= (λs. s ''z''))
   POST (λs. s ''x'' = b ∧ s ''y'' = a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True) 
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_division2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. x ≥ 0)
    (''q'' ::= (λs. 0)); 
    (''r'' ::= (λs. x));
    (WHILE (λs. y ≤ s ''r'') INV (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0)
     DO
      (''q'' ::= (λs. s ''q'' + 1));
      (''r'' ::= (λs. s ''r'' - y))
      OD)
   POST (λs. x = s ''q'' * y + s ''r'' ∧ s ''r'' ≥ 0 ∧ s ''r'' &lt; y)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>my_power2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs::nat store. True)
   (''i'' ::= (λs. 0));
   (''y'' ::= (λs. 1));
   (WHILE (λs. s ''i'' &lt; n) INV (λs. s ''y'' = x ^ (s ''i'') ∧ s ''i'' ≤ n)
     DO
       (''y'' ::= (λs. (s ''y'') * x));
       (''i'' ::= (λs. s ''i'' + 1))
     OD)
   POST (λs. s ''y'' = x ^ n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>hoare</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imp_reverse2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: 'a list store. s ''x'' = X)
   (''y'' ::= (λs. []));
   (WHILE (λs. s ''x'' ≠ []) INV (λs. rev (s ''x'') @ s ''y'' = rev X)
    DO 
     (''y'' ::= (λs. hd (s ''x'') # s ''y'')); 
     (''x'' ::= (λs. tl (s ''x'')))
    OD) 
   POST (λs. s ''y''= rev X )"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.simps</span><span> </span><span>append_assoc</span><span> </span><span>hd_Cons_tl</span><span> </span><span>rev.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Pointer_Examples">
<div class="head"><h1>Theory Pointer_Examples</h1>
<span class="command">theory</span> <span class="name">Pointer_Examples</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD_Examples2.html"><span class="name">VC_KAD_Examples2</span></a> <a href="Heap.html"><span class="name">Heap</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Verification Component Based on KAD: Programs with Pointers
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹KAD Component for Pointer Programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pointer_Examples</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>VC_KAD_Examples2</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Hoare.Heap"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification of simple while programs
with pointers in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹All we do here is integrating Nipkow's implementation of pointers and heaps.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"string  ⇒ ('a ref + ('a ⇒ 'a ref))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_reversal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs :: 'a state. List (projr (s ''h'')) (projl (s ''p'')) Ps 
        ∧ List (projr (s ''h'')) (projl (s ''q'')) Qs 
        ∧ set Ps ∩ set Qs = {})
    (WHILE (λs. projl (s ''p'') ≠ Null) 
     INV (λs. ∃ps qs. List (projr (s ''h'')) (projl (s ''p'')) ps 
              ∧ List (projr (s ''h'')) (projl (s ''q'')) qs 
              ∧ set ps ∩ set qs = {} ∧ rev ps @ qs = rev Ps @ Qs)
     DO
      (''r'' ::= (λs. s ''p''));
      (''p'' ::= (λs. Inl (projr (s ''h'') (addr (projl (s ''p''))))) );
      (''h'' ::= (λs. Inr ((projr (s ''h''))(addr (projl (s ''r'')) := projl (s ''q''))) ));
      (''q'' ::= (λs. s ''r''))
     OD)
  POST (λs. List (projr (s ''h'')) (projl (s ''q'')) (rev Ps @ Qs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hoare</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>notin_List_update</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="KAD_is_KAT">
<div class="head"><h1>Theory KAD_is_KAT</h1>
<span class="command">theory</span> <span class="name">KAD_is_KAT</span><br/>
<span class="keyword">imports</span> <a href="VC_KAD.html"><span class="name">VC_KAD</span></a> <a href="VC_KAT.html"><span class="name">VC_KAT</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: KAD is KAT
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Bringing KAT Components into Scope of KAD›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>KAD_is_KAT</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>KAD.Antidomain_Semiring</span><span> 
</span><span>        </span><span>KAT_and_DRA.KAT</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"AVC_KAD/VC_KAD"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"AVC_KAT/VC_KAT"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>antidomain_kleene_algebra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Every Kleene algebra with domain is a Kleene algebra with tests. This fact should eventually move into
the AFP KAD entry.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>kat</span><span> </span><span class="string"><span class="delete"><span class="delete">"(+)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span>star</span><span> </span><span>antidomain_op</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_mult_closure</span><span> </span><span>am_d_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpdz.dom_weakly_local</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_d_add_closure</span><span> </span><span>a_de_morgan</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next statement links the wp operator with the Hoare triple.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_kat_to_kad</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H p x q ⟷ d p ≤ |x] (d q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H_def</span><span> </span><span>addual.ars_r_def</span><span> </span><span>fbox_demodalisation3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ⊆ Id ⟹ Q ⊆ Id ⟹ rel_kat.H P X Q = rel_antidomain_kleene_algebra.H P X Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_kat.H_def</span><span> </span><span>rel_antidomain_kleene_algebra.H_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antidomain_kleene_algebra.t P = Id ∩ P"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antidomain_kleene_algebra.t Q = Id ∩ Q"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_ad_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>VC_KAD.spec_sugar</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"PRE _ _ POST _"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VC_KAD.cond_sugar</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"IF _ THEN _ ELSE _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span> </span><span>63</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VC_KAD.gets</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ::= _"</span></span></span><span> </span><span class="delimiter">[</span><span>70</span><span class="delimiter">,</span><span> </span><span>65</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next we provide some syntactic sugar.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>H_from_kat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PRE p x POST q = (⌈p⌉ ≤ (rel_antidomain_kleene_algebra.fbox x) ⌈q⌉)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>H_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rel_antidomain_kleene_algebra.H_kat_to_kad</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antidomain_kleene_algebra.ads_d ⌈p⌉ = ⌈p⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_antidomain_kleene_algebra.ads_d ⌈q⌉ = ⌈q⌉"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_antidomain_kleene_algebra.ads_d_def</span><span> </span><span>rel_ad_def</span><span> </span><span>p2r_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cond_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_kat.ifthenelse ⌈P⌉ X Y = rel_antidomain_kleene_algebra.cond ⌈P⌉ X Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_kat.ifthenelse_def</span><span> </span><span>rel_antidomain_kleene_algebra.cond_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gets_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ::= e = VC_KAD.gets v e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VC_KAT.gets_def</span><span> </span><span>VC_KAD.gets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally we present two examples to test the integration.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True)
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>sH_cond_iff</span><span> </span><span>H_assign_iff</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maximum2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PRE (λs:: nat store. True)
   (IF (λs. s ''x'' ≥ s ''y'') 
    THEN (''z'' ::= (λs. s ''x''))
    ELSE (''z'' ::= (λs. s ''y''))
    FI)
   POST (λs. s ''z'' = max (s ''x'') (s ''y''))"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>H_from_kat</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>cond_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>gets_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>gets_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Domain_Quantale">
<div class="head"><h1>Theory Domain_Quantale</h1>
<span class="command">theory</span> <span class="name">Domain_Quantale</span><br/>
<span class="keyword">imports</span> <a href="Modal_Kleene_Algebra.html"><span class="name">Modal_Kleene_Algebra</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title: Domain Quantales
   Author: Victor Gomes, Georg Struth
   Maintainer: Victor Gomes &lt;victor.gomes@cl.cam.ac.uk&gt;
               Georg Struth &lt;g.struth@sheffield.ac.uk&gt; 
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Component for Recursive Programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Domain_Quantale</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>KAD.Modal_Kleene_Algebra</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This component supports the verification and step-wise refinement of recursive programs
in a partial correctness setting.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span>
</span><span>  </span><span>times</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>bot</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>top</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⊤"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>inf</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊓"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>sup</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊔"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Inf ("⨅_" [900] 900) and
  Sup ("⨆_" [900] 900)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
syntax
  "_INF1"     :: "pttrns ⇒ 'b ⇒ 'b"           ("(3⨅_./ _)" [0, 10] 10)
  "_INF"      :: "pttrn ⇒ 'a set ⇒ 'b ⇒ 'b"  ("(3⨅_∈_./ _)" [0, 0, 10] 10)
  "_SUP1"     :: "pttrns ⇒ 'b ⇒ 'b"           ("(3⨆_./ _)" [0, 10] 10)
  "_SUP"      :: "pttrn ⇒ 'a set ⇒ 'b ⇒ 'b"  ("(3⨆_∈_./ _)" [0, 0, 10] 10)

*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lattice-Ordered Monoids with Domain›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>bd_lattice_ordered_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>bounded_lattice</span><span> </span><span class="delimiter">+</span><span> </span><span>distrib_lattice</span><span> </span><span class="delimiter">+</span><span> </span><span>monoid_mult</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>left_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ (y ⊔ z) = x ⋅ y ⊔ x ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>right_distrib</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ⊔ y) ⋅ z = x ⋅ z ⊔ y ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_annil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ ⋅ x = ⊥"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_annir</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ ⊥ = ⊥"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>semiring_one_zero</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bot"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sup.assoc</span><span> </span><span>sup.commute</span><span> </span><span>sup_left_commute</span><span> </span><span>left_distrib</span><span> </span><span>right_distrib</span><span> </span><span>sup_absorb1</span><span class="delimiter">)</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>dioid_one_zero</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>bot</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_iff_sup</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>ads_d</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"d"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ars_r</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antirange_op</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"ar _"</span></span></span><span> </span><span class="delimiter">[</span><span>999</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>domain_bdlo_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>bd_lattice_ordered_monoid</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rdv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ⊓ x ⋅ top) ⋅ y = z ⋅ y ⊓ x ⋅ top"</span></span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d x = 1 ⊓ x ⋅ ⊤"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ds</span><span class="delimiter">:</span><span> </span><span>domain_semiring</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊔ d x ⋅ x = d x ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>d_def</span><span> </span><span>inf_sup_absorb</span><span> </span><span>left_distrib</span><span> </span><span>mult_1_left</span><span> </span><span>mult_1_right</span><span> </span><span>rdv</span><span> </span><span>sup.absorb_iff1</span><span> </span><span>sup.idem</span><span> </span><span>sup.left_commute</span><span> </span><span>top_greatest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d (x ⋅ d y) = d (x ⋅ y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d_def</span><span> </span><span>inf_absorb2</span><span> </span><span>rdv</span><span>  </span><span>mult_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d x ⊔ 1 = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d_def</span><span> </span><span>sup.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d bot = bot"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d_def</span><span> </span><span>inf.absorb1</span><span> </span><span>inf.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d (x ⊔ y) = d x ⊔ d y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d_def</span><span> </span><span>inf_sup_distrib1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Boolean Monoids with Domain›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>boolean_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>boolean_algebra</span><span> </span><span class="delimiter">+</span><span> </span><span>monoid_mult</span><span> </span><span class="delimiter">+</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>left_distrib'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ (y ⊔ z) = x ⋅ y ⊔ x ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>right_distrib'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ⊔ y) ⋅ z = x ⋅ z ⊔ y ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_annil'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ ⋅ x = ⊥"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_annir'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ ⊥ = ⊥"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>bd_lattice_ordered_monoid</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>left_distrib'</span><span> </span><span>right_distrib'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_bot_iff_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊓ y = ⊥ ⟷ x ≤ -y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_iff_inf</span><span> </span><span>inf_sup_distrib1</span><span> </span><span>inf_top_right</span><span> </span><span>sup_bot.left_neutral</span><span> </span><span>sup_compl_top</span><span> </span><span>compl_inf_bot</span><span> </span><span>inf.assoc</span><span> </span><span>inf_bot_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>domain_boolean_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>boolean_monoid</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rdv'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ⊓ x ⋅ ⊤) ⋅ y = z ⋅ y ⊓ x ⋅ ⊤"</span></span></span><span>     
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>dblo</span><span class="delimiter">:</span><span> </span><span>domain_bdlo_monoid</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊓)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rdv'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a x = 1 ⊓ -(dblo.d x)"</span></span></span><span>
</span><span>                                
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_d_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a x = 1 ⊓ -(x ⋅ ⊤)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>a_def</span><span> </span><span>dblo.d_def</span><span> </span><span>inf_sup_distrib1</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>topr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"-(x ⋅ ⊤) ⋅ ⊤ = -(x ⋅ ⊤)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-(x ⋅ ⊤) ≤ -(x ⋅ ⊤) ⋅ ⊤"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult_isol_var</span><span> </span><span>mult_oner</span><span> </span><span>order_refl</span><span> </span><span>top_greatest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-(x ⋅ ⊤) ⊓ (x ⋅ ⊤) = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(-(x ⋅ ⊤) ⊓ (x ⋅ ⊤)) ⋅ ⊤  = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-(x ⋅ ⊤) ⋅ ⊤ ⊓ (x ⋅ ⊤)  = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rdv'</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"-(x ⋅ ⊤) ⋅ ⊤ ≤ -(x ⋅ ⊤)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf_bot_iff_le</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dd_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dblo.d x = a (a x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_d_iff</span><span> </span><span>dblo.d_def</span><span> </span><span>double_compl</span><span> </span><span>inf_top.left_neutral</span><span> </span><span>mult_1_left</span><span> </span><span>rdv'</span><span> </span><span>topr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ad_a</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a (dblo.d x) = a x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>da_a</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dblo.d (a x) = a x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ad_a</span><span> </span><span>dd_a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a x ⋅ x = ⊥"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a x ⋅ x ⋅ ⊤ = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_d_iff</span><span> </span><span>inf_compl_bot</span><span> </span><span>mult_1_left</span><span> </span><span>rdv'</span><span> </span><span>topr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>dblo.d_def</span><span> </span><span>dblo.ds.domain_very_strict</span><span> </span><span>inf_bot_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a (x ⋅ y) ⊔ a (x ⋅ a (a y)) = a (x ⋅ a (a y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_def</span><span> </span><span>dblo.ds.dsr2</span><span> </span><span>dd_a</span><span> </span><span>sup.idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a (a x) ⊔ a x = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a_def</span><span> </span><span>da_a</span><span> </span><span>inf.commute</span><span> </span><span>sup.commute</span><span> </span><span>sup_compl_top</span><span> </span><span>sup_inf_absorb</span><span> </span><span>sup_inf_distrib1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>domain_bdlo_monoid</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The next statement shows that every boolean monoid with domain is an antidomain semiring. 
In this setting the domain operation has been defined explicitly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ad</span><span class="delimiter">:</span><span> </span><span>antidomain_semiring</span><span> </span><span>a</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span>ad_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad.ads_d x = d x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"class.antidomain_semiring a (⊔) (⋅) 1 ⊥ (≤) (&lt;)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ad</span><span class="delimiter">:</span><span> </span><span>antidomain_semiring</span><span> </span><span>a</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ad.ads_d x = d x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ad.ads_d_def</span><span> </span><span>dd_a</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Boolean Monoids with Range›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>range_boolean_monoid</span><span> </span><span class="delimiter">=</span><span> </span><span>boolean_monoid</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ldv'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ (z ⊓ ⊤ ⋅ x) = y ⋅ z ⊓ ⊤ ⋅ x"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r x = 1 ⊓ ⊤ ⋅ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ar x = 1 ⊓ -(r x)"</span></span></span><span>
</span><span>                                
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ar_r_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar x = 1 ⊓ -(⊤ ⋅ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ar_def</span><span> </span><span>inf_sup_distrib1</span><span> </span><span>r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>topl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤⋅(-(⊤ ⋅ x)) = -(⊤ ⋅ x)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤ ⋅ - (⊤ ⋅ x) ≤ - (⊤ ⋅ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bot_annir'</span><span> </span><span>compl_inf_bot</span><span> </span><span>inf_bot_iff_le</span><span> </span><span>ldv'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"- (⊤ ⋅ x) ≤ ⊤ ⋅ - (⊤ ⋅ x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_le2</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>mult_1_left</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>r_ar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r x = ar (ar x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ar_r_iff</span><span> </span><span>double_compl</span><span> </span><span>inf.commute</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>ldv'</span><span> </span><span>mult_1_right</span><span> </span><span>r_def</span><span> </span><span>topl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ar_ar</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar (r x) = ar x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ar_def</span><span> </span><span>ldv'</span><span> </span><span>r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rar_ar</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r (ar x) = ar x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_ar</span><span> </span><span>ar_ar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ar1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ ar x = ⊥"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊤ ⋅ x ⋅ ar x = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ar_r_iff</span><span> </span><span>inf_compl_bot</span><span> </span><span>ldv'</span><span> </span><span>mult_oner</span><span> </span><span>topl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_bot_iff_le</span><span> </span><span>inf_le2</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>mult_1_left</span><span> </span><span>mult_isor</span><span> </span><span>mult_oner</span><span> </span><span>topl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r (r x ⋅ y) = r (x ⋅ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf.commute</span><span> </span><span>inf_top.right_neutral</span><span> </span><span>ldv'</span><span> </span><span>mult_oner</span><span> </span><span>mult_assoc</span><span> </span><span>r_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ar2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar (x ⋅ y) ⊔ ar (ar (ar x) ⋅ y) = ar (ar (ar x) ⋅ y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ar_def</span><span> </span><span>ars</span><span> </span><span>r_ar</span><span> </span><span>sup.idem</span><span class="delimiter">)</span><span>
</span><span>                         
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ar3</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar (ar x) ⊔ ar x = 1 "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ar_def</span><span> </span><span>rar_ar</span><span> </span><span>inf.commute</span><span> </span><span>sup.commute</span><span> </span><span>sup_compl_top</span><span> </span><span>sup_inf_absorb</span><span> </span><span>sup_inf_distrib1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ar</span><span class="delimiter">:</span><span> </span><span>antirange_semiring</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span>ar</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span>ar_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar.ars_r x = r x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"class.antirange_semiring (⊔) (⋅) 1 ⊥ ar (≤) (&lt;)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>ar</span><span class="delimiter">:</span><span> </span><span>antirange_semiring</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span>ar</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ar.ars_r x = r x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ar.ars_r_def</span><span> </span><span>r_ar</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Quantales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This part will eventually move into an AFP quantale entry.›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>complete_lattice</span><span> </span><span class="delimiter">+</span><span> </span><span>monoid_mult</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Sup_distr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup X ⋅ y = Sup {z. ∃x ∈ X. z = x ⋅ y}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Sup_distl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ Sup Y = Sup {z. ∃y ∈ Y. z = x ⋅ y}"</span></span></span><span>       
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bot_annil''</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥ ⋅ x = ⊥"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distr</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bot_annirr''</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ ⊥ = ⊥"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distl</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_distl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⋅ (y ⊔ z) = x ⋅ y ⊔ x ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distl</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{y, z}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Sup_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sup_distr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x ⊔ y) ⋅ z = x ⋅ z ⊔ y ⋅ z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distr</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{x, y}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Sup_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>semiring_one_zero</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sup.assoc</span><span> </span><span>sup.commute</span><span> </span><span>sup_left_commute</span><span> </span><span>sup_distl</span><span> </span><span>sup_distr</span><span class="delimiter">)</span><span>     
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>dioid_one_zero</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_iff_sup</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Sup_sup_pred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ⊔ Sup{y. P y} = Sup{y. y = x ∨ P y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_mono</span><span> </span><span>Sup_subset_mono</span><span> </span><span>Sup_upper</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_least</span><span> </span><span>Sup_upper</span><span> </span><span>le_supI2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"star x = (SUP i. x ^ i)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_def_var1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"star x = Sup{y. ∃i. y = x ^ i}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_def_var2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"star x = Sup{x ^ i |i. True}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def</span><span> </span><span>full_SetCompr_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_unfoldl'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⊔ x ⋅ (star x) = star x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⊔ x ⋅ (star x) = x ^ 0 ⊔ x ⋅ Sup{y. ∃i. y = x ^ i}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = x ^ 0 ⊔ Sup{y. ∃i. y = x ^ (i + 1)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sup_distl</span><span class="delimiter">,</span><span> </span><span>metis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Sup{y. y = x ^ 0 ∨ (∃i. y = x ^ (i + 1))}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_sup_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Sup{y. ∃i. y = x ^ i}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>power.power.power_Suc</span><span> </span><span>power.power_eq_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_unfoldr'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⊔ (star x) ⋅ x = star x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ⊔ (star x) ⋅ x = x ^ 0 ⊔ Sup{y. ∃i. y = x ^ i} ⋅ x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = x ^ 0 ⊔ Sup{y. ∃i. y = x ^ i ⋅ x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Sup_distr</span><span class="delimiter">,</span><span> </span><span>metis</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = x ^ 0 ⊔ Sup{y. ∃i. y = x ^ (i + 1)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_Suc2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Sup{y. y = x ^ 0 ∨ (∃i. y = x ^ (i + 1))}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_sup_pred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Sup{y. ∃i. y = x ^ i}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>power.power.power_Suc</span><span> </span><span>power.power_eq_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid_one_zero</span><span class="delimiter">)</span><span> </span><span>power_inductl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + x ⋅ y ≤ y ⟹ (x ^ n) ⋅ z ≤ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>mult_isol</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dioid_one_zero</span><span class="delimiter">)</span><span> </span><span>power_inductr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ (x ^ n) ≤ y"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y ⟹ z ⋅ x ^ n ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z + y ⋅ x ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ n ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ Suc n = z ⋅ x ⋅ x ^ n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>power_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (z ⋅ x ^ n) ⋅ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mult.assoc</span><span> </span><span>power_commutes</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ y ⋅ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_isor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹z + y ⋅ x ≤ y›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ x ^ Suc n ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_inductl'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⊔ x ⋅ y ≤ y ⟹ (star x) ⋅ z ≤ y"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⊔ x ⋅ y ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. x ^ i ⋅ z ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_inductl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup{w. ∃i. w = x ^ i ⋅ z} ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Sup_least</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup{w. ∃i. w = x ^ i} ⋅ z ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distr</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(star x) ⋅ z ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>star_inductr'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⊔ y ⋅ x ≤ y ⟹ z ⋅ (star x) ≤ y"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⊔ y ⋅ x ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. z ⋅ x ^ i  ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_inductr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sup{w. ∃i. w = z ⋅ x ^ i} ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Sup_least</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ Sup{w. ∃i. w = x ^ i} ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Sup_distl</span><span> </span><span>Sup_le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ⋅ (star x) ≤ y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_def_var1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ka</span><span class="delimiter">:</span><span> </span><span>kleene_algebra</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊥"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span>star</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>star_inductl'</span><span> </span><span>star_inductr'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distributive quantales are often assumed to satisfy infinite distributivity laws between
joins and meets, but finite ones suffice for our purposes.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>distributive_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>quantale</span><span> </span><span class="delimiter">+</span><span> </span><span>distrib_lattice</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>bd_lattice_ordered_monoid</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>distrib_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1 ⊓ x ⋅ ⊤) ⋅ x = x"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* nitpick [expect=genuine]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Domain Quantales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>domain_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>distributive_quantale</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>rdv''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(z ⊓ x ⋅ ⊤) ⋅ y = z ⋅ y ⊓ x ⋅ ⊤"</span></span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>domain_bdlo_monoid</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rdv''</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>range_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>distributive_quantale</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ldv''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ⋅ (z ⊓ ⊤ ⋅ x) = y ⋅ z ⊓ ⊤ ⋅ x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>boolean_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>quantale</span><span> </span><span class="delimiter">+</span><span> </span><span>complete_boolean_algebra</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>boolean_monoid</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sup_distl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1 ⊓ x ⋅ ⊤) ⋅ x = x"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick[expect=genuine]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1 ⊓ -(x ⋅ ⊤)) ⋅ x = ⊥"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*nitpick[expect=genuine]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Boolean Domain Quantales›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>domain_boolean_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>domain_quantale</span><span> </span><span class="delimiter">+</span><span> </span><span>boolean_quantale</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>domain_boolean_monoid</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rdv''</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad.fbox x q = Sup{d p |p. d p ⋅ x ≤ x ⋅ d q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sup_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ad.fbox_demodalisation3</span><span> </span><span>ad.fbox_simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ad.fbox_def</span><span> </span><span>ad.fbox_demodalisation3</span><span> </span><span>ad.fbox_simp</span><span> </span><span>da_a</span><span> </span><span>eq_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ad.fdia x p = Inf{d q |q. x ⋅ d p ≤ d q ⋅ x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Inf_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ds.fdemodalisation2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ad.fd_eq_fdia</span><span> </span><span>ad.fdia_def</span><span> </span><span>da_a</span><span> </span><span>double_compl</span><span> </span><span>ds.fdemodalisation2</span><span> </span><span>inf_bot_iff_le</span><span> </span><span>inf_compl_bot</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The specification statement can be defined explicitly.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"R p q ≡ Sup{x. (d p) ⋅ x ≤ x ⋅ d q}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ R p q ⟹ d p ≤ ad.fbox x (d q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R_def</span><span> </span><span>ad.kat_1_equiv</span><span> </span><span>ad.kat_2_equiv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≤ Sup{x. d p ⋅ x ⋅ a q = ⊥}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ⋅ x ⋅ a q ≤ d p ⋅ Sup{x. d p ⋅ x ⋅ a q = ⊥} ⋅ a q "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mult_double_iso</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = Sup{d p ⋅ x ⋅ a q |x. d p ⋅ x ⋅ a q = ⊥}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sup_distl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sup_distr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = ⊥"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Sup_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ad.fbox_demodalisation3</span><span> </span><span>ad.kat_3</span><span> </span><span>ad.kat_4</span><span> </span><span>le_bot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d p ≤ ad.fbox x (d q) ⟹ x ≤ R p q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sup_upper</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ad.fbox_demodalisation3</span><span> </span><span>ad.fbox_simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Relational Model of Boolean Domain Quantales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>rel_dbq</span><span class="delimiter">:</span><span> </span><span>domain_boolean_quantale</span><span> </span><span>Inter</span><span> </span><span>Union</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∩)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊆)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊂)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∪)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span> </span><span>UNIV</span><span> </span><span>minus</span><span> </span><span>uminus</span><span> </span><span>Id</span><span> </span><span class="string"><span class="delete"><span class="delete">"(O)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>O_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Modal Boolean Quantales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>range_boolean_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>range_quantale</span><span> </span><span class="delimiter">+</span><span> </span><span>boolean_quantale</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span>range_boolean_monoid</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ldv''</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fbox_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar.bbox x (r q) = Sup{r p |p. x ⋅ r p ≤ (r q) ⋅ x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sup_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ar.ardual.fbox_demodalisation3</span><span> </span><span>ar.ardual.fbox_simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ar.ardual.fbox_def</span><span> </span><span>ar.ardual.fbox_demodalisation3</span><span> </span><span>eq_refl</span><span> </span><span>rar_ar</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fdia_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ar.bdia x (r p) = Inf{r q |q. (r p) ⋅ x ≤ x ⋅ r q}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Inf_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ar.ars_r_def</span><span> </span><span>ar.ardual.fdemodalisation22</span><span> </span><span>ar.ardual.kat_3_equiv_opp</span><span> </span><span>ar.ardual.kat_4_equiv_opp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ar.bdia_def</span><span> </span><span>ar.ardual.ds.fdemodalisation2</span><span> </span><span>r_ar</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>modal_boolean_quantale</span><span> </span><span class="delimiter">=</span><span> </span><span>domain_boolean_quantale</span><span> </span><span class="delimiter">+</span><span> </span><span>range_boolean_quantale</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>domrange'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"d (r x) = r x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rangedom'</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r (d x) = d x"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>mka</span><span class="delimiter">:</span><span> </span><span>modal_kleene_algebra</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⊔)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span>1</span><span> </span><span>⊥</span><span> </span><span class="string"><span class="delete"><span class="delete">"(≤)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(&lt;)"</span></span></span><span> </span><span>star</span><span> </span><span>a</span><span> </span><span>ar</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ar_eq</span><span> </span><span>ad_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"( |_] _)"</span></span></span><span> </span><span class="delimiter">[</span><span>61</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>82</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antidomain_semiringl_class.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"( |_] _)"</span></span></span><span> </span><span class="delimiter">[</span><span>61</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>82</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>ad.fbox</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"( |_] _)"</span></span></span><span> </span><span class="delimiter">[</span><span>61</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>82</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recursion Rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>recursion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mono (f :: 'a ⇒ 'a :: domain_boolean_quantale) ⟹ 
  (⋀x. d p ≤ |x] d q ⟹ d p ≤ |f x] d q) ⟹  d p ≤ |lfp f] d q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>lfp_ordinal_induct</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>f</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ad.addual.ardual.fbox_demodalisation3</span><span> </span><span>Sup_distr</span><span> </span><span>Sup_distl</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Sup_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We have already tested this rule in the context of test quantales~\cite{ArmstrongGS15}, which is based
on a formalisation of quantales that is currently not in the AFP. The two theories will be merged as
soon as the quantale is available in the AFP.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>