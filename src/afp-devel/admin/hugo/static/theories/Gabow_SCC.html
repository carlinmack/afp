<div id="Gabow_Skeleton">
<div class="head">
<h1>Theory Gabow_Skeleton</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Skeleton for Gabow's SCC Algorithm \label{sec:skel}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_Skeleton
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../CAVA_Automata/Digraph.html">CAVA_Automata.Digraph</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* TODO: convenience locale, consider merging this with invariants *)</span>
<span class="keyword1"><span class="command">locale</span></span> fr_graph <span class="main">=</span>
  graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_reachableE_V0<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> V0<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we formalize a skeleton of Gabow's SCC algorithm. 
  The skeleton serves as a starting point to develop concrete algorithms,
  like enumerating the SCCs or checking emptiness of a generalized Büchi automaton.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Statistics Setup›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define some dummy-constants that are included into the generated code,
  and may be mapped to side-effecting ML-code that records statistics and debug information
  about the execution. In the skeleton algorithm, we count the number of visited nodes,
  and include a timing for the whole algorithm.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stat_newnode</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">=&gt;</span> unit"</span></span>   <span class="comment1">― ‹Invoked if new node is visited›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stat_newnode</span> <span class="main">≡</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stat_start</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">=&gt;</span> unit"</span></span>     <span class="comment1">― ‹Invoked once if algorithm starts›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stat_start</span> <span class="main">≡</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">stat_stop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">=&gt;</span> unit"</span></span>      <span class="comment1">― ‹Invoked once if algorithm stops›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stat_stop</span> <span class="main">≡</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">()</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>stat_newnode<span class="main">,</span>stat_newnode<span class="main">)</span> <span class="main">∈</span> unit_rel <span class="main">→</span> unit_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>stat_start<span class="main">,</span>stat_start<span class="main">)</span> <span class="main">∈</span> unit_rel <span class="main">→</span> unit_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>stat_stop<span class="main">,</span>stat_stop<span class="main">)</span> <span class="main">∈</span> unit_rel <span class="main">→</span> unit_rel"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">stat_newnode_nres</span> <span class="main">≡</span> RETURN <span class="main">(</span>stat_newnode <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">stat_start_nres</span> <span class="main">≡</span> RETURN <span class="main">(</span>stat_start <span class="main">()</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">stat_stop_nres</span> <span class="main">≡</span> RETURN <span class="main">(</span>stat_stop <span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> discard_stat_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">m1</span><span class="main">≤</span><span class="free">m2</span> <span class="main">⟹</span> stat_newnode_nres <span class="main">⪢</span> <span class="free">m1</span> <span class="main">≤</span> <span class="free">m2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m1</span><span class="main">≤</span><span class="free">m2</span> <span class="main">⟹</span> stat_start_nres <span class="main">⪢</span> <span class="free">m1</span> <span class="main">≤</span> <span class="free">m2</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">m1</span><span class="main">≤</span><span class="free">m2</span> <span class="main">⟹</span> stat_stop_nres <span class="main">⪢</span> <span class="free">m1</span> <span class="main">≤</span> <span class="free">m2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Abstract Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we formalize an abstract version of a path-based SCC algorithm.
  Later, this algorithm will be refined to use Gabow's data structure.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_seg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set list <span class="main">⇒</span> nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span>
  <span class="comment1">― ‹Set of nodes in a segment of the path›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">path_seg</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> <span class="main">⋃</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">!</span><span class="bound">k</span><span class="main">|</span><span class="bound">k</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">≤</span><span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_seg_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">≤</span><span class="free">i</span> <span class="main">⟹</span> path_seg <span class="free">p</span> <span class="free">i</span> <span class="free">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> path_seg_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> le_less_Suc_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> path_seg_drop<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="free">i</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> path_seg_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_drop_conv_nth Bex_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> path_seg_butlast<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> path_seg <span class="free">p</span> <span class="main">0</span> <span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def nth_append in_set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">idx_of</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span>
  <span class="comment1">― ‹Index of path segment that contains a node›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">idx_of</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">THE</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">!</span><span class="bound">i</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> idx_of_props<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    p_disjoint_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="bound">i</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="bound">j</span> <span class="main">⟶</span> <span class="bound">i</span><span class="main">=</span><span class="bound">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ON_STACK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"idx_of <span class="free">p</span> <span class="free">v</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">!</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ON_STACK <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">j</span></span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">.</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span> <span class="main">!</span> <span class="bound">j</span> <span class="main">⟶</span> <span class="skolem">i</span><span class="main">=</span><span class="bound">j</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> p_disjoint_sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"idx_of <span class="free">p</span> <span class="free">v</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">!</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> idx_of_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">)</span></span> theI'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> idx_of_uniq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    p_disjoint_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="bound">i</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="bound">j</span> <span class="main">⟶</span> <span class="bound">i</span><span class="main">=</span><span class="bound">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"idx_of <span class="free">p</span> <span class="free">v</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> A p_disjoint_sym <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">j</span></span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">.</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span> <span class="main">!</span> <span class="bound">j</span> <span class="main">⟶</span> <span class="free">i</span><span class="main">=</span><span class="bound">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> idx_of_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">)</span></span> the_equality<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariants›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The state of the inner loop consists of the path <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> of
  collapsed nodes, the set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D›</span></span></span></span> of finished (done) nodes, and the set
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pE›</span></span></span></span> of pending edges.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> abs_state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list <span class="main">×</span> <span class="tfree">'v</span> set <span class="main">×</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">touched</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="tfree">'v</span> set"</span></span> 
    <span class="comment1">― ‹Touched: Nodes that are done or on path›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">touched</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">vE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span>
    <span class="comment1">― ‹Visited edges: No longer pending edges from touched nodes›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vE</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">pE</span></span></span> <span class="main">≡</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">(</span>touched <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">pE</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> vE_ss_E<span class="main">:</span> <span class="quoted"><span class="quoted">"vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">⊆</span> E"</span></span> <span class="comment1">― ‹Visited edges are edges›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> outer_invar_loc <span class="comment1">― ‹Invariant of the outer loop›</span>
  <span class="main">=</span> fr_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span> <span class="comment1">― ‹Remaining nodes to iterate over›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span> <span class="comment1">― ‹Finished nodes›</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> it_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">it</span><span class="main">⊆</span>V0"</span></span>  <span class="comment1">― ‹Only start nodes to iterate over›</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> it_done<span class="main">:</span> <span class="quoted"><span class="quoted">"V0 <span class="main">-</span> <span class="free">it</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>  <span class="comment1">― ‹Nodes already iterated over are visited›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span><span class="main">⊆</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span> <span class="comment1">― ‹Done nodes are reachable›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="free">D</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span> <span class="comment1">― ‹Done is closed under transitions›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar_loc <span class="free">G</span> <span class="free">it</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fr_graph<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">outer_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">it</span> <span class="bound">D</span><span class="main">.</span> outer_invar_loc <span class="free">G</span> <span class="bound">it</span> <span class="bound">D</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> outer_invar_this<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar <span class="free">it</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> 
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> invar_loc <span class="comment1">― ‹Invariant of the inner loop›</span>
  <span class="main">=</span> fr_graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">D0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pE</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> v0_initial<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span>V0"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D0</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> pE_E_from_p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">⊆</span> E <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV"</span></span> 
    <span class="comment1">― ‹Pending edges are edges from path›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> E_from_p_touched<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">⊆</span> <span class="free">pE</span> <span class="main">∪</span> UNIV <span class="main">×</span> touched <span class="free">p</span> <span class="free">D</span>"</span></span> 
    <span class="comment1">― ‹Edges from path are pending or touched›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> D_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span><span class="main">⊆</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span> <span class="comment1">― ‹Done nodes are reachable›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p_connected<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span> <span class="main">×</span> <span class="free">p</span><span class="main">!</span>Suc <span class="free">i</span> <span class="main">∩</span> <span class="main">(</span>E<span class="main">-</span><span class="free">pE</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="comment1">― ‹CNodes on path are connected by non-pending edges›</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> p_disjoint<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span><span class="free">j</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span> <span class="main">∩</span> <span class="free">p</span><span class="main">!</span><span class="free">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="comment1">― ‹CNodes on path are disjoint›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p_sc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">U</span><span class="main">∈</span>set <span class="free">p</span> <span class="main">⟹</span> <span class="free">U</span><span class="main">×</span><span class="free">U</span> <span class="main">⊆</span> <span class="main">(</span>vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">∩</span> <span class="free">U</span><span class="main">×</span><span class="free">U</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
    <span class="comment1">― ‹Nodes in CNodes are mutually reachable by visited edges›</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> root_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="free">v0</span><span class="main">∈</span>hd <span class="free">p</span>"</span></span> <span class="comment1">― ‹Root CNode contains start node›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p_empty_v0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">⟹</span> <span class="free">v0</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="comment1">― ‹Start node is done if path empty›</span>
  
  <span class="keyword2"><span class="keyword">assumes</span></span> D_closed<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="free">D</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span> <span class="comment1">― ‹Done is closed under transitions›</span>
  <span class="comment1">(*assumes D_vis: "E∩D×D ⊆ vE" -- "All edges from done nodes are visited"*)</span>

  <span class="keyword2"><span class="keyword">assumes</span></span> vE_no_back<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span><span class="free">j</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">⟧</span> <span class="main">⟹</span> vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">∩</span> <span class="free">p</span><span class="main">!</span><span class="free">j</span> <span class="main">×</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="comment1">― ‹Visited edges do not go back on path›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p_not_D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">∩</span> <span class="free">D</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="comment1">― ‹Path does not contain done nodes›</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ltouched</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ltouched</span> <span class="main">≡</span> touched <span class="free">p</span> <span class="free">D</span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">lvE</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lvE</span> <span class="main">≡</span> vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fr_graph<span class="main">)</span> 
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">D0</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> invar_loc <span class="free">G</span> <span class="bound">v0</span> <span class="bound">D0</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_this<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> 

  <span class="keyword1"><span class="command">lemma</span></span> finite_reachableE_v0<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_reachableE_V0<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> v0_initial <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> D_vis<span class="main">:</span> <span class="quoted"><span class="quoted">"E<span class="main">∩</span><span class="free">D</span><span class="main">×</span>UNIV <span class="main">⊆</span> lvE"</span></span> <span class="comment1">― ‹All edges from done nodes are visited›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def <span class="keyword1"><span class="command">using</span></span> pE_E_from_p p_not_D <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 

  <span class="keyword1"><span class="command">lemma</span></span> vE_touched<span class="main">:</span> <span class="quoted"><span class="quoted">"lvE <span class="main">⊆</span> ltouched <span class="main">×</span> ltouched"</span></span> 
    <span class="comment1">― ‹Visited edges only between touched nodes›</span>
    <span class="keyword1"><span class="command">using</span></span> E_from_p_touched D_closed <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemma</span></span> lvE_ss_E<span class="main">:</span> <span class="quoted"><span class="quoted">"lvE <span class="main">⊆</span> E"</span></span> <span class="comment1">― ‹Visited edges are edges›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">lemma</span></span> path_touched<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> ltouched"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> D_touched<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">⊆</span> ltouched"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> pE_by_vE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">=</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">-</span> lvE"</span></span>
    <span class="comment1">― ‹Pending edges are edges from path not yet visited›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def
    <span class="keyword1"><span class="command">using</span></span> pE_E_from_p
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> pick_pending<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="free">pE</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">(</span>E<span class="main">-</span>lvE<span class="main">)</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV"</span></span>
    <span class="comment1">― ‹Pending edges from end of path are non-visited edges from end of path›</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> pE_by_vE<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> p_connected'<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">i</span> <span class="main">×</span> <span class="free">p</span><span class="main">!</span>Suc <span class="free">i</span> <span class="main">∩</span> lvE <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A p_not_D <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">i</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span>Suc <span class="free">i</span> <span class="main">∈</span> set <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> p_connected<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Termination›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The termination argument is based on unprocessed edges: 
    Reachable edges from untouched nodes and pending edges.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">unproc_edges</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">pE</span></span></span> <span class="main">≡</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span> <span class="main">-</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">∪</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">pE</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    In each iteration of the loop, either the number of unprocessed edges
    decreases, or the path length decreases.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_wf_rel</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">≡</span> inv_image <span class="main">(</span>finite_psubset <span class="keyword1">&lt;*lex*&gt;</span> measure length<span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>unproc_edges <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span><span class="main">,</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> abs_wf_rel_wf<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>abs_wf_rel <span class="free">v0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abs_wf_rel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Skeleton Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fr_graph<span class="main">)</span> <span class="entity">initial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="tfree">'v</span> abs_state"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">,</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">collapse_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set list <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> set list"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse_aux</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> take <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">collapse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_state <span class="main">⇒</span> <span class="tfree">'a</span> abs_state"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span> 
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">PDPE</span></span></span><span class="main">;</span> 
      <span class="bound">i</span><span class="main">=</span>idx_of <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      <span class="bound">p</span> <span class="main">=</span> collapse_aux <span class="bound">p</span> <span class="bound">i</span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> 
    <span class="entity">select_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> abs_state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> option <span class="main">×</span> <span class="tfree">'a</span> abs_state<span class="main">)</span> nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">select_edge</span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span><span class="main">;</span>
      <span class="bound">e</span> <span class="main">←</span> SELECT <span class="main">(</span><span class="main">λ</span><span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">e</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fr_graph<span class="main">)</span> <span class="entity">push</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'v</span> abs_state <span class="main">⇒</span> <span class="tfree">'v</span> abs_state"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">push</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span>
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span><span class="main">;</span>
      <span class="bound">p</span> <span class="main">=</span> <span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">]</span><span class="main">;</span>
      <span class="bound">pE</span> <span class="main">=</span> <span class="bound">pE</span> <span class="main">∪</span> <span class="main">(</span>E<span class="main">∩</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">pop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> abs_state <span class="main">⇒</span> <span class="tfree">'v</span> abs_state"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pop</span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span>
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">PDPE</span></span></span><span class="main">;</span>
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">V</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>butlast <span class="bound">p</span><span class="main">,</span> last <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">D</span> <span class="main">=</span> <span class="bound">V</span> <span class="main">∪</span> <span class="bound">D</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemmas match the definitions presented in the paper:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"select_edge <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">e</span> <span class="main">←</span> SELECT <span class="main">(</span><span class="main">λ</span><span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">pE</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">case</span> <span class="bound">e</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> select_edge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> 
    <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">i</span><span class="main">=</span>idx_of <span class="free">p</span> <span class="free">v</span> <span class="keyword1">in</span> <span class="main">(</span>take <span class="bound">i</span> <span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="bound">i</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_def collapse_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span> <span class="main">∪</span> E <span class="main">∩</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"pop <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span>butlast <span class="free">p</span><span class="main">,</span> last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pop_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">thm</span></span> pop_def<span class="main">[</span><span class="operator">unfolded</span> Let_def<span class="main">,</span> <span class="operator">no_vars</span><span class="main">]</span>

  <span class="keyword1"><span class="command">thm</span></span> select_edge_def<span class="main">[</span><span class="operator">unfolded</span> Let_def<span class="main">]</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">skeleton</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set nres"</span></span> 
    <span class="comment1">― ‹Abstract Skeleton Algorithm›</span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">skeleton</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">D</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
      <span class="bound">r</span> <span class="main">←</span> FOREACHi outer_invar V0 <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">D0</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> <span class="bound">v0</span><span class="main">∉</span><span class="bound">D0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> initial <span class="bound">v0</span> <span class="bound">D0</span><span class="main">;</span>

          <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">←</span> WHILEIT <span class="main">(</span>invar <span class="bound">v0</span> <span class="bound">D0</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="bound">p</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> 
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="comment1">― ‹Select edge from end of path›</span>
            <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> select_edge <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

            ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
              Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="comment1">― ‹Found outgoing edge to node <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>v›</span></span>›</span>
                <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">p</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Back edge: Collapse path›</span>
                  RETURN <span class="main">(</span>collapse <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">D</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to new node. Append to path›</span>
                  RETURN <span class="main">(</span>push <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to done node. Skip›</span>
                  RETURN <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                <span class="main">}</span>
              <span class="main">}</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                ASSERT <span class="main">(</span><span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
                <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                RETURN <span class="main">(</span>pop <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
              <span class="main">}</span>
          <span class="main">}</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
          ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="bound">pE</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
          RETURN <span class="bound">D</span>
        <span class="main">}</span> <span class="keyword1">else</span>
          RETURN <span class="bound">D0</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">D</span><span class="main">;</span>
      RETURN <span class="bound">r</span>
    <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariant Preservation›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> set_collapse_aux<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>collapse_aux <span class="free">p</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> append_take_drop_id<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="main">,</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> append_take_drop_id<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_aux_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> touched_collapse<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"touched <span class="main">(</span>collapse_aux <span class="free">p</span> <span class="free">i</span><span class="main">)</span> <span class="free">D</span> <span class="main">=</span> touched <span class="free">p</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> vE_collapse_aux<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"vE <span class="main">(</span>collapse_aux <span class="free">p</span> <span class="free">i</span><span class="main">)</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">=</span> vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> touched_push<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"touched <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span>V<span class="main">]</span><span class="main">)</span> <span class="free">D</span> <span class="main">=</span> touched <span class="free">p</span> <span class="free">D</span> <span class="main">∪</span> V"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Corollaries of the invariant›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section, we prove some more corollaries of the invariant,
  which are helpful to show invariant preservation›</span></span>

<span class="keyword1"><span class="command">context</span></span> invar_loc
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> cnode_connectedI<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">;</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">×</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> p_sc<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> cnode_connectedI'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">;</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inf.cobounded1 rtrancl_mono_mp cnode_connectedI<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> p_no_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span> <span class="main">∉</span> set <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> IDX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">i</span><span class="main">=</span><span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">with</span></span> root_v0 IDX <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> p_connected'<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> IDX <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">corollary</span></span> p_no_empty_idx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> p_no_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nth_mem<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> p_disjoint_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length <span class="free">p</span><span class="main">;</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">;</span> <span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">j</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">i</span><span class="main">=</span><span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal linorder_neqE_nat p_disjoint<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> pi_ss_path_seg_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≤</span>length <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">⊆</span>path_seg <span class="free">p</span> <span class="free">l</span> <span class="free">u</span> <span class="main">⟷</span> <span class="free">l</span><span class="main">≤</span><span class="free">i</span> <span class="main">∧</span> <span class="free">i</span><span class="main">&lt;</span><span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">i</span><span class="main">⊆</span>path_seg <span class="free">p</span> <span class="free">l</span> <span class="free">u</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> p_no_empty_idx<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> B <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≤</span><span class="skolem">i'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span><span class="main">&lt;</span><span class="free">u</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> p_disjoint_sym<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> _ <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i'</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">i'</span><span class="main">&lt;</span><span class="free">u</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">≤</span>length <span class="free">p</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">=</span><span class="skolem">i'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> C <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≤</span><span class="free">i</span> <span class="main">∧</span> <span class="free">i</span><span class="main">&lt;</span><span class="free">u</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> path_seg_ss_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l1</span><span class="main">&lt;</span><span class="free">u1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u1</span><span class="main">≤</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">l2</span><span class="main">&lt;</span><span class="free">u2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u2</span><span class="main">≤</span>length <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">l1</span> <span class="free">u1</span> <span class="main">⊆</span> path_seg <span class="free">p</span> <span class="free">l2</span> <span class="free">u2</span> <span class="main">⟷</span> <span class="free">l2</span><span class="main">≤</span><span class="free">l1</span> <span class="main">∧</span> <span class="free">u1</span><span class="main">≤</span><span class="free">u2</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">l1</span> <span class="free">u1</span> <span class="main">⊆</span> path_seg <span class="free">p</span> <span class="free">l2</span> <span class="free">u2</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="free">l1</span> <span class="main">⊆</span> path_seg <span class="free">p</span> <span class="free">l1</span> <span class="free">u1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> S <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l2</span><span class="main">≤</span><span class="free">l1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="main">(</span><span class="free">u1</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">⊆</span> path_seg <span class="free">p</span> <span class="free">l1</span> <span class="free">u1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> S <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u1</span><span class="main">≤</span><span class="free">u2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> 1 2 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">l2</span><span class="main">≤</span><span class="free">l1</span> <span class="main">∧</span> <span class="free">u1</span><span class="main">≤</span><span class="free">u2</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">l2</span><span class="main">≤</span><span class="free">l1</span> <span class="main">∧</span> <span class="free">u1</span><span class="main">≤</span><span class="free">u2</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">l1</span> <span class="free">u1</span> <span class="main">⊆</span> path_seg <span class="free">p</span> <span class="free">l2</span> <span class="free">u2</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans1 dual_order.trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> pathI<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">j</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">seg</span> <span class="main">≡</span> path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="free">j</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> <span class="free">seg</span><span class="main">×</span><span class="free">seg</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="comment1">― ‹We can obtain a path between cnodes on path›</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">,</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> seg_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> dec_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> base <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cnode_connectedI<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">j</span><span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?seg</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?seg'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> SSS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?seg</span> <span class="main">⊆</span> <span class="var">?seg'</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> path_seg_ss_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> step.hyps step.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> p_connected'<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      UV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> ISS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">j</span> <span class="main">⊆</span> <span class="var">?seg'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span> <span class="main">⊆</span> <span class="var">?seg'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> step.hyps step.prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

    <span class="keyword1"><span class="command">from</span></span> p_no_empty_idx<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x'</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> step.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x'</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span> 
    <span class="keyword1"><span class="command">have</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE<span class="main">∩</span><span class="var">?seg</span><span class="main">×</span><span class="var">?seg</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">x'</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE<span class="main">∩</span><span class="var">?seg'</span><span class="main">×</span><span class="var">?seg'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> SSS 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ t<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> 
    <span class="keyword1"><span class="command">from</span></span> cnode_connectedI<span class="main">[</span><span class="operator">OF</span> _ <span class="quoted"><span class="quoted">‹<span class="skolem">x'</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>›</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span>
      t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>lvE <span class="main">∩</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">×</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x'</span><span class="main">,</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>lvE<span class="main">∩</span><span class="var">?seg'</span><span class="main">×</span><span class="var">?seg'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ISS
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ t<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE<span class="main">∩</span><span class="var">?seg'</span><span class="main">×</span><span class="var">?seg'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> UV ISS <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> cnode_connectedI<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span>›</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">have</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>lvE <span class="main">∩</span> <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">j</span> <span class="main">×</span> <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">j</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>lvE<span class="main">∩</span><span class="var">?seg'</span><span class="main">×</span><span class="var">?seg'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> ISS
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ t<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE<span class="main">∩</span><span class="var">?seg'</span><span class="main">×</span><span class="var">?seg'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> p_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span> <span class="comment1">― ‹Nodes on path are reachable›</span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnionE in_set_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> A root_v0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 
      t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> path_seg <span class="free">p</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">×</span> path_seg <span class="free">p</span> <span class="main">0</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> pathI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> lvE_ss_E <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ t<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> touched_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"ltouched <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span> <span class="comment1">― ‹Touched nodes are reachable›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> touched_def <span class="keyword1"><span class="command">using</span></span> p_reachable D_reachable <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemma</span></span> vE_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"lvE <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0 <span class="main">×</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vE_touched<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> touched_reachable <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemma</span></span> pE_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span> <span class="main">×</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> pE_E_from_p p_reachable <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> D_closed_vE_rtrancl<span class="main">:</span> <span class="quoted"><span class="quoted">"lvE<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">D</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> D_closed Image_closed_trancl eq_iff reachable_mono lvE_ss_E<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> D_closed_path<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>path E <span class="free">u</span> <span class="free">q</span> <span class="free">w</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span><span class="free">D</span><span class="main">⟧</span> <span class="main">⟹</span> set <span class="free">q</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="free">u</span> <span class="free">q</span> <span class="free">w</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> bot.extremum <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> a1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_subset path_nodes_reachable<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> D_closed rtrancl_reachable_induct subset_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> D_closed_path_vE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>path lvE <span class="free">u</span> <span class="free">q</span> <span class="free">w</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span><span class="free">D</span><span class="main">⟧</span> <span class="main">⟹</span> set <span class="free">q</span> <span class="main">⊆</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> D_closed_path path_mono lvE_ss_E<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> path_in_lastnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path lvE <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ND<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">⊆</span> last <span class="free">p</span>"</span></span>
    <span class="comment1">― ‹A path from the last Cnode to the last Cnode remains in the last Cnode›</span>
    <span class="comment1">(* TODO: This can be generalized in two directions: 
      either 1) The path end anywhere. Due to vE_touched we can infer 
        that it ends in last cnode  
      or 2) We may use any cnode, not only the last one
    *)</span>
    <span class="keyword1"><span class="command">using</span></span> P ND
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>path_prepend <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">l</span> <span class="skolem">w</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE›</span></span> vE_touched <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>ltouched"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> touched_def
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹path lvE <span class="skolem">v</span> <span class="skolem">l</span> <span class="skolem">w</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">∈</span>lvE<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> path_is_rtrancl<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> D_closed_vE_rtrancl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> p_not_D <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> IntI Misc.last_in_set Sup_inf_eq_bot_iff assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
          bex_empty path_prepend.hyps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnionE in_set_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≠</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> vE_no_back<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> <span class="free">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> path_prepend.IH <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> loop_in_lastnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path lvE <span class="free">u</span> <span class="free">q</span> <span class="free">u</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ND<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">⊆</span> last <span class="free">p</span>"</span></span>
    <span class="comment1">― ‹A loop that touches the last node is completely inside the last node›</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> ND <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>set <span class="free">q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q1</span></span> <span class="skolem"><span class="skolem">q2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span><span class="main">=</span><span class="skolem">q1</span><span class="main">@</span><span class="skolem">v</span><span class="main">#</span><span class="skolem">q2</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="skolem">v</span> <span class="main">(</span><span class="skolem">v</span><span class="main">#</span><span class="skolem">q2</span><span class="main">@</span><span class="skolem">q1</span><span class="main">)</span> <span class="skolem">v</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_conc_conv path_cons_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> path_in_lastnode<span class="main">[</span><span class="operator">OF</span> this <span class="quoted"><span class="quoted">‹<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span><span class="main">]</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="free">q</span> <span class="main">⊆</span> last <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> P <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">q</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹set <span class="free">q</span> <span class="main">⊆</span> last <span class="free">p</span>›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> no_D_p_edges<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> <span class="free">D</span> <span class="main">×</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> D_closed p_not_D <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> idx_of_props<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ON_STACK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> 
      <span class="quoted"><span class="quoted">"idx_of <span class="free">p</span> <span class="free">v</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">!</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> idx_of_props<span class="main">[</span><span class="operator">OF</span> _ assms<span class="main">]</span> p_disjoint_sym <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas Regarding the Operations›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> fr_graph<span class="main">)</span> vE_initial<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"vE <span class="main">[</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">]</span> <span class="main">{}</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">{</span><span class="free">v0</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> invar_loc
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> vE_push<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span><span class="main">;</span> <span class="free">u</span><span class="main">∈</span>last <span class="free">p</span><span class="main">;</span> <span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span><span class="main">;</span> <span class="free">v</span><span class="main">∉</span><span class="free">D</span> <span class="main">⟧</span> 
    <span class="main">⟹</span> vE <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="free">D</span> <span class="main">(</span><span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> E<span class="main">∩</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def <span class="keyword1"><span class="command">using</span></span> pE_E_from_p
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> vE_remove<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">;</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span><span class="main">⟧</span> <span class="main">⟹</span> vE <span class="free">p</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def <span class="keyword1"><span class="command">using</span></span> pE_E_from_p <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">lemma</span></span> vE_pop<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> vE <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">)</span> <span class="free">pE</span> <span class="main">=</span> lvE"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> vE_def touched_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">lemma</span></span> pE_fin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">⟹</span> <span class="free">pE</span><span class="main">=</span><span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> pE_by_vE <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> invar_loc<span class="main">)</span> lastp_un_D_closed<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NO'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"E<span class="main">``</span><span class="main">(</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹On pop, the popped CNode and D are closed under transitions›</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> ImageE<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> NO' <span class="keyword1"><span class="command">have</span></span> NO<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>E <span class="main">-</span> lvE<span class="main">)</span> <span class="main">∩</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pick_pending<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NE<span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?i</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> NE <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">=</span> <span class="free">p</span><span class="main">!</span><span class="var">?i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> last_conv_nth<span class="main">)</span> 
    
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> UI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="var">?i</span> <span class="main">∪</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∉</span>last <span class="free">p</span>"</span></span> 
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> E NO <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span> <span class="main">∨</span> <span class="skolem">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> vE_touched <span class="keyword1"><span class="command">unfolding</span></span> touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnionE in_set_conv_nth<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∉</span>last <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span><span class="var">?i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">=</span><span class="var">?i</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> vE_no_back<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span><span class="var">?i</span>›</span></span> _<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE›</span></span> V <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> E UI D_closed <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>



<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Preservation of Invariant by Operations›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> outer_invar_loc<span class="main">)</span> invar_initial_aux<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span> <span class="main">-</span> <span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D</span> <span class="main">(</span>initial <span class="free">v0</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def initial_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">using</span></span> assms it_initial <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> D_reachable it_initial assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> D_closed <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_initial<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>outer_invar <span class="free">it</span> <span class="free">D0</span><span class="main">;</span> <span class="free">v0</span><span class="main">∈</span><span class="free">it</span><span class="main">;</span> <span class="free">v0</span><span class="main">∉</span><span class="free">D0</span><span class="main">⟧</span> <span class="main">⟹</span> invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>initial <span class="free">v0</span> <span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> outer_invar_loc.invar_initial_aux<span class="main">)</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> outer_invar_initial<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar V0 <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_pop<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NO'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def pop_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">p</span> <span class="main">=</span> insert <span class="main">(</span>last <span class="free">p</span><span class="main">)</span> <span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> NE <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> p_disjoint <span class="keyword1"><span class="command">have</span></span> lp_dj_blp<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">∩</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth nth_append<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> A'<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> nth_butlast<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"butlast <span class="free">p</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> nth_butlast<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> A 
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"butlast <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">i</span> <span class="main">=</span> <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> p_connected<span class="main">[</span><span class="operator">OF</span> A'<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"butlast <span class="free">p</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">×</span> butlast <span class="free">p</span> <span class="main">!</span> Suc <span class="skolem">i</span> <span class="main">∩</span> <span class="main">(</span>E <span class="main">-</span> <span class="free">pE</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_connected <span class="main">=</span> this

    <span class="comment1">(*have [simp]: "(E ∩ (last p ∪ D ∪ ⋃set (butlast p)) × UNIV - pE) = vE"
      unfolding vE_def touched_def by auto*)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">)</span> <span class="free">pE</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  
      <span class="keyword1"><span class="command">unfolding</span></span> vE_pop<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> D_incr <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> pE_E_from_p NO' <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
      <span class="keyword1"><span class="command">using</span></span> E_from_p_touched <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  
      <span class="keyword1"><span class="command">using</span></span> D_reachable p_reachable NE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_connected<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> p_disjoint <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_butlast<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> p_sc <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> root_v0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> root_v0 p_empty_v0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> lastp_un_D_closed<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> NO'<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> vE_no_back <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_butlast<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> p_not_D lp_dj_blp <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">thm</span></span> invar_pop<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v_0</span></span> <span class="quoted"><span class="free">D_0</span></span><span class="main">,</span> <span class="operator">no_vars</span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_collapse<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BACK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≡</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">≡</span> collapse_aux <span class="free">p</span> <span class="free">i</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def collapse_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">unfolding</span></span> i_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> p'_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">p'</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> SETP'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> p'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> IL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> VMEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> idx_of_props<span class="main">[</span><span class="operator">OF</span> BACK<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> i_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">p'</span> <span class="main">=</span> Suc <span class="free">i</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def <span class="keyword1"><span class="command">using</span></span> IL <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> P'_IDX_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">j</span></span><span class="main">&lt;</span>Suc <span class="free">i</span><span class="main">.</span> <span class="free">p</span><span class="main">!</span><span class="bound">j</span> <span class="main">⊆</span> <span class="free">p'</span><span class="main">!</span><span class="bound">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def <span class="keyword1"><span class="command">using</span></span> IL 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append path_seg_drop<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> defs_fold<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"vE <span class="free">p'</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE"</span></span> 
      <span class="quoted"><span class="quoted">"touched <span class="free">p'</span> <span class="free">D</span> <span class="main">=</span> ltouched"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def E<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IL <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> p_connected<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">j</span> <span class="main">×</span> <span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span> <span class="main">∩</span> <span class="main">(</span>E<span class="main">-</span><span class="free">pE</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> P'_IDX_SS A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">j</span><span class="main">⊆</span><span class="free">p'</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span>Suc <span class="skolem">j</span> <span class="main">⊆</span> <span class="free">p'</span><span class="main">!</span>Suc <span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">×</span> <span class="free">p'</span> <span class="main">!</span> Suc <span class="skolem">j</span> <span class="main">∩</span> <span class="main">(</span>E <span class="main">-</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_connected <span class="main">=</span> this

    <span class="keyword1"><span class="command">have</span></span> P_IDX_EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="main">⟶</span> <span class="free">p'</span><span class="main">!</span><span class="bound">j</span> <span class="main">=</span> <span class="free">p</span><span class="main">!</span><span class="bound">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def <span class="keyword1"><span class="command">using</span></span> IL  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> P'_LAST<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span><span class="main">!</span><span class="free">i</span> <span class="main">=</span> path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?last_cnode</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def <span class="keyword1"><span class="command">using</span></span> IL 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append path_seg_drop<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span> <span class="skolem">k</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">&lt;</span> length <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">∩</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p'</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p'</span><span class="main">!</span><span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span><span class="free">i</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p'</span><span class="main">!</span><span class="skolem">k</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">k'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="skolem">k'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k'</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">∩</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">k'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> p_disjoint<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">k'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">≠</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">&lt;</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IL <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">note</span></span> p_disjoint<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span><span class="skolem">k</span>›</span></span> this<span class="main">]</span> 
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">j</span> <span class="main">=</span> <span class="free">p'</span><span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span><span class="skolem">k</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">k</span><span class="main">&lt;</span><span class="free">i</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">p'</span><span class="main">!</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">k</span><span class="main">&lt;</span><span class="free">i</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p'</span><span class="main">!</span><span class="skolem">j</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">p'</span><span class="main">!</span><span class="skolem">k</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_disjoint <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">U</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">∈</span>set <span class="free">p'</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>Suc <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">=</span><span class="free">p'</span><span class="main">!</span><span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span> <span class="main">×</span> <span class="skolem">U</span> <span class="main">⊆</span> <span class="main">(</span>insert <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> lvE <span class="main">∩</span> <span class="skolem">U</span> <span class="main">×</span> <span class="skolem">U</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">=</span><span class="free">i</span>"</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span>path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span>path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ix</span></span> <span class="skolem"><span class="skolem">iy</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
            IX<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">ix</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="skolem">ix</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ix</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            IY<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">iy</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="skolem">iy</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">iy</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span>
            

          <span class="keyword1"><span class="command">from</span></span> IX <span class="keyword1"><span class="command">have</span></span> SS1<span class="main">:</span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="skolem">ix</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span> <span class="main">⊆</span> <span class="var">?last_cnode</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> path_seg_ss_eq<span class="main">)</span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">from</span></span> IY <span class="keyword1"><span class="command">have</span></span> SS2<span class="main">:</span> <span class="quoted"><span class="quoted">"path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="skolem">iy</span><span class="main">)</span> <span class="main">⊆</span> <span class="var">?last_cnode</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> path_seg_ss_eq<span class="main">)</span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rE</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">R</span><span class="main">.</span> <span class="main">(</span>lvE <span class="main">∩</span> <span class="bound">R</span><span class="main">×</span><span class="bound">R</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE <span class="main">∩</span> <span class="var">?last_cnode</span> <span class="main">×</span> <span class="var">?last_cnode</span><span class="main">)</span>"</span></span>

          <span class="keyword1"><span class="command">from</span></span> pathI<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">ix</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="var">?rE</span> <span class="main">(</span>path_seg <span class="free">p</span> <span class="skolem">ix</span> <span class="main">(</span>Suc <span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IX <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span><span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
            <span class="keyword1"><span class="command">using</span></span> SS1
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="var">?E</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>›</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> VMEM<span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
          <span class="keyword1"><span class="command">also</span></span> 
          <span class="keyword1"><span class="command">from</span></span> pathI<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">iy</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="var">?rE</span> <span class="main">(</span>path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>Suc <span class="skolem">iy</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IY <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span><span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
            <span class="keyword1"><span class="command">using</span></span> SS2
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span><span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">≠</span><span class="free">i</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span>Suc <span class="free">i</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">j</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_lessD in_set_conv_nth less_trans_Suc<span class="main">)</span> 

        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> p_sc<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">U</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">p</span><span class="main">!</span><span class="skolem">j</span><span class="main">∈</span>set <span class="free">p</span>›</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="improper">a</span><span class="main">,</span><span class="improper">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">×</span> <span class="free">p</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_sc <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span> <span class="skolem">k</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span><span class="skolem">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">&lt;</span>length <span class="free">p'</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> lvE <span class="main">∩</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">×</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∩</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">×</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> IL P_IDX_EQ Suc_lessD VMEM <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> <span class="free">i</span>›</span></span> 
            less_irrefl_nat less_trans_Suc p_disjoint_sym<span class="main">)</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lvE <span class="main">∩</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">k</span> <span class="main">×</span> <span class="free">p'</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">&lt;</span><span class="free">i</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">using</span></span> vE_no_back<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span> <span class="quoted"><span class="skolem">k</span></span><span class="main">]</span> A <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span><span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjointI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span><span class="free">i</span>›</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
            <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span>path_seg <span class="free">p</span> <span class="free">i</span> <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">j</span>"</span></span>
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">ix</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">ix</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="skolem">ix</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ix</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_seg_def<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span><span class="skolem">ix</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> vE_no_back<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">j</span></span> <span class="quoted"><span class="skolem">ix</span></span><span class="main">]</span> B <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_vE_no_back <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs_fold

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> D_incr <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> pE_E_from_p <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> E_from_p_touched BACK <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_reachable<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_connected<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_disjoint<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_sc<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> root_v0 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def collapse_aux_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> NE hd_in_set<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def collapse_aux_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def collapse_aux_def<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_closed<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> AUX_vE_no_back<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> p_not_D <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> invar_push<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UIL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def push_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="main">=</span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E <span class="main">∩</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">note</span></span> defs_fold <span class="main">=</span> vE_push<span class="main">[</span><span class="operator">OF</span> E UIL VNE<span class="main">]</span> touched_push

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">assume</span></span> SILL<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">×</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> Suc <span class="skolem">i</span> 
             <span class="main">∩</span> <span class="main">(</span>E <span class="main">-</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E <span class="main">∩</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> SILL E pE_E_from_p UIL VNE
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append last_conv_nth<span class="main">)</span> <span class="operator">fast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">with</span></span> SILL <span class="keyword1"><span class="command">have</span></span> SILL'<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
            
        <span class="keyword1"><span class="command">with</span></span> SILL' VNE <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            
        <span class="keyword1"><span class="command">from</span></span> p_connected<span class="main">[</span><span class="operator">OF</span> SILL'<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
          <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∉</span><span class="free">pE</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> X1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∉</span><span class="free">pE</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E <span class="main">-</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E <span class="main">∩</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="skolem">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">b</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span>Suc <span class="skolem">i</span>›</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span>  SILL'
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span> 
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_connected <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">U</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span> <span class="main">∈</span> set <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span> <span class="main">×</span> <span class="skolem">U</span> <span class="main">⊆</span> <span class="main">(</span>insert <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> lvE <span class="main">∩</span> <span class="skolem">U</span> <span class="main">×</span> <span class="skolem">U</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">∈</span>set <span class="free">p</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> p_sc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">×</span><span class="skolem">U</span> <span class="main">⊆</span> <span class="main">(</span>lvE <span class="main">∩</span> <span class="skolem">U</span><span class="main">×</span><span class="skolem">U</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">,</span></span> no_types<span class="main"><span class="main">)</span></span> Int_insert_left_if0 Int_insert_left_if1 
            in_mono insert_subset rtrancl_mono_mp subsetI<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">∉</span>set <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">U</span><span class="main">=</span><span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_p_sc <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span> lvE <span class="main">∩</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">×</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">=</span>length <span class="free">p</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> vE_no_back <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span><span class="skolem">j</span>›</span></span> this VNE <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword1"><span class="command">from</span></span> p_not_D A <span class="keyword1"><span class="command">have</span></span> PDDJ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">!</span><span class="skolem">i</span> <span class="main">∩</span> <span class="free">D</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Sup_inf_eq_bot_iff<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> UIL A p_disjoint_sym
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Misc.last_in_set NE UnionI VNE<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

          <span class="keyword1"><span class="command">using</span></span> vE_touched VNE PDDJ <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_vE_no_back <span class="main">=</span> this
        
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs_fold

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> D_incr <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> pE_E_from_p <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> E_from_p_touched VNE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_reachable<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_connected<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> p_disjoint <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_p_sc<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> root_v0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_closed<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_vE_no_back<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> p_not_D VNE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_skip<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UIL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VNP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> VD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">p</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> defs_fold <span class="main">=</span> vE_remove<span class="main">[</span><span class="operator">OF</span> NE E<span class="main">]</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs_fold
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> D_incr <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> pE_E_from_p <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> E_from_p_touched VD <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> touched_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_reachable<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> p_connected <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> p_disjoint<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> p_sc<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_mono<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> root_v0<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> p_empty_v0<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> D_closed<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> vE_no_back VD p_not_D 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Suc_lessD UnionI VNP less_trans_Suc nth_mem<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> p_not_D<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> fin_D_is_reachable<span class="main">:</span> 
    <span class="comment1">― ‹When inner loop terminates, all nodes reachable from start node are
      finished›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">⊇</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> p_empty_v0 rtrancl_reachable_induct<span class="main">[</span><span class="operator">OF</span> order_refl D_closed<span class="main">]</span> D_reachable
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fin_reachable_path<span class="main">:</span> 
    <span class="comment1">― ‹When inner loop terminates, nodes reachable from start node are
      reachable over visited edges›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> UR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>vE <span class="main">[]</span> <span class="free">D</span> <span class="free">pE</span><span class="main">)</span> <span class="free">u</span> <span class="free">q</span> <span class="free">v</span> <span class="main">⟷</span> path E <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_mono<span class="main">[</span><span class="operator">OF</span> lvE_ss_E<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"path E <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="free">u</span> <span class="free">q</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> UR
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>path_prepend <span class="skolem">u</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">w</span><span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> fin_D_is_reachable<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> D_closed <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> path_prepend.prems path_prepend.hyps <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> path_prepend.IH fin_D_is_reachable<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">w</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span><span class="free">D</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E›</span></span> D_vis <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_outer_newnode<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar <span class="free">it</span> <span class="free">D0</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"outer_invar <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span> <span class="free">D'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">interpret</span></span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> inv<span class="main">:</span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">D'</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword1"><span class="command">from</span></span> fin_D_is_reachable<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">D'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">using</span></span> it_initial <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> it_done inv.D_incr <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> inv.D_reachable <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command">using</span></span> inv.D_closed <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_outer_Dnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">D0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar <span class="free">it</span> <span class="free">D0</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"outer_invar <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span> <span class="free">D0</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">interpret</span></span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def <span class="keyword1"><span class="command">.</span></span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">using</span></span> it_initial <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> it_done A <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> D_reachable <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command">using</span></span> D_closed <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> pE_fin'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">x</span> <span class="free">σ</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">pE</span><span class="main">=</span><span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_loc.pE_fin<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Termination›</span></span>

<span class="keyword1"><span class="command">context</span></span> invar_loc 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> unproc_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹The set of unprocessed edges is finite›</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span> <span class="main">×</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> unproc_edges_def 
      <span class="keyword1"><span class="command">using</span></span> pE_reachable
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> unproc_decreasing<span class="main">:</span> 
    <span class="comment1">― ‹As effect of selecting a pending edge, the set of unprocessed edges
      decreases›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">⊂</span> unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">unfolding</span></span> unproc_edges_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph 
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> abs_wf_pop<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NO<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> last <span class="free">aba</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pop_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>butlast <span class="free">p</span><span class="main">,</span> last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unproc_edges <span class="free">v0</span> <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">∪</span> <span class="free">D</span><span class="main">)</span> <span class="free">pE</span> <span class="main">=</span> unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> unproc_edges_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> abs_wf_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> abs_wf_collapse<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>collapse_aux <span class="free">p</span> <span class="skolem">i</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unproc_edges <span class="free">v0</span> <span class="main">(</span>collapse_aux <span class="free">p</span> <span class="skolem">i</span><span class="main">)</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> 
      <span class="main">=</span> unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> unproc_edges_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> unproc_decreasing<span class="main">[</span><span class="operator">OF</span> NE E<span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> abs_wf_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> abs_wf_push<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">D</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">∩</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unproc_edges <span class="free">v0</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">∩</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span> 
      <span class="main">=</span> unproc_edges <span class="free">v0</span> <span class="free">p</span> <span class="free">D</span> <span class="main">(</span><span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> unproc_edges_def
      <span class="keyword1"><span class="command">using</span></span> E A pE_reachable
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> unproc_decreasing<span class="main">[</span><span class="operator">OF</span> NE E<span class="main">]</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> abs_wf_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> abs_wf_skip<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> abs_wf_rel <span class="free">v0</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">from</span></span> unproc_decreasing<span class="main">[</span><span class="operator">OF</span> NE E<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> abs_wf_rel_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Correctness Theorem›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> invar_preserve <span class="main">=</span> 
    invar_initial
    invar_pop invar_push invar_skip invar_collapse 
    abs_wf_pop abs_wf_collapse abs_wf_push abs_wf_skip 
    outer_invar_initial invar_outer_newnode invar_outer_Dnode

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The main correctness theorem for the dummy-algorithm just states that
    it satisfies the invariant when finished, and the path is empty.
›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> skeleton_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"skeleton <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">D</span><span class="main">.</span> outer_invar <span class="main">{}</span> <span class="bound">D</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> Union_iff
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 4<span class="main">]</span><span class="main">]</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> skeleton_def select_edge_def select_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> abs_wf_rel_wf<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> invar_preserve <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pE_fin' finite_V0<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Short proof, as presented in the paper›</span></span>
  <span class="keyword1"><span class="command">context</span></span> 
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"skeleton <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">D</span><span class="main">.</span> outer_invar <span class="main">{}</span> <span class="bound">D</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> skeleton_def select_edge_def select_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_vcg</span> WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> abs_wf_rel_wf<span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> invar_preserve <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pE_fin' finite_V0<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Consequences of Invariant when Finished"</span></span>
<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> fin_outer_D_is_reachable<span class="main">:</span>
    <span class="comment1">― ‹When outer loop terminates, exactly the reachable nodes are finished›</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar <span class="main">{}</span> <span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">=</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span> <span class="quoted"><span class="free">D</span></span> <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> it_done rtrancl_reachable_induct<span class="main">[</span><span class="operator">OF</span> order_refl D_closed<span class="main">]</span> D_reachable
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Gabow's Data Structure›</span></span><span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‹\label{sec:algo-ds}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The implementation due to Gabow \cite{Gabow2000} represents a path as
  a stack <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S›</span></span></span></span> of single nodes, and a stack <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>B›</span></span></span></span> that contains the
  boundaries of the collapsed segments. Moreover, a map <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>I›</span></span></span></span> maps nodes
  to their stack indices.

  As we use a tail-recursive formulation, we use another stack 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P :: (nat × 'v set) list›</span></span></span></span> to represent the pending edges. The
  entries in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> are sorted by ascending first component,
  and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>P›</span></span></span></span> only contains entries with non-empty second component. 
  An entry <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(i,l)›</span></span></span></span> means that the edges from the node at 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>S[i]›</span></span></span></span> to the nodes stored in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l›</span></span></span></span> are pending.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">find_max_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span>nat<span class="main">⇒</span>bool<span class="main">)</span> <span class="main">⇒</span> nat"</span></span> 
  <span class="comment1">― ‹Find the maximum number below an upper bound for which a predicate holds›</span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">find_max_nat</span> <span class="main">0</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">find_max_nat</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> <span class="free">find_max_nat</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> find_max_nat_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span> <span class="main">0</span><span class="main">;</span> <span class="main">0</span><span class="main">&lt;</span><span class="free">u</span><span class="main">⟧</span> <span class="main">⟹</span> find_max_nat <span class="free">u</span> <span class="free">P</span> <span class="main">=</span> Max <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free">u</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">i</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Max_eqI<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> sym<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">u</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> less_SucI less_antisym<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> find_max_nat_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">,</span><span class="free">n'</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">j</span> <span class="bound">j'</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">j'</span><span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">;</span> <span class="bound">j'</span><span class="main">&lt;</span><span class="free">n'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="bound">j</span><span class="main">,</span><span class="free">P'</span> <span class="bound">j'</span><span class="main">)</span><span class="main">∈</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_max_nat <span class="free">n</span> <span class="free">P</span><span class="main">,</span>find_max_nat <span class="free">n'</span> <span class="free">P'</span><span class="main">)</span> <span class="main">∈</span> nat_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n'</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> find_max_nat_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">,</span><span class="free">n'</span><span class="main">)</span><span class="main">∈</span>nat_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">j</span> <span class="bound">j'</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">j'</span><span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">;</span> <span class="bound">j'</span><span class="main">&lt;</span><span class="free">n'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="bound">j</span><span class="main">,</span><span class="free">P'</span><span class="main">$</span><span class="bound">j'</span><span class="main">)</span><span class="main">∈</span>bool_rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_max_nat <span class="free">n</span> <span class="free">P</span><span class="main">,</span>
        <span class="main">(</span><span class="keyword1">OP</span> find_max_nat <span class="main">:::</span> nat_rel <span class="main">→</span> <span class="main">(</span>nat_rel<span class="main">→</span>bool_rel<span class="main">)</span> <span class="main">→</span> nat_rel<span class="main">)</span> <span class="main">$</span><span class="free">n'</span><span class="main">$</span><span class="free">P'</span>
      <span class="main">)</span> <span class="main">∈</span> nat_rel"</span></span>
    <span class="keyword1"><span class="command">using</span></span> find_max_nat_param<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Gabow's Datastructure›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definition and Invariant›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> node_state <span class="main">=</span> STACK <span class="quoted">nat</span> <span class="main">|</span> DONE

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'v</span> oGS <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇀</span> node_state"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oGS_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> oGS <span class="main">⇒</span> <span class="tfree">'v</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">oGS_α</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="bound">v</span> <span class="main">=</span> Some DONE<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> oGS_invar <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> oGS"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I_no_stack<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">v</span> <span class="main">≠</span> Some <span class="main">(</span>STACK <span class="free">j</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> GS 
  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">×</span> nat list <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇀</span> node_state<span class="main">)</span> <span class="main">×</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span> set<span class="main">)</span> list"</span></span>
<span class="keyword1"><span class="command">locale</span></span> GS <span class="main">=</span>  
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">SBIP</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> GS"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">.</span> <span class="bound">S</span><span class="main">)</span> <span class="free">SBIP</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">.</span> <span class="bound">B</span><span class="main">)</span> <span class="free">SBIP</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">.</span> <span class="bound">I</span><span class="main">)</span> <span class="free">SBIP</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">.</span> <span class="bound">P</span><span class="main">)</span> <span class="free">SBIP</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">seg_start</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span> <span class="comment1">― ‹Start index of segment, inclusive›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">seg_start</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> B<span class="main">!</span><span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span> 

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">seg_end</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>  <span class="comment1">― ‹End index of segment, exclusive›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">seg_end</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span> <span class="main">=</span> length B <span class="keyword1">then</span> length S <span class="keyword1">else</span> B<span class="main">!</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">seg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="comment1">― ‹Collapsed set at index›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">seg</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="main">{</span>S<span class="main">!</span><span class="bound">j</span> <span class="main">|</span> <span class="bound">j</span><span class="main">.</span> seg_start <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≤</span> <span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span> <span class="main">&lt;</span> seg_end <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">p_α</span> <span class="main">≡</span> map seg <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length B<span class="main">]</span>"</span></span> <span class="comment1">― ‹Collapsed path›</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">D_α</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">v</span><span class="main">.</span> I <span class="bound">v</span> <span class="main">=</span> Some DONE<span class="main">}</span>"</span></span> <span class="comment1">― ‹Done nodes›</span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE_α</span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">.</span> <span class="main">∃</span><span class="bound">j</span> <span class="bound">I</span><span class="main">.</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">∈</span>set P <span class="main">∧</span> <span class="bound">u</span> <span class="main">=</span> S<span class="main">!</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">I</span> <span class="main">}</span>"</span></span> 
    <span class="comment1">― ‹Pending edges›</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">≡</span> <span class="main">(</span>p_α<span class="main">,</span>D_α<span class="main">,</span>pE_α<span class="main">)</span>"</span></span> <span class="comment1">― ‹Abstract state›</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> GS_sel_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"GS.S <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">B</span><span class="main">,</span><span class="free">I</span><span class="main">,</span><span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
  <span class="quoted"><span class="quoted">"GS.B <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">B</span><span class="main">,</span><span class="free">I</span><span class="main">,</span><span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span>"</span></span>
  <span class="quoted"><span class="quoted">"GS.I <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">B</span><span class="main">,</span><span class="free">I</span><span class="main">,</span><span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">I</span>"</span></span>
  <span class="quoted"><span class="quoted">"GS.P <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">B</span><span class="main">,</span><span class="free">I</span><span class="main">,</span><span class="free">P</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> GS.S_def GS.B_def GS.I_def GS.P_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> GS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> seg_start_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.seg_start <span class="main">(</span><span class="free">S'</span><span class="main">,</span>B<span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span> <span class="main">=</span> seg_start"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> GS.seg_start_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> seg_end_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.seg_end <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span> <span class="main">=</span> seg_end"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> GS.seg_end_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">lemma</span></span> seg_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.seg <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span> <span class="main">=</span> seg"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> GS.seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">lemma</span></span> p_α_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span> <span class="main">=</span> p_α"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS.p_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> D_α_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.D_α <span class="main">(</span><span class="free">S'</span><span class="main">,</span><span class="free">B'</span><span class="main">,</span>I<span class="main">,</span><span class="free">P'</span><span class="main">)</span> <span class="main">=</span> D_α"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS.D_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> pE_α_indep<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.pE_α <span class="main">(</span>S<span class="main">,</span><span class="free">B'</span><span class="main">,</span><span class="free">I'</span><span class="main">,</span>P<span class="main">)</span> <span class="main">=</span> pE_α"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> GS.pE_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_seg</span> <span class="comment1">― ‹Abs-path index for stack index›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_seg</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> Max <span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length B <span class="main">∧</span> B<span class="main">!</span><span class="bound">i</span><span class="main">≤</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">S_idx_of</span> <span class="comment1">― ‹Stack index for node›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S_idx_of</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> I <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> Some <span class="main">(</span>STACK <span class="bound">i</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">i</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> GS_invar <span class="main">=</span> GS <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> B_in_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"set B <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length S<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> B_sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted B"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> B_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct B"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> B0<span class="main">:</span> <span class="quoted"><span class="quoted">"S<span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> B<span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> B<span class="main">!</span><span class="main">0</span><span class="main">=</span><span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct S"</span></span>

  <span class="keyword2"><span class="keyword">assumes</span></span> I_consistent<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>I <span class="free">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">j</span><span class="main">&lt;</span>length S <span class="main">∧</span> <span class="free">v</span> <span class="main">=</span> S<span class="main">!</span><span class="free">j</span><span class="main">)</span>"</span></span>
  
  <span class="keyword2"><span class="keyword">assumes</span></span> P_sorted<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>map fst P<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst P<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> P_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"set P <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length S<span class="main">}</span><span class="main">×</span>Collect <span class="main">(</span><span class="main">(≠)</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">SBIP</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">oGS_rel</span> <span class="main">≡</span> br oGS_α oGS_invar"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> oGS_rel_sv<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">,</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued oGS_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> oGS_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">GS_rel</span> <span class="main">≡</span> br GS.α GS_invar"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> GS_rel_sv<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">,</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued GS_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> GS_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> GS_invar
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> empty_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"S<span class="main">=</span><span class="main">[]</span> <span class="main">⟷</span> B<span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> B_in_bound B0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> B_in_bound'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length B <span class="main">⟹</span> B<span class="main">!</span><span class="free">i</span> <span class="main">&lt;</span> length S"</span></span>
    <span class="keyword1"><span class="command">using</span></span> B_in_bound nth_mem <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword1"><span class="command">lemma</span></span> seg_start_bound<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"seg_start <span class="free">i</span> <span class="main">&lt;</span> length S"</span></span>
    <span class="keyword1"><span class="command">using</span></span> B_in_bound nth_mem<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> seg_end_bound<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"seg_end <span class="free">i</span> <span class="main">≤</span> length S"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">+</span><span class="main">1</span><span class="main">=</span>length B"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> seg_end_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">+</span><span class="main">1</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> nth_mem<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> B_in_bound <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" B <span class="main">!</span> <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> length S"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> seg_end_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> seg_start_less_end<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length B <span class="main">⟹</span> seg_start <span class="free">i</span> <span class="main">&lt;</span> seg_end <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def seg_end_def
    <span class="keyword1"><span class="command">using</span></span> B_in_bound' distinct_sorted_mono<span class="main">[</span><span class="operator">OF</span> B_sorted B_distinct<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> seg_end_less_start<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span><span class="free">j</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length B<span class="main">⟧</span> <span class="main">⟹</span> seg_end <span class="free">i</span> <span class="main">≤</span> seg_start <span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def seg_end_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_sorted_mono_iff<span class="main"><span class="main">[</span></span><span class="operator">OF</span> B_distinct B_sorted<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> find_seg_bounds<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length S"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"seg_start <span class="main">(</span>find_seg <span class="free">j</span><span class="main">)</span> <span class="main">≤</span> <span class="free">j</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> seg_end <span class="main">(</span>find_seg <span class="free">j</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">&lt;</span> length B"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length B <span class="main">∧</span> B<span class="main">!</span><span class="bound">i</span><span class="main">≤</span><span class="free">j</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> empty_eq <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">S</span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?M</span><span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A B0 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">B</span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> F<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="var">?M</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">from</span></span> Max_in<span class="main">[</span><span class="operator">OF</span> F NE<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> LEN<span class="main">:</span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">&lt;</span> length B"</span></span> <span class="keyword2"><span class="keyword">and</span></span> LB<span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">!</span>find_seg <span class="free">j</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> find_seg_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">&lt;</span> length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span>
    
    <span class="keyword1"><span class="command">from</span></span> LB <span class="keyword3"><span class="command">show</span></span> LB'<span class="main">:</span> <span class="quoted"><span class="quoted">"seg_start <span class="main">(</span>find_seg <span class="free">j</span><span class="main">)</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">show</span></span> UB'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> seg_end <span class="main">(</span>find_seg <span class="free">j</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> seg_end_def 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">split</span> if_split<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> impI conjI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length S"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">.</span></span>
      
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≠</span> length B"</span></span> 
      <span class="keyword1"><span class="command">with</span></span> LEN <span class="keyword1"><span class="command">have</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">+</span> <span class="main">1</span> <span class="main">&lt;</span> length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> B <span class="main">!</span> <span class="main">(</span>find_seg <span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> linorder_not_less<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"B <span class="main">!</span> <span class="main">(</span>find_seg <span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> P1 Max_ge<span class="main">[</span><span class="operator">OF</span> F<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">+</span> <span class="main">1</span>"</span></span><span class="main">,</span> <span class="operator">folded</span> find_seg_def<span class="main">]</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> find_seg_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length S"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"S<span class="main">!</span><span class="free">j</span> <span class="main">∈</span> seg <span class="main">(</span>find_seg <span class="free">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="free">j</span> <span class="main">&lt;</span> length B"</span></span>
    <span class="keyword1"><span class="command">using</span></span> find_seg_bounds<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> seg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> set_p_α_is_set_S<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span> <span class="main">=</span> set S"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command">unfolding</span></span> p_α_def seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> seg_end_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>

    <span class="keyword1"><span class="command">using</span></span> find_seg_bounds
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> S_idx_uniq<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span>length S<span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length S<span class="main">⟧</span> <span class="main">⟹</span> S<span class="main">!</span><span class="free">i</span><span class="main">=</span>S<span class="main">!</span><span class="free">j</span> <span class="main">⟷</span> <span class="free">i</span><span class="main">=</span><span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S_distinct
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_eq_iff_index_eq<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> S_idx_of_correct<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"S_idx_of <span class="free">v</span> <span class="main">&lt;</span> length S"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"S<span class="main">!</span>S_idx_of <span class="free">v</span> <span class="main">=</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>set S"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_p_α_is_set_S<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> I_consistent <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"I <span class="free">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"S_idx_of <span class="free">v</span> <span class="main">=</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_idx_of_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> G1 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"S_idx_of <span class="free">v</span> <span class="main">&lt;</span> length S"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"S<span class="main">!</span>S_idx_of <span class="free">v</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> p_α_disjoint_sym<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span>length p_α <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span>length p_α <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span>p_α<span class="main">!</span><span class="bound">i</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∈</span>p_α<span class="main">!</span><span class="bound">j</span> <span class="main">⟶</span> <span class="bound">i</span><span class="main">=</span><span class="bound">j</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> conjE<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length p_α"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length p_α"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> p_α <span class="main">!</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> p_α <span class="main">!</span> <span class="skolem">j</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> LI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword2"><span class="keyword">and</span></span> LJ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> B1<span class="main">:</span> <span class="quoted"><span class="quoted">"seg_start <span class="skolem">j</span> <span class="main">&lt;</span> seg_end <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B2<span class="main">:</span> <span class="quoted"><span class="quoted">"seg_start <span class="skolem">i</span> <span class="main">&lt;</span> seg_end <span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p_α_def seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> S_idx_uniq<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans1 seg_end_bound<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans1 seg_end_bound<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> S_idx_uniq<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans1 seg_end_bound<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans1 seg_end_bound<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">from</span></span> B1 <span class="keyword1"><span class="command">have</span></span> B1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B<span class="main">!</span><span class="skolem">j</span> <span class="main">&lt;</span> B<span class="main">!</span>Suc <span class="skolem">i</span> <span class="main">∧</span> Suc <span class="skolem">i</span> <span class="main">&lt;</span> length B<span class="main">)</span> <span class="main">∨</span> <span class="skolem">i</span><span class="main">=</span>length B <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> LI <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def seg_end_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> B2 <span class="keyword1"><span class="command">have</span></span> B2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>B<span class="main">!</span><span class="skolem">i</span> <span class="main">&lt;</span> B<span class="main">!</span>Suc <span class="skolem">j</span> <span class="main">∧</span> Suc <span class="skolem">j</span> <span class="main">&lt;</span> length B<span class="main">)</span> <span class="main">∨</span> <span class="skolem">j</span><span class="main">=</span>length B <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> LJ <span class="keyword1"><span class="command">unfolding</span></span> seg_start_def seg_end_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> B1 <span class="keyword1"><span class="command">have</span></span> B1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>Suc <span class="skolem">i</span> <span class="main">∨</span> <span class="skolem">i</span><span class="main">=</span>length B <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> LI LJ distinct_sorted_strict_mono_iff<span class="main">[</span><span class="operator">OF</span> B_distinct B_sorted<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> B2 <span class="keyword1"><span class="command">have</span></span> B2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>Suc <span class="skolem">j</span> <span class="main">∨</span> <span class="skolem">j</span><span class="main">=</span>length B <span class="main">-</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> LI LJ distinct_sorted_strict_mono_iff<span class="main">[</span><span class="operator">OF</span> B_distinct B_sorted<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> B1 B2 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span><span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> LI LJ
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement of the Operations›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">GS_initial_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> oGS <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> set <span class="main">⇒</span> <span class="tfree">'a</span> GS"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">GS_initial_impl</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span> <span class="main">≡</span> <span class="main">(</span>
    <span class="main">[</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">]</span><span class="main">,</span>
    <span class="main">[</span><span class="main">0</span><span class="main">]</span><span class="main">,</span>
    <span class="free"><span class="bound"><span class="entity">I</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">↦</span><span class="main">(</span>STACK <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">succs</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> GS
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">push_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span>
      <span class="main"><span class="bound">_</span></span> <span class="main">=</span> stat_newnode <span class="main">()</span><span class="main">;</span>
      <span class="bound">j</span> <span class="main">=</span> length S<span class="main">;</span>
      <span class="bound">S</span> <span class="main">=</span> S<span class="main">@</span><span class="main">[</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span><span class="main">;</span>
      <span class="bound">B</span> <span class="main">=</span> B<span class="main">@</span><span class="main">[</span><span class="bound">j</span><span class="main">]</span><span class="main">;</span>
      <span class="bound">I</span> <span class="main">=</span> I<span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↦</span> STACK <span class="bound">j</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">P</span> <span class="main">=</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">succs</span></span></span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> P <span class="keyword1">else</span> P<span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">succs</span></span></span><span class="main">)</span><span class="main">]</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span>"</span></span>

  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mark_as_done</span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span> <span class="bound">u</span> <span class="bound">I</span><span class="main">.</span> <span class="free">mark_as_done</span> <span class="bound">l</span> <span class="bound">u</span> <span class="bound">I</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">←</span>WHILET 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">.</span> <span class="bound">l</span><span class="main">&lt;</span><span class="bound">u</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> ASSERT <span class="main">(</span><span class="bound">l</span><span class="main">&lt;</span>length S<span class="main">)</span><span class="main">;</span> RETURN <span class="main">(</span>Suc <span class="bound">l</span><span class="main">,</span><span class="bound">I</span><span class="main">(</span>S<span class="main">!</span><span class="bound">l</span> <span class="main">↦</span> DONE<span class="main">)</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> 
      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">;</span>
    RETURN <span class="bound">I</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mark_as_done_abs</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span> <span class="bound">u</span> <span class="bound">I</span><span class="main">.</span> <span class="free">mark_as_done_abs</span> <span class="bound">l</span> <span class="bound">u</span> <span class="bound">I</span> 
    <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span><span class="main">{</span>S<span class="main">!</span><span class="bound">j</span> <span class="main">|</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">l</span><span class="main">≤</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span><span class="bound">u</span><span class="main">}</span> <span class="keyword1">then</span> Some DONE <span class="keyword1">else</span> <span class="bound">I</span> <span class="bound">v</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> mark_as_done_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="free">u</span> <span class="free">I</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">l</span><span class="main">&lt;</span><span class="free">u</span><span class="main">;</span> <span class="free">u</span><span class="main">≤</span>length S<span class="main">⟧</span> <span class="main">⟹</span> mark_as_done <span class="free">l</span> <span class="free">u</span> <span class="free">I</span> 
    <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> mark_as_done_abs <span class="free">l</span> <span class="free">u</span> <span class="free">I</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mark_as_done_def mark_as_done_abs_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
      WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">I'</span><span class="main">)</span><span class="main">.</span> 
          <span class="bound">I'</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span><span class="main">{</span>S<span class="main">!</span><span class="bound">j</span> <span class="main">|</span> <span class="bound">j</span><span class="main">.</span> <span class="free">l</span><span class="main">≤</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span><span class="bound">l'</span><span class="main">}</span> <span class="keyword1">then</span> Some DONE <span class="keyword1">else</span> <span class="free">I</span> <span class="bound">v</span><span class="main">)</span>
          <span class="main">∧</span> <span class="free">l</span><span class="main">≤</span><span class="bound">l'</span> <span class="main">∧</span> <span class="bound">l'</span><span class="main">≤</span><span class="free">u</span>"</span></span>
        <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="free">u</span><span class="main">-</span><span class="bound">l'</span><span class="main">)</span>"</span></span> 
      <span class="main"><span class="main">]</span></span>
      <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_Suc_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pop_impl</span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">lsi</span> <span class="main">=</span> length B <span class="main">-</span> <span class="main">1</span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">lsi</span><span class="main">&lt;</span>length B<span class="main">)</span><span class="main">;</span>
      <span class="bound">I</span> <span class="main">←</span> mark_as_done <span class="main">(</span>seg_start <span class="bound">lsi</span><span class="main">)</span> <span class="main">(</span>seg_end <span class="bound">lsi</span><span class="main">)</span> I<span class="main">;</span>
      ASSERT <span class="main">(</span>B<span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">S</span> <span class="main">=</span> take <span class="main">(</span>last B<span class="main">)</span> S<span class="main">;</span>
      ASSERT <span class="main">(</span>B<span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">B</span> <span class="main">=</span> butlast B<span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span>P<span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">sel_rem_last</span> <span class="main">≡</span> 
    <span class="keyword1">if</span> P<span class="main">=</span><span class="main">[]</span> <span class="keyword1">then</span> 
      RETURN <span class="main">(</span>None<span class="main">,</span><span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span>P<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">succs</span><span class="main">)</span> <span class="main">=</span> last P<span class="main">;</span>
      ASSERT <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span> <span class="main">&lt;</span> length B<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">if</span> <span class="bound">j</span> <span class="main">≥</span> seg_start <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="bound">succs</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">v</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span><span class="bound">succs</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">succs</span> <span class="main">=</span> <span class="bound">succs</span> <span class="main">-</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">;</span>
        ASSERT <span class="main">(</span>P<span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> length P <span class="main">-</span> <span class="main">1</span> <span class="main">&lt;</span> length P<span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">P</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">succs</span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> butlast P <span class="keyword1">else</span> P<span class="main">[</span>length P <span class="main">-</span> <span class="main">1</span> <span class="main">:=</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">succs</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">;</span>
        RETURN <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span><span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span>P<span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span> 


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_seg_impl</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">≡</span> find_max_nat <span class="main">(</span>length B<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> B<span class="main">!</span><span class="bound">i</span><span class="main">≤</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> find_seg_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length S <span class="main">⟹</span> find_seg_impl <span class="free">j</span> <span class="main">=</span> find_seg <span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_seg_impl_def
    <span class="keyword1"><span class="command">thm</span></span> find_max_nat_correct
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> find_max_nat_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> B0<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> B0<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_seg_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">idx_of_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span><span class="main">∃</span><span class="bound">i</span><span class="main">.</span> I <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">j</span> <span class="main">=</span> S_idx_of <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">j</span><span class="main">&lt;</span>length S<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> find_seg_impl <span class="bound">j</span><span class="main">;</span>
      RETURN <span class="bound">i</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span> 
      <span class="bound">i</span><span class="main">←</span>idx_of_impl <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span> <span class="main">≤</span> length B<span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">B</span> <span class="main">=</span> take <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> B<span class="main">;</span>
      RETURN <span class="main">(</span>S<span class="main">,</span><span class="bound">B</span><span class="main">,</span>I<span class="main">,</span>P<span class="main">)</span>
    <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> GS_initial_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> REL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">I</span><span class="main">,</span><span class="free">D</span><span class="main">)</span><span class="main">∈</span>oGS_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"GS.α <span class="main">(</span>GS_initial_impl <span class="free">I</span> <span class="free">v0</span> <span class="free">succs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">]</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">×</span><span class="free">succs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"GS_invar <span class="main">(</span>GS_initial_impl <span class="free">I</span> <span class="free">v0</span> <span class="free">succs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> REL <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">=</span> oGS_α <span class="free">I</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"oGS_invar <span class="free">I</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oGS_rel_def br_def<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> I <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">j</span> <span class="bound">v</span><span class="main">.</span> <span class="free">I</span> <span class="bound">v</span> <span class="main">≠</span> Some <span class="main">(</span>STACK <span class="bound">j</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oGS_invar_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS.α_def GS_initial_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>

    <span class="keyword1"><span class="command">unfolding</span></span> GS.p_α_def GS.seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> GS.seg_start_def GS.seg_end_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">unfolding</span></span> GS.D_α_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> oGS_α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command">unfolding</span></span> GS.pE_α_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS_initial_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> GS_invar
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> push_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>D_α"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"GS.α <span class="main">(</span>push_impl <span class="free">v</span> <span class="free">succs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>p_α<span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">,</span>D_α<span class="main">,</span>pE_α <span class="main">∪</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">×</span><span class="free">succs</span><span class="main">)</span>"</span></span> 
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"GS_invar <span class="main">(</span>push_impl <span class="free">v</span> <span class="free">succs</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Let_def

    <span class="keyword1"><span class="command">have</span></span> A1<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.D_α <span class="main">(</span>push_impl <span class="free">v</span> <span class="free">succs</span><span class="main">)</span> <span class="main">=</span> D_α"</span></span>
      <span class="keyword1"><span class="command">using</span></span> B
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> push_impl_def GS.D_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> iexI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">j</span> <span class="bound">P</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">a</span><span class="main">!</span><span class="bound">j</span> <span class="main">=</span> <span class="bound">b</span><span class="main">!</span><span class="bound">j</span><span class="main">;</span> <span class="bound">P</span> <span class="bound">j</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">j'</span><span class="main">.</span> <span class="bound">a</span><span class="main">!</span><span class="bound">j</span> <span class="main">=</span> <span class="bound">b</span><span class="main">!</span><span class="bound">j'</span> <span class="main">∧</span> <span class="bound">P</span> <span class="bound">j'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> A2<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span>push_impl <span class="free">v</span> <span class="free">succs</span><span class="main">)</span> <span class="main">=</span> p_α <span class="main">@</span> <span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> push_impl_def GS.p_α_def GS.seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
        GS.seg_start_def GS.seg_end_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="operator">rule</span> iexI<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">,</span></span> 
        <span class="main">(</span><span class="operator">auto</span>  
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append nat_in_between_eq 
          <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order.strict_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ B_in_bound'<span class="main"><span class="main">]</span></span>
        <span class="main">)</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="main">)</span> <span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> iexI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">j</span> <span class="bound">I</span> <span class="bound">Q</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">∈</span>set P<span class="main">;</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span><span class="main">∈</span>set P <span class="main">⟹</span> <span class="bound">Q</span> <span class="bound">j</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">j</span><span class="main">.</span> <span class="bound">Q</span> <span class="bound">j</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> A3<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.pE_α <span class="main">(</span>push_impl <span class="free">v</span> <span class="free">succs</span><span class="main">)</span> <span class="main">=</span> pE_α <span class="main">∪</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span> <span class="main">×</span> <span class="free">succs</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> push_impl_def GS.pE_α_def
      <span class="keyword1"><span class="command">using</span></span> P_bound
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> iexI2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> GS.α_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A1 A2 A3<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> push_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>

      <span class="keyword1"><span class="command">using</span></span> B_in_bound B_sorted B_distinct <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> B_in_bound B0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">S</span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> S_distinct A <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_p_α_is_set_S<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> A I_consistent 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append set_p_α_is_set_S <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      
      <span class="keyword1"><span class="command">using</span></span> P_sorted P_distinct P_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> no_last_out_P_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"p_α<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> NS<span class="main">:</span> <span class="quoted"><span class="quoted">"pE_α <span class="main">∩</span> last p_α <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set P <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>last B<span class="main">}</span> <span class="main">×</span> UNIV"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span> <span class="skolem">I</span>
      <span class="keyword3"><span class="command">assume</span></span> jII<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="skolem">I</span><span class="main">)</span><span class="main">∈</span>set P"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> JL<span class="main">:</span> <span class="quoted"><span class="quoted">"last B<span class="main">≤</span><span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> P_bound <span class="keyword1"><span class="command">have</span></span> JU<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="keyword2"><span class="keyword">and</span></span> INE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">I</span><span class="main">≠</span><span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> JL JU <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"S<span class="main">!</span><span class="skolem">j</span> <span class="main">∈</span> last p_α"</span></span>
        <span class="keyword1"><span class="command">using</span></span> NE
        <span class="keyword1"><span class="command">unfolding</span></span> p_α_def 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_map seg_def seg_start_def seg_end_def last_conv_nth<span class="main">)</span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> jII <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span>S<span class="main">!</span><span class="skolem">j</span><span class="main">}</span> <span class="main">×</span> <span class="skolem">I</span> <span class="main">⊆</span> pE_α"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> pE_α_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> INE NS
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> pop_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"p_α<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> NS<span class="main">:</span> <span class="quoted"><span class="quoted">"pE_α <span class="main">∩</span> last p_α <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pop_impl 
      <span class="main">≤</span> <span class="main">⇓</span>GS_rel <span class="main">(</span>SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span><span class="main">(</span>butlast p_α<span class="main">,</span> D_α <span class="main">∪</span> last p_α<span class="main">,</span> pE_α<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> iexI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">j</span> <span class="bound">P</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">a</span><span class="main">!</span><span class="bound">j</span> <span class="main">=</span> <span class="bound">b</span><span class="main">!</span><span class="bound">j</span><span class="main">;</span> <span class="bound">P</span> <span class="bound">j</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">j'</span><span class="main">.</span> <span class="bound">a</span><span class="main">!</span><span class="bound">j</span> <span class="main">=</span> <span class="bound">b</span><span class="main">!</span><span class="bound">j'</span> <span class="main">∧</span> <span class="bound">P</span> <span class="bound">j'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span> <span class="main">-</span> Suc <span class="main">0</span> <span class="main">≠</span> <span class="bound">n</span> <span class="main">⟷</span> <span class="bound">n</span><span class="main">≠</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> NE <span class="keyword1"><span class="command">have</span></span> BNE<span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">≠</span><span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>B<span class="main">!</span><span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length B"</span></span>
      <span class="keyword1"><span class="command">note</span></span> B
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> sorted_nth_mono<span class="main">[</span><span class="operator">OF</span> B_sorted<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="quoted">"length B <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> A 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"B<span class="main">!</span><span class="skolem">i</span> <span class="main">≤</span> last B"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> last B"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"take <span class="main">(</span>last B<span class="main">)</span> S <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> S <span class="main">!</span> <span class="skolem">j</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"take <span class="main">(</span>B<span class="main">!</span><span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> S <span class="main">!</span><span class="skolem">j</span> <span class="main">=</span> S<span class="main">!</span><span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth BNE<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">j</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>mark_as_done_abs 
              <span class="main">(</span>seg_start <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span>
              <span class="main">(</span>seg_end <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> I <span class="skolem">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">⟷</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">&lt;</span> length S <span class="main">∧</span> <span class="skolem">j</span> <span class="main">&lt;</span> last B <span class="main">∧</span> <span class="skolem">v</span> <span class="main">=</span> take <span class="main">(</span>last B<span class="main">)</span> S <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mark_as_done_abs_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> I_consistent
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span>
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_start_def seg_end_def last_conv_nth BNE
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> S_idx_uniq<span class="main">)</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> nth_take<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX2 <span class="main">=</span> this

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ci</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ci</span> <span class="main">=</span> <span class="main">(</span> 
      take <span class="main">(</span>last B<span class="main">)</span> S<span class="main">,</span> 
      butlast B<span class="main">,</span>
      mark_as_done_abs 
        <span class="main">(</span>seg_start <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>seg_end <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> I<span class="main">,</span>
      P<span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> ABS<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.α <span class="skolem">ci</span> <span class="main">=</span> <span class="main">(</span>butlast p_α<span class="main">,</span> D_α <span class="main">∪</span> last p_α<span class="main">,</span> pE_α<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.α_def ci_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>  
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> map_butlast
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_butlast<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> butlast_upt
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.p_α_def GS.seg_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> GS.seg_start_def GS.seg_end_def
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_butlast last_conv_nth nth_take AUX1
        <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> iexI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> order.strict_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ B_in_bound'<span class="main"><span class="main">]</span></span>
      <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.D_α_def p_α_def last_map BNE seg_def mark_as_done_abs_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> AUX1 no_last_out_P_aux<span class="main">[</span><span class="operator">OF</span> NE NS<span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.pE_α_def mark_as_done_abs_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bex2I<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="skolem">ci</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ci_def<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> B_in_bound B_sorted B_distinct 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">B</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_append order.strict_iff_order<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span> 

      <span class="keyword1"><span class="command">using</span></span> B_sorted BNE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_butlast<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> B_distinct BNE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_butlast<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> B0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">B</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BNE<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
   
      <span class="keyword1"><span class="command">using</span></span> S_distinct <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX2<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> P_sorted P_distinct 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> P_bound no_last_out_P_aux<span class="main">[</span><span class="operator">OF</span> NE NS<span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pop_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
        SPEC_refine <span class="dynamic"><span class="dynamic">refine_vcg</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> mark_as_done_aux<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> BNE seg_start_less_end seg_end_bound<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> ci_def<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> GS_rel_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ABS INV<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> sel_rem_last_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"p_α<span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"sel_rem_last <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> GS_rel<span class="main">)</span> <span class="main">(</span>select_edge <span class="main">(</span>p_α<span class="main">,</span>D_α<span class="main">,</span>pE_α<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="skolem">i</span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">b'</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">i</span><span class="main">&lt;</span>length <span class="skolem">l</span><span class="main">;</span> <span class="skolem">l</span><span class="main">!</span><span class="skolem">i</span><span class="main">=</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> map fst <span class="main">(</span><span class="skolem">l</span><span class="main">[</span><span class="skolem">i</span><span class="main">:=</span><span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> map fst <span class="skolem">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.split<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> map_fst_upd_snd_eq <span class="main">=</span> this

    <span class="keyword1"><span class="command">from</span></span> NE <span class="keyword1"><span class="command">have</span></span> BNE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> p_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> INVAR<span class="main">:</span> <span class="quoted"><span class="quoted">"sel_rem_last <span class="main">≤</span> SPEC <span class="main">(</span>GS_invar <span class="keyword1">o</span> snd<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> sel_rem_last_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> locale_this <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">SBIP</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> P_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">P</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> impI conjI<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> B_in_bound B_sorted B_distinct B0 S_distinct I_consistent 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>6<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> P_sorted P_distinct 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_butlast sorted_butlast distinct_butlast<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> P_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_set_butlastD<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">using</span></span> B_in_bound B_sorted B_distinct B0 S_distinct I_consistent 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>6<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> P_sorted P_distinct 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_conv_nth map_fst_upd_snd_eq<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> P_bound 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">P</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> locale_this <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">SBIP</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> NS<span class="main">:</span> <span class="quoted"><span class="quoted">"pE_α<span class="main">∩</span>last p_α<span class="main">×</span>UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"sel_rem_last 
        <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> <span class="main">(</span>None<span class="main">,</span><span class="bound">SBIP'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">SBIP'</span><span class="main">=</span><span class="free">SBIP</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> sel_rem_last_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">SBIP</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">using</span></span> P_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">P</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">using</span></span> no_last_out_P_aux<span class="main">[</span><span class="operator">OF</span> NE NS<span class="main">]</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_start_def last_conv_nth<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">SBIP</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> SPEC_E <span class="main">=</span> this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> NON_EMPTY<span class="main">:</span> <span class="quoted"><span class="quoted">"pE_α<span class="main">∩</span>last p_α<span class="main">×</span>UNIV <span class="main">≠</span> <span class="main">{}</span>"</span></span>

      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">succs</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        EFMT<span class="main">:</span> <span class="quoted"><span class="quoted">"P <span class="main">=</span> <span class="skolem">P'</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="skolem">succs</span><span class="main">)</span><span class="main">]</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pE_α_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted">P</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>
        
      <span class="keyword1"><span class="command">with</span></span> P_bound <span class="keyword1"><span class="command">have</span></span> J_UPPER<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="keyword2"><span class="keyword">and</span></span> SNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">succs</span><span class="main">≠</span><span class="main">{}</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">have</span></span> J_LOWER<span class="main">:</span> <span class="quoted"><span class="quoted">"seg_start <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span>seg_start <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">j</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> seg_start <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> P_sorted EFMT 
        <span class="keyword1"><span class="command">have</span></span> P_bound'<span class="main">:</span> <span class="quoted"><span class="quoted">"set P <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>seg_start <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">}</span> <span class="main">×</span> UNIV"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"pE_α <span class="main">∩</span> last p_α<span class="main">×</span>UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def last_conv_nth seg_def pE_α_def S_idx_uniq seg_end_def<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> NON_EMPTY <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">from</span></span> J_UPPER J_LOWER <span class="keyword1"><span class="command">have</span></span> SJL<span class="main">:</span> <span class="quoted"><span class="quoted">"S<span class="main">!</span><span class="skolem">j</span><span class="main">∈</span>last p_α"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> p_α_def seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> seg_end_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_map<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> EFMT <span class="keyword1"><span class="command">have</span></span> SSS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>S<span class="main">!</span><span class="skolem">j</span><span class="main">}</span><span class="main">×</span><span class="skolem">succs</span><span class="main">⊆</span>pE_α"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pE_α_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="skolem">succs</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> SJL SSS <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>S<span class="main">!</span><span class="skolem">j</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>pE_α <span class="main">∩</span> last p_α<span class="main">×</span>UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j'</span> <span class="skolem">succs'</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"S <span class="main">!</span> <span class="skolem">j'</span> <span class="main">=</span> S <span class="main">!</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">j'</span><span class="main">,</span> <span class="skolem">succs'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">P'</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> J_UPPER P_bound S_idx_uniq EFMT <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j'</span><span class="main">=</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> P_distinct <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">j'</span><span class="main">,</span> <span class="skolem">succs'</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">P'</span>›</span></span> EFMT <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX3<span class="main">=</span>this

        <span class="keyword1"><span class="command">have</span></span> G1<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.pE_α <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span><span class="skolem">P'</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">j</span><span class="main">,</span> <span class="skolem">succs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> pE_α <span class="main">-</span> <span class="main">{</span><span class="main">(</span>S<span class="main">!</span><span class="skolem">j</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> GS.pE_α_def <span class="keyword1"><span class="command">using</span></span> AUX3
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> EFMT<span class="main">)</span>
        
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">succs</span><span class="main">⊆</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"GS.pE_α <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span><span class="skolem">P'</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="skolem">j</span><span class="main">,</span> <span class="skolem">succs</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> GS.pE_α <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> GS.pE_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">with</span></span> G1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"GS.pE_α <span class="main">(</span>S<span class="main">,</span>B<span class="main">,</span>I<span class="main">,</span><span class="skolem">P'</span><span class="main">)</span> <span class="main">=</span> pE_α <span class="main">-</span> <span class="main">{</span><span class="main">(</span>S<span class="main">!</span><span class="skolem">j</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> G2 <span class="main">=</span> this

        <span class="keyword1"><span class="command">note</span></span> G G1 G2
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX3 <span class="main">=</span> this

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sel_rem_last <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
        <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span><span class="bound">SBIP'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">∃</span><span class="bound">u</span><span class="main">.</span> 
            <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>pE_α<span class="main">∩</span>last p_α<span class="main">×</span>UNIV<span class="main">)</span> 
          <span class="main">∧</span> GS.α <span class="bound">SBIP'</span> <span class="main">=</span> <span class="main">(</span>p_α<span class="main">,</span>D_α<span class="main">,</span>pE_α<span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
      <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> sel_rem_last_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>

        <span class="keyword1"><span class="command">using</span></span> SNE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> J_LOWER EFMT<span class="main">)</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> AUX3<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> AUX3<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> EFMT GS.α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> AUX3<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> SPEC_NE<span class="main">=</span>this

    <span class="keyword1"><span class="command">have</span></span> SPEC<span class="main">:</span> <span class="quoted"><span class="quoted">"sel_rem_last <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> 
        <span class="main">(</span>None<span class="main">,</span> <span class="bound">SBIP'</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">SBIP'</span> <span class="main">=</span> <span class="free">SBIP</span> <span class="main">∧</span> pE_α <span class="main">∩</span> last p_α <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span> <span class="main">∧</span> GS_invar <span class="free">SBIP</span>
      <span class="main">|</span> <span class="main">(</span>Some <span class="bound">v</span><span class="main">,</span> <span class="bound">SBIP'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">∃</span><span class="bound">u</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> pE_α <span class="main">∩</span> last p_α <span class="main">×</span> UNIV 
                        <span class="main">∧</span> GS.α <span class="bound">SBIP'</span> <span class="main">=</span> <span class="main">(</span>p_α<span class="main">,</span> D_α<span class="main">,</span> pE_α <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                        <span class="main">∧</span> GS_invar <span class="bound">SBIP'</span>
    <span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">using</span></span> INVAR
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"pE_α <span class="main">∩</span> last p_α <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> SPEC_E<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> SPEC_NE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>    
      
      
    <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">=</span>None <span class="main">⟶</span> <span class="skolem">Φ</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">y</span><span class="main">=</span>Some <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> <span class="skolem">Ψ</span> <span class="bound">y</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
      <span class="main">(</span><span class="skolem">Φ</span> None <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="skolem">Ψ</span> <span class="main">(</span>Some <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">Φ</span> <span class="skolem">Ψ</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SPEC<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> select_edge_def select_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> 
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> prod_rel_sv 
        <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> SELECT_pw
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> br_def GS_rel_def GS.α_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> find_seg_idx_of_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_seg <span class="main">(</span>S_idx_of <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> idx_of p_α <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> S_idx_of_correct<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> idx_of_props<span class="main">[</span><span class="operator">OF</span> p_α_disjoint_sym A<span class="main">]</span>
    <span class="keyword1"><span class="command">from</span></span> find_seg_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted"><span class="quoted">‹S_idx_of <span class="free"><span class="free">v</span></span> <span class="main"><span class="main">&lt;</span></span> length S›</span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"find_seg <span class="main">(</span>S_idx_of <span class="free">v</span><span class="main">)</span> <span class="main">&lt;</span> length p_α"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"S<span class="main">!</span>S_idx_of <span class="free">v</span> <span class="main">∈</span> p_α<span class="main">!</span>find_seg <span class="main">(</span>S_idx_of <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> idx_of_uniq<span class="main">[</span><span class="operator">OF</span> p_α_disjoint_sym this<span class="main">]</span> <span class="quoted"><span class="quoted">‹S <span class="main">!</span> S_idx_of <span class="free">v</span> <span class="main">=</span> <span class="free">v</span>›</span></span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> idx_of_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"idx_of_impl <span class="free">v</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">=</span>idx_of p_α <span class="free">v</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">&lt;</span>length B<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> idx_of_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> I_consistent in_set_conv_nth set_p_α_is_set_S<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> S_idx_of_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_seg_impl find_seg_idx_of_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> find_seg_correct<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> find_seg_impl<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> collapse_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"collapse_impl <span class="free">v</span> <span class="main">≤</span><span class="main">⇓</span>GS_rel <span class="main">(</span>SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>collapse <span class="free">v</span> α<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length p_α"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> ILEN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_α_def<span class="main">)</span>

      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?SBIP'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>S<span class="main">,</span> take <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> B<span class="main">,</span> I<span class="main">,</span> P<span class="main">)</span>"</span></span>

      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.seg_start <span class="var">?SBIP'</span> <span class="skolem">i</span> <span class="main">=</span> seg_start <span class="skolem">i</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.seg_start_def<span class="main">)</span>

        <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.seg_end <span class="var">?SBIP'</span> <span class="skolem">i</span> <span class="main">=</span> seg_end <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> ILEN <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.seg_end_def min_absorb2<span class="main">)</span>

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
          <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"seg_start <span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> seg_end <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="keyword1"><span class="command">using</span></span> ILEN seg_end_bound 
          <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword1"><span class="command">note</span></span> B<span class="main">(</span>2<span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length B›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">&lt;</span> length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> seg_end_bound<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> 
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"seg_end <span class="main">(</span>length B <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">≤</span> length S"</span></span> <span class="keyword1"><span class="command">.</span></span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">qed</span></span>

          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> find_seg <span class="skolem">j</span> <span class="main">∧</span> find_seg <span class="skolem">j</span> <span class="main">&lt;</span> length B 
            <span class="main">∧</span> seg_start <span class="main">(</span>find_seg <span class="skolem">j</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">j</span> <span class="main">∧</span> <span class="skolem">j</span> <span class="main">&lt;</span> seg_end <span class="main">(</span>find_seg <span class="skolem">j</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≤</span>find_seg <span class="skolem">j</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le_trans not_less B<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> find_seg_bounds<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
                seg_end_less_start ILEN <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> length S›</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> find_seg_bounds<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem"><span class="skolem">j</span></span></span><span class="main"><span class="main"><span class="main">&lt;</span></span></span>length S›</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1 <span class="main">=</span> this

        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">Q</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">j</span><span class="main">::</span><span class="quoted">nat</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">Q</span> <span class="skolem">j</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> S<span class="main">!</span><span class="skolem">j</span> <span class="main">=</span> S<span class="main">!</span><span class="bound">i</span> <span class="main">∧</span> <span class="skolem">Q</span> <span class="bound">i</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_ex_conj_SeqSI <span class="main">=</span> this

        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"GS.seg <span class="var">?SBIP'</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">⋃</span> <span class="main">(</span>seg <span class="main">`</span> <span class="main">{</span><span class="skolem">i</span><span class="main">..&lt;</span>length B<span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> GS.seg_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

          <span class="comment1">(* The following three lines complete the proof. AUX_ex_conj_SeqSI
            and all stuff 
            below would be unnecessary, if smt would be allowed for AFP.
          apply (auto simp: seg_start_def seg_end_def split: if_split_asm)
          apply (smt distinct_sorted_mono[OF B_sorted B_distinct])
          apply (smt distinct_sorted_mono[OF B_sorted B_distinct] B_in_bound')
          *)</span>

          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_start_def seg_end_def 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
            <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX_ex_conj_SeqSI
          <span class="main">)</span>

         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> diff_diff_cancel le_diff_conv le_eq_less_or_eq 
           lessI trans_le_add1 
           distinct_sorted_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> B_sorted B_distinct<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> diff_diff_cancel le_diff_conv le_eq_less_or_eq 
           trans_le_add1 distinct_sorted_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> B_sorted B_distinct<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>hide_lams<span class="main"><span class="main">,</span></span> no_types<span class="main"><span class="main">)</span></span> Suc_lessD Suc_lessI less_trans_Suc
           B_in_bound'<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX2 <span class="main">=</span> this
      
      <span class="keyword1"><span class="command">from</span></span> ILEN <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span>S<span class="main">,</span> take <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> B<span class="main">,</span> I<span class="main">,</span> P<span class="main">)</span> <span class="main">=</span> collapse_aux p_α <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> GS.p_α_def collapse_aux_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> min_absorb2 drop_map<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.seg_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> GS.seg_start_def GS.seg_end_def take_map<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> AUX2<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1 <span class="main">=</span> this

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="free">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> I_consistent set_p_α_is_set_S
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>collapse_aux p_α <span class="main">(</span>idx_of p_α <span class="free">v</span><span class="main">)</span><span class="main">,</span> D_α<span class="main">,</span> pE_α<span class="main">)</span> <span class="main">=</span>
        GS.α <span class="main">(</span>S<span class="main">,</span> take <span class="main">(</span>Suc <span class="main">(</span>idx_of p_α <span class="free">v</span><span class="main">)</span><span class="main">)</span> B<span class="main">,</span> I<span class="main">,</span> P<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> GS.α_def
      <span class="keyword1"><span class="command">using</span></span> idx_of_props<span class="main">[</span><span class="operator">OF</span> p_α_disjoint_sym A<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> ABS<span class="main">=</span>this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"GS_invar <span class="main">(</span>S<span class="main">,</span> take <span class="main">(</span>Suc <span class="main">(</span>idx_of p_α <span class="free">v</span><span class="main">)</span><span class="main">)</span> B<span class="main">,</span> I<span class="main">,</span> P<span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>

        <span class="keyword1"><span class="command">using</span></span> B_in_bound B_sorted B_distinct
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_take <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_set_takeD<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> B0 S_distinct <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> I_consistent <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

        <span class="keyword1"><span class="command">using</span></span> P_sorted P_distinct P_bound <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> INV<span class="main">=</span>this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> collapse_impl_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> SPEC_refine <span class="dynamic"><span class="dynamic">refine_vcg</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> idx_of_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> discrete<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_def α_def find_seg_impl<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> GS_rel_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> brI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ABS<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> INV<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Technical adjustment for avoiding case-splits for definitions
  extracted from GS-locale›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> opt_GSdef<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">≡</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">s</span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free">s</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">g</span> <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> ext_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">≡</span><span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≡</span> <span class="free">g</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> fr_graph <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">push_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.push_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">lemmas</span></span> push_impl_def_opt <span class="main">=</span> 
    push_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> 
    <span class="operator">THEN</span> ext_def<span class="main">,</span> <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> <span class="operator">unfolded</span> GS.push_impl_def GS_sel_simps<span class="main">]</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition for presentation›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"push_impl <span class="free">v</span> <span class="main">(</span><span class="free">S</span><span class="main">,</span><span class="free">B</span><span class="main">,</span><span class="free">I</span><span class="main">,</span><span class="free">P</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">S</span><span class="main">@</span><span class="main">[</span><span class="free">v</span><span class="main">]</span><span class="main">,</span> <span class="free">B</span><span class="main">@</span><span class="main">[</span>length <span class="free">S</span><span class="main">]</span><span class="main">,</span> <span class="free">I</span><span class="main">(</span><span class="free">v</span><span class="main">↦</span>STACK <span class="main">(</span>length <span class="free">S</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
    <span class="keyword1">if</span> E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">=</span><span class="main">{}</span> <span class="keyword1">then</span> <span class="free">P</span> <span class="keyword1">else</span> <span class="free">P</span><span class="main">@</span><span class="main">[</span><span class="main">(</span>length <span class="free">S</span><span class="main">,</span>E<span class="main">``</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_impl_def GS.push_impl_def GS.P_def GS.S_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> GS_α_split<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"GS.α <span class="free">s</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> <span class="main">=</span> GS.α <span class="free">s</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.α_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> push_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>push_impl <span class="free">v</span> <span class="free">s</span><span class="main">,</span> push <span class="free">v'</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_α_split<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV B <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_invar.push_correct push_impl_def push_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pop_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.pop_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> pop_impl_def_opt <span class="main">=</span> 
    pop_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> <span class="operator">unfolded</span> GS.pop_impl_def
    GS.mark_as_done_def GS.seg_start_def GS.seg_end_def 
    GS_sel_simps<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> pop_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"pop_impl <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span>GS_rel <span class="main">(</span>RETURN <span class="main">(</span>pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_α_split<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pop_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> pop_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> GS_invar.pop_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> INV B
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Un_commute RETURN_def<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">thm</span></span> pop_refine<span class="main">[</span><span class="operator">no_vars</span><span class="main">]</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">collapse_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.collapse_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> collapse_impl_def_opt <span class="main">=</span> 
    collapse_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> 
    <span class="operator">THEN</span> ext_def<span class="main">,</span> <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> <span class="operator">unfolded</span> GS.collapse_impl_def GS_sel_simps<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> collapse_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"collapse_impl <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span><span class="main">⇓</span>GS_rel <span class="main">(</span>RETURN <span class="main">(</span>collapse <span class="free">v'</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_α_split<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> collapse_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> GS_invar.collapse_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> INV B <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.α_def RETURN_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">select_edge_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.sel_rem_last <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> select_edge_impl_def_opt <span class="main">=</span> 
    select_edge_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> 
      <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> 
      <span class="operator">unfolded</span> GS.sel_rem_last_def GS.seg_start_def GS_sel_simps<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> select_edge_refine<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"select_edge_impl <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> GS_rel<span class="main">)</span> <span class="main">(</span>select_edge <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_α_split<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV NE <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> select_edge_impl_def
      <span class="keyword1"><span class="command">using</span></span> GS_invar.sel_rem_last_correct<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> NE
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial_impl</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">≡</span> GS_initial_impl <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span>E<span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> initial_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">v0</span><span class="main">∉</span><span class="free">D0</span><span class="main">;</span> <span class="main">(</span><span class="free">I</span><span class="main">,</span><span class="free">D0</span><span class="main">)</span><span class="main">∈</span>oGS_rel<span class="main">;</span> <span class="main">(</span><span class="free">v0i</span><span class="main">,</span><span class="free">v0</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">(</span>initial_impl <span class="free">v0i</span> <span class="free">I</span><span class="main">,</span>initial <span class="free">v0</span> <span class="free">D0</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> initial_impl_def GS_rel_def br_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_initial_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> initial_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">path_is_empty_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.S <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> path_is_empty_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span> <span class="main">⟹</span> path_is_empty_impl <span class="free">s</span> <span class="main">⟷</span> GS.p_α <span class="free">s</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> path_is_empty_impl_def GS.p_α_def GS_invar.empty_eq
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">is_on_stack_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
    <span class="main">≡</span> <span class="keyword1">case</span> I <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> Some <span class="main">(</span>STACK <span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> is_on_stack_impl_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_on_stack_impl <span class="free">v</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set p_α<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_on_stack_impl_def
    <span class="keyword1"><span class="command">using</span></span> I_consistent<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_p_α_is_set_S in_set_conv_nth 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split node_state.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_on_stack_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.is_on_stack_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> is_on_stack_impl_def_opt <span class="main">=</span> 
    is_on_stack_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">THEN</span> ext_def<span class="main">,</span> <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> 
      <span class="operator">unfolded</span> GS.is_on_stack_impl_def GS_sel_simps<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> is_on_stack_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> GS_invar <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> is_on_stack_impl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>GS.p_α <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_on_stack_impl_def GS_rel_def br_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_invar.is_on_stack_impl_correct<span class="main">)</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">is_done_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> 
    <span class="main">≡</span> <span class="keyword1">case</span> I <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> Some DONE <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> is_done_impl_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_done_impl <span class="free">v</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span>D_α"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_done_impl_def D_α_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split node_state.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_done_oimpl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> Some DONE <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_done_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.is_done_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> is_done_orefine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> oGS_invar <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> is_done_oimpl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span>oGS_α <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_done_oimpl_def oGS_rel_def br_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> oGS_invar_def oGS_α_def 
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits node_state.split<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> is_done_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> GS_invar <span class="free">s</span> <span class="main">⟧</span> <span class="main">⟹</span> is_done_impl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span>GS.D_α <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_done_impl_def GS_rel_def br_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_invar.is_done_impl_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> oinitial_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Map.empty<span class="main">,</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∈</span> oGS_rel"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> oGS_rel_def br_def oGS_α_def oGS_invar_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refined Skeleton Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> I_to_outer<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span><span class="main">,</span> <span class="free">B</span><span class="main">,</span> <span class="free">I</span><span class="main">,</span> <span class="free">P</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> GS_rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">I</span><span class="main">,</span><span class="free">D</span><span class="main">)</span><span class="main">∈</span>oGS_rel"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> GS_rel_def oGS_rel_def br_def oGS_α_def GS.α_def GS.D_α_def GS_invar_def oGS_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.p_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">skeleton_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> oGS nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">skeleton_impl</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      stat_start_nres<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">I</span><span class="main">=</span>Map.empty<span class="main">;</span>
      <span class="bound">r</span> <span class="main">←</span> FOREACHi <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">I</span><span class="main">.</span> outer_invar <span class="bound">it</span> <span class="main">(</span>oGS_α <span class="bound">I</span><span class="main">)</span><span class="main">)</span> V0 <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">I0</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> <span class="main">¬</span>is_done_oimpl <span class="bound">v0</span> <span class="bound">I0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> initial_impl <span class="bound">v0</span> <span class="bound">I0</span><span class="main">;</span>

          <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">←</span>WHILEIT <span class="main">(</span>invar <span class="bound">v0</span> <span class="main">(</span>oGS_α <span class="bound">I0</span><span class="main">)</span> <span class="keyword1">o</span> GS.α<span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span>path_is_empty_impl <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span>
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="comment1">― ‹Select edge from end of path›</span>
            <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> select_edge_impl <span class="bound">s</span><span class="main">;</span>

            <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
              Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">if</span> is_on_stack_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  collapse_impl <span class="bound">v</span> <span class="bound">s</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span>is_done_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to new node. Append to path›</span>
                  RETURN <span class="main">(</span>push_impl <span class="bound">v</span> <span class="bound">s</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to done node. Skip›</span>
                  RETURN <span class="bound">s</span>
                <span class="main">}</span>
              <span class="main">}</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                pop_impl <span class="bound">s</span>
              <span class="main">}</span>
          <span class="main">}</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
          RETURN <span class="bound">I</span>
        <span class="main">}</span> <span class="keyword1">else</span>
          RETURN <span class="bound">I0</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">I</span><span class="main">;</span>
      stat_stop_nres<span class="main">;</span>
      RETURN <span class="bound">r</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Theorem›</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"skeleton_impl <span class="main">≤</span> <span class="main">⇓</span>oGS_rel skeleton"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> skeleton_impl_def skeleton_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
      bind_refine'
      select_edge_refine push_refine 
      pop_refine
      collapse_refine 
      initial_refine
      oinitial_refine
      inj_on_id
    <span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 5<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>  

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl I_to_outer
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def oGS_rel_def oGS_α_def 
      is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine
    <span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> skeleton_refines 
    <span class="main">=</span> select_edge_refine push_refine pop_refine collapse_refine 
      initial_refine oinitial_refine
  <span class="keyword1"><span class="command">lemmas</span></span> skeleton_refine_simps 
    <span class="main">=</span> GS_rel_def br_def GS.α_def oGS_rel_def oGS_α_def 
      is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Short proof, for presentation›</span></span>
  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> inj_on_id bind_refine'
  <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"skeleton_impl <span class="main">≤</span> <span class="main">⇓</span>oGS_rel skeleton"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> skeleton_impl_def skeleton_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span> skeleton_refines<span class="main"><span class="keyword3">,</span></span> <span class="operator">refine_dref_type</span><span class="main">)</span>
       <span class="main">(</span><span class="operator">vc_solve</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl I_to_outer <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> skeleton_refine_simps<span class="main">)</span>  

  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Gabow_SCC">
<div class="head">
<h1>Theory Gabow_SCC</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Enumerating the SCCs of a Graph \label{sec:scc}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_SCC
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Gabow_Skeleton.html">Gabow_Skeleton</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As a first variant, we implement an algorithm that computes a list of SCCs 
  of a graph, in topological order. This is the standard variant described by
  Gabow~\cite{Gabow2000}.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Specification›</span></span>
<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We specify a distinct list that covers all reachable nodes and
    contains SCCs in topological order›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_SCC_spec</span> <span class="main">≡</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> 
    distinct <span class="bound">l</span> <span class="main">∧</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">l</span><span class="main">)</span> <span class="main">=</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0 <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">U</span><span class="main">∈</span>set <span class="bound">l</span><span class="main">.</span> is_scc E <span class="bound">U</span><span class="main">)</span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span>length <span class="bound">l</span> <span class="main">⟶</span> <span class="bound">l</span><span class="main">!</span><span class="bound">j</span> <span class="main">×</span> <span class="bound">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Extended Invariant›</span></span>

<span class="keyword1"><span class="command">locale</span></span> cscc_invar_ext <span class="main">=</span> fr_graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="main">+</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> l_is_D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">l</span><span class="main">)</span> <span class="main">=</span> <span class="free">D</span>"</span></span> <span class="comment1">― ‹The output contains all done CNodes›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> l_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">l</span> <span class="main">⊆</span> Collect <span class="main">(</span>is_scc E<span class="main">)</span>"</span></span> <span class="comment1">― ‹The output contains only SCCs›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> l_no_fwd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">i</span><span class="main">&lt;</span><span class="bound">j</span><span class="main">;</span> <span class="bound">j</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="bound">j</span> <span class="main">×</span> <span class="free">l</span><span class="main">!</span><span class="bound">i</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="comment1">― ‹The output contains no forward edges›</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> l_no_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{}</span><span class="main">∉</span>set <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> l_scc <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_decomp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
  
<span class="keyword1"><span class="command">locale</span></span> cscc_outer_invar_loc <span class="main">=</span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">D</span></span> <span class="main">+</span> cscc_invar_ext <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">D</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">it</span> <span class="free">l</span> <span class="free">D</span> 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_outer_invar_loc <span class="free">G</span> <span class="free">it</span> <span class="free">l</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">lemma</span></span> abs_outer_this<span class="main">:</span> <span class="quoted"><span class="quoted">"outer_invar_loc <span class="free">G</span> <span class="free">it</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> cscc_invar_loc <span class="main">=</span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="main">+</span> cscc_invar_ext <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">D</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">v0</span> <span class="free">D0</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">l</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">lemma</span></span> invar_this<span class="main">:</span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cscc_outer_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span><span class="main">.</span> cscc_outer_invar_loc <span class="free">G</span> <span class="bound">it</span> <span class="bound">l</span> <span class="bound">D</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cscc_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">v0</span> <span class="bound">D0</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> cscc_invar_loc <span class="free">G</span> <span class="bound">v0</span> <span class="bound">D0</span> <span class="bound">l</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Definition of the SCC-Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">compute_SCC</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">compute_SCC</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">so</span> <span class="main">=</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span> <span class="main">←</span> FOREACHi cscc_outer_invar V0 <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D0</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> <span class="bound">v0</span><span class="main">∉</span><span class="bound">D0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>initial <span class="bound">v0</span> <span class="bound">D0</span><span class="main">)</span><span class="main">;</span>

          <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">←</span>
          WHILEIT <span class="main">(</span>cscc_invar <span class="bound">v0</span> <span class="bound">D0</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="bound">p</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> 
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="comment1">― ‹Select edge from end of path›</span>
            <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> select_edge <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

            ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
              Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">p</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Collapse›</span>
                  RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span>collapse <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">D</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to new node. Append to path›</span>
                  RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span>push <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
              <span class="main">}</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                ASSERT <span class="main">(</span><span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
                <span class="keyword1">let</span> <span class="bound">V</span> <span class="main">=</span> last <span class="bound">p</span><span class="main">;</span>
                <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> pop <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>
                <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> <span class="bound">V</span><span class="main">#</span><span class="bound">l</span><span class="main">;</span>
                RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
              <span class="main">}</span>
          <span class="main">}</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
          ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="bound">pE</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
          RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span>
          RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D0</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">so</span><span class="main">;</span>
      RETURN <span class="bound">l</span>
    <span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Preservation of Invariant Extension›</span></span>
<span class="keyword1"><span class="command">context</span></span> cscc_invar_ext
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> l_disjoint<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span><span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>length <span class="free">l</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">!</span><span class="free">i</span> <span class="main">∩</span> <span class="free">l</span><span class="main">!</span><span class="free">j</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjointI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">l</span><span class="main">!</span><span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">l</span><span class="main">!</span><span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> l_no_fwd A <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">corollary</span></span> l_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> l_disjoint l_no_empty
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> distinct_conv_nth inf_idem linorder_cases nth_mem<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">cscc_invar_part</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> cscc_invar_ext <span class="free">G</span> <span class="bound">l</span> <span class="bound">D</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_invarI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span> <span class="main">⟹</span> cscc_invar_part <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> initial_def cscc_invar_def invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_loc_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cscc_invar_part_def cscc_invar_ext_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">thm</span></span> cscc_invarI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v_0</span></span> <span class="quoted"><span class="free">D_0</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_outer_invarI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"outer_invar <span class="free">it</span> <span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"outer_invar <span class="free">it</span> <span class="free">D</span> <span class="main">⟹</span> cscc_invar_ext <span class="free">G</span> <span class="free">l</span> <span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> initial_def cscc_outer_invar_def outer_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> outer_invar_loc_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cscc_invar_ext_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_invar_initial<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_part <span class="main">(</span><span class="free">l</span><span class="main">,</span>initial <span class="free">v0</span> <span class="free">D0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> cscc_outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">D0</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_outer_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_part_def initial_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_invar_pop<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NO'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_part <span class="main">(</span>last <span class="free">p</span> <span class="main">#</span> <span class="free">l</span><span class="main">,</span> pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> cscc_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> AUX_l_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"is_scc E <span class="main">(</span>last <span class="free">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_scc_pointwise
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> 
          <span class="keyword1"><span class="command">using</span></span> p_no_empty <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">}</span></span>

      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> p_sc<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> lvE_ss_E <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_mono equalityE rtrancl_mono_mp<span class="main">)</span>
      
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u'</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∉</span>last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u'</span><span class="main">∉</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> rtrancl_reachable_induct<span class="main">[</span><span class="operator">OF</span> order_refl lastp_un_D_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> NE NO'<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u'</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> rtrancl_reachable_induct<span class="main">[</span><span class="operator">OF</span> order_refl D_closed<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> p_not_D <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="skolem">j</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span><span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>Suc <span class="main">(</span>length <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjointI<span class="main"><span class="keyword3">,</span></span> <span class="operator">safe</span><span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">v</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="free">l</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> <span class="free">l</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span>›</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">l</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ex_list_of_length Suc_pred UnionI length_greater_0_conv 
            less_nat_zero_code not_less_eq nth_mem<span class="main">)</span> 
        <span class="keyword1"><span class="command">with</span></span> l_is_D <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> rtrancl_reachable_induct<span class="main">[</span><span class="operator">OF</span> order_refl D_closed<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">=</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∈</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">with</span></span> p_not_D <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">D</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">≠</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span> <span class="main">∈</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">#</span> <span class="free">l</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">l</span><span class="main">!</span><span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> l_no_fwd<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span> <span class="main">∈</span> <span class="free">l</span> <span class="main">!</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">≠</span><span class="main">0</span>›</span></span> A
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_l_no_fwd <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_part_def pop_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
      <span class="keyword1"><span class="command">using</span></span> l_is_D <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> l_scc AUX_l_scc <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> AUX_l_no_fwd<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">thm</span></span> cscc_invar_pop<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v_0</span></span> <span class="quoted"><span class="free">D_0</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_invar_unchanged<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_part <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">p'</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_def cscc_invar_part_def cscc_invar_loc_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">corollary</span></span> cscc_invar_collapse<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_part <span class="main">(</span><span class="free">l</span><span class="main">,</span>collapse <span class="free">v</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cscc_invar_unchanged<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">corollary</span></span> cscc_invar_push<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_part <span class="main">(</span><span class="free">l</span><span class="main">,</span>push <span class="free">v</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cscc_invar_unchanged<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">]</span></span><span class="main">)</span>


  <span class="keyword1"><span class="command">lemma</span></span> cscc_outer_invar_initial<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar_ext <span class="free">G</span> <span class="main">[]</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">lemma</span></span> cscc_invar_outer_newnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">l'</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_ext <span class="free">G</span> <span class="free">l'</span> <span class="free">D'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">interpret</span></span> cscc_outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">D0</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_outer_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> inv<span class="main">:</span> cscc_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">l'</span></span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">D'</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> cscc_invar_outer_Dnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cscc_invar_ext <span class="free">G</span> <span class="free">l</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cscc_outer_invar_def cscc_outer_invar_loc_def<span class="main">)</span>
    
  <span class="keyword1"><span class="command">lemmas</span></span> cscc_invar_preserve <span class="main">=</span> invar_preserve
    cscc_invar_initial
    cscc_invar_pop cscc_invar_collapse cscc_invar_push cscc_invar_unchanged 
    cscc_outer_invar_initial cscc_invar_outer_newnode cscc_invar_outer_Dnode

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹On termination, the invariant implies the specification›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> cscc_finI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="main">{}</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> fin_l_is_scc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">U</span><span class="main">∈</span>set <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> is_scc E <span class="free">U</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> fin_l_distinct<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> fin_l_is_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">l</span><span class="main">)</span> <span class="main">=</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> V0"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> fin_l_no_fwd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span><span class="free">j</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="free">j</span> <span class="main">×</span><span class="free">l</span><span class="main">!</span><span class="free">i</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> cscc_outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="quoted">"<span class="main">{}</span>"</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">D</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cscc_outer_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">U</span><span class="main">∈</span>set <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> is_scc E <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> l_scc <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_distinct<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">l</span><span class="main">)</span> <span class="main">=</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> V0"</span></span>
      <span class="keyword1"><span class="command">using</span></span> fin_outer_D_is_reachable<span class="main">[</span><span class="operator">OF</span> outer_invar_this<span class="main">]</span> l_is_D
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">i</span><span class="main">&lt;</span><span class="free">j</span><span class="main">;</span> <span class="free">j</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">l</span><span class="main">!</span><span class="free">j</span> <span class="main">×</span><span class="free">l</span><span class="main">!</span><span class="free">i</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> l_no_fwd<span class="main">)</span>

  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Main Correctness Proof›</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> invar_from_cscc_invarI<span class="main">:</span> <span class="quoted"><span class="quoted">"cscc_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span> <span class="main">⟹</span> invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_def invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cscc_invar_loc_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> outer_invar_from_cscc_invarI<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"cscc_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">L</span><span class="main">,</span><span class="free">D</span><span class="main">)</span> <span class="main">⟹</span>outer_invar <span class="free">it</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cscc_outer_invar_def outer_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> cscc_outer_invar_loc_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹With the extended invariant and the auxiliary lemmas, the actual 
    correctness proof is straightforward:›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> compute_SCC_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"compute_SCC <span class="main">≤</span> compute_SCC_spec"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 2<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> Union_iff

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> compute_SCC_def compute_SCC_spec_def select_edge_def select_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
        WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>abs_wf_rel <span class="skolem">v0</span><span class="main">)</span> snd"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">v0</span><span class="main"><span class="main">]</span></span>
        <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      <span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span>
        <span class="quasi_keyword">rec</span><span class="main"><span class="main">:</span></span> cscc_invarI cscc_outer_invarI
        <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> cscc_invar_preserve cscc_finI
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> invar_from_cscc_invarI outer_invar_from_cscc_invarI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sym<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"pop <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">A</span><span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pE_fin'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invar_from_cscc_invarI<span class="main"><span class="main">]</span></span> finite_V0
      <span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Simple proof, for presentation›</span></span>
  <span class="keyword1"><span class="command">context</span></span> 
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">=</span><span class="dynamic"><span class="dynamic">refine_vcg</span></span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">theorem</span></span> <span class="quoted"><span class="quoted">"compute_SCC <span class="main">≤</span> compute_SCC_spec"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> compute_SCC_def compute_SCC_spec_def select_edge_def select_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
        WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>abs_wf_rel <span class="skolem">v0</span><span class="main">)</span> snd"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">v0</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">vc_solve</span> 
        <span class="quasi_keyword">rec</span><span class="main"><span class="main">:</span></span> cscc_invarI cscc_outer_invarI <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> cscc_invar_preserve cscc_finI
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> invar_from_cscc_invarI outer_invar_from_cscc_invarI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sym<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"pop <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">A</span><span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pE_fin'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invar_from_cscc_invarI<span class="main"><span class="main">]</span></span> finite_V0<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Gabow's Data Structure›</span></span>

<span class="keyword1"><span class="command">context</span></span> GS <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">seg_set_impl</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> WHILET
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">l</span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> 
        ASSERT <span class="main">(</span><span class="bound">l</span><span class="main">&lt;</span>length S<span class="main">)</span><span class="main">;</span> 
        <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> S<span class="main">!</span><span class="bound">l</span><span class="main">;</span>
        ASSERT <span class="main">(</span><span class="bound">x</span><span class="main">∉</span><span class="bound">res</span><span class="main">)</span><span class="main">;</span> 
        RETURN <span class="main">(</span>Suc <span class="bound">l</span><span class="main">,</span>insert <span class="bound">x</span> <span class="bound">res</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> 
      <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
      
    RETURN <span class="bound">res</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> seg_set_impl_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">l</span> <span class="free">u</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">l</span><span class="main">&lt;</span><span class="free">u</span><span class="main">;</span> <span class="free">u</span><span class="main">≤</span>length S<span class="main">;</span> distinct S<span class="main">⟧</span> <span class="main">⟹</span> seg_set_impl <span class="free">l</span> <span class="free">u</span> 
    <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> <span class="main">{</span>S<span class="main">!</span><span class="bound">j</span> <span class="main">|</span> <span class="bound">j</span><span class="main">.</span> <span class="free">l</span><span class="main">≤</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> seg_set_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
      WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> <span class="bound">res</span> <span class="main">=</span> <span class="main">{</span>S<span class="main">!</span><span class="bound">j</span> <span class="main">|</span> <span class="bound">j</span><span class="main">.</span> <span class="free">l</span><span class="main">≤</span><span class="bound">j</span> <span class="main">∧</span> <span class="bound">j</span><span class="main">&lt;</span><span class="bound">l'</span><span class="main">}</span> <span class="main">∧</span> <span class="free">l</span><span class="main">≤</span><span class="bound">l'</span> <span class="main">∧</span> <span class="bound">l'</span><span class="main">≤</span><span class="free">u</span>"</span></span>
        <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="free">u</span><span class="main">-</span><span class="bound">l'</span><span class="main">)</span>"</span></span> 
      <span class="main"><span class="main">]</span></span>
      <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> less_Suc_eq nth_eq_iff_index_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> seg_set_impl_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length B"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"seg_set_impl <span class="main">(</span>seg_start <span class="free">i</span><span class="main">)</span> <span class="main">(</span>seg_end <span class="free">i</span><span class="main">)</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>p_α<span class="main">!</span><span class="free">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> seg_set_impl_aux<span class="main"><span class="main">]</span></span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">using</span></span> assms 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> seg_start_less_end seg_end_bound S_distinct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def assms seg_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">last_seg_impl</span> 
    <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span> <span class="main">&lt;</span> length B<span class="main">)</span><span class="main">;</span>
      seg_set_impl <span class="main">(</span>seg_start <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>seg_end <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> last_seg_impl_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"p_α <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"last_seg_impl <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span>last p_α<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> last_seg_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> seg_set_impl_correct<span class="main"><span class="main">]</span></span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p_α_def last_conv_nth<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">last_seg_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> GS.last_seg_impl <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> last_seg_impl_def_opt <span class="main">=</span> 
    last_seg_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> 
      <span class="operator">unfolded</span> GS.last_seg_impl_def GS.seg_set_impl_def 
    GS.seg_start_def GS.seg_end_def GS_sel_simps<span class="main">]</span> 
    <span class="comment1">(* TODO: Some potential for optimization here: the assertion 
      guarantees that length B - 1 + 1 = length B !*)</span>

  <span class="keyword1"><span class="command">lemma</span></span> last_seg_impl_refine<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"last_seg_impl <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>RETURN <span class="main">(</span>last <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span>GS.p_α <span class="free">s</span> <span class="main">∧</span> <span class="free">D</span><span class="main">=</span>GS.D_α <span class="free">s</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span>GS.pE_α <span class="free">s</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS_α_split<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> last_seg_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> GS_invar.last_seg_impl_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> INV NE
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">compute_SCC_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set list nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">compute_SCC_impl</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      stat_start_nres<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">so</span> <span class="main">=</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span>Map.empty<span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span> <span class="main">←</span> FOREACHi <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> cscc_outer_invar <span class="bound">it</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>oGS_α <span class="bound">s</span><span class="main">)</span><span class="main">)</span> 
        V0 <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I0</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> <span class="main">¬</span>is_done_oimpl <span class="bound">v0</span> <span class="bound">I0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">let</span> <span class="bound">ls</span> <span class="main">=</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>initial_impl <span class="bound">v0</span> <span class="bound">I0</span><span class="main">)</span><span class="main">;</span>

            <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">)</span><span class="main">←</span>WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> cscc_invar <span class="bound">v0</span> <span class="main">(</span>oGS_α <span class="bound">I0</span><span class="main">)</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>GS.α <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
              <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span>path_is_empty_impl <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span>
            <span class="keyword1">do</span> <span class="main">{</span>
              <span class="comment1">― ‹Select edge from end of path›</span>
              <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> select_edge_impl <span class="bound">s</span><span class="main">;</span>

              <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
                Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">if</span> is_on_stack_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="bound">s</span><span class="main">←</span>collapse_impl <span class="bound">v</span> <span class="bound">s</span><span class="main">;</span>
                    RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
                  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span>is_done_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="comment1">― ‹Edge to new node. Append to path›</span>
                    RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span>push_impl <span class="bound">v</span> <span class="bound">s</span><span class="main">)</span>
                  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="comment1">― ‹Edge to done node. Skip›</span>
                    RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
                  <span class="main">}</span>
                <span class="main">}</span>
              <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                  <span class="bound">scc</span> <span class="main">←</span> last_seg_impl <span class="bound">s</span><span class="main">;</span>
                  <span class="bound">s</span><span class="main">←</span>pop_impl <span class="bound">s</span><span class="main">;</span>
                  <span class="keyword1">let</span> <span class="bound">l</span> <span class="main">=</span> <span class="bound">scc</span><span class="main">#</span><span class="bound">l</span><span class="main">;</span>
                  RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
                <span class="main">}</span>
            <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">ls</span><span class="main">)</span><span class="main">;</span>
            RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I</span><span class="main">)</span>
          <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">I0</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">so</span><span class="main">;</span>
      stat_stop_nres<span class="main">;</span>
      RETURN <span class="bound">l</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> compute_SCC_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"compute_SCC_impl <span class="main">≤</span> <span class="main">⇓</span>Id compute_SCC"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine2</span><span class="main">]</span> <span class="main">=</span> bind_Let_refine2<span class="main">[</span><span class="operator">OF</span> last_seg_impl_refine<span class="main">]</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s'</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span> <span class="bound">l'</span> <span class="bound">l</span> <span class="bound">v'</span> <span class="bound">v</span><span class="main">.</span> <span class="main">⟦</span>
      <span class="main">(</span><span class="bound">s'</span><span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel<span class="main">;</span>
      <span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">l</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span>
      <span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span>
      <span class="bound">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="bound">p</span><span class="main">)</span>
    <span class="main">⟧</span> <span class="main">⟹</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">s'</span><span class="main">←</span>collapse_impl <span class="bound">v'</span> <span class="bound">s'</span><span class="main">;</span> RETURN <span class="main">(</span><span class="bound">l'</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span> <span class="main">}</span> 
      <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> GS_rel<span class="main">)</span> <span class="main">(</span>RETURN <span class="main">(</span><span class="bound">l</span><span class="main">,</span>collapse <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> collapse_refine<span class="main"><span class="main">]</span></span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> compute_SCC_impl_def compute_SCC_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
        bind_refine'
        select_edge_refine push_refine 
        pop_refine
        <span class="comment1">(*collapse_refine*)</span> 
        initial_refine
        oinitial_refine
        <span class="comment1">(*last_seg_impl_refine*)</span>
        prod_relI IdI
        inj_on_id
      <span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl I_to_outer
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def oGS_rel_def oGS_α_def 
        is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine
      <span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Find_Path">
<div class="head">
<h1>Theory Find_Path</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Safety-Property Model-Checker\label{sec:find_path}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Find_Path
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CAVA_Automata/Digraph.html">CAVA_Automata.Digraph</a>
  <a href="../CAVA_Base/CAVA_Code_Target.html">CAVA_Base.CAVA_Code_Target</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Finding Path to Error›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    This function searches a graph and a set of start nodes for a reachable
    node that satisfies some property, and returns a path to such a node iff it
    exists.
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>finite <span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">)</span><span class="main">;</span>
    ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">∃</span><span class="bound">u0</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">.</span> path <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="bound">u0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="bound">p</span><span class="main">.</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span><span class="main">)</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">∀</span><span class="bound">u0</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="bound">u0</span><span class="main">}</span><span class="main">.</span> <span class="main">¬</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> find_path_ex_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">U0</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span><span class="main">.</span> <span class="free">P</span> <span class="bound">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
      <span class="main">∃</span><span class="bound">p</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="bound">p</span><span class="main">.</span> <span class="main">¬</span><span class="free">P</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u0</span><span class="main">∈</span><span class="free">U0</span><span class="main">.</span> path <span class="free">E</span> <span class="bound">u0</span> <span class="bound">p</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_path_def
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> 

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nontrivial Paths›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">u0</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> 
    ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u0</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">p</span> <span class="keyword1">of</span> 
      Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> path <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">u0</span></span></span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span> <span class="main">∧</span> <span class="bound">p</span><span class="main">≠</span><span class="main">[]</span>
    <span class="main">|</span> None <span class="main">⇒</span> <span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u0</span></span></span><span class="main">}</span><span class="main">.</span> <span class="main">¬</span><span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">v</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> find_path1_ex_rule<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="main">{</span><span class="free">u0</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span><span class="main">``</span><span class="main">{</span><span class="free">u0</span><span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"find_path1 <span class="free">E</span> <span class="free">u0</span> <span class="free">P</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> 
      <span class="main">∃</span><span class="bound">p</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">r</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">p</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">∧</span> path <span class="free">E</span> <span class="free">u0</span> <span class="bound">p</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_path1_def
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span> 

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Gabow_GBG">
<div class="head">
<h1>Theory Gabow_GBG</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Lasso Finding Algorithm for Generalized B\"uchi Graphs \label{sec:gbg}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_GBG
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Gabow_Skeleton.html">Gabow_Skeleton</a> 
  <a href="../CAVA_Automata/Lasso.html">CAVA_Automata.Lasso</a>
  <a href="Find_Path.html">Find_Path</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* TODO: convenience locale, consider merging this with invariants *)</span>
<span class="keyword1"><span class="command">locale</span></span> igb_fr_graph <span class="main">=</span> 
  igb_graph <span class="quoted"><span class="free">G</span></span> <span class="main">+</span> fr_graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> igb_graph_rec_scheme"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> igb_fr_graphI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"igb_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>g_E <span class="free">G</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> g_V0 <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"igb_fr_graph <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> igb_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We implement an algorithm that computes witnesses for the 
  non-emptiness of Generalized B\"uchi Graphs (GBG).
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Specification›</span></span>
<span class="keyword1"><span class="command">context</span></span> igb_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ce_correct</span> 
    <span class="comment1">― ‹Specifies a correct counter-example›</span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ce_correct</span> <span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∃</span><span class="bound">pr</span> <span class="bound">pl</span><span class="main">.</span> 
        <span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0 <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0 <span class="comment1">― ‹Only reachable nodes are covered›</span>
      <span class="main">∧</span> set <span class="bound">pr</span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="main">∧</span> set <span class="bound">pl</span><span class="main">⊆</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span>     <span class="comment1">― ‹The paths are inside the specified sets›</span>
      <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">⊆</span> <span class="main">(</span>E <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>      <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Vl›</span></span> is mutually connected›</span>
      <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">×</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">∩</span> E <span class="main">≠</span> <span class="main">{}</span>            <span class="comment1">― ‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Vl›</span></span> is non-trivial›</span>
      <span class="main">∧</span> is_lasso_prpl <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span><span class="main">)</span>    <span class="comment1">― ‹Paths form a lasso›</span>
    "</span></span>     

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_ce_spec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">find_ce_spec</span> <span class="main">≡</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="main">(</span><span class="main">∀</span><span class="bound">prpl</span><span class="main">.</span> <span class="main">¬</span>is_lasso_prpl <span class="bound">prpl</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span><span class="bound">Vl</span><span class="main">)</span> <span class="main">⇒</span> ce_correct <span class="bound">Vr</span> <span class="bound">Vl</span>
    <span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_lasso_spec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> list <span class="main">×</span> <span class="tfree">'Q</span> list<span class="main">)</span> option nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">find_lasso_spec</span> <span class="main">≡</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="main">(</span><span class="main">∀</span><span class="bound">prpl</span><span class="main">.</span> <span class="main">¬</span>is_lasso_prpl <span class="bound">prpl</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="bound">prpl</span> <span class="main">⇒</span> is_lasso_prpl <span class="bound">prpl</span>
    <span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Invariant Extension›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extension of the outer invariant:›</span></span>
<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">no_acc_over</span>
    <span class="comment1">― ‹Specifies that there is no accepting cycle touching a set of nodes›</span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">no_acc_over</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">≡</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">D</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">pl</span><span class="main">.</span> <span class="bound">pl</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> path E <span class="bound">v</span> <span class="bound">pl</span> <span class="bound">v</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="bound">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fgl_outer_invar_ext</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span><span class="main">.</span> 
    <span class="keyword1">case</span> <span class="bound">brk</span> <span class="keyword1">of</span> None <span class="main">⇒</span> no_acc_over <span class="bound">D</span> <span class="main">|</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span><span class="bound">Vl</span><span class="main">)</span> <span class="main">⇒</span> ce_correct <span class="bound">Vr</span> <span class="bound">Vl</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fgl_outer_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">brk</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> outer_invar <span class="bound">it</span> <span class="bound">D</span> <span class="main">∧</span> no_acc_over <span class="bound">D</span>
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span><span class="bound">Vl</span><span class="main">)</span> <span class="main">⇒</span> ce_correct <span class="bound">Vr</span> <span class="bound">Vl</span>"</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extension of the inner invariant:›</span></span>
<span class="keyword1"><span class="command">locale</span></span> fgl_invar_loc <span class="main">=</span> 
  invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
  <span class="main">+</span> igb_graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span><span class="main">,</span> <span class="tfree">'more</span><span class="main">)</span> igb_graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">v0</span> <span class="free">D0</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">brk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_acc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">brk</span><span class="main">=</span>None <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">v</span> <span class="bound">pl</span><span class="main">.</span> <span class="bound">pl</span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> path lvE <span class="bound">v</span> <span class="bound">pl</span> <span class="bound">v</span> <span class="main">∧</span> 
    <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="bound">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="comment1">― ‹No accepting cycle over 
      visited edges›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> acc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">brk</span><span class="main">=</span>Some <span class="main">(</span><span class="free">Vr</span><span class="main">,</span><span class="free">Vl</span><span class="main">)</span> <span class="main">⟹</span> ce_correct <span class="free">Vr</span> <span class="free">Vl</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">brk</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">lemma</span></span> invar_loc_this<span class="main">:</span> <span class="quoted"><span class="quoted">"invar_loc <span class="free">G</span> <span class="free">v0</span> <span class="free">D0</span> <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">lemma</span></span> eas_gba_graph_this<span class="main">:</span> <span class="quoted"><span class="quoted">"igb_graph <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> igb_graph<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">fgl_invar</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">D0</span></span></span> <span class="main">≡</span> 
  <span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">D</span><span class="main">,</span> <span class="bound">pE</span><span class="main">)</span><span class="main">.</span> fgl_invar_loc <span class="free">G</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">D0</span></span></span> <span class="bound">brk</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Definition of the Lasso-Finding Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_ce</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">find_ce</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">D</span> <span class="main">=</span> <span class="main">{}</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">←</span>FOREACHci fgl_outer_invar V0 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">brk</span><span class="main">=</span>None<span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">D0</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">if</span> <span class="bound">v0</span><span class="main">∉</span><span class="bound">D0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">(</span>None<span class="main">,</span>initial <span class="bound">v0</span> <span class="bound">D0</span><span class="main">)</span><span class="main">;</span>

            <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">←</span> WHILEIT <span class="main">(</span>fgl_invar <span class="bound">v0</span> <span class="bound">D0</span><span class="main">)</span>
              <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="bound">brk</span><span class="main">=</span>None <span class="main">∧</span> <span class="bound">p</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> 
            <span class="keyword1">do</span> <span class="main">{</span>
              <span class="comment1">― ‹Select edge from end of path›</span>
              <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> select_edge <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

              ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
                Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">p</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="comment1">― ‹Collapse›</span>
                    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> collapse <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

                    ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>

                    <span class="keyword1">if</span> <span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>last <span class="bound">p</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span> <span class="keyword1">then</span>
                      RETURN <span class="main">(</span>Some <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>last <span class="bound">p</span><span class="main">)</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                    <span class="keyword1">else</span>
                      RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                  <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">D</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                    <span class="comment1">― ‹Edge to new node. Append to path›</span>
                    RETURN <span class="main">(</span>None<span class="main">,</span>push <span class="bound">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                <span class="main">}</span>
              <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                  ASSERT <span class="main">(</span><span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
                  RETURN <span class="main">(</span>None<span class="main">,</span>pop <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span>
            <span class="main">}</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
            ASSERT <span class="main">(</span><span class="bound">brk</span><span class="main">=</span>None <span class="main">⟶</span> <span class="main">(</span><span class="bound">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="bound">pE</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            RETURN <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">D</span><span class="main">)</span>
          <span class="main">}</span> <span class="keyword1">else</span> 
            RETURN <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">D0</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span><span class="bound">D</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="bound">brk</span>
    <span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Invariant Preservation›</span></span>


<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">fgl_invar_part</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">D</span><span class="main">,</span> <span class="bound">pE</span><span class="main">)</span><span class="main">.</span> 
    fgl_invar_loc_axioms <span class="free">G</span> <span class="bound">brk</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invarI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>
      <span class="free">brk</span><span class="main">=</span>None <span class="main">⟹</span> outer_invar <span class="free">it</span> <span class="free">D</span><span class="main">;</span> 
      <span class="main">⟦</span><span class="free">brk</span><span class="main">=</span>None <span class="main">⟹</span> outer_invar <span class="free">it</span> <span class="free">D</span><span class="main">⟧</span> <span class="main">⟹</span> fgl_outer_invar_ext <span class="free">it</span> <span class="main">(</span><span class="free">brk</span><span class="main">,</span><span class="free">D</span><span class="main">)</span><span class="main">⟧</span> 
      <span class="main">⟹</span> fgl_outer_invar <span class="free">it</span> <span class="main">(</span><span class="free">brk</span><span class="main">,</span><span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> outer_invar_def fgl_outer_invar_ext_def fgl_outer_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invarI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span><span class="main">;</span> 
       invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span> <span class="main">⟹</span> fgl_invar_part <span class="main">(</span><span class="free">B</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span><span class="main">⟧</span> 
     <span class="main">⟹</span> fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">B</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def fgl_invar_part_def fgl_invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">intro_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_loc_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_initial<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>None<span class="main">,</span><span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>None<span class="main">,</span> initial <span class="free">v0</span> <span class="free">D0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">interpret</span></span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">D0</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def outer_invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">have</span></span> no_acc<span class="main">:</span> <span class="quoted"><span class="quoted">"no_acc_over <span class="free">D0</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def fgl_outer_invar_ext_def<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">pl</span>

      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>vE <span class="main">[</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">]</span> <span class="free">D0</span> <span class="main">(</span>E <span class="main">∩</span> <span class="main">{</span><span class="free">v0</span><span class="main">}</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main">)</span> <span class="skolem">v</span> <span class="skolem">pl</span> <span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D0</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv vE_def touched_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">v</span> <span class="skolem">pl</span> <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> path_mono<span class="main">[</span><span class="operator">OF</span> vE_ss_E P<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">note</span></span> 1 2
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this


    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> fgl_invar_part_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initial_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> AUX1 no_acc <span class="keyword1"><span class="command">unfolding</span></span> no_acc_over_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_pop<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NO'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>None<span class="main">,</span> pop <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> fgl_invar_part_def pop_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> vE_pop<span class="main">[</span><span class="operator">OF</span> NE<span class="main">]</span>

      <span class="keyword1"><span class="command">using</span></span> no_acc <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_collapse_ce_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NONTRIV<span class="main">:</span> <span class="quoted"><span class="quoted">"vE <span class="free">p</span> <span class="free">D</span> <span class="free">pE</span> <span class="main">∩</span> <span class="main">(</span>last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ACC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>last <span class="free">p</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>Some <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> last <span class="free">p</span><span class="main">)</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The last collapsed node on the path contains states from all 
      accepting sets.
      As it is strongly connected and reachable, we get a counter-example. 
      Here, we explicitely construct the lasso.›</span></span>

    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Er</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> UNIV<span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We choose a node in the last Cnode, that is reachable only using
      former Cnodes.›</span></span>

    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">∈</span><span class="var">?Er</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> root_v0 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span><span class="main">≠</span><span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Suc <span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> p_connected'<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        UIP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> VIP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> root_v0 <span class="keyword1"><span class="command">have</span></span> V0IP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>
      
      <span class="keyword1"><span class="command">from</span></span> VIP <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>

      <span class="keyword1"><span class="command">from</span></span> pathI<span class="main">[</span><span class="operator">OF</span> V0IP UIP<span class="main">]</span> <span class="quoted"><span class="quoted">‹length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∈</span> <span class="main">…</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="main">)</span>  
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_seg_butlast<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="var">?Er</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lvE_ss_E <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>rtrancl_mono_mp<span class="main">[</span><span class="operator">rotated</span><span class="main">]</span><span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="var">?Er</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE›</span></span> UIP <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="var">?Er</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> lvE_ss_E <span class="quoted"><span class="quoted">‹length <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Bex_def in_set_conv_nth<span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_lessE <span class="quoted"><span class="quoted">‹Suc <span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">&lt;</span> length <span class="free">p</span>›</span></span> 
          diff_Suc_1 length_butlast nth_butlast<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span> <span class="operator">fact</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted">"<span class="skolem"><span class="skolem">pr</span></span>"</span> <span class="keyword2"><span class="keyword">where</span></span> 
      P_REACH<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="free">v0</span> <span class="skolem">pr</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      R_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">pr</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rtrancl_is_path<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> path_nodes_edges<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ image_Int_subset<span class="main"><span class="main">]</span></span> 
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">=</span> <span class="free">p</span><span class="main">!</span><span class="main">(</span>length <span class="free">p</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹From that node, we construct a lasso by inductively appending a path
      for each accepting set›</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">na</span>
      <span class="keyword3"><span class="command">assume</span></span> na_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">na</span> <span class="main">=</span> num_acc"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">pl</span><span class="main">.</span> <span class="bound">pl</span><span class="main">≠</span><span class="main">[]</span> 
        <span class="main">∧</span> path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span><span class="main">×</span>last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="bound">pl</span> <span class="skolem">w</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="bound">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ACC
        <span class="keyword1"><span class="command">unfolding</span></span> na_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">na</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> 0 

        <span class="keyword1"><span class="command">from</span></span> NONTRIV <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> 
          <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> cnode_connectedI <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span>›</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>rtrancl_into_trancl1<span class="main">)</span> <span class="keyword1"><span class="command">from</span></span> cnode_connectedI <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pl</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> trancl_is_path<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> Suc.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>last <span class="free">p</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> Suc.IH <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pl</span></span> <span class="keyword2"><span class="keyword">where</span></span> IH<span class="main">:</span> 
          <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span> 
          <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> 
          <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  
        <span class="keyword1"><span class="command">from</span></span> Suc.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span><span class="main">∈</span>acc <span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> cnode_connectedI <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pl1</span></span> <span class="keyword2"><span class="keyword">where</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl1</span> <span class="skolem">v</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_is_path<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> cnode_connectedI <span class="quoted"><span class="quoted">‹<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pl2</span></span> <span class="keyword2"><span class="keyword">where</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="skolem">v</span> <span class="skolem">pl2</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_is_path<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>path_conc<span class="main">)</span> <span class="keyword1"><span class="command">note</span></span> IH<span class="main">(</span>2<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>path_conc<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
          P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="main">(</span><span class="skolem">pl1</span><span class="main">@</span><span class="skolem">pl2</span><span class="main">@</span><span class="skolem">pl</span><span class="main">)</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> IH<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pl1</span><span class="main">@</span><span class="skolem">pl2</span><span class="main">@</span><span class="skolem">pl</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i'</span></span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">pl1</span><span class="main">@</span><span class="skolem">pl2</span><span class="main">@</span><span class="skolem">pl</span><span class="main">)</span><span class="main">.</span> <span class="bound">i'</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> IH<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">pl1</span><span class="main">@</span><span class="skolem">pl2</span><span class="main">@</span><span class="skolem">pl</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P1 P2 P IH<span class="main">(</span>1<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl2</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_cons_conv path_conc_conv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl1</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span><span class="main">∈</span>acc <span class="skolem">v</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="main">(</span><span class="skolem">pl1</span><span class="main">@</span><span class="skolem">pl2</span><span class="main">@</span><span class="skolem">pl</span><span class="main">)</span><span class="main">.</span> <span class="skolem">n</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> less_SucE<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pl</span></span> <span class="keyword2"><span class="keyword">where</span></span> pl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span><span class="main">×</span>last <span class="free">p</span><span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">pl</span> <span class="main">⊆</span> last <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> lvE_ss_E
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> path_nodes_edges<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ image_Int_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">have</span></span> LASSO<span class="main">:</span> <span class="quoted"><span class="quoted">"is_lasso_prpl <span class="main">(</span><span class="skolem">pr</span><span class="main">,</span><span class="skolem">pl</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_lasso_prpl_def is_lasso_prpl_pre_def
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹path E <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>›</span></span> P_REACH pl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">from</span></span> p_sc <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span> <span class="main">⊆</span> <span class="main">(</span>lvE <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> lvE_ss_E <span class="keyword1"><span class="command">have</span></span> VL_CLOSED<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span> <span class="main">⊆</span> <span class="main">(</span>E <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> order_trans<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_mono<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> NONTRIV'<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">×</span> last <span class="free">p</span> <span class="main">∩</span> E <span class="main">≠</span> <span class="main">{}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Int_commute NONTRIV disjoint_mono lvE_ss_E subset_refl<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> order_trans<span class="main">[</span><span class="operator">OF</span> path_touched touched_reachable<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> LP_REACH<span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="free">p</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> BLP_REACH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_part_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>

      <span class="keyword1"><span class="command">using</span></span> LASSO R_SS L_SS VL_CLOSED NONTRIV' LP_REACH BLP_REACH
      <span class="keyword1"><span class="command">unfolding</span></span> ce_correct_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_collapse_ce<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">u</span> <span class="free">v</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE'</span> <span class="main">≡</span> <span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CFMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE''</span><span class="main">)</span> <span class="main">=</span> collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BACK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ACC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>last <span class="free">p'</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> i_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≡</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>
      Some <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p'</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> last <span class="free">p'</span><span class="main">)</span><span class="main">,</span> 
      collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

    <span class="keyword1"><span class="command">from</span></span> CFMT <span class="keyword1"><span class="command">have</span></span> p'_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">=</span> collapse_aux <span class="free">p</span> <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D'</span><span class="main">=</span><span class="free">D</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE''</span><span class="main">=</span><span class="free">pE'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_def i_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> idx_of_props<span class="main">[</span><span class="operator">OF</span> BACK<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_drop last_snoc<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Misc.last_in_set drop_eq_Nil last_drop not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>last <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnionI append_Nil Cons_nth_drop_Suc in_set_conv_decomp last_snoc<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vE <span class="free">p'</span> <span class="free">D</span> <span class="free">pE'</span> <span class="main">∩</span> last <span class="free">p'</span> <span class="main">×</span> last <span class="free">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def pE'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> E<span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p'</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def collapse_aux_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> collapse_def p'_def i_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> fgl_invar_collapse_ce_aux<span class="main">)</span> 
      <span class="keyword1"><span class="command">using</span></span> INV' <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_collapse_nce<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">u</span> <span class="free">v</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE'</span> <span class="main">≡</span> <span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CFMT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE''</span><span class="main">)</span> <span class="main">=</span> collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE''</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BACK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> NACC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">j</span><span class="main">&lt;</span>num_acc"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">q</span><span class="main">∈</span>last <span class="free">p'</span><span class="main">.</span> <span class="free">j</span><span class="main">∉</span>acc <span class="bound">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≡</span> idx_of <span class="free">p</span> <span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>None<span class="main">,</span> collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> CFMT <span class="keyword1"><span class="command">have</span></span> p'_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p'</span> <span class="main">=</span> collapse_aux <span class="free">p</span> <span class="free">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D'</span><span class="main">=</span><span class="free">D</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE''</span><span class="main">=</span><span class="free">pE'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_def i_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_def p'_def i_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV' <span class="keyword1"><span class="command">interpret</span></span> inv'<span class="main">:</span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p'</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE'</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">vE'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vE'</span> <span class="main">=</span> vE <span class="free">p'</span> <span class="free">D</span> <span class="free">pE'</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> vE'_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vE'</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vE'_def p'_def pE'_def E<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> idx_of_props<span class="main">[</span><span class="operator">OF</span> BACK<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_drop last_snoc<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Misc.last_in_set drop_eq_Nil last_drop leD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>last <span class="free">p'</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span><span class="free">p</span><span class="main">!</span><span class="free">i</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">i</span><span class="main">&lt;</span>length <span class="free">p</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> p'_def collapse_aux_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnionI append_Nil Cons_nth_drop_Suc in_set_conv_decomp last_snoc<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vE'</span> <span class="main">∩</span> last <span class="free">p'</span> <span class="main">×</span> last <span class="free">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> vE'_alt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p'</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> p'_def collapse_aux_def<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
        We show that no visited strongly connected component contains states
        from all acceptance sets.›</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">pl</span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹For this, we chose a non-trivial loop inside the visited edges›</span></span>
      <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="skolem">vE'</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> NT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹And show that there is one acceptance set disjoint with the nodes
        of the loop›</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∀</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∉</span>acc <span class="bound">q</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">pl</span> <span class="main">∩</span> last <span class="free">p'</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
          <span class="comment1">― ‹Case: The loop is outside the last Cnode›</span>
        <span class="keyword1"><span class="command">with</span></span> path_restrict<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="free">u</span><span class="main">∈</span>last <span class="free">p'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v</span><span class="main">∈</span>last <span class="free">p'</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted">lvE</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">unfolding</span></span> vE'_alt
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> no_acc NT <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">pl</span> <span class="main">∩</span> last <span class="free">p'</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
          <span class="comment1">― ‹Case: The loop touches the last Cnode›</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Then, the loop must be completely inside the last CNode›</span></span>
        <span class="keyword1"><span class="command">from</span></span> inv'.loop_in_lastnode<span class="main">[</span><span class="operator">folded</span> vE'_def<span class="main">,</span> <span class="operator">OF</span> P <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">p'</span></span><span class="main"><span class="main">≠</span></span><span class="main"><span class="main">[]</span></span>›</span></span></span> this<span class="main">]</span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span>last <span class="free">p'</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">pl</span> <span class="main">⊆</span> last <span class="free">p'</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">with</span></span> NACC <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_no_acc <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_part_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">using</span></span> AUX_no_acc<span class="main">[</span><span class="operator">unfolded</span> vE'_def<span class="main">]</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> collapse_ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span> <span class="main">≠</span> collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> collapse_def collapse_aux_def Let_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_push<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BRK<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">brk</span><span class="main">=</span>None"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UIL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VNE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>None<span class="main">,</span> push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">pE'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pE'</span> <span class="main">=</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> E<span class="main">∩</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">×</span>UNIV<span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"push <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="skolem">pE'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_def pE'_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> INV' <span class="keyword1"><span class="command">interpret</span></span> inv'<span class="main">:</span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">@</span><span class="main">[</span><span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pE'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">note</span></span> defs_fold <span class="main">=</span> vE_push<span class="main">[</span><span class="operator">OF</span> E UIL VNE<span class="main">,</span> <span class="operator">folded</span> pE'_def<span class="main">]</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We show that there still is no loop that contains all accepting
        nodes. For this, we choose some loop.›</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">pl</span>
      <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE<span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∀</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∉</span>acc <span class="bound">q</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>set <span class="skolem">pl</span>"</span></span> <span class="comment1">― ‹Case: The newly pushed last cnode is on the loop›</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Then the loop is entirely on the last cnode›</span></span>
        <span class="keyword1"><span class="command">with</span></span> inv'.loop_in_lastnode<span class="main">[</span><span class="operator">unfolded</span> defs_fold<span class="main">,</span> <span class="operator">OF</span> P<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">=</span><span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> SPL<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">pl</span> <span class="main">=</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹However, we then either have that the last cnode is contained in
          the last but one cnode, or that there is a visited edge inside the
          last cnode.›</span></span>
        <span class="keyword1"><span class="command">from</span></span> P SPL <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">v</span> <span class="main">∨</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">list</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Both leads to a contradiction›</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="free">v</span>"</span></span> <span class="comment1">― ‹This is impossible, as <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"u"</span><span class="antiquote">}</span></span> was on the 
            original path, but <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"v"</span><span class="antiquote">}</span></span> was not›</span>
          <span class="keyword1"><span class="command">with</span></span> UIL VNE <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>lvE"</span></span> <span class="comment1">― ‹This is impossible, as all visited edges are
            from touched nodes, but <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"v"</span><span class="antiquote">}</span></span> was untouched›</span>
          <span class="keyword1"><span class="command">with</span></span> vE_touched VNE <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> touched_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∉</span>set <span class="skolem">pl</span>"</span></span> 
          <span class="comment1">― ‹Case: The newly pushed last cnode is not on the loop›</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Then, the path lays inside the old visited edges›</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path lvE <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span>set <span class="skolem">pl</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> P <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_cons_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> A <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> path_restrict<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted">lvE</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pl</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
            
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹And thus, the proposition follows from the invariant on the old
          state›</span></span>
        <span class="keyword1"><span class="command">with</span></span> no_acc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>›</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_no_acc <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> fgl_invar_part_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> defs_fold

      <span class="keyword1"><span class="command">using</span></span> AUX_no_acc <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> fgl_invar_skip<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> BRK<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">brk</span><span class="main">=</span>None"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span><span class="free">pE</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> UIL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>last <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV'<span class="main">:</span> <span class="quoted"><span class="quoted">"invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_invar_part <span class="main">(</span>None<span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> INV' <span class="keyword1"><span class="command">interpret</span></span> inv'<span class="main">:</span> invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">pE</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹We show that there still is no loop that contains all accepting
        nodes. For this, we choose some loop.›</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span> <span class="skolem">pl</span>
      <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>insert <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> lvE<span class="main">)</span> <span class="skolem">w</span> <span class="skolem">pl</span> <span class="skolem">w</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> P <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∀</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">pl</span><span class="main">.</span> <span class="bound">i</span><span class="main">∉</span>acc <span class="bound">q</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_edge_rev_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> no_use <span class="comment1">― ‹Case: The loop does not use the new edge›</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The proposition follows from the invariant for the old state›</span></span>
        <span class="keyword1"><span class="command">with</span></span> no_acc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">pl</span><span class="main">≠</span><span class="main">[]</span>›</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>split <span class="skolem">p1</span> <span class="skolem">p2</span><span class="main">)</span> <span class="comment1">― ‹Case: The loop uses the new edge›</span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹As done is closed under transitions, the nodes of the edge have
          already been visited›</span></span>
        <span class="keyword1"><span class="command">from</span></span> split<span class="main">(</span>2<span class="main">)</span> D_closed_vE_rtrancl 
        <span class="keyword1"><span class="command">have</span></span> WID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">w</span><span class="main">∈</span><span class="free">D</span>"</span></span> 
          <span class="keyword1"><span class="command">using</span></span> VID <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> split<span class="main">(</span>1<span class="main">)</span> WID D_closed_vE_rtrancl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">D</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_edge_cases<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Which is a contradition to the assumptions›</span></span>
        <span class="keyword1"><span class="command">with</span></span> UIL p_not_D <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX_no_acc <span class="main">=</span> this


    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_part_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> vE_remove<span class="main">[</span><span class="operator">OF</span> NE E<span class="main">]</span>

      <span class="keyword1"><span class="command">using</span></span> AUX_no_acc <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invar_initial<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"outer_invar V0 <span class="main">{}</span> <span class="main">⟹</span> fgl_outer_invar_ext V0 <span class="main">(</span>None<span class="main">,</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fgl_outer_invar_ext_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_acc_over_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invar_brk<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">Vr</span><span class="main">,</span><span class="free">Vl</span><span class="main">)</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_outer_invar_ext <span class="free">anyIt</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">Vr</span><span class="main">,</span><span class="free">Vl</span><span class="main">)</span><span class="main">,</span> <span class="free">anyD</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted"><span class="quoted">"Some <span class="main">(</span><span class="free">Vr</span><span class="main">,</span><span class="free">Vl</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D</span></span> <span class="quoted"><span class="free">pE</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_invar_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> acc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_ext_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invar_newnode_nobrk<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>None<span class="main">,</span><span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span>None<span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_outer_invar_ext <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span><span class="free">D'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> OINV <span class="keyword1"><span class="command">interpret</span></span> outer_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">it</span></span> <span class="quoted"><span class="free">D0</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> fgl_outer_invar_def outer_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">interpret</span></span> inv<span class="main">:</span> fgl_invar_loc <span class="quoted"><span class="free">G</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="quoted">None</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">D'</span></span> <span class="quoted"><span class="free">pE</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> fgl_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> inv.pE_fin <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">pl</span>
      <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="free">D'</span>"</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">v</span> <span class="skolem">pl</span> <span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>E <span class="main">∩</span> <span class="free">D'</span> <span class="main">×</span> UNIV<span class="main">)</span> <span class="skolem">v</span> <span class="skolem">pl</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ path_restrict_closed<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inv.D_closed A<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> fgl_outer_invar_ext_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">using</span></span> inv.no_acc AUX1 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vE_def touched_def no_acc_over_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invar_newnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span><span class="free">D0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span><span class="free">it</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> OINV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>None<span class="main">,</span><span class="free">D0</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">brk</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CASES<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">Vr</span> <span class="bound">Vl</span><span class="main">.</span> <span class="free">brk</span> <span class="main">=</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span> <span class="bound">Vl</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span> <span class="free">p</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_outer_invar_ext <span class="main">(</span><span class="free">it</span><span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">brk</span><span class="main">,</span><span class="free">D'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> CASES
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE1<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> fgl_outer_invar_brk<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">D0</span></span> <span class="main">_</span> <span class="main">_</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">D'</span></span> <span class="quoted"><span class="free">pE</span></span><span class="main">]</span> INV 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command">using</span></span> fgl_outer_invar_newnode_nobrk<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> OINV INV <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_outer_invar_Dnode<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>None<span class="main">,</span> <span class="free">D</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fgl_outer_invar_ext <span class="main">(</span><span class="free">it</span> <span class="main">-</span> <span class="main">{</span><span class="free">v</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>None<span class="main">,</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def fgl_outer_invar_ext_def<span class="main">)</span>

  
  <span class="keyword1"><span class="command">lemma</span></span> fgl_fin_no_lasso<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="main">{}</span> <span class="main">(</span>None<span class="main">,</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"is_lasso_prpl <span class="free">prpl</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="quoted">"<span class="skolem"><span class="skolem">pr</span></span>"</span> <span class="skolem"><span class="skolem">pl</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">prpl</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">pr</span><span class="main">,</span><span class="skolem">pl</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">prpl</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> NA<span class="main">:</span> <span class="quoted"><span class="quoted">"no_acc_over <span class="free">D</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def fgl_outer_invar_ext_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"outer_invar <span class="main">{}</span> <span class="free">D</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> fin_outer_D_is_reachable <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">D</span><span class="main">=</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> NA B <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_acc_over_def is_lasso_prpl_def is_lasso_prpl_pre_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> fgl_fin_lasso<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>Some <span class="main">(</span><span class="free">Vr</span><span class="main">,</span><span class="free">Vl</span><span class="main">)</span><span class="main">,</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ce_correct <span class="free">Vr</span> <span class="free">Vl</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fgl_outer_invar_def fgl_outer_invar_ext_def<span class="main">)</span>


  <span class="keyword1"><span class="command">lemmas</span></span> fgl_invar_preserve <span class="main">=</span> 
    fgl_invar_initial fgl_invar_push fgl_invar_pop 
    fgl_invar_collapse_ce fgl_invar_collapse_nce fgl_invar_skip
    fgl_outer_invar_newnode fgl_outer_invar_Dnode
    invar_initial outer_invar_initial fgl_invar_initial fgl_outer_invar_initial
    fgl_fin_no_lasso fgl_fin_lasso

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Main Correctness Proof›</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> outer_invar_from_fgl_invarI<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"fgl_outer_invar <span class="free">it</span> <span class="main">(</span>None<span class="main">,</span><span class="free">D</span><span class="main">)</span> <span class="main">⟹</span> outer_invar <span class="free">it</span> <span class="free">D</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fgl_outer_invar_def outer_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> invar_from_fgl_invarI<span class="main">:</span> <span class="quoted"><span class="quoted">"fgl_invar <span class="free">v0</span> <span class="free">D0</span> <span class="main">(</span><span class="free">B</span><span class="main">,</span><span class="free">PDPE</span><span class="main">)</span> <span class="main">⟹</span> invar <span class="free">v0</span> <span class="free">D0</span> <span class="free">PDPE</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fgl_invar_def invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> fgl_invar_loc_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
   
  <span class="keyword1"><span class="command">theorem</span></span> find_ce_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"find_ce <span class="main">≤</span> find_ce_spec"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> <span class="main">=</span> Union_iff

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> find_ce_def find_ce_spec_def select_edge_def select_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
        WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>abs_wf_rel <span class="skolem">v0</span><span class="main">)</span> snd"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">v0</span><span class="main"><span class="main">]</span></span>
        <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      <span class="main">)</span>
      
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 5<span class="main">]</span><span class="main">]</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span>
        <span class="quasi_keyword">rec</span><span class="main"><span class="main">:</span></span> fgl_invarI fgl_outer_invarI
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> invar_from_fgl_invarI outer_invar_from_fgl_invarI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sym<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"collapse <span class="skolem">a</span> <span class="skolem">b</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem">a</span> <span class="skolem">b</span><span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> collapse_ne
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pE_fin'<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invar_from_fgl_invarI<span class="main"><span class="main">]</span></span> finite_V0
        <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> invar_preserve 
        <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∩</span> <span class="main">_</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main"><span class="main">]</span></span>
        <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> fgl_invar_preserve<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Emptiness Check"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using the lasso-finding algorithm, we can define an emptiness check›</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_is_empty</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">ce</span> <span class="main">←</span> find_ce<span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">ce</span> <span class="main">=</span> None<span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> abs_is_empty_correct<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"abs_is_empty <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">res</span><span class="main">.</span> <span class="bound">res</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="main">¬</span>is_acc_run <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abs_is_empty_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_ce_correct<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> find_ce_spec_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> ce_correct_def
    <span class="keyword1"><span class="command">using</span></span> lasso_accepted accepted_lasso
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> is_lasso_prpl_of_lasso surj_pair<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_lasso_prpl_conv<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">abs_is_empty_ce</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">ce</span> <span class="main">←</span> find_ce<span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">ce</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> RETURN None
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span><span class="bound">Vl</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="main">∃</span><span class="bound">pr</span> <span class="bound">pl</span><span class="main">.</span> set <span class="bound">pr</span> <span class="main">⊆</span> <span class="bound">Vr</span> <span class="main">∧</span> set <span class="bound">pl</span> <span class="main">⊆</span> <span class="bound">Vl</span> <span class="main">∧</span> <span class="bound">Vl</span> <span class="main">×</span> <span class="bound">Vl</span> <span class="main">⊆</span> <span class="main">(</span>E <span class="main">∩</span> <span class="bound">Vl</span><span class="main">×</span><span class="bound">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> 
          <span class="main">∧</span> is_lasso_prpl <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span><span class="main">.</span> 
           set <span class="bound">pr</span> <span class="main">⊆</span> <span class="bound">Vr</span> 
          <span class="main">∧</span> set <span class="bound">pl</span> <span class="main">⊆</span> <span class="bound">Vl</span> 
          <span class="main">∧</span> <span class="bound">Vl</span> <span class="main">×</span> <span class="bound">Vl</span> <span class="main">⊆</span> <span class="main">(</span>E <span class="main">∩</span> <span class="bound">Vl</span><span class="main">×</span><span class="bound">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>
          <span class="main">∧</span> is_lasso_prpl <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        RETURN <span class="main">(</span>Some <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> abs_is_empty_ce_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"abs_is_empty_ce <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">res</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">res</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="main">¬</span>is_acc_run <span class="bound">r</span><span class="main">)</span>
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">pl</span><span class="main">)</span> <span class="main">⇒</span> is_acc_run <span class="main">(</span><span class="bound">pr</span><span class="main">⌢</span><span class="bound">pl</span><span class="keyword1"><span class="hidden">⇧</span><sup>ω</sup></span><span class="main">)</span>
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abs_is_empty_ce_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_ce_correct<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> find_ce_spec_def<span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ce_correct_def<span class="main">)</span>

    <span class="keyword1"><span class="command">using</span></span> accepted_lasso finite_reachableE_V0 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> is_lasso_prpl_of_lasso surj_pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lasso_prpl_acc_run<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Refinement›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we refine the lasso finding algorithm to use efficient
  data structures. First, we explicitely keep track of the set of acceptance
  classes for every c-node on the path. Second, we use Gabow's data structure
  to represent the path.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Addition of Explicit Accepting Sets›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a first step, we explicitely keep track of the current set of
  acceptance classes for every c-node on the path.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> abs_gstate <span class="main">=</span> <span class="quoted"><span class="quoted">"nat set list <span class="main">×</span> <span class="tfree">'a</span> abs_state"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> ce <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> set <span class="main">×</span> <span class="tfree">'a</span> set<span class="main">)</span> option"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> abs_gostate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> ce <span class="main">×</span> <span class="tfree">'a</span> set"</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gstate_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> abs_gstate <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">gstate_invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">V</span><span class="main">.</span> <span class="main">⋃</span><span class="main">(</span>acc<span class="main">`</span><span class="bound">V</span><span class="main">)</span><span class="main">)</span> <span class="bound">p</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gstate_rel</span> <span class="main">≡</span> br snd gstate_invar"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gstate_rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">,</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued gstate_rel"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gstate_rel_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gcollapse_aux</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set list <span class="main">⇒</span> <span class="tfree">'a</span> set list <span class="main">⇒</span> nat <span class="main">⇒</span> nat set list <span class="main">×</span> <span class="tfree">'a</span> set list"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gcollapse_aux</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> 
      <span class="main">(</span>take <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>take <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gcollapse</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> abs_gstate <span class="main">⇒</span> <span class="tfree">'a</span> abs_gstate"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gcollapse</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">APDPE</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span> 
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">APDPE</span></span></span><span class="main">;</span> 
      <span class="bound">i</span><span class="main">=</span>idx_of <span class="bound">p</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">=</span> gcollapse_aux <span class="bound">a</span> <span class="bound">p</span> <span class="bound">i</span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gpush</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">@</span><span class="main">[</span>acc <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span><span class="main">,</span>push <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gpop</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span>butlast <span class="bound">a</span><span class="main">,</span>pop <span class="bound">s</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ginitial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> abs_gostate <span class="main">⇒</span> <span class="tfree">'Q</span> abs_gstate"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ginitial</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">[</span>acc <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">]</span><span class="main">,</span> initial <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goinitial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> abs_gostate"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goinitial</span> <span class="main">≡</span> <span class="main">(</span>None<span class="main">,</span><span class="main">{}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">go_is_no_brk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> abs_gostate <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">go_is_no_brk</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fst <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goD</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> abs_gostate <span class="main">⇒</span> <span class="tfree">'Q</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goD</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> snd <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goBrk</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> abs_gostate <span class="main">⇒</span> <span class="tfree">'Q</span> ce"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goBrk</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fst <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gto_outer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> ce <span class="main">⇒</span> <span class="tfree">'Q</span> abs_gstate <span class="main">⇒</span> <span class="tfree">'Q</span> abs_gostate"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gto_outer</span> <span class="free"><span class="bound"><span class="entity">brk</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">brk</span></span></span><span class="main">,</span><span class="bound">D</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gselect_edge</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> 
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">←</span>select_edge <span class="bound">s</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> 
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gfind_ce</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gfind_ce</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">os</span> <span class="main">=</span> goinitial<span class="main">;</span>
      <span class="bound">os</span><span class="main">←</span>FOREACHci fgl_outer_invar V0 <span class="main">(</span>go_is_no_brk<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s0</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> <span class="bound">v0</span><span class="main">∉</span>goD <span class="bound">s0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">(</span>None<span class="main">,</span>ginitial <span class="bound">v0</span> <span class="bound">s0</span><span class="main">)</span><span class="main">;</span>

          <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">←</span> WHILEIT <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> fgl_invar <span class="bound">v0</span> <span class="main">(</span>goD <span class="bound">s0</span><span class="main">)</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> <span class="bound">brk</span><span class="main">=</span>None <span class="main">∧</span> <span class="bound">p</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">.</span> 
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="comment1">― ‹Select edge from end of path›</span>
            <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> gselect_edge <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

            ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
            <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
              Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">if</span> <span class="bound">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">p</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Collapse›</span>
                  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> gcollapse <span class="bound">v</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>

                  ASSERT <span class="main">(</span><span class="bound">p</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
                  ASSERT <span class="main">(</span><span class="bound">a</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>

                  <span class="keyword1">if</span> last <span class="bound">a</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span> <span class="keyword1">then</span>
                    RETURN <span class="main">(</span>Some <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>last <span class="bound">p</span><span class="main">)</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                  <span class="keyword1">else</span>
                    RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">D</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to new node. Append to path›</span>
                  RETURN <span class="main">(</span>None<span class="main">,</span>gpush <span class="bound">v</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span>
              <span class="main">}</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                ASSERT <span class="main">(</span><span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span><span class="main">)</span><span class="main">;</span>
                RETURN <span class="main">(</span>None<span class="main">,</span>gpop <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
              <span class="main">}</span>
          <span class="main">}</span><span class="main">)</span> <span class="bound">s</span><span class="main">;</span>
          ASSERT <span class="main">(</span><span class="bound">brk</span><span class="main">=</span>None <span class="main">⟶</span> <span class="main">(</span><span class="bound">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="bound">pE</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
          RETURN <span class="main">(</span>gto_outer <span class="bound">brk</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="bound">s0</span>
    <span class="main">}</span><span class="main">)</span> <span class="bound">os</span><span class="main">;</span>
    RETURN <span class="main">(</span>goBrk <span class="bound">os</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gcollapse_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel<span class="main">⟧</span> 
      <span class="main">⟹</span> <span class="main">(</span>gcollapse <span class="free">v'</span> <span class="free">s'</span><span class="main">,</span>collapse <span class="free">v</span> <span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gcollapse_def collapse_def collapse_aux_def gcollapse_aux_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gstate_rel_def br_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gstate_invar_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_map drop_map<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gpush_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">;</span> <span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel<span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>gpush <span class="free">v'</span> <span class="free">s'</span><span class="main">,</span>push <span class="free">v</span> <span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpush_def push_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gstate_rel_def br_def<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gstate_invar_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gpop_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel<span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span>gpop <span class="free">s'</span><span class="main">,</span>pop <span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpop_def pop_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gstate_rel_def br_def<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gstate_invar_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_butlast<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ginitial_refine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>ginitial <span class="free">x</span> <span class="main">(</span>None<span class="main">,</span> <span class="free">b</span><span class="main">)</span><span class="main">,</span> initial <span class="free">x</span> <span class="free">b</span><span class="main">)</span> <span class="main">∈</span> gstate_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ginitial_def gstate_rel_def br_def gstate_invar_def initial_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> oinitial_b_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>None<span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">,</span><span class="main">(</span>None<span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>Id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> gselect_edge_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel<span class="main">⟧</span> <span class="main">⟹</span> gselect_edge <span class="free">s'</span> 
    <span class="main">≤</span><span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span>Id<span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> gstate_rel<span class="main">)</span> <span class="main">(</span>select_edge <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gselect_edge_def select_edge_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> prod_rel_sv
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gstate_rel_def br_def gstate_invar_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> last_acc_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">a'</span><span class="main">,</span><span class="free">p'</span><span class="main">,</span><span class="free">D'</span><span class="main">,</span><span class="free">pE'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gstate_rel"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>last <span class="free">a'</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>last <span class="free">p</span><span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>acc <span class="bound">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms acc_bound <span class="keyword1"><span class="command">unfolding</span></span> gstate_rel_def br_def gstate_invar_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_map<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> fglr_aux1<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="free">s</span><span class="main">)</span><span class="main">∈</span>gstate_rel"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a'</span> <span class="bound">p'</span> <span class="bound">D'</span> <span class="bound">pE'</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="bound">D'</span><span class="main">,</span><span class="bound">pE'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gstate_rel 
      <span class="main">⟹</span> <span class="free">f'</span> <span class="bound">a'</span> <span class="bound">p'</span> <span class="bound">D'</span> <span class="bound">pE'</span> <span class="main">≤</span><span class="main">⇓</span><span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">p'</span><span class="main">,</span><span class="bound">D'</span><span class="main">,</span><span class="bound">pE'</span><span class="main">)</span> <span class="main">=</span> gcollapse <span class="free">v'</span> <span class="free">s'</span> <span class="keyword1">in</span> <span class="free">f'</span> <span class="bound">a'</span> <span class="bound">p'</span> <span class="bound">D'</span> <span class="bound">pE'</span><span class="main">)</span> 
      <span class="main">≤</span> <span class="main">⇓</span><span class="free">R</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span> <span class="main">=</span> collapse <span class="free">v</span> <span class="free">s</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> P<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> gcollapse_refine<span class="main">[</span><span class="operator">OF</span> V S<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gstate_invar_empty<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gstate_invar <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="quoted"><span class="quoted">"gstate_invar <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gstate_invar_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> find_ce_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"gfind_ce <span class="main">≤</span><span class="main">⇓</span>Id find_ce"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gfind_ce_def find_ce_def
    <span class="keyword1"><span class="command">unfolding</span></span> goinitial_def go_is_no_brk_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> goD_def goBrk_def 
      gto_outer_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
      gselect_edge_refine prod_relI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IdI gpop_refine<span class="main"><span class="main">]</span></span>
      prod_relI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IdI gpush_refine<span class="main"><span class="main">]</span></span>
      fglr_aux1 last_acc_impl oinitial_b_refine
      inj_on_id
    <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ginitial_refine<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">nopre</span><span class="main"><span class="main">)</span></span> 
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> asm_rl 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gstate_rel_def br_def gstate_invar_empty<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Gabow's Data Structure›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Un_set_drop_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> set list <span class="main">⇒</span> <span class="tfree">'a</span> set nres"</span></span>
  <span class="comment1">― ‹Executable version of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"⋃set (drop i A)"</span><span class="antiquote">}</span></span>, using indexing to
  access <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"A"</span><span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Un_set_drop_impl</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> WHILET <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> length <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">res</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">!</span><span class="bound">i</span> <span class="main">∪</span> <span class="bound">res</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">i</span> <span class="main">=</span> <span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
    <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span>
    RETURN <span class="bound">res</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Un_set_drop_impl_correct<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Un_set_drop_impl <span class="free">i</span> <span class="free">A</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span><span class="main">=</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="free">i</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Un_set_drop_impl_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
    WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">i'</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> <span class="bound">res</span><span class="main">=</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span><span class="main">(</span>drop <span class="free">i</span> <span class="main">(</span>take <span class="bound">i'</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">i</span><span class="main">≤</span><span class="bound">i'</span>"</span></span> 
    <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i'</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> length <span class="free">A</span> <span class="main">-</span> <span class="bound">i'</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span> 
    <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take_Suc_conv_app_nth<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> Un_set_drop_code_aux<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">es_impl</span><span class="main">,</span><span class="main">{}</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">un_impl</span><span class="main">,</span><span class="main">(∪)</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>Un_set_drop_impl<span class="main">)</span><span class="main">∈</span>nat_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">⟩</span>as_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Un_set_drop_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span> <span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">Un_set_drop_code</span> <span class="keyword2"><span class="keyword">uses</span></span> Un_set_drop_code_aux

<span class="keyword1"><span class="command">schematic_goal</span></span> Un_set_drop_tr_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> Un_set_drop_code <span class="free">es_impl</span> <span class="free">un_impl</span> <span class="free">i</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Un_set_drop_code_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">Un_set_drop_tr</span> <span class="keyword2"><span class="keyword">for</span></span> es_impl un_impl i A 
  <span class="keyword2"><span class="keyword">uses</span></span> Un_set_drop_tr_aux 

<span class="keyword1"><span class="command">lemma</span></span> Un_set_drop_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">es_impl</span> <span class="main">{}</span> <span class="main">(</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">un_impl</span> <span class="main">(∪)</span> <span class="main">(</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="bound">A</span><span class="main">.</span> RETURN <span class="main">(</span>Un_set_drop_tr <span class="free">es_impl</span> <span class="free">un_impl</span> <span class="bound">i</span> <span class="bound">A</span><span class="main">)</span><span class="main">,</span>Un_set_drop_impl<span class="main">)</span>
    <span class="main">∈</span>nat_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">⟩</span>as_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span><span class="free">Rs</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> Un_set_drop_tr.refine<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> Un_set_drop_code.refine<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">es_impl</span></span> <span class="quoted"><span class="free">Rs</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="free">un_impl</span></span><span class="main">,</span> 
    <span class="operator">param_fo</span><span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Actual Refinement›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'Q</span> gGS <span class="main">=</span> <span class="quoted"><span class="quoted">"nat set list <span class="main">×</span> <span class="tfree">'Q</span> GS"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'Q</span> goGS <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> ce <span class="main">×</span> <span class="tfree">'Q</span> oGS"</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_graph
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gGS_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gGS_invar</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> 
    GS_invar <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span>
    <span class="main">∧</span> length <span class="bound">a</span> <span class="main">=</span> length <span class="bound">B</span>
    <span class="main">∧</span> <span class="main">⋃</span><span class="main">(</span>set <span class="bound">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>
  "</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">gGS_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="tfree">'Q</span> abs_gstate"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gGS_α</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span>GS.α <span class="bound">s</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gGS_rel</span> <span class="main">≡</span> br gGS_α gGS_invar"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> gGS_rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued gGS_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gGS_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">goGS_invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> goGS <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">goGS_invar</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">ogs</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="bound">brk</span><span class="main">=</span>None <span class="main">⟶</span> oGS_invar <span class="bound">ogs</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">goGS_α</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">ogs</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span>oGS_α <span class="bound">ogs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">goGS_rel</span> <span class="main">≡</span> br goGS_α goGS_invar"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> goGS_rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"single_valued goGS_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> goGS_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">context</span></span> igb_fr_graph
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> gGS_relE<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">S'</span> <span class="free">B'</span> <span class="free">I'</span> <span class="free">P'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">S'</span><span class="main">,</span><span class="free">B'</span><span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S'</span><span class="main">,</span><span class="free">B'</span><span class="main">,</span><span class="free">I'</span><span class="main">,</span><span class="free">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="free">B'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_α_def GS.α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def gGS_invar_def GS.α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goinitial_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> goGS"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goinitial_impl</span> <span class="main">≡</span> <span class="main">(</span>None<span class="main">,</span>Map.empty<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> goinitial_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>goinitial_impl<span class="main">,</span>goinitial<span class="main">)</span><span class="main">∈</span>goGS_rel"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goinitial_impl_def goinitial_def goGS_rel_def br_def 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_α_def goGS_invar_def oGS_α_def oGS_invar_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gto_outer_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> ce <span class="main">⇒</span> <span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="tfree">'Q</span> goGS"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gto_outer_impl</span> <span class="free"><span class="bound"><span class="entity">brk</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">brk</span></span></span><span class="main">,</span><span class="bound">I</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gto_outer_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">brk</span> <span class="main">=</span> None <span class="main">⟶</span> <span class="main">(</span><span class="free">p</span><span class="main">=</span><span class="main">[]</span> <span class="main">∧</span> <span class="free">pE</span><span class="main">=</span><span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">brk'</span><span class="main">,</span><span class="free">brk</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gto_outer_impl <span class="free">brk'</span> <span class="free">s</span><span class="main">,</span>gto_outer <span class="free">brk</span> <span class="main">(</span><span class="free">A</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>goGS_rel"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">A</span> <span class="skolem">S</span> <span class="skolem">B</span> <span class="skolem">I</span> <span class="skolem">P</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">=</span><span class="main">(</span><span class="skolem">A</span><span class="main">,</span><span class="skolem">S</span><span class="main">,</span><span class="skolem">B</span><span class="main">,</span><span class="skolem">I</span><span class="main">,</span><span class="skolem">P</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> C
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">brk</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms I_to_outer<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">S</span></span> <span class="quoted"><span class="skolem">B</span></span> <span class="quoted"><span class="skolem">I</span></span> <span class="quoted"><span class="skolem">P</span></span> <span class="quoted"><span class="free">D</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_α_def gto_outer_def 
              gto_outer_impl_def goGS_invar_def 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def oGS_rel_def GS_rel_def gGS_α_def gGS_invar_def 
              GS.α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command">using</span></span> B <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gto_outer_def gto_outer_impl_def
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> br_def goGS_rel_def goGS_invar_def goGS_α_def oGS_α_def
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def gGS_α_def GS.α_def GS.D_α_def
      <span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gpush_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">a</span><span class="main">@</span><span class="main">[</span>acc <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">]</span><span class="main">,</span> push_impl <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">)</span>"</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> gpush_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v'</span> <span class="main">∉</span> <span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span> <span class="main">∉</span> <span class="free">D</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gpush_impl <span class="free">v'</span> <span class="free">s'</span><span class="main">,</span> gpush <span class="free">v</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> B <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="skolem"><span class="skolem">B'</span></span> <span class="skolem"><span class="skolem">I'</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> OSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="skolem">B'</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gGS_relE<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">B</span> <span class="skolem">I</span> <span class="skolem">P</span> <span class="skolem">S'</span> <span class="skolem">B'</span> <span class="skolem">I'</span> <span class="skolem">P'</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"push_impl <span class="free">v</span> <span class="main">(</span><span class="skolem">S</span><span class="main">,</span> <span class="skolem">B</span><span class="main">,</span> <span class="skolem">I</span><span class="main">,</span> <span class="skolem">P</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span> <span class="skolem">B'</span><span class="main">,</span> <span class="skolem">I'</span><span class="main">,</span> <span class="skolem">P'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">B'</span> <span class="main">=</span> Suc <span class="main">(</span>length <span class="skolem">B</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_impl_def GS.push_impl_def Let_def<span class="main">)</span>  
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this

    <span class="keyword1"><span class="command">from</span></span> push_refine<span class="main">[</span><span class="operator">OF</span> OSR A PRE<span class="main">]</span> A L acc_bound R <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gpush_impl_def gpush_def
        gGS_rel_def gGS_invar_def gGS_α_def GS_rel_def br_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gpop_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="tfree">'Q</span> gGS nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gpop_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">s</span><span class="main">←</span>pop_impl <span class="bound">s</span><span class="main">;</span>
    ASSERT <span class="main">(</span><span class="bound">a</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> butlast <span class="bound">a</span><span class="main">;</span>
    RETURN <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gpop_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">pE</span> <span class="main">∩</span> last <span class="free">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gpop_impl <span class="free">s'</span> <span class="main">≤</span> <span class="main">⇓</span>gGS_rel <span class="main">(</span>RETURN <span class="main">(</span>gpop <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="skolem"><span class="skolem">B'</span></span> <span class="skolem"><span class="skolem">I'</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> OSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="skolem">B'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gGS_relE<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> PRE OSR <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> L
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def GS.p_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">B</span> <span class="skolem">I</span> <span class="skolem">P</span> <span class="skolem">S'</span> <span class="skolem">B'</span> <span class="skolem">I'</span> <span class="skolem">P'</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>pop_impl <span class="main">(</span><span class="main">(</span><span class="skolem">S</span><span class="main">,</span> <span class="skolem">B</span><span class="main">,</span> <span class="skolem">I</span><span class="main">,</span> <span class="skolem">P</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span> GS<span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"inres <span class="main">(</span>pop_impl <span class="main">(</span><span class="main">(</span><span class="skolem">S</span><span class="main">,</span> <span class="skolem">B</span><span class="main">,</span> <span class="skolem">I</span><span class="main">,</span> <span class="skolem">P</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span> GS<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span> <span class="skolem">B'</span><span class="main">,</span> <span class="skolem">I'</span><span class="main">,</span> <span class="skolem">P'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">B'</span> <span class="main">=</span> length <span class="skolem">B</span> <span class="main">-</span> Suc <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pop_impl_def GS.pop_impl_def Let_def
          <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this

    <span class="keyword1"><span class="command">from</span></span> A L <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gpop_impl_def gpop_def gGS_rel_def gGS_α_def br_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> pop_refine<span class="main">[</span><span class="operator">OF</span> OSR PRE<span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gGS_rel_def gGS_invar_def gGS_α_def GS_rel_def GS.α_def br_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX1 in_set_butlastD <span class="quasi_keyword">iff</span><span class="main"><span class="main">:</span></span> Sup_le_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gselect_edge_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span> option <span class="main">×</span> <span class="tfree">'Q</span> gGS<span class="main">)</span> nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gselect_edge_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span> 
      <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">←</span>select_edge_impl <span class="bound">s</span><span class="main">;</span> 
      RETURN <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">thm</span></span> select_edge_refine
  <span class="keyword1"><span class="command">lemma</span></span> gselect_edge_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span> <span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">∈</span> gGS_rel"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gselect_edge_impl <span class="free">s'</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> gGS_rel<span class="main">)</span> <span class="main">(</span>gselect_edge <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="skolem"><span class="skolem">B'</span></span> <span class="skolem"><span class="skolem">I'</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> OSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="skolem">B'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gGS_relE<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">S</span> <span class="skolem">B</span> <span class="skolem">I</span> <span class="skolem">P</span> <span class="skolem">S'</span> <span class="skolem">B'</span> <span class="skolem">I'</span> <span class="skolem">P'</span> <span class="skolem">vo</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>select_edge_impl <span class="main">(</span><span class="main">(</span><span class="skolem">S</span><span class="main">,</span> <span class="skolem">B</span><span class="main">,</span> <span class="skolem">I</span><span class="main">,</span> <span class="skolem">P</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span> GS<span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"inres <span class="main">(</span>select_edge_impl <span class="main">(</span><span class="main">(</span><span class="skolem">S</span><span class="main">,</span> <span class="skolem">B</span><span class="main">,</span> <span class="skolem">I</span><span class="main">,</span> <span class="skolem">P</span><span class="main">)</span><span class="main">::</span><span class="tfree">'a</span> GS<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="skolem">vo</span><span class="main">,</span> <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span> <span class="skolem">B'</span><span class="main">,</span> <span class="skolem">I'</span><span class="main">,</span> <span class="skolem">P'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">B'</span> <span class="main">=</span> length <span class="skolem">B</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> select_edge_impl_def GS.sel_rem_last_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span>
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm prod.splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1<span class="main">=</span>this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> select_edge_refine<span class="main">[</span><span class="operator">OF</span> OSR PRE<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gselect_edge_impl_def gselect_edge_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff prod_rel_sv<span class="main">)</span>

      <span class="keyword1"><span class="command">unfolding</span></span> gGS_rel_def br_def gGS_α_def gGS_invar_def GS_rel_def GS.α_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command">using</span></span> R
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> L <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">GS.idx_of_impl</span>

  <span class="keyword1"><span class="command">thm</span></span> GS_invar.idx_of_correct


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gcollapse_impl_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="tfree">'Q</span> gGS nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">gcollapse_impl_aux</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="comment1">⌦‹ASSERT (v∈⋃set (GS.p_α s));›</span>
      <span class="bound">i</span> <span class="main">←</span> GS.idx_of_impl <span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      <span class="bound">s</span> <span class="main">←</span> collapse_impl <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">s</span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="bound">A</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">us</span> <span class="main">←</span> Un_set_drop_impl <span class="bound">i</span> <span class="bound">A</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">A</span> <span class="main">=</span> take <span class="bound">i</span> <span class="bound">A</span> <span class="main">@</span> <span class="main">[</span><span class="bound">us</span><span class="main">]</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">collapse</span>
  <span class="keyword1"><span class="command">lemma</span></span> gcollapse_alt<span class="main">:</span>
    <span class="quoted"><span class="quoted">"gcollapse <span class="free">v</span> <span class="free">APDPE</span> <span class="main">=</span> <span class="main">(</span> 
      <span class="keyword1">let</span> 
        <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">=</span><span class="free">APDPE</span><span class="main">;</span> 
        <span class="bound">i</span><span class="main">=</span>idx_of <span class="bound">p</span> <span class="free">v</span><span class="main">;</span>
        <span class="bound">s</span><span class="main">=</span>collapse <span class="free">v</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">us</span><span class="main">=</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>drop <span class="bound">i</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">a</span> <span class="main">=</span> take <span class="bound">i</span> <span class="bound">a</span> <span class="main">@</span> <span class="main">[</span><span class="bound">us</span><span class="main">]</span>
      <span class="keyword1">in</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gcollapse_def gcollapse_aux_def collapse_def collapse_aux_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">thm</span></span> collapse_refine
  <span class="keyword1"><span class="command">lemma</span></span> gcollapse_impl_aux_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span> <span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">∈</span> gGS_rel"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gcollapse_impl_aux <span class="free">v'</span> <span class="free">s'</span> 
      <span class="main">≤</span> <span class="main">⇓</span> gGS_rel <span class="main">(</span>RETURN <span class="main">(</span>gcollapse <span class="free">v</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Let_def

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="skolem"><span class="skolem">B'</span></span> <span class="skolem"><span class="skolem">I'</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> OSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="skolem">B'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>set <span class="free">a</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gGS_relE<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> B <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> OSR <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> OSR PRE <span class="keyword1"><span class="command">have</span></span> PRE'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>GS.p_α <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> OSR <span class="keyword1"><span class="command">have</span></span> GS_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def<span class="main">)</span>

    <span class="keyword1"><span class="command">term</span></span> <span class="quoted">GS.B</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"collapse <span class="free">v</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>GS.p_α <span class="skolem">s</span><span class="main">,</span> GS.D_α <span class="skolem">s</span><span class="main">,</span> GS.pE_α <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>GS.B <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>idx_of <span class="free">p</span> <span class="free">v</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> collapse_def collapse_aux_def Let_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> GS.p_α_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">length</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> GS_invar.p_α_disjoint_sym<span class="main">[</span><span class="operator">OF</span> GS_invar<span class="main">]</span>
          <span class="keyword2"><span class="keyword">and</span></span> PRE <span class="quoted"><span class="quoted">‹GS.p_α <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span> <span class="skolem">B'</span><span class="main">,</span> <span class="skolem">I'</span><span class="main">,</span> <span class="skolem">P'</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>›</span></span> idx_of_props<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> AUX1 <span class="main">=</span> this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gcollapse_alt gcollapse_impl_aux_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RETURN_as_SPEC_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
        order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> GS_invar.idx_of_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> GS_invar PRE'<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span> 
        order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> collapse_refine<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> OSR B PRE<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">simplified</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span>
        <span class="dynamic"><span class="dynamic">refine_vcg</span></span>
      <span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> PRE' <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> L<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> Un_set_drop_impl_correct acc_bound R
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gGS_rel_def GS_rel_def GS.α_def br_def gGS_α_def gGS_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> L <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> AUX1 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> L<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> in_set_dropD<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> in_set_takeD<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gcollapse_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="tfree">'Q</span> gGS nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gcollapse_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>     
    <span class="keyword1">do</span> <span class="main">{</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      <span class="bound">i</span> <span class="main">←</span> GS.idx_of_impl <span class="main">(</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span> <span class="main">≤</span> length <span class="bound">B</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">B</span> <span class="main">=</span> take <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="bound">B</span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">i</span> <span class="main">&lt;</span> length <span class="bound">A</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">us</span><span class="main">←</span>Un_set_drop_impl <span class="bound">i</span> <span class="bound">A</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">A</span> <span class="main">=</span> take <span class="bound">i</span> <span class="bound">A</span> <span class="main">@</span> <span class="main">[</span><span class="bound">us</span><span class="main">]</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">A</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gcollapse_impl_aux_opt_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"gcollapse_impl <span class="free">v</span> <span class="free">s</span> <span class="main">≤</span> gcollapse_impl_aux <span class="free">v</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gcollapse_impl_def gcollapse_impl_aux_def collapse_impl_def 
      GS.collapse_impl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> pw_le_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> gcollapse_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s'</span><span class="main">,</span> <span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span> <span class="main">∈</span> gGS_rel"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v'</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"gcollapse_impl <span class="free">v'</span> <span class="free">s'</span> 
    <span class="main">≤</span> <span class="main">⇓</span> gGS_rel <span class="main">(</span>RETURN <span class="main">(</span>gcollapse <span class="free">v</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span> <span class="free">p</span><span class="main">,</span> <span class="free">D</span><span class="main">,</span> <span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> order_trans<span class="main">[</span><span class="operator">OF</span> 
      gcollapse_impl_aux_opt_refine 
      gcollapse_impl_aux_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ginitial_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> goGS <span class="main">⇒</span> <span class="tfree">'Q</span> gGS"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ginitial_impl</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">s0</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">[</span>acc <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">]</span><span class="main">,</span>initial_impl <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s0</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> ginitial_impl_refine<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∉</span>goD <span class="free">s0</span>"</span></span> <span class="quoted"><span class="quoted">"go_is_no_brk <span class="free">s0</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> REL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s0i</span><span class="main">,</span><span class="free">s0</span><span class="main">)</span><span class="main">∈</span>goGS_rel"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0i</span><span class="main">,</span><span class="free">v0</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ginitial_impl <span class="free">v0i</span> <span class="free">s0i</span><span class="main">,</span>ginitial <span class="free">v0</span> <span class="free">s0</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ginitial_impl_def ginitial_def 
    <span class="keyword1"><span class="command">using</span></span> REL initial_refine<span class="main">[</span><span class="operator">OF</span> A<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> _ REL<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"snd <span class="free">s0i</span>"</span></span><span class="main">]</span> A<span class="main">(</span>2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_α_def gGS_invar_def goGS_rel_def goGS_α_def
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> go_is_no_brk_def goD_def oGS_rel_def GS_rel_def goGS_invar_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits

    <span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> acc_bound
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> initial_impl_def GS_initial_impl_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gpath_is_empty_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gpath_is_empty_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> path_is_empty_impl <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gpath_is_empty_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel <span class="main">⟹</span> gpath_is_empty_impl <span class="free">s</span> <span class="main">⟷</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpath_is_empty_impl_def 
    <span class="keyword1"><span class="command">using</span></span> path_is_empty_refine
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_invar_def gGS_α_def GS.α_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gis_on_stack_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> gGS <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gis_on_stack_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> is_on_stack_impl <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gis_on_stack_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel<span class="main">⟧</span> <span class="main">⟹</span> gis_on_stack_impl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span><span class="main">⋃</span><span class="main">(</span>set <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gis_on_stack_impl_def 
    <span class="keyword1"><span class="command">using</span></span> is_on_stack_refine
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_invar_def gGS_α_def GS.α_def<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gis_done_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> gGS <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gis_done_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> is_done_impl <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">thm</span></span> is_done_refine
  <span class="keyword1"><span class="command">lemma</span></span> gis_done_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel 
    <span class="main">⟹</span> gis_done_impl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">v</span> <span class="main">∈</span> <span class="free">D</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> is_done_refine<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snd <span class="free">s</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_α_def gGS_invar_def GS.α_def 
            gis_done_impl_def<span class="main">)</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">on_stack_less</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
      Some <span class="main">(</span>STACK <span class="bound">j</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">j</span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">u</span></span></span>
    <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">on_stack_ge</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span> 
      Some <span class="main">(</span>STACK <span class="bound">j</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">≤</span><span class="bound">j</span>
    <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> set_butlast_p_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"p_α<span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Collect <span class="main">(</span>on_stack_less I <span class="main">(</span>last B<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast p_α<span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span><span class="main">=</span><span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"S<span class="main">≠</span><span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_eq<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?L</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="skolem">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>last B"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> on_stack_less_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits node_state.splits<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> I_consistent<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
      <span class="keyword1"><span class="command">from</span></span> B0 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"B<span class="main">!</span><span class="main">0</span><span class="main">=</span><span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span>last B›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>B<span class="main">!</span><span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> find_seg_bounds<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem"><span class="skolem">j</span></span></span><span class="main"><span class="main"><span class="main">&lt;</span></span></span>length S›</span></span></span></span><span class="main">]</span> find_seg_correct<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="skolem"><span class="skolem">j</span></span><span class="main"><span class="main">&lt;</span></span>length S›</span></span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>seg <span class="main">(</span>find_seg <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="skolem">j</span> <span class="main">&lt;</span> length B"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">&lt;</span>B<span class="main">!</span><span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="skolem">j</span> <span class="main">&lt;</span> length B <span class="main">-</span> <span class="main">1</span>"</span></span>
        <span class="comment1">(* What follows is an unreadable, auto-generated structured proof
          that replaces the following smt-call:
        by (smt GS.seg_start_def `seg_start (find_seg j) ≤ j`)*)</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span><span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">-</span> <span class="bound">x</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> less_imp_diff_less <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">≤</span> last B"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> last B›</span></span> less_le<span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span><span class="main">.</span> <span class="main">¬</span> last B <span class="main">&lt;</span> <span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> f1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> diff_diff_cancel le_trans<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span><span class="main">.</span> seg_end <span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">≤</span> <span class="skolem">j</span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">x<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">&lt;</span> find_seg <span class="skolem">j</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="quoted"><span class="quoted">‹seg_start <span class="main">(</span>find_seg <span class="skolem">j</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">j</span>›</span></span> calculation<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 
            le_trans seg_end_less_start<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"find_seg <span class="skolem">j</span> <span class="main">&lt;</span> length B <span class="main">-</span> <span class="main">1</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> f1 f2 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> GS.seg_start_def <span class="quoted"><span class="quoted">‹B <span class="main">≠</span> <span class="main">[]</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> B <span class="main">!</span> <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>›</span></span>
            <span class="quoted"><span class="quoted">‹seg_start <span class="main">(</span>find_seg <span class="skolem">j</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">j</span>›</span></span> calculation<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> diff_diff_cancel 
            last_conv_nth nat_neq_iff seg_start_less_end<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?R</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def map_butlast<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> butlast_upt<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?R</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length B <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>seg <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def map_butlast<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> butlast_upt<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> seg_end <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>B<span class="main">!</span><span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">+</span><span class="main">1</span> <span class="main">≤</span> length B <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">&lt;</span>length B <span class="main">-</span> <span class="main">1</span>›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_end_def last_conv_nth <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> sorted_nth_mono<span class="main">[</span><span class="operator">OF</span> B_sorted <span class="quoted"><span class="quoted">‹<span class="skolem">i</span><span class="main">+</span><span class="main">1</span> <span class="main">≤</span> length B <span class="main">-</span> <span class="main">1</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>last B"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> last_conv_nth<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span> <span class="main">&lt;</span> seg_end <span class="skolem">i</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> GS.seg_end_def add_diff_inverse_nat <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> length B <span class="main">-</span> <span class="main">1</span>›</span></span>
          add_lessD1 less_imp_diff_less less_le_not_le nat_neq_iff 
          seg_end_bound<span class="main">)</span>
        <span class="comment1">(*by (smt `i &lt; length B - 1` seg_end_bound)*)</span>
      <span class="keyword1"><span class="command">with</span></span> I_consistent <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"I <span class="skolem">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?L</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> on_stack_less_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> GS_invar<span class="main">)</span> set_last_p_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"p_α<span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Collect <span class="main">(</span>on_stack_ge I <span class="main">(</span>last B<span class="main">)</span><span class="main">)</span> <span class="main">=</span> last p_α"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?L</span><span class="main">=</span><span class="var">?R</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"B<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"S<span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> empty_eq<span class="main">)</span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?L</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="skolem">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">≥</span>last B"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> on_stack_ge_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits node_state.splits<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> I_consistent<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>seg <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">≥</span>last B›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_def last_conv_nth seg_start_def seg_end_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>last p_α"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def last_map<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?R</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>seg <span class="main">(</span>length B <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_α_def last_map<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">=</span>S<span class="main">!</span><span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">≥</span>last B"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span><span class="main">&lt;</span>length S"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> seg_def last_conv_nth seg_start_def seg_end_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> I_consistent <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"I <span class="skolem">v</span> <span class="main">=</span> Some <span class="main">(</span>STACK <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">j</span><span class="main">≥</span>last B›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="var">?L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> on_stack_ge_def<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">ce_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> gGS <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option <span class="main">×</span> <span class="tfree">'Q</span> gGS<span class="main">)</span> nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ce_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">B</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">bls</span> <span class="main">=</span> Collect <span class="main">(</span>on_stack_less <span class="bound">I</span> <span class="main">(</span>last <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">ls</span> <span class="main">=</span> Collect <span class="main">(</span>on_stack_ge <span class="bound">I</span> <span class="main">(</span>last <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span>Some <span class="main">(</span><span class="bound">bls</span><span class="main">,</span> <span class="bound">ls</span><span class="main">)</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">S</span><span class="main">,</span><span class="bound">B</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">P</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ce_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ce_impl <span class="free">s</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>Id<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>gGS_rel<span class="main">)</span> 
      <span class="main">(</span>RETURN <span class="main">(</span>Some <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>set <span class="main">(</span>butlast <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>last <span class="free">p</span><span class="main">)</span><span class="main">,</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">S'</span></span> <span class="skolem"><span class="skolem">B'</span></span> <span class="skolem"><span class="skolem">I'</span></span> <span class="skolem"><span class="skolem">P'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> OSR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>GS_rel"</span></span> <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">a</span> <span class="main">=</span> length <span class="skolem">B'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gGS_relE<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> OSR <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def GS.α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> NE'<span class="main">:</span> <span class="quoted"><span class="quoted">"GS.p_α <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span> <span class="skolem">B'</span><span class="main">,</span> <span class="skolem">I'</span><span class="main">,</span> <span class="skolem">P'</span><span class="main">)</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> BNE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">B'</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS.p_α_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> OSR <span class="keyword1"><span class="command">have</span></span> GS_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"GS_invar <span class="main">(</span><span class="skolem">S'</span><span class="main">,</span><span class="skolem">B'</span><span class="main">,</span><span class="skolem">I'</span><span class="main">,</span><span class="skolem">P'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> GS_rel_def br_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> GS_invar.set_butlast_p_refine<span class="main">[</span><span class="operator">OF</span> GS_invar NE'<span class="main">]</span>
      <span class="keyword1"><span class="command">using</span></span> GS_invar.set_last_p_refine<span class="main">[</span><span class="operator">OF</span> GS_invar NE'<span class="main">]</span>
      <span class="keyword1"><span class="command">unfolding</span></span> ce_impl_def
      <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">last_is_acc_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">a</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>last <span class="bound">a</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> last_is_acc_impl_refine<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">p</span><span class="main">,</span><span class="free">D</span><span class="main">,</span><span class="free">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span><span class="main">≠</span><span class="main">[]</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"last_is_acc_impl <span class="free">s</span> <span class="main">≤</span> RETURN <span class="main">(</span>last <span class="free">a</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> A PRE <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"last <span class="free">a</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gGS_rel_def gGS_invar_def br_def gGS_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="bound">i</span><span class="main">∈</span>last <span class="free">a</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>last <span class="free">a</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">gs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">=</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="skolem">gs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def gGS_α_def br_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> last_is_acc_impl_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gGS_rel_def br_def gGS_α_def C PRE <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">go_is_no_brk_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> goGS <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">go_is_no_brk_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> fst <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> None"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> go_is_no_brk_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>goGS_rel <span class="main">⟹</span> go_is_no_brk_impl <span class="free">s</span> <span class="main">⟷</span> go_is_no_brk <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> go_is_no_brk_def go_is_no_brk_impl_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goD_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> goGS <span class="main">⇒</span> <span class="tfree">'Q</span> oGS"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goD_impl</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> snd <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> goD_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"go_is_no_brk <span class="free">s'</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>goGS_rel <span class="main">⟹</span> <span class="main">(</span>goD_impl <span class="free">s</span><span class="main">,</span> goD <span class="free">s'</span><span class="main">)</span><span class="main">∈</span>oGS_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> goD_impl_def goD_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_α_def goGS_invar_def oGS_rel_def 
            go_is_no_brk_def<span class="main">)</span> 

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">go_is_done_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> <span class="main">⇒</span> <span class="tfree">'Q</span> goGS <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">go_is_done_impl</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> is_done_oimpl <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">thm</span></span> is_done_orefine
  <span class="keyword1"><span class="command">lemma</span></span> go_is_done_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>go_is_no_brk <span class="free">s'</span><span class="main">;</span> <span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>goGS_rel<span class="main">;</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>Id<span class="main">⟧</span> 
    <span class="main">⟹</span> go_is_done_impl <span class="free">v</span> <span class="free">s</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">v'</span><span class="main">∈</span>goD <span class="free">s'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> is_done_orefine
    <span class="keyword1"><span class="command">unfolding</span></span> go_is_done_impl_def goD_def go_is_no_brk_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_invar_def goGS_α_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">goBrk_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> goGS <span class="main">⇒</span> <span class="tfree">'Q</span> ce"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">goBrk_impl</span> <span class="main">≡</span> fst"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> goBrk_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span><span class="free">s'</span><span class="main">)</span><span class="main">∈</span>goGS_rel <span class="main">⟹</span> <span class="main">(</span>goBrk_impl <span class="free">s</span><span class="main">,</span> goBrk <span class="free">s'</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> goBrk_impl_def goBrk_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_α_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_ce_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'Q</span> set <span class="main">×</span> <span class="tfree">'Q</span> set<span class="main">)</span> option nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">find_ce_impl</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      stat_start_nres<span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">os</span><span class="main">=</span>goinitial_impl<span class="main">;</span>
      <span class="bound">os</span><span class="main">←</span>FOREACHci <span class="main">(</span><span class="main">λ</span><span class="bound">it</span> <span class="bound">os</span><span class="main">.</span> fgl_outer_invar <span class="bound">it</span> <span class="main">(</span>goGS_α <span class="bound">os</span><span class="main">)</span><span class="main">)</span> V0 
        <span class="main">(</span>go_is_no_brk_impl<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v0</span> <span class="bound">s0</span><span class="main">.</span> 
      <span class="keyword1">do</span> <span class="main">{</span>
        <span class="keyword1">if</span> <span class="main">¬</span>go_is_done_impl <span class="bound">v0</span> <span class="bound">s0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>

          <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">(</span>None<span class="main">,</span>ginitial_impl <span class="bound">v0</span> <span class="bound">s0</span><span class="main">)</span><span class="main">;</span>

          <span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">←</span>WHILEIT 
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> fgl_invar <span class="bound">v0</span> <span class="main">(</span>oGS_α <span class="main">(</span>goD_impl <span class="bound">s0</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="bound">brk</span><span class="main">,</span>snd <span class="main">(</span>gGS_α <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">brk</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="bound">brk</span><span class="main">=</span>None <span class="main">∧</span> <span class="main">¬</span>gpath_is_empty_impl <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span>
          <span class="keyword1">do</span> <span class="main">{</span>
            <span class="comment1">― ‹Select edge from end of path›</span>
            <span class="main">(</span><span class="bound">vo</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span> <span class="main">←</span> gselect_edge_impl <span class="bound">s</span><span class="main">;</span>

            <span class="keyword1">case</span> <span class="bound">vo</span> <span class="keyword1">of</span> 
              Some <span class="bound">v</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="keyword1">if</span> gis_on_stack_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="bound">s</span><span class="main">←</span>gcollapse_impl <span class="bound">v</span> <span class="bound">s</span><span class="main">;</span>
                  <span class="bound">b</span><span class="main">←</span>last_is_acc_impl <span class="bound">s</span><span class="main">;</span>
                  <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span>
                    ce_impl <span class="bound">s</span>
                  <span class="keyword1">else</span> 
                    RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">s</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">¬</span>gis_done_impl <span class="bound">v</span> <span class="bound">s</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to new node. Append to path›</span>
                  RETURN <span class="main">(</span>None<span class="main">,</span>gpush_impl <span class="bound">v</span> <span class="bound">s</span><span class="main">)</span>
                <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
                  <span class="comment1">― ‹Edge to done node. Skip›</span>
                  RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">s</span><span class="main">)</span>
                <span class="main">}</span>
              <span class="main">}</span>
            <span class="main">|</span> None <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
                <span class="comment1">― ‹No more outgoing edges from current node on path›</span>
                <span class="bound">s</span><span class="main">←</span>gpop_impl <span class="bound">s</span><span class="main">;</span>
                RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">s</span><span class="main">)</span>
              <span class="main">}</span>
          <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">s</span><span class="main">)</span><span class="main">;</span>
          RETURN <span class="main">(</span>gto_outer_impl <span class="bound">brk</span> <span class="bound">s</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="bound">s0</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">os</span><span class="main">;</span>
      stat_stop_nres<span class="main">;</span>
      RETURN <span class="main">(</span>goBrk_impl <span class="bound">os</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> find_ce_impl_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"find_ce_impl <span class="main">≤</span> <span class="main">⇓</span>Id gfind_ce"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine2</span><span class="main">]</span> <span class="main">=</span> prod_relI<span class="main">[</span><span class="operator">OF</span> IdI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted">None</span><span class="main"><span class="main">]</span></span> ginitial_impl_refine<span class="main">]</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">a</span> <span class="bound">p</span> <span class="bound">D</span> <span class="bound">pE</span><span class="main">.</span> <span class="main">⟦</span>
      <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span><span class="main">∈</span>gGS_rel<span class="main">;</span>
      <span class="bound">p</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">;</span> <span class="bound">pE</span> <span class="main">∩</span> last <span class="bound">p</span> <span class="main">×</span> UNIV <span class="main">=</span> <span class="main">{}</span>
      <span class="main">⟧</span> <span class="main">⟹</span>
      gpop_impl <span class="bound">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>None<span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
        <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> None<span class="main">,</span> gpop <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">D</span><span class="main">,</span><span class="bound">pE</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> gGS_rel<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> gpop_impl_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>

    <span class="keyword1"><span class="command">note</span></span> FOREACHci_refine_rcg'<span class="main">[</span><span class="operator">refine</span> <span class="quasi_keyword">del</span><span class="main">]</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> find_ce_impl_def gfind_ce_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
        bind_refine'
        prod_relI IdI
        inj_on_id

        gselect_edge_impl_refine gpush_impl_refine 
        oinitial_refine ginitial_impl_refine 
        bind_Let_refine2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> gcollapse_impl_refine<span class="main"><span class="main">]</span></span>
        if_bind_cond_refine<span class="main"><span class="main">[</span></span><span class="operator">OF</span> last_is_acc_impl_refine<span class="main"><span class="main">]</span></span>
        ce_impl_refine
        goinitial_impl_refine
        gto_outer_refine
        goBrk_refine
        FOREACHci_refine_rcg'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">goGS_rel</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> inj_on_id<span class="main"><span class="main">]</span></span>
      <span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_dref_type</span>
    
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> go_is_no_brk_refine go_is_done_impl_refine<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> goGS_rel_def br_def goGS_α_def gGS_α_def gGS_rel_def 
                        goD_def goD_impl_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> gpath_is_empty_refine <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> gis_on_stack_refine<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> gis_done_refine<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Constructing a Lasso from Counterexample›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lassos in GBAs›</span></span>

<span class="keyword1"><span class="command">context</span></span> igb_fr_graph <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">reconstruct_reach</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span> list <span class="main">×</span> <span class="tfree">'Q</span><span class="main">)</span> nres"</span></span>
    <span class="comment1">― ‹Reconstruct the reaching path of a lasso›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reconstruct_reach</span> <span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">res</span> <span class="main">←</span> find_path <span class="main">(</span>E<span class="main">∩</span><span class="free"><span class="bound"><span class="entity">Vr</span></span></span><span class="main">×</span>UNIV<span class="main">)</span> V0 <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">)</span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">res</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span>the <span class="bound">res</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> reconstruct_reach_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> CEC<span class="main">:</span> <span class="quoted"><span class="quoted">"ce_correct <span class="free">Vr</span> <span class="free">Vl</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reconstruct_reach <span class="free">Vr</span> <span class="free">Vl</span> 
      <span class="main">≤</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">va</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">v0</span><span class="main">∈</span>V0<span class="main">.</span> path E <span class="bound">v0</span> <span class="bound">pr</span> <span class="bound">va</span> <span class="main">∧</span> <span class="bound">va</span><span class="main">∈</span><span class="free">Vl</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> FIN_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span>E <span class="main">∩</span> <span class="free">Vr</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> V0<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_reachableE_V0 finite_subset inf_sup_ord<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> inf_sup_ord<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
        inf_top.left_neutral reachable_mono<span class="main">)</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>
      <span class="keyword3"><span class="command">assume</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="skolem">p</span> <span class="main">⊆</span> <span class="free">Vr</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span>E <span class="main">∩</span> <span class="free">Vr</span><span class="main">×</span>UNIV<span class="main">)</span> <span class="skolem">u</span> <span class="skolem">p</span> <span class="skolem">v</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ path_restrict<span class="main"><span class="main">[</span></span><span class="operator">OF</span> P<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> SS <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> P_CONV<span class="main">=</span>this

    <span class="keyword1"><span class="command">from</span></span> CEC <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v0</span></span> <span class="quoted">"<span class="skolem"><span class="skolem">pr</span></span>"</span> <span class="skolem"><span class="skolem">va</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span><span class="main">∈</span>V0"</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">pr</span> <span class="main">⊆</span> <span class="free">Vr</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">va</span><span class="main">∈</span><span class="free">Vl</span>"</span></span> 
      <span class="quoted"><span class="quoted">"path <span class="main">(</span>E <span class="main">∩</span> <span class="free">Vr</span><span class="main">×</span>UNIV<span class="main">)</span> <span class="skolem">v0</span> <span class="skolem">pr</span> <span class="skolem">va</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> ce_correct_def is_lasso_prpl_def is_lasso_prpl_pre_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv path_simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> P_CONV<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">va</span> <span class="main">∈</span> <span class="main">(</span>E <span class="main">∩</span> <span class="free">Vr</span> <span class="main">×</span> UNIV<span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> V0"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
      
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> reconstruct_reach_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path_ex_rule<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> FIN_aux finite_V0<span class="main">)</span>

      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">va</span><span class="main">∈</span><span class="free">Vl</span>›</span></span> 1 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> <span class="free">Vr</span> <span class="main">×</span> UNIV"</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">rec_loop_invar</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="free"><span class="bound"><span class="entity">va</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">cS</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span> 
    <span class="free"><span class="bound"><span class="entity">va</span></span></span> <span class="main">∈</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0 <span class="main">∧</span>
    path E <span class="free"><span class="bound"><span class="entity">va</span></span></span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span>
    <span class="bound">cS</span> <span class="main">=</span> acc <span class="bound">v</span> <span class="main">∪</span> <span class="main">(</span><span class="main">⋃</span><span class="main">(</span>acc<span class="main">`</span>set <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">va</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">∧</span> set <span class="bound">p</span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">reconstruct_lasso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="tfree">'Q</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'Q</span> list <span class="main">×</span> <span class="tfree">'Q</span> list<span class="main">)</span> nres"</span></span>
    <span class="comment1">― ‹Reconstruct lasso›</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">reconstruct_lasso</span> <span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">pr</span><span class="main">,</span><span class="bound">va</span><span class="main">)</span> <span class="main">←</span> reconstruct_reach <span class="free"><span class="bound"><span class="entity">Vr</span></span></span> <span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">;</span>
    
    <span class="keyword1">let</span> <span class="bound">cS_full</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">E</span> <span class="main">=</span> E <span class="main">∩</span> UNIV<span class="main">×</span><span class="free"><span class="bound"><span class="entity">Vl</span></span></span><span class="main">;</span>
    
    <span class="main">(</span><span class="bound">vd</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> WHILEIT <span class="main">(</span>rec_loop_invar <span class="free"><span class="bound"><span class="entity">Vl</span></span></span> <span class="bound">va</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">cS</span><span class="main">)</span><span class="main">.</span> <span class="bound">cS</span> <span class="main">≠</span> <span class="bound">cS_full</span><span class="main">)</span> 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">,</span><span class="bound">cS</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="main">∃</span><span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span><span class="bound">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">¬</span> <span class="main">(</span>acc <span class="bound">v'</span> <span class="main">⊆</span> <span class="bound">cS</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">sr</span> <span class="main">←</span> find_path <span class="bound">E</span> <span class="main">{</span><span class="bound">v</span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="main">¬</span> <span class="main">(</span>acc <span class="bound">v</span> <span class="main">⊆</span> <span class="bound">cS</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        ASSERT <span class="main">(</span><span class="bound">sr</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p_seg</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">=</span> the <span class="bound">sr</span><span class="main">;</span>
        RETURN <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">p</span><span class="main">@</span><span class="bound">p_seg</span><span class="main">,</span><span class="bound">cS</span> <span class="main">∪</span> acc <span class="bound">v</span><span class="main">)</span>
      <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="bound">va</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span>acc <span class="bound">va</span><span class="main">)</span><span class="main">;</span>

    <span class="bound">p_close_r</span> <span class="main">←</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">p</span><span class="main">=</span><span class="main">[]</span> <span class="keyword1">then</span> 
        find_path1 <span class="bound">E</span> <span class="bound">vd</span> <span class="main">(</span><span class="main">(=)</span> <span class="bound">va</span><span class="main">)</span>
      <span class="keyword1">else</span>
        find_path <span class="bound">E</span> <span class="main">{</span><span class="bound">vd</span><span class="main">}</span> <span class="main">(</span><span class="main">(=)</span> <span class="bound">va</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

    ASSERT <span class="main">(</span><span class="bound">p_close_r</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">p_close</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">=</span> the <span class="bound">p_close_r</span><span class="main">;</span>

    RETURN <span class="main">(</span><span class="bound">pr</span><span class="main">,</span> <span class="bound">p</span><span class="main">@</span><span class="bound">p_close</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> igb_fr_graph<span class="main">)</span> reconstruct_lasso_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> CEC<span class="main">:</span> <span class="quoted"><span class="quoted">"ce_correct <span class="free">Vr</span> <span class="free">Vl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"reconstruct_lasso <span class="free">Vr</span> <span class="free">Vl</span> <span class="main">≤</span> SPEC <span class="main">(</span>is_lasso_prpl<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?E</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> UNIV <span class="main">×</span> <span class="free">Vl</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> E_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"E <span class="main">∩</span> <span class="free">Vl</span> <span class="main">×</span> <span class="free">Vl</span> <span class="main">⊆</span> <span class="var">?E</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">from</span></span> CEC <span class="keyword1"><span class="command">have</span></span>
    REACH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Vl</span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> CONN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span> <span class="main">⊆</span> <span class="main">(</span>E <span class="main">∩</span> <span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> NONTRIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span> <span class="main">∩</span> E <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> NES<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Vl</span><span class="main">≠</span><span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ALL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>acc<span class="main">`</span><span class="free">Vl</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ce_correct_def is_lasso_prpl_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">term_rel</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">term_rel</span> <span class="main">=</span> <span class="main">(</span>inv_image <span class="main">(</span>finite_psupset <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">::</span><span class="tfree">'Q</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">::</span><span class="tfree">'Q</span> list<span class="main">,</span><span class="bound">cS</span><span class="main">)</span><span class="main">.</span> <span class="bound">cS</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="skolem">term_rel</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">va</span> <span class="main">∈</span> <span class="free">Vl</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">va</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> acc <span class="skolem">va</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def <span class="keyword1"><span class="command">using</span></span> REACH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> INVAR_INITIAL <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">cS</span> <span class="skolem">va</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>V0"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command">using</span></span> REACH
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp_all</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_is_rtrancl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> rtrancl_mono_mp<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> U<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="var">?E</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> V<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> rev_ImageI rtrancl_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> FIN1 <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'Q</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="skolem">cS</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">cS</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> NC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cS</span> <span class="main">≠</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> NC INV <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>num_acc"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">∉</span><span class="skolem">cS</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">with</span></span> ALL <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span><span class="free">Vl</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> acc <span class="skolem">v'</span> <span class="main">⊆</span> <span class="skolem">cS</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">smt</span> UN_iff atLeastLessThan_iff le0 subsetCE<span class="main">)</span>
     
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">with</span></span></span> CONN INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E <span class="main">∩</span> <span class="free">Vl</span> <span class="main">×</span> <span class="free">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span><span class="var">?E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> rtrancl_mono_mp<span class="main">[</span><span class="operator">OF</span> E_SS<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="main">¬</span> acc <span class="bound">v'</span> <span class="main">⊆</span> <span class="skolem">cS</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> ASSERT1 <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">cS</span> <span class="skolem">v'</span> <span class="skolem">p'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"path <span class="main">(</span><span class="var">?E</span><span class="main">)</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">v'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span>acc <span class="skolem">v'</span> <span class="main">⊆</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="skolem">p'</span><span class="main">.</span> acc <span class="bound">v</span> <span class="main">⊆</span> <span class="skolem">cS</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">p</span><span class="main">@</span><span class="skolem">p'</span><span class="main">,</span> <span class="skolem">cS</span> <span class="main">∪</span> acc <span class="skolem">v'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?E</span>"</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> path_set_induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> INV_PRES <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">cS</span> <span class="skolem">v'</span> <span class="skolem">p'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?E</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">v'</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span>acc <span class="skolem">v'</span> <span class="main">⊆</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="skolem">p'</span><span class="main">.</span> acc <span class="bound">v</span> <span class="main">⊆</span> <span class="skolem">cS</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="skolem">v'</span><span class="main">,</span> <span class="skolem">p</span><span class="main">@</span><span class="skolem">p'</span><span class="main">,</span> <span class="skolem">cS</span> <span class="main">∪</span> acc <span class="skolem">v'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">cS</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">term_rel</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> term_rel_def rec_loop_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_psupset_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> VAR <span class="main">=</span> this

  <span class="keyword1"><span class="command">have</span></span> CONN1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Vl</span> <span class="main">×</span> <span class="free">Vl</span> <span class="main">⊆</span> <span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">clarify</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span><span class="main">∈</span><span class="free">Vl</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span><span class="main">∈</span><span class="free">Vl</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> NONTRIV <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> E<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E <span class="main">∩</span> <span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> CONN <span class="quoted"><span class="quoted">‹<span class="skolem">a</span><span class="main">∈</span><span class="free">Vl</span>›</span></span> E <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E<span class="main">∩</span><span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> E
    <span class="keyword1"><span class="command">also</span></span> <span class="main">(</span>rtrancl_into_trancl1<span class="main">)</span> <span class="keyword1"><span class="command">from</span></span> CONN <span class="quoted"><span class="quoted">‹<span class="skolem">b</span><span class="main">∈</span><span class="free">Vl</span>›</span></span> E <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span>E<span class="main">∩</span><span class="free">Vl</span><span class="main">×</span><span class="free">Vl</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">a</span><span class="main">,</span><span class="skolem">b</span><span class="main">)</span><span class="main">∈</span><span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">using</span></span> trancl_mono<span class="main">[</span><span class="operator">OF</span> _ E_SS<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">cS</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">va</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command">using</span></span> CONN1
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> CLOSE1 <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">cS</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span> <span class="skolem">p</span><span class="main">,</span> <span class="skolem">cS</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">va</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="var">?E</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command">using</span></span> CONN rtrancl_mono<span class="main">[</span><span class="operator">OF</span> E_SS<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> CLOSE2 <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="quoted">"<span class="skolem">pr</span>"</span> <span class="skolem">vd</span> <span class="skolem">pl</span> <span class="skolem">va</span> <span class="skolem">v0</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">vd</span><span class="main">,</span> <span class="main">[]</span><span class="main">,</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">va</span> <span class="main">∈</span> <span class="free">Vl</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span> <span class="main">∈</span> V0"</span></span>
      <span class="quoted"><span class="quoted">"path E <span class="skolem">v0</span> <span class="skolem">pr</span> <span class="skolem">va</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pl</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?E</span> <span class="skolem">vd</span> <span class="skolem">pl</span> <span class="skolem">va</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_lasso_prpl <span class="main">(</span><span class="skolem">pr</span><span class="main">,</span> <span class="skolem">pl</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_lasso_prpl_def is_lasso_prpl_pre_def rec_loop_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv path_simps
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?E</span>"</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> INV_POST1 <span class="main">=</span> this

  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">va</span> <span class="skolem">v</span> <span class="skolem">p</span> <span class="skolem">p'</span> <span class="quoted">"<span class="skolem">pr</span>"</span> <span class="skolem">v0</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"rec_loop_invar <span class="free">Vl</span> <span class="skolem">va</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">p</span><span class="main">,</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>num_acc<span class="main">}</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"path <span class="var">?E</span> <span class="skolem">v</span> <span class="skolem">p'</span> <span class="skolem">va</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> PR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v0</span><span class="main">∈</span>V0"</span></span> <span class="quoted"><span class="quoted">"path E <span class="skolem">v0</span> <span class="skolem">pr</span> <span class="skolem">va</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>insert <span class="skolem">v</span> <span class="main">(</span>set <span class="skolem">p</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∈</span> acc <span class="bound">q</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> INV 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insert <span class="skolem">v</span> <span class="main">(</span>set <span class="skolem">p</span><span class="main">)</span> <span class="main">⊆</span> set <span class="skolem">p</span> <span class="main">∪</span> set <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rec_loop_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> path_simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> ACC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>num_acc<span class="main">.</span> <span class="main">∃</span><span class="bound">q</span><span class="main">∈</span>set <span class="skolem">p</span> <span class="main">∪</span> set <span class="skolem">p'</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∈</span> acc <span class="bound">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
    <span class="keyword1"><span class="command">from</span></span> INV 1 <span class="keyword1"><span class="command">have</span></span> PL<span class="main">:</span> <span class="quoted"><span class="quoted">"path E <span class="skolem">va</span> <span class="main">(</span><span class="skolem">p</span> <span class="main">@</span> <span class="skolem">p'</span><span class="main">)</span> <span class="skolem">va</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rec_loop_invar_def path_simps 
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_mono<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?E</span>"</span></span> <span class="quoted">E</span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_lasso_prpl <span class="main">(</span><span class="skolem">pr</span><span class="main">,</span><span class="skolem">p</span><span class="main">@</span><span class="skolem">p'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_lasso_prpl_def is_lasso_prpl_pre_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ACC<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> PR PL <span class="quoted"><span class="quoted">‹<span class="skolem">p</span><span class="main">≠</span><span class="main">[]</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> INV_POST2 <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reconstruct_lasso_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> 
      WF
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reconstruct_reach_correct<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path_ex_rule<span class="main"><span class="main">]</span></span>
      order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> find_path1_ex_rule<span class="main"><span class="main">]</span></span>
      <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
    <span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> 
      <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> subsetI
      <span class="quasi_keyword">solve</span><span class="main"><span class="main">:</span></span> ASSERT1 INV_PRES asm_rl VAR CLOSE1 CLOSE2 INV_POST1 INV_POST2
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> INVAR_INITIAL FIN1 CEC<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">find_lasso</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_lasso</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">ce</span> <span class="main">←</span> find_ce_spec<span class="main">;</span>
  <span class="keyword1">case</span> <span class="bound">ce</span> <span class="keyword1">of</span> 
    None <span class="main">⇒</span> RETURN None
  <span class="main">|</span> Some <span class="main">(</span><span class="bound">Vr</span><span class="main">,</span><span class="bound">Vl</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">l</span> <span class="main">←</span> reconstruct_lasso <span class="bound">Vr</span> <span class="bound">Vl</span><span class="main">;</span>
      RETURN <span class="main">(</span>Some <span class="bound">l</span><span class="main">)</span>
    <span class="main">}</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> igb_fr_graph<span class="main">)</span> find_lasso_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"find_lasso <span class="main">≤</span> find_lasso_spec"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_lasso_spec_def find_lasso_def find_ce_spec_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> reconstruct_lasso_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Gabow_Skeleton_Code">
<div class="head">
<h1>Theory Gabow_Skeleton_Code</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code Generation for the Skeleton Algorithm \label{sec:skel_code}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_Skeleton_Code
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Gabow_Skeleton.html">Gabow_Skeleton</a>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
  <a href="../CAVA_Base/CAVA_Code_Target.html">CAVA_Base.CAVA_Code_Target</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Statistics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this section, we do the ML setup that gathers statistics about the 
  algorithm's execution.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> Gabow_Skeleton_Statistics <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‹
    structure Gabow_Skeleton_Statistics = struct
      val active = Unsynchronized.ref false
      val num_vis = Unsynchronized.ref 0

      val time = Unsynchronized.ref Time.zeroTime

      fun is_active () = !active
      fun newnode () =
      (
        num_vis := !num_vis + 1;
        if !num_vis mod 10000 = 0 then tracing (IntInf.toString (!num_vis) ^ "\n") else ()
      )

      fun start () = (active := true; time := Time.now ())
      fun stop () = (time := Time.- (Time.now (), !time))

      fun to_string () = let
        val t = Time.toMilliseconds (!time)
        val states_per_ms = real (!num_vis) / real t
        val realStr = Real.fmt (StringCvt.FIX (SOME 2))
      in
        "Required time: " ^ IntInf.toString (t) ^ "ms\n"
      ^ "States per ms: " ^ realStr states_per_ms ^ "\n"
      ^ "# states: " ^ IntInf.toString (!num_vis) ^ "\n"
      end
        
      val _ = Statistics.register_stat ("Gabow-Skeleton",is_active,to_string)

    end
›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Gabow_Skeleton_Statistics

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stat_newnode</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Gabow'_Skeleton'_Statistics.newnode"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stat_start</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Gabow'_Skeleton'_Statistics.start"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">stat_stop</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Gabow'_Skeleton'_Statistics.stop"</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automatic Refinement Setup›</span></span>
<span class="keyword1"><span class="command">consts</span></span> i_node_state <span class="main">::</span> <span class="quoted">interface</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">node_state_rel</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">::</span>int<span class="main">,</span>DONE<span class="main">)</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span>int <span class="bound">k</span><span class="main">,</span>STACK <span class="bound">k</span><span class="main">)</span> <span class="main">|</span> <span class="bound">k</span><span class="main">.</span> True <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> node_state_rel_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span>DONE<span class="main">)</span><span class="main">∈</span>node_state_rel <span class="main">⟷</span> <span class="free">i</span><span class="main">=</span><span class="main">-</span><span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">,</span>STACK <span class="free">n</span><span class="main">)</span><span class="main">∈</span>node_state_rel <span class="main">⟷</span> <span class="free">i</span> <span class="main">=</span> int <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> node_state_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> node_state_rel_sv<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"single_valued node_state_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> node_state_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> single_valuedI<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">node_state_rel</span> <span class="quoted">i_node_state</span><span class="main">]</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">is_DONE</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_DONE</span> DONE <span class="main">=</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_DONE</span> <span class="main">(</span>STACK <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> node_state_rel_refine<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">,</span>DONE<span class="main">)</span><span class="main">∈</span>node_state_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span>STACK<span class="main">)</span><span class="main">∈</span>nat_rel<span class="main">→</span>node_state_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="main">0</span><span class="main">,</span>is_DONE<span class="main">)</span><span class="main">∈</span>node_state_rel<span class="main">→</span>bool_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">g</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span><span class="main">≥</span><span class="main">0</span> <span class="keyword1">then</span> <span class="bound">f</span> <span class="main">(</span>nat <span class="bound">i</span><span class="main">)</span> <span class="keyword1">else</span> <span class="bound">g</span><span class="main">)</span><span class="main">,</span>case_node_state<span class="main">)</span>
    <span class="main">∈</span><span class="main">(</span>nat_rel <span class="main">→</span> <span class="free">R</span><span class="main">)</span> <span class="main">→</span> <span class="free">R</span> <span class="main">→</span> node_state_rel <span class="main">→</span> <span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> node_state_rel_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">=</span>DONE<span class="main">)</span> <span class="main">≡</span> is_DONE <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>DONE<span class="main">=</span><span class="free">x</span><span class="main">)</span> <span class="main">≡</span> is_DONE <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eq_reflection<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* TODO: Make changing the Autoref-config simpler, by concentrating
    everything here *)</span>
<span class="keyword1"><span class="command">consts</span></span> i_node <span class="main">::</span> <span class="quoted">interface</span>

<span class="comment1">(* TODO: Move generic part of this locale to Digraph_impl *)</span>
<span class="keyword1"><span class="command">locale</span></span> fr_graph_impl_loc <span class="main">=</span> fr_graph <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">mrel</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_eq_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'vi</span> <span class="main">⇒</span> <span class="tfree">'vi</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_hash_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'vi</span> <span class="main">⇒</span> nat"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_def_hash_size</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_impl</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
     
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_impl</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">mrel</span><span class="main">,</span><span class="free">node_rel</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_eq_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">node_eq_impl</span><span class="main">,</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_hash<span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_hash_def_size<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(*abbreviation "node_rel ≡ Id :: ('v × _) set"*)</span>
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">node_rel</span></span> <span class="quoted">i_node</span><span class="main">]</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> G_refine node_eq_refine

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span> <span class="main">=</span> node_hash node_hash_def_size
  
  
  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"fr_graph_impl_loc <span class="free">mrel</span> <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">oGSi_rel</span> <span class="main">≡</span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">,</span>node_state_rel<span class="main">⟩</span><span class="main">(</span>ahm_rel <span class="free">node_hash_impl</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">GSi_rel</span> <span class="main">≡</span> 
    <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>as_rel 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>as_rel 
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> oGSi_rel
    <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span>nat_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>as_rel"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span> <span class="main">=</span> GS.S_def GS.B_def GS.I_def GS.P_def

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generating the Code›</span></span>


<span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">autoref_ga_rules</span></span>


<span class="keyword1"><span class="command">context</span></span> fr_graph_impl_loc
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> push_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>push_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> GSi_rel <span class="main">→</span> GSi_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> push_impl_def_opt<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">push_code</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.push_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> push_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>
  
  <span class="keyword1"><span class="command">schematic_goal</span></span> pop_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>pop_impl<span class="main">)</span><span class="main">∈</span>GSi_rel <span class="main">→</span> <span class="main">⟨</span>GSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pop_impl_def_opt<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS.mark_as_done_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">pop_code</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.pop_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> pop_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> S_idx_of_code_aux<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"undefined<span class="main">::</span>nat"</span></span><span class="main">]</span> <span class="comment1">(* TODO: hack!*)</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>GS.S_idx_of<span class="main">)</span><span class="main">∈</span>GSi_rel <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> nat_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> GS.S_idx_of_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">S_idx_of_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.S_idx_of_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> S_idx_of_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 

  <span class="keyword1"><span class="command">schematic_goal</span></span> idx_of_code_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> IdI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"undefined<span class="main">::</span>nat"</span></span><span class="main">]</span> <span class="comment1">(* TODO: hack!*)</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>GS.idx_of_impl<span class="main">)</span><span class="main">∈</span> GSi_rel <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> 
      GS.idx_of_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">,</span> <span class="operator">unfolded</span> GS.find_seg_impl_def GS.S_idx_of_def<span class="main">,</span>
        <span class="operator">THEN</span> opt_GSdef<span class="main">,</span> <span class="operator">unfolded</span> GS_sel_simps<span class="main">,</span> <span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">idx_of_code</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.idx_of_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> idx_of_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 

  <span class="keyword1"><span class="command">schematic_goal</span></span> collapse_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>collapse_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> GSi_rel <span class="main">→</span> <span class="main">⟨</span>GSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_impl_def_opt<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">collapse_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.collapse_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> collapse_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">select_edge_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> select_edge_code_aux<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>select_edge_impl<span class="main">)</span> 
      <span class="main">∈</span> GSi_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> GSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> select_edge_impl_def_opt<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 

    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span><span class="main"><span class="main">=</span></span>1<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">select_edge_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.select_edge_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> select_edge_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">term</span></span> <span class="quoted">fr_graph.pop_impl</span>
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"push_impl <span class="main">≡</span> <span class="keyword1">OP</span> push_impl"</span></span>
      <span class="quoted"><span class="quoted">"collapse_impl <span class="main">≡</span> <span class="keyword1">OP</span> collapse_impl"</span></span>
      <span class="quoted"><span class="quoted">"select_edge_impl <span class="main">≡</span> <span class="keyword1">OP</span> select_edge_impl"</span></span>
      <span class="quoted"><span class="quoted">"pop_impl <span class="main">≡</span> <span class="keyword1">OP</span> pop_impl"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> skeleton_code_aux<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>skeleton_impl<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>oGSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> skeleton_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> initial_impl_def GS_initial_impl_def
    <span class="keyword1"><span class="command">unfolding</span></span> path_is_empty_impl_def is_on_stack_impl_def is_done_impl_def 
      is_done_oimpl_def
    <span class="keyword1"><span class="command">unfolding</span></span> GS.is_on_stack_impl_def GS.is_done_impl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
    
    
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">skeleton_code</span> 
    <span class="keyword2"><span class="keyword">for</span></span> node_eq_impl G_impl
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.skeleton_code_aux
    
  <span class="keyword1"><span class="command">thm</span></span>   skeleton_code.refine
    
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> skeleton_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 
  

  <span class="keyword1"><span class="command">schematic_goal</span></span> pop_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> pop_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pop_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">pop_tr</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.pop_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> pop_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> select_edge_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> select_edge_code <span class="free">node_eq_impl</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> select_edge_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">select_edge_tr</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.select_edge_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> select_edge_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> idx_of_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> idx_of_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">v</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> idx_of_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">idx_of_tr</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.idx_of_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> idx_of_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> collapse_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> collapse_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">v</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> collapse_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">collapse_tr</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.collapse_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> collapse_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> skeleton_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> skeleton_code <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">node_eq_impl</span> <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> skeleton_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">skeleton_tr</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.skeleton_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> skeleton_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">skeleton_tr</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">skeleton_tr</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Gabow_SCC_Code">
<div class="head">
<h1>Theory Gabow_SCC_Code</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code Generation for SCC-Computation \label{sec:scc_code}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_SCC_Code
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Gabow_SCC.html">Gabow_SCC</a> 
  <a href="Gabow_Skeleton_Code.html">Gabow_Skeleton_Code</a>
  <a href="../CAVA_Base/CAVA_Code_Target.html">CAVA_Base.CAVA_Code_Target</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automatic Refinement to Efficient Data Structures›</span></span>
<span class="keyword1"><span class="command">context</span></span> fr_graph_impl_loc
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> last_seg_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>last_seg_impl<span class="main">)</span><span class="main">∈</span>GSi_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> last_seg_impl_def_opt<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">last_seg_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.last_seg_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> last_seg_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"last_seg_impl <span class="main">≡</span> <span class="keyword1">OP</span> last_seg_impl"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> compute_SCC_code_aux<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>compute_SCC_impl<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>list_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_SCC_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> initial_impl_def GS_initial_impl_def
    <span class="keyword1"><span class="command">unfolding</span></span> path_is_empty_impl_def is_on_stack_impl_def is_done_impl_def 
      is_done_oimpl_def
    <span class="keyword1"><span class="command">unfolding</span></span> GS.is_on_stack_impl_def GS.is_done_impl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">compute_SCC_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.compute_SCC_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> compute_SCC_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span> 

  <span class="keyword1"><span class="command">schematic_goal</span></span> last_seg_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> last_seg_code <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> last_seg_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">last_seg_tr</span> <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.last_seg_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> last_seg_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> compute_SCC_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> compute_SCC_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> compute_SCC_code_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">compute_SCC_tr</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> fr_graph_impl_loc.compute_SCC_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> compute_SCC_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">compute_SCC_tr</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Correctness Theorem›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> compute_SCC_tr_correct<span class="main">:</span>
  <span class="comment1">― ‹Correctness theorem for the constant we extracted to SML›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Re</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> graph_rec_scheme"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_impl</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">Re</span><span class="main">,</span><span class="free">node_rel</span><span class="main">⟩</span>g_impl_rel_ext"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">node_eq_impl</span><span class="main">,</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
      <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
  
  <span class="keyword2"><span class="keyword">assumes</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"fr_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>compute_SCC_tr <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span><span class="main">)</span> 
  <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel<span class="main">⟩</span>list_rel<span class="main">)</span> <span class="main">(</span>fr_graph.compute_SCC_spec <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> C <span class="keyword1"><span class="command">interpret</span></span> fr_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"fr_graph_impl_loc <span class="free">Re</span> <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> fr_graph_impl_loc <span class="quoted"><span class="free">Re</span></span> <span class="quoted"><span class="free">node_rel</span></span> <span class="quoted"><span class="free">node_eq_impl</span></span> <span class="quoted"><span class="free">node_hash_impl</span></span> <span class="quoted"><span class="free">node_def_hash_size</span></span> <span class="quoted"><span class="free">G_impl</span></span> <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">note</span></span> compute_SCC_tr.refine<span class="main">[</span><span class="operator">OF</span> I<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> compute_SCC_code.refine<span class="main">[</span><span class="operator">OF</span> I<span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> compute_SCC_impl_refine
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> compute_SCC_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Extraction of Benchmark Code›</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> list_set_of_list_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>set<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_rel <span class="main">→</span> <span class="main">⟨</span>nat_rel<span class="main">⟩</span>list_set_rel"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">autoref</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">list_set_of_list</span> <span class="keyword2"><span class="keyword">uses</span></span> list_set_of_list_aux

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">compute_SCC_tr</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">compute_SCC_tr_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> nat list list"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">compute_SCC_tr_nat</span> <span class="main">≡</span> compute_SCC_tr"</span></span>

<span class="comment1">(*export_code 
  compute_SCC_tr_nat
  succ_of_list_impl
  nat_of_integer
  integer_of_nat
  list_set_of_list
  in SML module_name CSCC_Gabow
  file "Gabow_Benchmark/cscc_gabow.sml"
*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Find_Path_Impl">
<div class="head">
<h1>Theory Find_Path_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Safety Property Model Checker \label{sec:find_path_impl}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Find_Path_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Find_Path.html">Find_Path</a>
  <a href="../CAVA_Automata/Digraph_Impl.html">CAVA_Automata.Digraph_Impl</a>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Workset Algorithm›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A simple implementation is by a workset algorithm.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ws_update</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span>
             <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">,</span> 
             <span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="main">++</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∉</span><span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">s_init</span> <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span>None<span class="main">,</span><span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">,</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">u</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="keyword1">then</span> Some <span class="main">[]</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wset_find_path</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>finite <span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">s0</span> <span class="main">←</span> s_init <span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> WHILET 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="bound">res</span><span class="main">=</span>None <span class="main">∧</span> <span class="bound">ws</span><span class="main">≠</span>Map.empty<span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="bound">ws</span><span class="main">≠</span>Map.empty<span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span> <span class="main">←</span> SPEC <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">.</span> <span class="bound">ws</span> <span class="bound">u</span> <span class="main">=</span> Some <span class="bound">p</span><span class="main">)</span><span class="main">;</span>
        <span class="keyword1">let</span> <span class="bound">ws</span><span class="main">=</span><span class="bound">ws</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
        
        <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">u</span> <span class="keyword1">then</span>
          RETURN <span class="main">(</span>Some <span class="main">(</span>rev <span class="bound">p</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          ASSERT <span class="main">(</span>finite <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
          ASSERT <span class="main">(</span>dom <span class="bound">ws</span> <span class="main">⊆</span> <span class="bound">V</span><span class="main">)</span><span class="main">;</span>
          <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span> <span class="main">←</span> ws_update <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="bound">u</span> <span class="bound">p</span> <span class="bound">V</span> <span class="bound">ws</span><span class="main">;</span>
          RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span><span class="main">)</span> <span class="bound">s0</span><span class="main">;</span>
      RETURN <span class="bound">res</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> wset_find_path_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">E</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wset_find_path <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span> <span class="main">≤</span> find_path <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">inv</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">res</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> 
          dom <span class="bound">ws</span><span class="main">⊆</span><span class="bound">V</span> 
        <span class="main">∧</span> finite <span class="main">(</span>dom <span class="bound">ws</span><span class="main">)</span>  <span class="comment1">― ‹Derived›</span>
        <span class="main">∧</span> <span class="bound">V</span><span class="main">⊆</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span> 
        <span class="main">∧</span> <span class="free">E</span><span class="main">``</span><span class="main">(</span><span class="bound">V</span><span class="main">-</span>dom <span class="bound">ws</span><span class="main">)</span> <span class="main">⊆</span> <span class="bound">V</span> 
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="bound">V</span><span class="main">-</span>dom <span class="bound">ws</span><span class="main">.</span> <span class="main">¬</span> <span class="free">P</span> <span class="bound">v</span><span class="main">)</span>
        <span class="main">∧</span> <span class="free">U0</span> <span class="main">⊆</span> <span class="bound">V</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span> <span class="bound">p</span><span class="main">.</span> <span class="bound">ws</span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">⟶</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="bound">p</span><span class="main">.</span> <span class="main">¬</span><span class="free">P</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u0</span><span class="main">∈</span><span class="free">U0</span><span class="main">.</span> path <span class="free">E</span> <span class="bound">u0</span> <span class="main">(</span>rev <span class="bound">p</span><span class="main">)</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u0</span><span class="main">∈</span><span class="free">U0</span><span class="main">.</span> path <span class="free">E</span> <span class="bound">u0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">v</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>set <span class="bound">p</span><span class="main">.</span> <span class="main">¬</span><span class="free">P</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">var</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">var</span> <span class="main">=</span> inv_image 
        <span class="main">(</span>brk_rel <span class="main">(</span>finite_psupset <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span><span class="main">)</span> <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span>card <span class="keyword1">o</span> dom<span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">::</span><span class="main">(</span><span class="tfree">'v</span> list <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> option<span class="main">,</span><span class="bound">V</span><span class="main">::</span><span class="tfree">'v</span> set<span class="main">,</span><span class="bound">ws</span><span class="main">::</span><span class="tfree">'v</span><span class="main">⇀</span><span class="tfree">'v</span> list<span class="main">)</span><span class="main">.</span> 
            <span class="main">(</span><span class="bound">res</span><span class="main">≠</span>None<span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="comment1">(*have [simp, intro!]: "wf var"
      unfolding var_def
      by (auto intro: FIN)*)</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span> <span class="bound">p</span> <span class="bound">V</span><span class="main">.</span> dom <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∉</span> <span class="bound">V</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">u</span> <span class="main">#</span> <span class="bound">p</span><span class="main">)</span>
                     <span class="keyword1">else</span> None<span class="main">)</span> <span class="main">=</span> <span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="bound">u</span><span class="main">}</span> <span class="main">-</span> <span class="bound">V</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>


    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">V</span> <span class="skolem">ws</span> <span class="skolem">u</span> <span class="skolem">p</span>
      <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">(</span>None<span class="main">,</span><span class="skolem">V</span><span class="main">,</span><span class="skolem">ws</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> WSU<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ws</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">p</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> INV WSU <span class="keyword1"><span class="command">have</span></span> 
        <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">⊆</span> <span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> <span class="skolem">V</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> UREACH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">u0</span><span class="main">∈</span><span class="free">U0</span><span class="main">.</span> <span class="main">(</span><span class="bound">u0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dom <span class="skolem">ws</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> inv_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">V</span> <span class="main">∪</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">,</span> <span class="skolem">V</span><span class="main">)</span> <span class="main">∈</span> finite_psupset <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">U0</span><span class="main">)</span> <span class="main">∨</span>
          <span class="skolem">V</span> <span class="main">∪</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">V</span> <span class="main">∧</span>
          card <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">-</span> <span class="skolem">V</span> <span class="main">∪</span> <span class="main">(</span>dom <span class="skolem">ws</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="main">(</span>dom <span class="skolem">ws</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">subst</span> disj_commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> disjCI conjI<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">V</span> <span class="main">∪</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">,</span> <span class="skolem">V</span><span class="main">)</span> <span class="main">∉</span> finite_psupset <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">U0</span><span class="main">)</span>"</span></span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">∪</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> UREACH 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_psupset_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_ImageI<span class="main">)</span>

        <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">-</span> <span class="skolem">V</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">-</span> <span class="skolem">V</span> <span class="main">∪</span> <span class="main">(</span>dom <span class="skolem">ws</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="main">(</span>dom <span class="skolem">ws</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> WSU
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> card_Diff1_less<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> wf_aux<span class="main">=</span>this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">V</span> <span class="skolem">ws</span> <span class="skolem">u</span> <span class="skolem">p</span>
      <span class="keyword3"><span class="command">assume</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">(</span>None<span class="main">,</span><span class="skolem">V</span><span class="main">,</span><span class="skolem">ws</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ws</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u0</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u0</span><span class="main">∈</span><span class="free">U0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u0</span><span class="main">,</span><span class="skolem">u</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> inv_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_ImageI<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> FIN<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> succs_finite<span class="main">=</span>this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">V</span> <span class="skolem">ws</span> <span class="skolem">u</span> <span class="skolem">p</span>
      <span class="keyword3"><span class="command">assume</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">U0</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">(</span>None<span class="main">,</span><span class="skolem">V</span><span class="main">,</span><span class="skolem">ws</span><span class="main">)</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> WSU<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ws</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">p</span>"</span></span>
      <span class="keyword3"><span class="command">assume</span></span> NVD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">P</span> <span class="skolem">u</span>"</span></span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">inv</span> <span class="main">(</span>None<span class="main">,</span> <span class="skolem">V</span> <span class="main">∪</span> <span class="free">E</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">,</span>
               <span class="skolem">ws</span> <span class="main">|`</span> <span class="main">(</span><span class="main">-</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span><span class="main">)</span> <span class="main">++</span>
               <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="skolem">u</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free">E</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∉</span> <span class="skolem">V</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="skolem">u</span> <span class="main">#</span> <span class="skolem">p</span><span class="main">)</span>
                    <span class="keyword1">else</span> None<span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> inv_def
        
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> INV WSU <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> INV WSU <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> INV WSU <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> succs_finite FIN<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> INV WSU <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def 
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl_image_advance
        <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> INV WSU <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> INV NVD <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command">using</span></span> INV NVD <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command">using</span></span> INV WSU NVD <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span>
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def restrict_map_def 
          <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> path_conc path1
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
        <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> ip_aux<span class="main">=</span>this

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wset_find_path_def find_path_def ws_update_def s_init_def

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> le_ASSERTI
        WHILET_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
          R <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">var</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem">inv</span></span><span class="main"><span class="main">]</span></span>
      <span class="main">)</span>
      
      <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> var_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def dom_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> var_def brk_rel_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> succs_finite<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ip_aux<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> var_def brk_rel_def wf_aux<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inv_def 
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits 
        <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_ImageI
        <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Image_closed_trancl<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refine the algorithm to use a foreach-loop›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">ws_update_foreach</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="main">≡</span> 
    FOREACH <span class="main">(</span>LIST_SET_REV_TAG <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> 
      <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">V</span> <span class="keyword1">then</span> 
        RETURN <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span> 
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="bound">v</span><span class="main">∉</span>dom <span class="bound">ws</span><span class="main">)</span><span class="main">;</span>
        RETURN <span class="main">(</span>insert <span class="bound">v</span> <span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">(</span> <span class="bound">v</span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>
      <span class="main">}</span>
    <span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ws</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> ws_update_foreach_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> WSS<span class="main">:</span> <span class="quoted"><span class="quoted">"dom <span class="free">ws</span> <span class="main">⊆</span> <span class="free">V</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">E'</span><span class="main">,</span><span class="free">E</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">u'</span><span class="main">,</span><span class="free">u</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p'</span><span class="main">,</span><span class="free">p</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">V'</span><span class="main">,</span><span class="free">V</span><span class="main">)</span><span class="main">∈</span>Id"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ws'</span><span class="main">,</span><span class="free">ws</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ws_update_foreach <span class="free">E'</span> <span class="free">u'</span> <span class="free">p'</span> <span class="free">V'</span> <span class="free">ws'</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>ws_update <span class="free">E</span> <span class="free">u</span> <span class="free">p</span> <span class="free">V</span> <span class="free">ws</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ID<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> ws_update_foreach_def ws_update_def LIST_SET_REV_TAG_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> FIN
      FOREACH_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">V'</span><span class="main">,</span><span class="bound">ws'</span><span class="main">)</span><span class="main">.</span> 
        <span class="bound">V'</span><span class="main">=</span><span class="free">V</span> <span class="main">∪</span> <span class="main">(</span><span class="free">E</span><span class="main">``</span><span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">-</span><span class="bound">it</span><span class="main">)</span>
      <span class="main">∧</span> dom <span class="bound">ws'</span> <span class="main">⊆</span> <span class="bound">V'</span>
      <span class="main">∧</span> <span class="bound">ws'</span> <span class="main">=</span> <span class="free">ws</span> <span class="main">++</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∉</span><span class="bound">it</span> <span class="main">∧</span> <span class="bound">v</span><span class="main">∉</span><span class="free">V</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="free">u</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span>
    <span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> WSS
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Map.map_add_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits if_split_asm
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="tfree">'b</span> list option"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">s_init_foreach</span> <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">U0</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span> <span class="main">←</span> FOREACH <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">(</span><span class="bound">U0</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> 
        RETURN <span class="main">(</span>insert <span class="bound">x</span> <span class="bound">U0</span><span class="main">,</span><span class="bound">ws</span><span class="main">(</span><span class="bound">x</span><span class="main">↦</span><span class="main">[]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span>Map.empty<span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">U0</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> s_init_foreach_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> FIN<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">U0</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> ID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">U0'</span><span class="main">,</span><span class="free">U0</span><span class="main">)</span><span class="main">∈</span>Id"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"s_init_foreach <span class="free">U0'</span> <span class="main">≤</span><span class="main">⇓</span>Id <span class="main">(</span>s_init <span class="free">U0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> s_init_foreach_def s_init_def ID<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span>
      FOREACH_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="main">(</span><span class="bound">U</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> 
          <span class="bound">U</span> <span class="main">=</span> <span class="free">U0</span><span class="main">-</span><span class="bound">it</span> 
        <span class="main">∧</span> <span class="bound">ws</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span><span class="main">∈</span><span class="free">U0</span><span class="main">-</span><span class="bound">it</span> <span class="keyword1">then</span> Some <span class="main">[]</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span>
    <span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> FIN
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext
    <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wset_find_path'</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">U0</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>finite <span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">s0</span><span class="main">←</span>s_init_foreach <span class="free"><span class="bound"><span class="entity">U0</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">←</span> WHILET 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="bound">res</span><span class="main">=</span>None <span class="main">∧</span> <span class="bound">ws</span><span class="main">≠</span>Map.empty<span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">res</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>
        ASSERT <span class="main">(</span><span class="bound">ws</span><span class="main">≠</span>Map.empty<span class="main">)</span><span class="main">;</span>
        <span class="main">(</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">p</span><span class="main">)</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span> <span class="main">←</span> op_map_pick_remove <span class="bound">ws</span><span class="main">;</span>
        
        <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">u</span> <span class="keyword1">then</span>
          RETURN <span class="main">(</span>Some <span class="main">(</span>rev <span class="bound">p</span><span class="main">,</span><span class="bound">u</span><span class="main">)</span><span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span> <span class="main">←</span> ws_update_foreach <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="bound">u</span> <span class="bound">p</span> <span class="bound">V</span> <span class="bound">ws</span><span class="main">;</span>
          RETURN <span class="main">(</span>None<span class="main">,</span><span class="bound">V</span><span class="main">,</span><span class="bound">ws</span><span class="main">)</span>
        <span class="main">}</span>
      <span class="main">}</span><span class="main">)</span>
      <span class="bound">s0</span><span class="main">;</span>
      RETURN <span class="bound">res</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> wset_find_path'_refine<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"wset_find_path' <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>wset_find_path <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wset_find_path'_def wset_find_path_def
    <span class="keyword1"><span class="command">unfolding</span></span> op_map_pick_remove_alt
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> IdI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Refinement to efficient data structures›</span></span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> wset_find_path'_refine_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">U0</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">P</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">E</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">×</span><span class="tfree">'a</span><span class="main">)</span> set"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Pimpl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ai</span> <span class="main">⇒</span> bool"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ai</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_eq_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ai</span> <span class="main">⇒</span> <span class="tfree">'ai</span> <span class="main">⇒</span> bool"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_hash_impl</span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_def_hash_size</span>
    
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">succi</span><span class="main">,</span><span class="free">E</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>slg_rel"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">Pimpl</span><span class="main">,</span><span class="free">P</span><span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">node_eq_impl</span><span class="main">,</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">U0'</span><span class="main">,</span><span class="free">U0</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span>"</span></span>  
      <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'ai</span><span class="main">)</span> <span class="free">node_def_hash_size</span>"</span></span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
      TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> 
        R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">node_rel</span><span class="main">,</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>list_map_rel"</span></span><span class="main">]</span>
      TYRELI<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>map2set_rel <span class="main">(</span>ahm_rel <span class="free">node_hash_impl</span><span class="main">)</span>"</span></span><span class="main">]</span>

    <span class="comment1">(*notes [autoref_rules] = 
      IdI[of P, unfolded fun_rel_id_simp[symmetric]]*)</span>

    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">,</span>wset_find_path' <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wset_find_path'_def ws_update_foreach_def s_init_foreach_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_intf_unif</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_pat</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">wset_find_path_impl</span> <span class="keyword2"><span class="keyword">for</span></span> node_eq_impl succi U0' Pimpl 
    <span class="keyword2"><span class="keyword">uses</span></span> wset_find_path'_refine_aux

  <span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Autoref Setup›</span></span>
  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"find_path <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_slg <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_set <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">(</span><span class="free">I</span><span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span>i_bool<span class="main">)</span> 
        <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="main">,</span> <span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_prod<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_option<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_nres"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">lemma</span></span> wset_find_path_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
      <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ai</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">node_eq_impl</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">node_rel</span><span class="main">→</span><span class="free">node_rel</span><span class="main">→</span>bool_rel<span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> hash<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> hash_dsz<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'ai</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>
        wset_find_path_impl <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">node_eq_impl</span><span class="main">,</span> 
        find_path<span class="main">)</span>
        <span class="main">∈</span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>slg_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_set_rel <span class="main">→</span> <span class="main">(</span><span class="free">node_rel</span><span class="main">→</span>bool_rel<span class="main">)</span> 
          <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span><span class="free">node_rel</span><span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">note</span></span> EQI <span class="main">=</span> GEN_OP_D<span class="main">[</span><span class="operator">OF</span> eq<span class="main">]</span>
      <span class="keyword1"><span class="command">note</span></span> HASHI <span class="main">=</span> SIDE_GEN_ALGO_D<span class="main">[</span><span class="operator">OF</span> hash<span class="main">]</span>
      <span class="keyword1"><span class="command">note</span></span> DSZI <span class="main">=</span> SIDE_GEN_ALGO_D<span class="main">[</span><span class="operator">OF</span> hash_dsz<span class="main">]</span>
    
    
      <span class="keyword1"><span class="command">note</span></span> wset_find_path_impl.refine<span class="main">[</span><span class="operator">THEN</span> nres_relD<span class="main">,</span> <span class="operator">OF</span> _ _ EQI _ HASHI DSZI<span class="main">]</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> wset_find_path'_refine
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> wset_find_path_correct
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>
    
  <span class="keyword1"><span class="command">schematic_goal</span></span> wset_find_path_transfer_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> wset_find_path_impl <span class="free">hashi</span> <span class="free">dszi</span> <span class="free">eqi</span> <span class="free">E</span> <span class="free">U0</span> <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wset_find_path_impl_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">refine_transfer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">post</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">wset_find_path_code</span> 
    <span class="keyword2"><span class="keyword">for</span></span> E <span class="var">?U0.0</span> P <span class="keyword2"><span class="keyword">uses</span></span> wset_find_path_transfer_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> wset_find_path_code.refine

  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">wset_find_path_code</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Nontrivial paths›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">find_path1_gen</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">u0</span></span></span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">res</span> <span class="main">←</span> find_path <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">``</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">u0</span></span></span><span class="main">}</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span><span class="main">;</span>
  <span class="keyword1">case</span> <span class="bound">res</span> <span class="keyword1">of</span> None <span class="main">⇒</span> RETURN None
    <span class="main">|</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">u0</span></span></span><span class="main">#</span><span class="bound">p</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span>
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> find_path1_gen_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"find_path1_gen <span class="free">E</span> <span class="free">u0</span> <span class="free">P</span> <span class="main">≤</span> find_path1 <span class="free">E</span> <span class="free">u0</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_gen_def find_path_def find_path1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span> le_ASSERTI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> path_prepend 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> tranclD
    <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span>
  <span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> find_path1_impl_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ai</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">node_eq_impl</span><span class="main">,</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">autoref_ga_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span>"</span></span>  
    <span class="quoted"><span class="quoted">"is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'ai</span><span class="main">)</span> <span class="free">node_def_hash_size</span>"</span></span>

  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>find_path1_gen<span class="main">::</span><span class="main">(</span><span class="main">_</span><span class="main">×</span><span class="main">_</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>slg_rel <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="main">(</span><span class="free">node_rel</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">node_rel</span><span class="main">⟩</span>option_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_gen_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"find_path1 <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_slg <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="free">I</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">(</span><span class="free">I</span><span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span>i_bool<span class="main">)</span> 
    <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="main">,</span> <span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_prod<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_option<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_nres"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path1_impl</span> <span class="keyword2"><span class="keyword">uses</span></span> find_path1_impl_aux

<span class="keyword1"><span class="command">lemma</span></span> find_path1_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ai</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">node_eq_impl</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">node_rel</span><span class="main">→</span><span class="free">node_rel</span><span class="main">→</span>bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hash<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hash_dsz<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'ai</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_path1_impl <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span><span class="main">,</span>find_path1<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>slg_rel <span class="main">→</span><span class="free">node_rel</span> <span class="main">→</span> <span class="main">(</span><span class="free">node_rel</span> <span class="main">→</span> bool_rel<span class="main">)</span> <span class="main">→</span> 
      <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">node_rel</span><span class="main">⟩</span>Relators.option_rel<span class="main">⟩</span>nres_rel"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>

  <span class="keyword1"><span class="command">note</span></span> EQI <span class="main">=</span> GEN_OP_D<span class="main">[</span><span class="operator">OF</span> eq<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> HASHI <span class="main">=</span> SIDE_GEN_ALGO_D<span class="main">[</span><span class="operator">OF</span> hash<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> DSZI <span class="main">=</span> SIDE_GEN_ALGO_D<span class="main">[</span><span class="operator">OF</span> hash_dsz<span class="main">]</span>
  
  <span class="keyword1"><span class="command">note</span></span> R <span class="main">=</span> find_path1_impl.refine<span class="main">[</span><span class="operator">param_fo</span><span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">,</span> <span class="operator">OF</span> EQI HASHI DSZI<span class="main">]</span>
  
  <span class="keyword1"><span class="command">note</span></span> R
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_path1_gen_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">schematic_goal</span></span> find_path1_transfer_aux<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> find_path1_impl <span class="free">eqi</span> <span class="free">hashi</span> <span class="free">dszi</span> <span class="free">E</span> <span class="free">u</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> find_path1_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">refine_transfer</span>
<span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">find_path1_code</span> <span class="keyword2"><span class="keyword">for</span></span> E u P <span class="keyword2"><span class="keyword">uses</span></span> find_path1_transfer_aux
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> find_path1_code.refine

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Gabow_GBG_Code">
<div class="head">
<h1>Theory Gabow_GBG_Code</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code Generation for GBG Lasso Finding Algorithm\label{sec:gbg_code}›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Gabow_GBG_Code
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Gabow_GBG.html">Gabow_GBG</a> 
  <a href="Gabow_Skeleton_Code.html">Gabow_Skeleton_Code</a> 
  <a href="../CAVA_Automata/Automata_Impl.html">CAVA_Automata.Automata_Impl</a>
  <a href="Find_Path_Impl.html">Find_Path_Impl</a>
  <a href="../CAVA_Base/CAVA_Code_Target.html">CAVA_Base.CAVA_Code_Target</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Autoref Setup›</span></span>

<span class="keyword1"><span class="command">locale</span></span> impl_lasso_loc <span class="main">=</span> igb_fr_graph <span class="quoted"><span class="free">G</span></span> 
  <span class="main">+</span> fr_graph_impl_loc <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">mrel</span><span class="main">,</span><span class="free">node_rel</span><span class="main">⟩</span>igbg_impl_rel_eext"</span></span> <span class="quoted"><span class="free">node_rel</span></span> <span class="quoted"><span class="free">node_eq_impl</span></span> <span class="quoted"><span class="free">node_hash_impl</span></span> <span class="quoted"><span class="free">node_def_hash_size</span></span> <span class="quoted"><span class="free">G_impl</span></span> <span class="quoted"><span class="free">G</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">mrel</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G_impl</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'q</span><span class="main">,</span><span class="tfree">'more</span><span class="main">)</span> igb_graph_rec_scheme"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> locale_this<span class="main">:</span> <span class="quoted"><span class="quoted">"impl_lasso_loc <span class="free">mrel</span> <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"goinitial_impl <span class="main">≡</span> <span class="keyword1">OP</span> goinitial_impl"</span></span>
      <span class="quoted"><span class="quoted">"ginitial_impl <span class="main">≡</span> <span class="keyword1">OP</span> ginitial_impl"</span></span>
      <span class="quoted"><span class="quoted">"gpath_is_empty_impl <span class="main">≡</span> <span class="keyword1">OP</span> gpath_is_empty_impl"</span></span>
      <span class="quoted"><span class="quoted">"gselect_edge_impl <span class="main">≡</span> <span class="keyword1">OP</span> gselect_edge_impl"</span></span>
      <span class="quoted"><span class="quoted">"gis_on_stack_impl <span class="main">≡</span> <span class="keyword1">OP</span> gis_on_stack_impl"</span></span>
      <span class="quoted"><span class="quoted">"gcollapse_impl <span class="main">≡</span> <span class="keyword1">OP</span> gcollapse_impl"</span></span>
      <span class="quoted"><span class="quoted">"last_is_acc_impl <span class="main">≡</span> <span class="keyword1">OP</span> last_is_acc_impl"</span></span>
      <span class="quoted"><span class="quoted">"ce_impl <span class="main">≡</span> <span class="keyword1">OP</span> ce_impl"</span></span>
      <span class="quoted"><span class="quoted">"gis_done_impl <span class="main">≡</span> <span class="keyword1">OP</span> gis_done_impl"</span></span>
      <span class="quoted"><span class="quoted">"gpush_impl <span class="main">≡</span> <span class="keyword1">OP</span> gpush_impl"</span></span>
      <span class="quoted"><span class="quoted">"gpop_impl <span class="main">≡</span> <span class="keyword1">OP</span> gpop_impl"</span></span>
      <span class="quoted"><span class="quoted">"goBrk_impl <span class="main">≡</span> <span class="keyword1">OP</span> goBrk_impl"</span></span> 
      <span class="quoted"><span class="quoted">"gto_outer_impl <span class="main">≡</span> <span class="keyword1">OP</span> gto_outer_impl"</span></span>
      <span class="quoted"><span class="quoted">"go_is_done_impl <span class="main">≡</span> <span class="keyword1">OP</span> go_is_done_impl"</span></span>
      <span class="quoted"><span class="quoted">"is_done_oimpl <span class="main">≡</span> <span class="keyword1">OP</span> is_done_oimpl"</span></span>
      <span class="quoted"><span class="quoted">"go_is_no_brk_impl <span class="main">≡</span> <span class="keyword1">OP</span> go_is_no_brk_impl"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">gGSi_rel</span> <span class="main">≡</span> <span class="main">⟨</span><span class="main">⟨</span>nat_rel<span class="main">⟩</span>bs_set_rel<span class="main">⟩</span>as_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> GSi_rel"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">ce_rel</span> <span class="free"><span class="bound"><span class="entity">node_rel</span></span></span> <span class="main">≡</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">node_rel</span></span></span><span class="main">⟩</span>fun_set_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">node_rel</span></span></span><span class="main">⟩</span>fun_set_rel<span class="main">⟩</span>option_rel"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">goGSi_rel</span> <span class="main">≡</span> ce_rel <span class="free">node_rel</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> oGSi_rel"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automatic Refinement›</span></span>

<span class="keyword1"><span class="command">context</span></span> impl_lasso_loc
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> goinitial_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>goinitial_impl<span class="main">)</span><span class="main">∈</span>goGSi_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> goinitial_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">goinitial_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.goinitial_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> goinitial_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>


  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">ginitial_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> ginitial_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>ginitial_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> goGSi_rel <span class="main">→</span> gGSi_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ginitial_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> initial_impl_def GS_initial_impl_def
      <span class="comment1">(* TODO: Declare autoref-rule for initial*)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">ginitial_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.ginitial_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> ginitial_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> gpath_is_empty_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gpath_is_empty_impl<span class="main">)</span><span class="main">∈</span>gGSi_rel<span class="main">→</span>bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpath_is_empty_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> path_is_empty_impl_def
      <span class="comment1">(* TODO: Declare autoref-rule for path_is_empty*)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gpath_is_empty_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gpath_is_empty_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gpath_is_empty_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">goBrk</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> goBrk_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>goBrk_impl<span class="main">)</span><span class="main">∈</span>goGSi_rel<span class="main">→</span>ce_rel <span class="free">node_rel</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> goBrk_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> goBrk_impl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">goBrk_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.goBrk_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> goBrk_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>
  <span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">autoref_itype</span></span><span class="main">(</span>1<span class="main">)</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">gto_outer_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> gto_outer_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gto_outer_impl<span class="main">)</span><span class="main">∈</span>ce_rel <span class="free">node_rel</span> <span class="main">→</span> gGSi_rel<span class="main">→</span>goGSi_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gto_outer_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> gto_outer_impl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gto_outer_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gto_outer_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gto_outer_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">go_is_done_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> go_is_done_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>go_is_done_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> goGSi_rel <span class="main">→</span> bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> go_is_done_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> is_done_oimpl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">go_is_done_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.go_is_done_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> go_is_done_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> go_is_no_brk_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>go_is_no_brk_impl<span class="main">)</span><span class="main">∈</span>goGSi_rel<span class="main">→</span>bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> go_is_no_brk_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> go_is_no_brk_impl_def
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">go_is_no_brk_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.go_is_no_brk_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> go_is_no_brk_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

<span class="comment1">(*
  schematic_lemma XXX_code_aux: "(?c,XXX_impl)∈goGSi_rel→ce_rel"
    unfolding XXX_impl_def[abs_def] XXX_impl_def
    using [[autoref_trace_failed_id]]
    by (autoref (trace,keep_goal))
  concrete_definition (in -) XXX_code uses impl_lasso_loc.XXX_code_aux
  lemmas [autoref_rules] = XXX_code.refine[OF locale_this]
*)</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> gselect_edge_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gselect_edge_impl<span class="main">)</span>
    <span class="main">∈</span> gGSi_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>option_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> gGSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gselect_edge_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gselect_edge_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gselect_edge_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gselect_edge_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">gis_on_stack_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> gis_on_stack_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gis_on_stack_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> gGSi_rel <span class="main">→</span> bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gis_on_stack_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> is_on_stack_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
      GS.is_on_stack_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="comment1">(* TODO: Declare autoref-rule for is_on_stack*)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gis_on_stack_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gis_on_stack_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gis_on_stack_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">gcollapse_impl</span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> gcollapse_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gcollapse_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> gGSi_rel 
    <span class="main">→</span> <span class="main">⟨</span>gGSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gcollapse_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gcollapse_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gcollapse_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gcollapse_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> last_is_acc_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>last_is_acc_impl<span class="main">)</span><span class="main">∈</span>gGSi_rel<span class="main">→</span><span class="main">⟨</span>bool_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> last_is_acc_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">last_is_acc_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.last_is_acc_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> last_is_acc_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> ce_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>ce_impl<span class="main">)</span>
    <span class="main">∈</span>gGSi_rel<span class="main">→</span><span class="main">⟨</span>ce_rel <span class="free">node_rel</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> gGSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ce_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> on_stack_less_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
      on_stack_ge_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">ce_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.ce_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> ce_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> gis_done_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gis_done_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span><span class="main">→</span>gGSi_rel<span class="main">→</span>bool_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gis_done_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> is_done_impl_def GS.is_done_impl_def
    <span class="comment1">(* TODO: Autoref rule for is_done *)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gis_done_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gis_done_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gis_done_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> gpush_code_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gpush_impl<span class="main">)</span><span class="main">∈</span><span class="free">node_rel</span> <span class="main">→</span> gGSi_rel<span class="main">→</span>gGSi_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpush_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gpush_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gpush_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gpush_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> gpop_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>gpop_impl<span class="main">)</span><span class="main">∈</span>gGSi_rel<span class="main">→</span><span class="main">⟨</span>gGSi_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gpop_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">gpop_code</span> <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.gpop_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> gpop_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>




  <span class="keyword1"><span class="command">schematic_goal</span></span> find_ce_code_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span>find_ce_impl<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>ce_rel <span class="free">node_rel</span><span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_ce_impl_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">find_ce_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.find_ce_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_ce_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> find_ce_tr_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> find_ce_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span>
      find_ce_code_def
      ginitial_code_def
      gpath_is_empty_code_def
      gselect_edge_code_def
      gis_on_stack_code_def
      gcollapse_code_def
      last_is_acc_code_def
      ce_code_def
      gis_done_code_def
      gpush_code_def
      gpop_code_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">find_ce_tr</span> <span class="keyword2"><span class="keyword">for</span></span> G_impl
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.find_ce_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> find_ce_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"find_ce_spec <span class="main">≡</span> <span class="keyword1">OP</span> find_ce_spec"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  
  <span class="keyword1"><span class="command">theorem</span></span> find_ce_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
    <span class="comment1">― ‹Main Correctness theorem (inside locale)›</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>find_ce_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span><span class="main">,</span> find_ce_spec<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>ce_rel <span class="free">node_rel</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> find_ce_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_ce_impl_refine
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_ce_refine
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_ce_correct
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> impl_lasso_loc
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"reconstruct_reach <span class="main">≡</span> <span class="keyword1">OP</span> reconstruct_reach"</span></span>
      <span class="quoted"><span class="quoted">"reconstruct_lasso <span class="main">≡</span> <span class="keyword1">OP</span> reconstruct_lasso"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> reconstruct_reach_code_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span> reconstruct_reach<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>fun_set_rel <span class="main">→</span>
    <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>fun_set_rel <span class="main">→</span>
    <span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="free">node_rel</span><span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reconstruct_lasso_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> reconstruct_reach_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span> <span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">reconstruct_reach_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.reconstruct_reach_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> reconstruct_reach_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>


  <span class="keyword1"><span class="command">schematic_goal</span></span> reconstruct_lasso_code_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">,</span> reconstruct_lasso<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>fun_set_rel <span class="main">→</span>
    <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>fun_set_rel <span class="main">→</span>
    <span class="main">⟨</span><span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">node_rel</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>nres_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reconstruct_lasso_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span> <span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">reconstruct_lasso_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.reconstruct_lasso_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> reconstruct_lasso_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> reconstruct_lasso_tr_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> reconstruct_lasso_code <span class="free">eqi</span> <span class="free">hi</span> <span class="free">dszi</span> <span class="free">G_impl</span> <span class="free">Vr</span> <span class="free">Vl</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reconstruct_lasso_code_def reconstruct_reach_code_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_transfer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">post</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">reconstruct_lasso_tr</span> <span class="keyword2"><span class="keyword">for</span></span> G_impl
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.reconstruct_lasso_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> reconstruct_lasso_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>
  
  <span class="keyword1"><span class="command">schematic_goal</span></span> find_lasso_code_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">,</span> find_lasso<span class="main">)</span><span class="main">∈</span><span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_lasso_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">keep_goal</span><span class="main"><span class="main">,</span></span> <span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">find_lasso_code</span> 
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.find_lasso_code_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span> <span class="main">=</span> find_lasso_code.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> find_lasso_tr_aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"RETURN <span class="var">?c</span> <span class="main">≤</span> find_lasso_code <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> find_lasso_code_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_transfer</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">post</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> -<span class="main">)</span> <span class="entity">find_lasso_tr</span> <span class="keyword2"><span class="keyword">for</span></span> G_impl
    <span class="keyword2"><span class="keyword">uses</span></span> impl_lasso_loc.find_lasso_tr_aux
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span> <span class="main">=</span> find_lasso_tr.refine<span class="main">[</span><span class="operator">OF</span> locale_this<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">find_lasso_tr</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Main Correctness Theorem›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">fl_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> option<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>  
  <span class="quoted"><span class="quoted">"<span class="free">fl_rel</span> <span class="free"><span class="bound"><span class="entity">node_rel</span></span></span> <span class="main">≡</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">node_rel</span></span></span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">node_rel</span></span></span><span class="main">⟩</span>list_rel<span class="main">⟩</span>Relators.option_rel"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> find_lasso_tr_correct<span class="main">:</span>
  <span class="comment1">― ‹Correctness theorem for the constant we extracted to SML›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Re</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_impl</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span>igbg_impl_rel_ext <span class="free">Re</span> <span class="free">node_rel</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_eq_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">node_eq_impl</span><span class="main">,</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="free">node_rel</span> <span class="main">→</span> bool_rel"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_hash<span class="main">:</span> <span class="quoted"><span class="quoted">"is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> node_hash_def_size<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
  
  <span class="keyword2"><span class="keyword">assumes</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"igb_fr_graph <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>find_lasso_tr <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span><span class="main">)</span> 
  <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>fl_rel <span class="free">node_rel</span><span class="main">)</span> <span class="main">(</span>igb_graph.find_lasso_spec <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> B <span class="keyword1"><span class="command">interpret</span></span> igb_fr_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"impl_lasso_loc <span class="free">Re</span> <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span> <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> impl_lasso_loc <span class="quoted"><span class="free">Re</span></span> <span class="quoted"><span class="free">node_rel</span></span> <span class="quoted"><span class="free">node_eq_impl</span></span> <span class="quoted"><span class="free">node_hash_impl</span></span> <span class="quoted"><span class="free">node_def_hash_size</span></span> <span class="quoted"><span class="free">G_impl</span></span> <span class="quoted"><span class="free">G</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">note</span></span> find_lasso_tr.refine<span class="main">[</span><span class="operator">OF</span> I<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_lasso_code.refine<span class="main">[</span><span class="operator">OF</span> I<span class="main">,</span> <span class="operator">THEN</span> nres_relD<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> find_lasso_correct
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Autoref Setup for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>igb_graph.find_lasso_spec›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Setup for Autoref, such that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>igb_graph.find_lasso_spec›</span></span></span></span> 
  can be used›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">op_find_lasso_spec</span> <span class="main">≡</span> igb_graph.find_lasso_spec"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"igb_graph.find_lasso_spec <span class="main">≡</span> op_find_lasso_spec"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">op_find_lasso_spec</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"op_find_lasso_spec 
    <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> i_igbg <span class="free">Ie</span> <span class="free">I</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="main">,</span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_prod<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_option<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_nres"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> find_lasso_spec_autoref<span class="main">[</span><span class="operator">autoref_rules_raw</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Re</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">node_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vi</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> GR<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_PRECOND <span class="main">(</span>igb_fr_graph <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq<span class="main">:</span> <span class="quoted"><span class="quoted">"GEN_OP <span class="free">node_eq_impl</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">node_rel</span><span class="main">→</span><span class="free">node_rel</span><span class="main">→</span>bool_rel<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hash<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_bounded_hashcode <span class="free">node_rel</span> <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hash_dsz<span class="main">:</span> <span class="quoted"><span class="quoted">"SIDE_GEN_ALGO <span class="main">(</span>is_valid_def_hm_size <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'vi</span><span class="main">)</span> <span class="free">node_def_hash_size</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Gi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">G_impl</span><span class="main">,</span><span class="free">G</span><span class="main">)</span><span class="main">∈</span>igbg_impl_rel_ext <span class="free">Re</span> <span class="free">node_rel</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>RETURN <span class="main">(</span>find_lasso_tr <span class="free">node_eq_impl</span> <span class="free">node_hash_impl</span> <span class="free">node_def_hash_size</span> <span class="free">G_impl</span><span class="main">)</span><span class="main">,</span> 
    <span class="main">(</span><span class="keyword1">OP</span> op_find_lasso_spec 
      <span class="main">:::</span> igbg_impl_rel_ext <span class="free">Re</span> <span class="free">node_rel</span> <span class="main">→</span> <span class="main">⟨</span>fl_rel <span class="free">node_rel</span><span class="main">⟩</span>nres_rel<span class="main">)</span><span class="main">$</span><span class="free">G</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>fl_rel <span class="free">node_rel</span><span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> find_lasso_tr_correct<span class="main">[</span><span class="operator">OF</span> Gi GEN_OP_D<span class="main"><span class="main">[</span></span><span class="operator">OF</span> eq<span class="main"><span class="main">]</span></span> SIDE_GEN_ALGO_D<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hash<span class="main"><span class="main">]</span></span> SIDE_GEN_ALGO_D<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hash_dsz<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> GR
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
    

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="All_Of_Gabow_SCC">
<div class="head">
<h1>Theory All_Of_Gabow_SCC</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> All_Of_Gabow_SCC
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Gabow_Skeleton.html">Gabow_Skeleton</a>
  <a href="Gabow_SCC.html">Gabow_SCC</a>
  <a href="Find_Path.html">Find_Path</a>
  <a href="Gabow_GBG.html">Gabow_GBG</a>

  <a href="Gabow_Skeleton_Code.html">Gabow_Skeleton_Code</a>
  <a href="Gabow_SCC_Code.html">Gabow_SCC_Code</a>
  <a href="Find_Path_Impl.html">Find_Path_Impl</a>
  <a href="Gabow_GBG_Code.html">Gabow_GBG_Code</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>