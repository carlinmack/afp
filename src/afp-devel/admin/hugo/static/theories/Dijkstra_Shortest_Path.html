<div id="Introduction">
<div class="head">
<h1>Theory Introduction</h1>
</div>
<pre class="source"><span class="comment1">(*  Title: A efficiently computable formalisation of Dijkstra's algorithm       
    Author: Benedikt Nordhoff &lt;bnord01 at gmail.com&gt;, 
            Peter Lammich &lt;lammich at in.tum.de&gt;
    Maintainer: lammich@in.tum.de
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Introduction and Overview"</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Introduction 
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹\label{thy:Introduction}›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  
  Dijkstra's algorithm \cite{Dijk59} is an algorithm used to
  find shortest paths from one given vertex to all other vertices in a
  non-negatively weighted graph.  
  
  The implementation of the algorithm is meant to be an application
  of our extensions to the Isabelle Collections Framework (ICF)
  \cite{L09_collections,LL10,NKP10}. Moreover, it serves as a test case 
  for our data refinement framework \cite{refinement_framework}.
  We use ICF-Maps to efficiently represent the graph and
  result and the newly introduced unique priority queues for the work
  list.

  For a documentation of the refinement framework see \cite{refinement_framework},
  that also contains a userguide and some simpler examples.

  The development utilizes a stepwise refinement approach. Starting from an
  abstract algorithm that has a nice correctness proof, we stepwise refine
  the algorithm until we end up with an efficient implementation, for that 
  we generate code using Isabelle/HOL's code generator\cite{Haft09,HaNi10}.
  
  \paragraph{Structure of the Submission.}
  The abstract version of the algorithm with the correctness proof, as well
  as the main refinement steps are contained in the theory \texttt{Dijkstra}.
  The refinement steps involving the ICF and code generation are contained in
  \texttt{Dijkstra-Impl}. 
  The theory \texttt{Infty} contains an extension of numbers with an infinity
  element. 
  The theory \texttt{Graph} contains a formalization of graphs, paths, and
  related concepts.
  The theories \texttt{GraphSpec,GraphGA,GraphByMap,HashGraphImpl} contain an
  ICF-style specification of graphs.
  The theory \texttt{Test} contains a small performance test on random graphs.
  It uses the ML-code generated by the code generator.
›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Dijkstra_Misc">
<div class="head">
<h1>Theory Dijkstra_Misc</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Miscellaneous Lemmas›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra_Misc
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">least_map</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">f</span> <span class="entity">S</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">∈</span><span class="free">S</span><span class="main">;</span> <span class="main">∀</span><span class="bound">x'</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="free">least_map</span> <span class="free">f</span> <span class="free">S</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"least_map <span class="free">f</span> <span class="free">S</span> <span class="main">⊆</span> <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> least_map.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> least_map_elemD <span class="main">=</span> subsetD<span class="main">[</span><span class="operator">OF</span> least_map_subset<span class="main">]</span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_leD<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> least_map <span class="free">f</span> <span class="free">S</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈</span><span class="free">S</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> least_map.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"least_map <span class="free">f</span> <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> least_map.cases<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"least_map <span class="main">(</span><span class="free">f</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">::</span>order<span class="main">)</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> least_map.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> least_map.intros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> refl<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_insert_min<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⇒</span><span class="tfree">'b</span><span class="main">::</span>order"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="bound">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> least_map <span class="free">f</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> least_map.intros<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> least_map_insert_nmin<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span><span class="main">∈</span>least_map <span class="free">f</span> <span class="free">S</span><span class="main">;</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">f</span> <span class="free">a</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span><span class="main">∈</span>least_map <span class="free">f</span> <span class="main">(</span>insert <span class="free">a</span> <span class="free">S</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> least_map.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> least_map.intros<span class="main">)</span>


<span class="keyword1"><span class="command">context</span></span> semilattice_inf
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> inf_absorb1 inf_absorb2

  <span class="keyword1"><span class="command">lemma</span></span> inf_absorb_less<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="free">b</span> <span class="main">⟹</span> inf <span class="free">a</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="free">b</span> <span class="main">⟹</span> inf <span class="free">b</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> le_iff_inf less_imp_le<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inf_commute le_iff_inf less_imp_le<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>







<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Graph">
<div class="head">
<h1>Theory Graph</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Graph
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines a notion of graphs. A graph is a record that
  contains a set of nodes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>V›</span></span></span></span> and a set of labeled edges 
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>E ⊆ V×W×V›</span></span></span></span>, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>W›</span></span></span></span> are the edge labels.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A graph is represented by a record.›</span></span>
  <span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> graph <span class="main">=</span>
    nodes <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> set"</span></span>
    edges <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">×</span> <span class="tfree">'w</span> <span class="main">×</span> <span class="tfree">'v</span><span class="main">)</span> set"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a valid graph, edges only go from nodes to nodes.›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> valid_graph <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> E_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"fst<span class="main">`</span>edges <span class="free">G</span> <span class="main">⊆</span> nodes <span class="free">G</span>"</span></span>
                     <span class="quoted"><span class="quoted">"snd<span class="main">`</span>snd<span class="main">`</span>edges <span class="free">G</span> <span class="main">⊆</span> nodes <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">V</span> <span class="main">≡</span> nodes <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">≡</span> edges <span class="free">G</span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> E_validD<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">∈</span>V"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> E_valid<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> E_valid<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic operations on Graphs›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The empty graph.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">empty</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">empty</span> <span class="main">≡</span> <span class="main">⦇</span> nodes <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> edges <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adds a node to a graph.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_node</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">add_node</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">⦇</span> nodes <span class="main">=</span> insert <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">,</span> edges<span class="main">=</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Deletes a node from a graph. Also deletes all adjacent edges.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">delete_node</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">delete_node</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">⦇</span> 
    nodes <span class="main">=</span> nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">,</span>   
    edges <span class="main">=</span> edges <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">∩</span> <span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span><span class="main">×</span>UNIV<span class="main">×</span><span class="main">(</span><span class="main">-</span><span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">}</span><span class="main">)</span>
    <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adds an edge to a graph.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_edge</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">add_edge</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    nodes <span class="main">=</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">}</span> <span class="main">∪</span> nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span>
    edges <span class="main">=</span> insert <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span> <span class="main">(</span>edges <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>
    <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Deletes an edge from a graph.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">delete_edge</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">delete_edge</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="main">⦇</span>
    nodes <span class="main">=</span> nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span> edges <span class="main">=</span> edges <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">)</span><span class="main">}</span> <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Successors of a node.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> graph <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now follow some simplification lemmas.›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> empty_valid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"valid_graph empty"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> empty_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">lemma</span></span> add_node_valid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="free">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="main">(</span>add_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> valid_graph <span class="quoted"><span class="free">g</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> add_node_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> delete_node_valid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="free">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="main">(</span>delete_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> valid_graph <span class="quoted"><span class="free">g</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> delete_node_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> add_edge_valid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="free">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="main">(</span>add_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> valid_graph <span class="quoted"><span class="free">g</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> add_edge_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> delete_edge_valid<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="free">g</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_graph <span class="main">(</span>delete_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> valid_graph <span class="quoted"><span class="free">g</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> delete_edge_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> succ_finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> finite <span class="main">(</span>succ <span class="free">G</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> succ_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"snd<span class="main"><span class="main"><span class="main">`</span></span></span>edges <span class="free"><span class="free"><span class="free">G</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> nodes_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes empty <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> empty_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">lemma</span></span> edges_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"edges empty <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> empty_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">lemma</span></span> succ_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"succ empty <span class="free">v</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> empty_def succ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> nodes_add_node<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>add_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">v</span> <span class="main">(</span>nodes <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_node_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> nodes_add_edge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"nodes <span class="main">(</span>add_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">v</span> <span class="main">(</span>insert <span class="free">v'</span> <span class="main">(</span>nodes <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_edge_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> edges_add_edge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"edges <span class="main">(</span>add_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span> <span class="main">(</span>edges <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_edge_def<span class="main">)</span>
  <span class="keyword1"><span class="command">lemma</span></span> edges_add_node<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"edges <span class="main">(</span>add_node <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> edges <span class="free">g</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_node_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> valid_graph<span class="main">)</span> succ_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"succ <span class="free">G</span> <span class="free">v</span> <span class="main">⊆</span> UNIV<span class="main">×</span>V"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> succ_def <span class="keyword1"><span class="command">using</span></span> E_valid
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Paths›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A path is represented by a list of adjacent edges.›</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> path <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">×</span><span class="tfree">'w</span><span class="main">×</span><span class="tfree">'v</span><span class="main">)</span> list"</span></span>

  <span class="keyword1"><span class="command">context</span></span> valid_graph
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following predicate describes a valid path:›</span></span>
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">is_path</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> path <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">is_path</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span><span class="main">∈</span>V"</span></span> <span class="main">|</span>
      <span class="quoted"><span class="quoted">"<span class="free">is_path</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v2</span></span></span><span class="main">)</span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">v1</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v2</span></span></span><span class="main">)</span><span class="main">∈</span>E <span class="main">∧</span> <span class="free">is_path</span> <span class="free"><span class="bound"><span class="entity">v2</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span>"</span></span>
  
    <span class="keyword1"><span class="command">lemma</span></span> is_path_simps<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="main">[]</span> <span class="free">v</span> <span class="main">⟷</span> <span class="free">v</span><span class="main">∈</span>V"</span></span>
      <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">]</span> <span class="free">v'</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
    
    <span class="keyword1"><span class="command">lemma</span></span> is_path_memb<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="free">v</span><span class="main">∈</span>V <span class="main">∧</span> <span class="free">v'</span><span class="main">∈</span>V"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    <span class="keyword1"><span class="command">lemma</span></span> is_path_split<span class="main">:</span>
      <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="free">v'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">u</span><span class="main">.</span> is_path <span class="free">v</span> <span class="free">p1</span> <span class="bound">u</span> <span class="main">∧</span> is_path <span class="bound">u</span> <span class="free">p2</span> <span class="free">v'</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">lemma</span></span> is_path_split'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">u'</span><span class="main">)</span><span class="main">#</span><span class="free">p2</span><span class="main">)</span> <span class="free">v'</span> 
        <span class="main">⟷</span> is_path <span class="free">v</span> <span class="free">p1</span> <span class="free">u</span> <span class="main">∧</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">u'</span><span class="main">)</span><span class="main">∈</span>E <span class="main">∧</span> is_path <span class="free">u'</span> <span class="free">p2</span> <span class="free">v'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> is_path_split<span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Set of intermediate vertices of a path. These are all vertices but
    the last one. Note that, if the last vertex also occurs earlier on the path,
    it is contained in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>int_vertices›</span></span></span></span>.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">int_vertices</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> path <span class="main">⇒</span> <span class="tfree">'v</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">int_vertices</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> set <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> int_vertices_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"int_vertices <span class="main">[]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="quoted"><span class="quoted">"int_vertices <span class="main">(</span><span class="free">vv</span><span class="main">#</span><span class="free">p</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>fst <span class="free">vv</span><span class="main">)</span> <span class="main">(</span>int_vertices <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"int_vertices <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span> <span class="main">=</span> int_vertices <span class="free">p1</span> <span class="main">∪</span> int_vertices <span class="free">p2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_vertices_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> valid_graph<span class="main">)</span> int_vertices_subset<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span> <span class="main">⟹</span> int_vertices <span class="free">p</span> <span class="main">⊆</span> V"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> int_vertices_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"int_vertices <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Splitting Paths›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Split a path at the point where it first leaves the set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>W›</span></span></span></span>:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> valid_graph<span class="main">)</span> path_split_set<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">∉</span><span class="free">W</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">p2</span> <span class="free">u</span> <span class="free">w</span> <span class="free">u'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p1</span><span class="main">@</span><span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">u'</span><span class="main">)</span><span class="main">#</span><span class="free">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"int_vertices <span class="free">p1</span> <span class="main">⊆</span> <span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u'</span><span class="main">∉</span><span class="free">W</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">thesis</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">vv</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∈</span><span class="free">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">v'</span><span class="main">∉</span><span class="free">W</span>›</span></span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        REST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="skolem">u'</span> <span class="skolem">p</span> <span class="free">v'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vv</span></span><span class="main">)</span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Distinguish wether the second node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u'›</span></span></span></span> of the path is 
      in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>W›</span></span></span></span>. If yes, the proposition follows by the 
      induction hypothesis, otherwise it is straightforward, as
      the split takes place at the first edge of the path.›</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> A <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∈</span><span class="free">W</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> Cons.hyps<span class="main">[</span><span class="operator">OF</span> _ REST<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">uu</span></span> <span class="skolem"><span class="skolem">ww</span></span> <span class="skolem"><span class="skolem">uu'</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="main">(</span><span class="skolem">uu</span><span class="main">,</span><span class="skolem">ww</span><span class="main">,</span><span class="skolem">uu'</span><span class="main">)</span><span class="main">#</span><span class="skolem">p2</span>"</span></span> <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p1</span> <span class="main">⊆</span> <span class="free">W</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">uu</span> <span class="main">∈</span> <span class="free">W</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">uu'</span> <span class="main">∉</span> <span class="free">W</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">with</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">#</span><span class="skolem">p1</span>"</span></span> <span class="quoted"><span class="skolem">uu</span></span> <span class="quoted"><span class="skolem">ww</span></span> <span class="quoted"><span class="skolem">uu'</span></span> <span class="quoted"><span class="skolem">p2</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∉</span><span class="free">W</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="skolem">v</span></span> <span class="quoted"><span class="skolem">w</span></span> <span class="quoted"><span class="skolem">u'</span></span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Split a path at the point where it first enters the set <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>W›</span></span></span></span>:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> valid_graph<span class="main">)</span> path_split_set'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">∈</span><span class="free">W</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">p2</span> <span class="free">u</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p1</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"is_path <span class="free">u</span> <span class="free">p2</span> <span class="free">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"int_vertices <span class="free">p1</span> <span class="main">⊆</span> <span class="main">-</span><span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span><span class="free">W</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span><span class="free">W</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> that<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">thesis</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">vv</span> <span class="skolem">p</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="quoted"><span class="quoted">‹<span class="free">v'</span><span class="main">∈</span><span class="free">W</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">v</span><span class="main">∉</span><span class="free">W</span>›</span></span>
      <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
          REST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="skolem">u'</span> <span class="skolem">p</span> <span class="free">v'</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vv</span></span><span class="main">)</span> <span class="operator">auto</span>
    
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Distinguish wether the second node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u'›</span></span></span></span> of the path is 
        in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>W›</span></span></span></span>. If yes, the proposition is straightforward, otherwise,
        it follows by the induction hypothesis.
›</span></span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> A <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∈</span><span class="free">W</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> Cons.prems<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="skolem">vv</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="skolem">p</span></span> <span class="quoted"><span class="skolem">u'</span></span><span class="main">]</span> REST <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u'</span><span class="main">∉</span><span class="free">W</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> Cons.hyps<span class="main">[</span><span class="operator">OF</span> REST<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="skolem"><span class="skolem">u''</span></span> <span class="keyword2"><span class="keyword">where</span></span>
          <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
            <span class="quoted"><span class="quoted">"is_path <span class="skolem">u'</span> <span class="skolem">p1</span> <span class="skolem">u''</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
            <span class="quoted"><span class="quoted">"is_path <span class="skolem">u''</span> <span class="skolem">p2</span> <span class="free">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p1</span> <span class="main">⊆</span> <span class="main">-</span><span class="free">W</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            <span class="quoted"><span class="quoted">"<span class="skolem">u''</span><span class="main">∈</span><span class="free">W</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">with</span></span> Cons.prems<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">#</span><span class="skolem">p1</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Split a path at the point where a given vertex is first visited:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> valid_graph<span class="main">)</span> path_split_vertex<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∈</span>int_vertices <span class="free">p</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">p1</span> <span class="free">p2</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p1</span> <span class="free">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∉</span> int_vertices <span class="free">p1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">thesis</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">vv</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">w</span></span> <span class="skolem"><span class="skolem">u'</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">=</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>V"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">u'</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        REST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="skolem">u'</span> <span class="skolem">p</span> <span class="free">v'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vv</span></span><span class="main">)</span> <span class="operator">auto</span>
    
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">=</span><span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">#</span><span class="skolem">p</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="skolem">thesis</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">≠</span><span class="skolem">v</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> Cons.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> _ REST<span class="main">]</span> Cons.prems<span class="main">(</span>3<span class="main">)</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> <span class="quoted"><span class="quoted">"is_path <span class="skolem">u'</span> <span class="skolem">p1</span> <span class="free">u</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">u</span><span class="main">∉</span>int_vertices <span class="skolem">p1</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">with</span></span> Cons.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">vv</span><span class="main">#</span><span class="skolem">p1</span>"</span></span> <span class="quoted"><span class="skolem">p2</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="skolem">thesis</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Weighted Graphs›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> valid_mgraph <span class="main">=</span> valid_graph <span class="quoted"><span class="free">G</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid_add<span class="main">)</span> graph"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_weight</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span><span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid_add<span class="main">)</span> path <span class="main">⇒</span> <span class="tfree">'w</span>"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">path_weight</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> sum_list <span class="main">(</span>map <span class="main">(</span>fst <span class="main">∘</span> snd<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

  <span class="comment1">(* 
    lemma path_weight_alt: "path_weight p ≡ sum_list (map (fst ∘ snd) p)"
    unfolding path_weight_def foldl_conv_fold
    by (simp add: sum_list_foldl)
  *)</span>

  <span class="keyword1"><span class="command">lemma</span></span> path_weight_split<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>path_weight <span class="main">(</span><span class="free">p1</span><span class="main">@</span><span class="free">p2</span><span class="main">)</span><span class="main">::</span><span class="tfree">'w</span><span class="main">::</span>monoid_add<span class="main">)</span> <span class="main">=</span> path_weight <span class="free">p1</span> <span class="main">+</span> path_weight <span class="free">p2</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> path_weight_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> path_weight_empty<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"path_weight <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> path_weight_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> path_weight_cons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>path_weight <span class="main">(</span><span class="free">e</span><span class="main">#</span><span class="free">p</span><span class="main">)</span><span class="main">::</span><span class="tfree">'w</span><span class="main">::</span>monoid_add<span class="main">)</span> <span class="main">=</span> fst <span class="main">(</span>snd <span class="free">e</span><span class="main">)</span> <span class="main">+</span> path_weight <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> path_weight_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Weight">
<div class="head">
<h1>Theory Weight</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Weights for Dijkstra's Algorithm"</span></span>
<span class="keyword1"><span class="command">theory</span></span> Weight
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we set up a type class for weights, and
  a typeclass for weights with an infinity element. The latter
  one is used internally in Dijkstra's algorithm.

  Moreover, we provide a datatype that adds an infinity element to a given
  base type.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type Classes Setup›</span></span>

<span class="keyword1"><span class="command">class</span></span> weight <span class="main">=</span> ordered_ab_semigroup_add <span class="main">+</span> comm_monoid_add <span class="main">+</span> linorder
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> add_nonneg_nonneg <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">b</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">+</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> add_nonpos_nonpos<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≤</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≤</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≤</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">+</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> add_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> add_nonneg_eq_0_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">+</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.comm_neutral add.left_neutral add_left_mono antisym x y<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> add_incr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">a</span><span class="main">+</span><span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.comm_neutral add_left_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> add_incr_left<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">+</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_incr add.commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sum_not_less<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="free">b</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="free">b</span> <span class="main">&lt;</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="free">a</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="free">b</span> <span class="main">&lt;</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> add_incr less_le_not_le<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> add_incr_left less_le_not_le<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> nat <span class="main">::</span> <span class="quoted">weight</span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">instance</span></span> int <span class="main">::</span> <span class="quoted">weight</span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">instance</span></span> rat <span class="main">::</span> <span class="quoted">weight</span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">instance</span></span> real <span class="main">::</span> <span class="quoted">weight</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">top</span>


<span class="keyword1"><span class="command">class</span></span> top_weight <span class="main">=</span> order_top <span class="main">+</span> weight <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> inf_add_right<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">+</span> top <span class="main">=</span> top"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inf_add_left<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"top <span class="main">+</span> <span class="free">a</span> <span class="main">=</span> top"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.commute inf_add_right<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> top_unique less_top<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  
<span class="keyword1"><span class="command">lemma</span></span> not_less_inf<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">a</span> <span class="main">&lt;</span> top<span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span>top"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Adding Infinity›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We provide a standard way to add an infinity element to any type.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> infty <span class="main">=</span> Infty <span class="main">|</span> Num <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">val</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">val</span> <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> num_val_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">≠</span>Infty <span class="main">⟹</span> Num <span class="main">(</span>val <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="free">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">type_synonym</span></span> NatB <span class="main">=</span> <span class="quoted"><span class="quoted">"nat infty"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> infty <span class="main">::</span> <span class="main">(</span><span class="quoted">weight</span><span class="main">)</span> <span class="quoted">top_weight</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="tfree">'a</span> infty<span class="main">)</span> <span class="main">==</span> Num <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"top <span class="main">≡</span> Infty"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">less_eq_infty</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"less_eq Infty <span class="main">(</span>Num <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="main">⟷</span> False"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"less_eq <span class="main"><span class="bound"><span class="entity">_</span></span></span> Infty <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"less_eq <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">≤</span><span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Infty<span class="main">≤</span><span class="free">a</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span>Infty"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">less_infty</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"less Infty <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"less <span class="main">(</span>Num <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> Infty <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"less <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"less <span class="free">a</span> Infty <span class="main">⟷</span> <span class="free">a</span> <span class="main">≠</span> Infty"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity"><span class="class_parameter">plus_infty</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"plus <span class="main"><span class="bound"><span class="entity">_</span></span></span> Infty <span class="main">=</span> Infty"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"plus Infty <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> Infty"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"plus <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span>Num <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> Num <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plus Infty <span class="free">a</span> <span class="main">=</span> Infty"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="operator">simp_all</span>


  <span class="keyword1"><span class="command">instance</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">x</span></span></span></span></span></span></span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">y</span></span></span></span></span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">z</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> top_infty_def zero_infty_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">a</span></span></span></span></span></span></span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>4<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">b</span></span></span></span></span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">c</span></span></span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>2<span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span> add_right_mono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="improper">x</span><span class="main">,</span><span class="improper">y</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_eq_infty.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> linear<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Unboxing›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Conversion between the constants defined by the
  typeclass, and the concrete functions on the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> infty"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> type. 
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> infty_inf_unbox<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Num <span class="free">a</span> <span class="main">≠</span> top"</span></span>
  <span class="quoted"><span class="quoted">"top <span class="main">≠</span> Num <span class="free">a</span>"</span></span>
  <span class="quoted"><span class="quoted">"Infty <span class="main">=</span> top"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> top_infty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_ord_unbox<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Num <span class="free">a</span> <span class="main">≤</span> Num <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">b</span>"</span></span>
  <span class="quoted"><span class="quoted">"Num <span class="free">a</span> <span class="main">&lt;</span> Num <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">&lt;</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_plus_unbox<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Num <span class="free">a</span> <span class="main">+</span> Num <span class="free">b</span> <span class="main">=</span> Num <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_zero_unbox<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Num <span class="free">a</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Num <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_infty_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> infty_unbox <span class="main">=</span> 
  infty_inf_unbox infty_zero_unbox infty_ord_unbox infty_plus_unbox

<span class="keyword1"><span class="command">lemma</span></span> inf_not_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"top<span class="main">≠</span><span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="main">_</span> infty<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="main">_</span> infty<span class="main">)</span><span class="main">≠</span>top"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> zero_infty_def top_infty_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> num_val_iff'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">≠</span>top <span class="main">⟹</span> Num <span class="main">(</span>val <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="free">e</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_neE<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span><span class="main">≠</span>Infty<span class="main">;</span> <span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">a</span><span class="main">=</span>Num <span class="bound">d</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span><span class="main">≠</span>top<span class="main">;</span> <span class="main">⋀</span><span class="bound">d</span><span class="main">.</span> <span class="free">a</span><span class="main">=</span>Num <span class="bound">d</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dijkstra">
<div class="head">
<h1>Theory Dijkstra</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Dijkstra's Algorithm›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra
  <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Graph.html">Graph</a> 
  <a href="Dijkstra_Misc.html">Dijkstra_Misc</a> 
  <a href="../Collections/Refine_Dflt_ICF.html">Collections.Refine_Dflt_ICF</a>
  <a href="Weight.html">Weight</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory defines Dijkstra's algorithm. First, a correct result of 
  Dijkstra's algorithm w.r.t. a graph and a start vertex is specified. 
  Then, the refinement 
  framework is used to specify Dijkstra's Algorithm, prove it correct, and
  finally refine it to datatypes that are closer to an implementation than
  the original specification.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Graph's for Dijkstra's Algorithm"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A graph annotated with weights.›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> weighted_graph <span class="main">=</span> valid_graph <span class="quoted"><span class="free">G</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">)</span> graph"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Specification of Correct Result"</span></span>
  <span class="keyword1"><span class="command">context</span></span> weighted_graph
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
      A result of Dijkstra's algorithm is correct, if it is a map from nodes 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> to the shortest path from the start node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v0›</span></span></span></span> to 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>. Iff there is no such path, the node is not in the map.
›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_shortest_path_map</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">is_shortest_path_map</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="bound">v</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">p</span> <span class="bound">v</span><span class="main">)</span> <span class="main">|</span>
        Some <span class="bound">p</span> <span class="main">⇒</span> is_path <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">p</span> <span class="bound">v</span> 
                  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p'</span><span class="main">.</span> is_path <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="bound">p'</span> <span class="bound">v</span> <span class="main">⟶</span> path_weight <span class="bound">p</span> <span class="main">≤</span> path_weight <span class="bound">p'</span><span class="main">)</span>
      <span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The following function returns the weight of an optional path,
    where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span> is interpreted as infinity.
›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">path_weight'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">path_weight'</span> None <span class="main">=</span> top"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">path_weight'</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> Num <span class="main">(</span>path_weight <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Dijkstra's Algorithm"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The state in the main loop of the algorithm consists of a workset 
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>wl›</span></span></span></span> of vertexes that still need to be explored, and a map 
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>res›</span></span></span></span> that contains the current shortest path for each vertex.
›</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> set<span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The preconditions of Dijkstra's algorithm, i.e., that it operates on a 
    valid and finite graph, and that the start node is a node of the graph,
    are summarized in a locale.
›</span></span>
  <span class="keyword1"><span class="command">locale</span></span> Dijkstra <span class="main">=</span> weighted_graph <span class="quoted"><span class="free">G</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">)</span> graph"</span></span><span class="main">+</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">v0</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'V</span></span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite V"</span></span> <span class="quoted"><span class="quoted">"finite E"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> v0_in_V<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span><span class="main">∈</span>V"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> nonneg_weights<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="free">w</span><span class="main">,</span><span class="free">v'</span><span class="main">)</span><span class="main">∈</span>edges <span class="free">G</span> <span class="main">⟹</span> <span class="main">0</span><span class="main">≤</span><span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Paths have non-negative weights.›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> path_nonneg_weight<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v</span> <span class="free">p</span> <span class="free">v'</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> path_weight <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_path.induct<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Invariant of the main loop: 
    \begin{itemize}
      \item The workset only contains nodes of the graph.
      \item If the result set contains a path for a node, it is actually a path,
        and uses only intermediate vertices outside the workset.
      \item For all vertices outside the workset, the result map contains the 
        shortest path.
      \item For all vertices in the workset, the result map contains the
        shortest path among all paths that only use intermediate vertices outside
        the workset.
    \end{itemize}
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dinvar</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">in</span>
    <span class="bound">wl</span> <span class="main">⊆</span> V <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">res</span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V<span class="main">-</span><span class="bound">wl</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">-</span><span class="bound">wl</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> 
       <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="bound">wl</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V<span class="main">-</span><span class="bound">wl</span>
       <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span>
    <span class="main">)</span>
    "</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Sanity check: The invariant is strong enough to imply correctness 
    of result.›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> invar_imp_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span><span class="main">{}</span><span class="main">,</span><span class="free">res</span><span class="main">)</span> <span class="main">⟹</span> is_shortest_path_map <span class="free">v0</span> <span class="free">res</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dinvar_def is_shortest_path_map_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The initial workset contains all vertices. The initial result maps
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v0›</span></span></span></span> to the empty path, and all other vertices to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span>.
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">dinit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">dinit</span> <span class="main">≡</span> SPEC <span class="main">(</span> <span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">.</span> 
        <span class="bound">wl</span><span class="main">=</span>V <span class="main">∧</span> <span class="bound">res</span> <span class="free">v0</span> <span class="main">=</span> Some <span class="main">[]</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">.</span> <span class="bound">res</span> <span class="bound">v</span> <span class="main">=</span> None<span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    The initial state satisfies the invariant.
›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> dinit_invar<span class="main">:</span> <span class="quoted"><span class="quoted">"dinit <span class="main">≤</span> SPEC dinvar"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dinit_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dinvar_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    In each iteration, the main loop of the algorithm pops a minimal node from
    the workset, and then updates the result map accordingly.
›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    Pop a minimal node from the workset. The node is minimal in the sense that
    the length of the current path for that node is minimal.
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">pop_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state<span class="main">)</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">pop_min</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span>
      ASSERT <span class="main">(</span><span class="bound">wl</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span><span class="main">;</span> 
      <span class="bound">v</span> <span class="main">←</span> RES <span class="main">(</span>least_map <span class="main">(</span>path_weight' <span class="main">∘</span> <span class="bound">res</span><span class="main">)</span> <span class="bound">wl</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="main">(</span><span class="bound">wl</span><span class="main">-</span><span class="main">{</span><span class="bound">v</span><span class="main">}</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    Updating the result according to a node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is done by checking, 
    for each successor node, whether the path over <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is shorter than 
    the path currently stored into the result map.
›</span></span>
  <span class="keyword1"><span class="command">inductive</span></span> <span class="entity">update_spec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> 
      <span class="free"><span class="bound"><span class="entity">res'</span></span></span> <span class="bound">v'</span> <span class="main">∈</span> least_map path_weight' <span class="main">(</span>
        <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="bound">v'</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>E <span class="main">}</span>
      <span class="main">)</span>
     <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">update_spec</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">res</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wl</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">res'</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    In order to ease the refinement proof, we will assert the following 
    precondition for updating.
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">update_pre</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">update_pre</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">∈</span>V 
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">-</span><span class="bound">wl</span><span class="main">.</span> <span class="bound">v'</span><span class="main">≠</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v'</span> 
          <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">res</span> <span class="bound">v'</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v'</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>ASSERT <span class="main">(</span>update_pre <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">;</span> SPEC <span class="main">(</span>update_spec <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we define Dijkstra's algorithm:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">dijkstra</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">dijkstra</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">σ0</span><span class="main">←</span>dinit<span class="main">;</span> 
       <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup></sup></span>dinvar<span class="main"><span class="hidden">⇖</span></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">wl</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> 
              <span class="keyword1">do</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> pop_min <span class="bound">σ</span><span class="main">;</span> update <span class="bound">v</span> <span class="bound">σ'</span> <span class="main">}</span>
            <span class="main">)</span>
            <span class="bound">σ0</span><span class="main">;</span>
       RETURN <span class="bound">res</span> <span class="main">}</span>
    "</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following theorem states (total) correctness of Dijkstra's 
    algorithm.›</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> dijkstra_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"dijkstra <span class="main">≤</span> SPEC <span class="main">(</span>is_shortest_path_map <span class="free">v0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dijkstra_def
    <span class="keyword1"><span class="command">unfolding</span></span> dinit_def
    <span class="keyword1"><span class="command">unfolding</span></span> pop_min_def update_def <span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span>
      WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span><span class="main">&lt;</span><span class="bound">y</span><span class="main">}</span> <span class="main">(</span>card <span class="main">∘</span> fst<span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span>
      <span class="dynamic"><span class="dynamic">refine_vcg</span></span> 
    <span class="main">)</span>

    <span class="comment1">(* TODO/FIXME: Should we built in such massaging of the goal into 
        refine_rcg ?*)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> defined_all<span class="main">]</span><span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">tactic</span> <span class="quoted">‹
      ALLGOALS <span class="main">(</span><span class="main">(</span>REPEAT_DETERM o <span class="entity">Hypsubst.bound_hyp_subst_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span><span class="main">)</span>
      THEN' <span class="entity">asm_full_simp_tac</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
      <span class="main">)</span>›</span><span class="main">)</span>

  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>least_map <span class="main">(</span>path_weight' <span class="main">∘</span> <span class="skolem">res</span><span class="main">)</span> <span class="skolem">wl</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> dinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_elemD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="bound">v'</span> <span class="main">≠</span> <span class="skolem">v</span> <span class="main">⟶</span> 
      <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v'</span> <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="bound">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dinvar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="skolem">res</span> <span class="bound">v'</span><span class="main">=</span>Some <span class="bound">p</span> <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dinvar_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"update_pre <span class="skolem">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> update_pre_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">res</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span><span class="main">{}</span><span class="main">,</span> <span class="skolem">res</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"is_shortest_path_map <span class="free">v0</span> <span class="skolem">res</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> invar_imp_correct<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>inv_image <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">}</span> <span class="main">(</span>card <span class="main">∘</span> fst<span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf_less<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">v</span> <span class="skolem">σ''</span>
    <span class="keyword3"><span class="command">assume</span></span> 
      LM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>least_map <span class="main">(</span>path_weight' <span class="main">∘</span> <span class="skolem">res</span><span class="main">)</span> <span class="skolem">wl</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 
      UD<span class="main">:</span> <span class="quoted"><span class="quoted">"update_spec <span class="skolem">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span> <span class="skolem">σ''</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      INV<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span> 

    <span class="keyword1"><span class="command">from</span></span> LM <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_elemD<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> UD <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fst <span class="skolem">σ''</span> <span class="main">=</span> <span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> update_spec.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">wl</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> dinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>fst <span class="skolem">σ''</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="skolem">wl</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_gt_0_iff diff_Suc_less empty_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">res</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> V <span class="main">∧</span> <span class="skolem">res</span> <span class="free">v0</span> <span class="main">=</span> Some <span class="main">[]</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">-</span><span class="main">{</span><span class="free">v0</span><span class="main">}</span><span class="main">.</span> <span class="skolem">res</span> <span class="bound">v</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span>V<span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dinvar_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvar <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span>  
      WL_SUBSET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">wl</span> <span class="main">⊆</span> V"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      PATH_VALID<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="skolem">res</span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
        <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="skolem">wl</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      NWL_MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V <span class="main">-</span> <span class="skolem">wl</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> 
        <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      WL_MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span><span class="skolem">wl</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="skolem">wl</span> 
        <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> dinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span> <span class="skolem">σ''</span>
    <span class="keyword3"><span class="command">assume</span></span> V_LEAST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span>least_map <span class="main">(</span>path_weight' <span class="keyword1">o</span> <span class="skolem">res</span><span class="main">)</span> <span class="skolem">wl</span>"</span></span> 
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"update_spec <span class="skolem">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span> <span class="skolem">σ''</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">res'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ''</span><span class="main">=</span><span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> CONSIDERED_NEW_PATHS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> <span class="skolem">res'</span> <span class="bound">v'</span> <span class="main">∈</span> least_map path_weight' 
        <span class="main">(</span>insert <span class="main">(</span><span class="skolem">res</span> <span class="bound">v'</span><span class="main">)</span> 
              <span class="main">(</span><span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="skolem">v</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>E <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> update_spec.cases<span class="main">)</span>
      
    <span class="keyword1"><span class="command">from</span></span> V_LEAST <span class="keyword1"><span class="command">have</span></span> V_MEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">∈</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> least_map_elemD<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dinvar <span class="skolem">σ''</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> dinvar_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> WL_SUBSET <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span> <span class="main">⊆</span> V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">va</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="skolem">res'</span> <span class="bound">va</span> <span class="main">=</span> Some <span class="bound">p</span> 
        <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">va</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ballI conjI impI allI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">p</span>
        <span class="keyword3"><span class="command">assume</span></span> V'_MEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v'</span> <span class="main">=</span> Some <span class="skolem">p</span>"</span></span>
        <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The new paths that we have added are valid and only use 
          intermediate vertices outside the workset. 
          
          This proof works as follows: A path <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res'</span></span> <span class="skolem"><span class="skolem">v'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is either
          the old path, or has been assembled as a path over node <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
          In the former case the proposition follows straightforwardly from the
          invariant for the old state. In the latter case we get, by the invariant
          for the old state, that the path over node <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is valid. 
          Then, we observe that appending an edge to a valid path yields a valid 
          path again. Also, adding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as intermediate node is legal, as we 
          just removed <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from the workset.
›</span></span>
        <span class="keyword1"><span class="command">with</span></span> CONSIDERED_NEW_PATHS <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v'</span> <span class="main">∈</span> <span class="main">(</span>insert <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> 
          <span class="main">(</span><span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="skolem">v</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>E <span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> least_map_elemD<span class="main">)</span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v'</span> <span class="main">=</span> <span class="skolem">res</span> <span class="skolem">v'</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> V'_MEM PATH_VALID <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p</span> <span class="skolem">v'</span>"</span></span> 
            <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">pv</span> <span class="skolem">w</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v'</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="skolem">v</span> <span class="main">=</span> Some <span class="skolem">pv</span>"</span></span> 
            <span class="keyword2"><span class="keyword">and</span></span> EDGE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          
          <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> PATH_VALID rev_subsetD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> V_MEM WL_SUBSET<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
            PATHV<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">pv</span> <span class="skolem">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> IVV<span class="main">:</span> <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">pv</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> 
            <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p</span> <span class="skolem">v'</span>"</span></span> 
            <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> EDGE V'_MEM<span class="main">)</span>
        <span class="keyword1"><span class="command">}</span></span> 
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> 
          <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p</span> <span class="skolem">v'</span>"</span></span> 
          <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
        We show that already the {\em original} result stores the minimal 
        path for all vertices not in the {\em new} workset. 
        For vertices also not in the original workset, this follows 
        straightforwardly from the invariant.
        
        For the vertex <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>, that has been removed from the
        workset, we split a path <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p'›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> at the point
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> where it first enters the original workset.  

        As we chose <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> to be the vertex in the workset with the
        minimal weight, its weight is less than the current weight of
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span>.  As the vertices of the prefix of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p'›</span></span></span></span> up to
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> are not in the workset, the current weight of
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>u›</span></span></span></span> is less than the weight of the prefix of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p'›</span></span></span></span>, and thus less than the weight of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p'›</span></span></span></span>. 
        Together, the current weight of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span> is less than the weight of
        <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p'›</span></span></span></span>.›</span></span>
      <span class="keyword1"><span class="command">have</span></span> RES_MIN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> 
        <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> ballI allI impI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">p'</span>
        <span class="keyword3"><span class="command">assume</span></span> NOT_IN_WL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p'</span> <span class="skolem">v'</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">=</span> <span class="skolem">v</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> NE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="skolem">v</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> NWL_MIN<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">v'</span></span><span class="main">]</span> NOT_IN_WL PATH <span class="keyword3"><span class="command">show</span></span>
            <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">assume</span></span> EQ<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="skolem">v</span>"</span></span>
          
          <span class="keyword1"><span class="command">from</span></span> path_split_set'<span class="main">[</span><span class="operator">OF</span> PATH<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">wl</span></span><span class="main">]</span> V_MEM <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p1</span></span> <span class="skolem"><span class="skolem">p2</span></span> <span class="skolem"><span class="skolem">u</span></span> <span class="keyword2"><span class="keyword">where</span></span>
            <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span><span class="main">=</span><span class="skolem">p1</span><span class="main">@</span><span class="skolem">p2</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> P1<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p1</span> <span class="skolem">u</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> P2<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="skolem">u</span> <span class="skolem">p2</span> <span class="skolem">v'</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> P1V<span class="main">:</span> <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p1</span> <span class="main">⊆</span> <span class="main">-</span><span class="skolem">wl</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span><span class="skolem">wl</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          
          <span class="keyword1"><span class="command">from</span></span> least_map_leD<span class="main">[</span><span class="operator">OF</span> V_LEAST<span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> WL_MIN<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">u</span></span><span class="main">]</span> P1 P1V int_vertices_subset<span class="main">[</span><span class="operator">OF</span> P1<span class="main">]</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p'</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> path_nonneg_weight<span class="main">[</span><span class="operator">OF</span> P2<span class="main">]</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox <span class="main">)</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_0_right add_left_mono<span class="main">)</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
        
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹With the previous statement, we easily show the
        third part of the invariant, as the new paths are not longer than the
        old ones.
›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v</span> 
        <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="bound">v</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI ballI impI<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">p</span>
        <span class="keyword3"><span class="command">assume</span></span> NOT_IN_WL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span> <span class="main">∈</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p</span> <span class="skolem">v'</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> CONSIDERED_NEW_PATHS<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">v'</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_leD<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> RES_MIN NOT_IN_WL<span class="main">]</span> PATH 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">qed</span></span>

      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
        Finally, we have to show that for nodes on the worklist,
        the stored paths are not longer than any path using only nodes not
        on the worklist. Compared to the situation before the step, those
        path may also use the node <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>.
›</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">va</span><span class="main">∈</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> 
        is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">va</span> <span class="main">∧</span> int_vertices <span class="bound">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span> 
        <span class="main">⟶</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="bound">va</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="bound">p</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI ballI<span class="main"><span class="keyword3">,</span></span> <span class="operator">elim</span> conjE<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v'</span> <span class="skolem">p</span>
        <span class="keyword3"><span class="command">assume</span></span> IWS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> PATH<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p</span> <span class="skolem">v'</span>"</span></span> 
          <span class="keyword2"><span class="keyword">and</span></span> VERTICES<span class="main">:</span> <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p</span> <span class="main">⊆</span> V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> IWS WL_SUBSET <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        
        <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
            If the path is empty, the proposition follows easily from the
            invariant for the original states, as no intermediate nodes are 
            used at all.
›</span></span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>
          <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> CONSIDERED_NEW_PATHS<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">v'</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span>
            <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> IWS WL_SUBSET <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_leD<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"int_vertices <span class="skolem">p</span> <span class="main">⊆</span> V<span class="main">-</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> WL_MIN IWS PATH 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> path_weight_empty<span class="main">)</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p1</span> <span class="skolem">u</span> <span class="skolem">w</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p1</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span>"</span></span>
          <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹If the path is not empty, we pick the last but one vertex, and
            call it <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
          <span class="keyword1"><span class="command">from</span></span> PATH <span class="keyword1"><span class="command">have</span></span> PATH1<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">p1</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> EDGE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> VERTICES <span class="keyword1"><span class="command">have</span></span> NIV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V <span class="main">-</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">-</span><span class="main">{</span><span class="skolem">v</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">hence</span></span> U_MEM<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

          <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹From <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] RES_MIN<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we know that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res</span></span> <span class="skolem"><span class="skolem">u</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> holds
            the shortest path to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Thus <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> is longer than the 
            path that is constructed by replacing the prefix of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by 
            {term "res u"}›</span></span>
          <span class="keyword1"><span class="command">from</span></span> NIV RES_MIN PATH1 
          <span class="keyword1"><span class="command">have</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted">"Num <span class="main">(</span>path_weight <span class="skolem">p1</span><span class="main">)</span> <span class="main">≥</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pu</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="skolem">u</span> <span class="main">=</span> Some <span class="skolem">pu</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="skolem">u</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span> <span class="main">≥</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox add_right_mono<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> 
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w</span> <span class="main">≥</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹
              The remaining argument depends on wether <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
              equals <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
              In the case <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">u</span></span><span class="main"><span class="main">≠</span></span><span class="skolem"><span class="skolem">v</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, all vertices of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res</span></span> <span class="skolem"><span class="skolem">u</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are
              outside the original workset. Thus, appending the edge 
              <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="skolem"><span class="skolem">u</span></span><span class="main"><span class="main">,</span></span><span class="skolem"><span class="skolem">w</span></span><span class="main"><span class="main">,</span></span><span class="skolem"><span class="skolem">v'</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res</span></span> <span class="skolem"><span class="skolem">u</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> yields a path to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
              over intermediate nodes only outside the workset. By the invariant
              for the original state, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res</span></span> <span class="skolem"><span class="skolem">v'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is shorter than this path.
              As a step does not replace paths by longer ones, also 
              <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">res'</span></span> <span class="skolem"><span class="skolem">v'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is shorter.

              In the case <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="skolem"><span class="skolem">u</span></span><span class="main"><span class="main">=</span></span><span class="skolem"><span class="skolem">v</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the step has
              considered the path to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v'›</span></span></span></span> over <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>v›</span></span></span></span>, and thus the
              result path is not longer.
›</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">=</span><span class="skolem">v</span>"</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">≠</span><span class="skolem">v</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> NIV <span class="keyword1"><span class="command">have</span></span> NIV'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">∈</span>V<span class="main">-</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> bspec<span class="main">[</span><span class="operator">OF</span> PATH_VALID U_MEM<span class="main">]</span> NIV'
            <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">pu</span> <span class="skolem">u</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> VU<span class="main">:</span> <span class="quoted"><span class="quoted">"int_vertices <span class="main">(</span><span class="skolem">pu</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">⊆</span> V<span class="main">-</span><span class="skolem">wl</span>"</span></span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> EDGE <span class="keyword1"><span class="command">have</span></span> PV'<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="main">(</span><span class="skolem">pu</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> bspec<span class="main">[</span><span class="operator">OF</span> WL_MIN<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">v'</span></span><span class="main">]</span> IWS VU <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="main">(</span><span class="skolem">pu</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">u</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w</span> <span class="main">≥</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> CONSIDERED_NEW_PATHS <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≥</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_leD<span class="main">)</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>order_trans<span class="main">[</span><span class="operator">rotated</span><span class="main">]</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span><span class="main">=</span><span class="skolem">v</span>"</span></span>
            <span class="keyword1"><span class="command">from</span></span> CONSIDERED_NEW_PATHS EDGE <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="main">(</span><span class="skolem">pu</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">w</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule_tac</span> least_map_leD<span class="main">)</span> <span class="operator">auto</span>
            <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="main">(</span>order_trans<span class="main">[</span><span class="operator">rotated</span><span class="main">]</span><span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="skolem">p</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> PATH <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_cases<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Structural Refinement of Update›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    Now that we have proved correct the initial version of the algorithm, we start
    refinement towards an efficient implementation.
›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    First, the update function is refined to iterate over each successor of the
    selected node, and update the result on demand.
›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">uinvar</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'V</span> set <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">uinvar</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl'</span><span class="main">,</span><span class="bound">res'</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">in</span> <span class="bound">wl'</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">wl</span></span></span> 
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> 
      <span class="bound">res'</span> <span class="bound">v'</span> <span class="main">∈</span> least_map path_weight' <span class="main">(</span>
        <span class="main">{</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="bound">v'</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">}</span>
      <span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v'</span><span class="main">∈</span>V<span class="main">.</span> <span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="bound">res'</span> <span class="bound">v'</span> <span class="main">=</span> Some <span class="bound">p</span> <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="bound">v'</span><span class="main">)</span>
    <span class="main">∧</span> <span class="bound">res'</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>
    "</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">update'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">update'</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>update_pre <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">wv</span> <span class="main">=</span> path_weight' <span class="main">(</span><span class="bound">res</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pv</span> <span class="main">=</span> <span class="bound">res</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">;</span>
      <span class="keyword1">FOREACH<span class="hidden">⇗</span><sup></sup></span>uinvar <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">wl</span> <span class="bound">res</span><span class="main"><span class="hidden">⇖</span></span> <span class="main">(</span>succ <span class="free">G</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> 
        <span class="keyword1">if</span> <span class="main">(</span><span class="bound">wv</span> <span class="main">+</span> Num <span class="bound">w'</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v'</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
            ASSERT <span class="main">(</span><span class="bound">v'</span><span class="main">∈</span><span class="bound">wl</span> <span class="main">∧</span> <span class="bound">pv</span><span class="main">≠</span>None<span class="main">)</span><span class="main">;</span> 
            RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">(</span><span class="bound">v'</span> <span class="main">↦</span> the <span class="bound">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
      <span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> update'_refines<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">σ'</span><span class="main">=</span><span class="free">σ</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"update' <span class="free">v'</span> <span class="free">σ'</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>update <span class="free">v</span> <span class="free">σ</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> update'_def update_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span> <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>

    <span class="comment1">(*apply (intro refine_vcg conjI)*)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> singleton_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"update_pre <span class="free">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="main">(</span>succ <span class="free">G</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uinvar_def update_pre_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>

    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">it</span> <span class="skolem">wl'</span> <span class="skolem">res'</span> <span class="skolem">v'</span> <span class="skolem">w'</span>
    <span class="keyword3"><span class="command">assume</span></span> PRE<span class="main">:</span> <span class="quoted"><span class="quoted">"update_pre <span class="free">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">it</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> MEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span><span class="skolem">it</span>"</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> IT_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">it</span><span class="main">⊆</span> succ <span class="free">G</span> <span class="free">v</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> LESS<span class="main">:</span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_pre_def<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> MEM IT_SS <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">using</span></span> succ_subset
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> LESS <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pv</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="skolem">pv</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="free">v</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="free">v</span> <span class="main">≠</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">wl'</span><span class="main">=</span><span class="skolem">wl</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="free">v</span> <span class="main">=</span> <span class="skolem">res</span> <span class="free">v</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> MEM IT_SS <span class="keyword1"><span class="command">have</span></span> EDGE<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>E"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> succ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="skolem">pv</span> <span class="free">v</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">≤</span><span class="skolem">w'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nonneg_weights<span class="main"><span class="main">[</span></span><span class="operator">OF</span> EDGE<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">≠</span><span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> LESS
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">≠</span><span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span><span class="skolem">wl'</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∉</span><span class="skolem">wl'</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V<span class="main">-</span><span class="skolem">wl</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∉</span><span class="skolem">wl</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">note</span></span> LESS
      <span class="keyword1"><span class="command">also</span></span>
      <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_leD<span class="main">)</span>      
      <span class="keyword1"><span class="command">also</span></span>
      <span class="keyword1"><span class="command">from</span></span> PRE <span class="keyword1"><span class="command">have</span></span> PW<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span><span class="main">.</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="skolem">v'</span> <span class="main">⟹</span> 
        path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="bound">p</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> update_pre_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> P<span class="main">:</span> <span class="quoted"><span class="quoted">"is_path <span class="free">v0</span> <span class="main">(</span><span class="skolem">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">v'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> PW<span class="main">[</span><span class="operator">OF</span> P<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
        <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> Num <span class="main">(</span>path_weight <span class="main">(</span><span class="skolem">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="main">(</span><span class="skolem">it</span><span class="main">-</span><span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span>the <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span>the <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">v</span> <span class="main">=</span> <span class="skolem">res'</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v''</span> <span class="keyword3"><span class="command">assume</span></span> VMEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v''</span><span class="main">∈</span>V"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span>the <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v''</span> <span class="main">∈</span> least_map path_weight' <span class="main">(</span>
          <span class="main">{</span> <span class="skolem">res</span> <span class="skolem">v''</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">}</span>
          <span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">.</span> <span class="main">(</span><span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span>the <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="skolem">v''</span> <span class="main">=</span> Some <span class="bound">p</span> 
                <span class="main">⟶</span> is_path <span class="free">v0</span> <span class="bound">p</span> <span class="skolem">v''</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v''</span><span class="main">=</span><span class="skolem">v'</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> False
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">}</span> <span class="main">=</span> 
            <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="skolem">it</span> <span class="main">}</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> INV VMEM <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def 
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
          <span class="keyword1"><span class="command">have</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="skolem">res</span> <span class="skolem">v''</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">}</span> <span class="main">=</span>
          insert <span class="main">(</span>Some <span class="main">(</span><span class="skolem">pv</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
            <span class="main">{</span> <span class="skolem">res</span> <span class="skolem">v''</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="skolem">it</span> <span class="main">}</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> MEM IT_SS
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> EQ<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> least_map_insert_min<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main">)</span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r'</span>
            <span class="keyword3"><span class="command">assume</span></span> A<span class="main">:</span> 
              <span class="quoted"><span class="quoted">"<span class="skolem">r'</span> <span class="main">∈</span> insert <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> 
               <span class="main">{</span>Some <span class="main">(</span><span class="skolem">pv</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">it</span><span class="main">}</span>"</span></span>

            <span class="keyword1"><span class="command">from</span></span> LESS <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span>Some <span class="main">(</span><span class="skolem">pv</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
            <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> INV<span class="main">[</span><span class="operator">unfolded</span> uinvar_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
              <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v'</span> <span class="main">∈</span> least_map path_weight' <span class="main">(</span>
                insert <span class="main">(</span><span class="skolem">res</span> <span class="skolem">v'</span><span class="main">)</span> 
                <span class="main">{</span>Some <span class="main">(</span><span class="skolem">pv</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span><span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">∉</span> <span class="skolem">it</span><span class="main">}</span>
              <span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="skolem">r'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> least_map_leD<span class="main">)</span>
            <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> 
              <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span>Some <span class="main">(</span><span class="skolem">pv</span> <span class="main">@</span> <span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="skolem">r'</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def Let_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">it</span> <span class="skolem">w'</span> <span class="skolem">v'</span> <span class="skolem">wl'</span> <span class="skolem">res'</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">it</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> NLESS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> path_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IN_IT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span><span class="skolem">it</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IT_SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">it</span> <span class="main">⊆</span> succ <span class="free">G</span> <span class="free">v</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> IN_IT IT_SS <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span>succ <span class="free">G</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>V"</span></span> <span class="keyword1"><span class="command">using</span></span> succ_subset
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="free">v</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> None
      <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Some <span class="skolem">p</span><span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v''</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v''</span><span class="main">∈</span>V"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">res'</span> <span class="skolem">v''</span> <span class="main">∈</span> least_map path_weight' <span class="main">(</span>
          <span class="main">{</span> <span class="skolem">res</span> <span class="skolem">v''</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
          <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">it</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="main">}</span>
          <span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">∈</span> least_map path_weight' <span class="var">?S</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">v''</span><span class="main">=</span><span class="skolem">v'</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> INV <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
          
          <span class="keyword1"><span class="command">have</span></span> EQ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">=</span> insert <span class="main">(</span>Some <span class="main">(</span><span class="skolem">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>
            <span class="main">{</span> <span class="skolem">res</span> <span class="skolem">v'</span> <span class="main">}</span> <span class="main">∪</span> <span class="main">{</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">w</span><span class="main">.</span> <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="bound">p</span> 
                            <span class="main">∧</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="skolem">v''</span><span class="main">)</span> <span class="main">∈</span> succ <span class="free">G</span> <span class="free">v</span> <span class="main">-</span> <span class="skolem">it</span> <span class="main">}</span>
            <span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> NLESS <span class="keyword1"><span class="command">have</span></span> 
            <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">≤</span> path_weight' <span class="main">(</span>Some <span class="main">(</span><span class="skolem">p</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox<span class="main">)</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> EQ<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> least_map_insert_nmin<span class="main">)</span>
            <span class="keyword1"><span class="command">using</span></span> INV <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">with</span></span> INV
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">σ'</span>

    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"uinvar <span class="free">v</span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="main">{}</span> <span class="skolem">σ'</span>"</span></span> 
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"update_spec <span class="free">v</span> <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span> <span class="skolem">σ'</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> uinvar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">σ'</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> update_spec.intros <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> succ_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>succ <span class="free">G</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We integrate the new update function into the main algorithm:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">dijkstra'</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">dijkstra'</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">σ0</span> <span class="main">←</span> dinit<span class="main">;</span> 
      <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup></sup></span>dinvar<span class="main"><span class="hidden">⇖</span></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">wl</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> pop_min <span class="bound">σ</span><span class="main">;</span> update' <span class="bound">v</span> <span class="bound">σ'</span><span class="main">}</span><span class="main">)</span>
            <span class="bound">σ0</span><span class="main">;</span>
      RETURN <span class="bound">res</span>
    <span class="main">}</span>"</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> dijkstra'_refines<span class="main">:</span> <span class="quoted"><span class="quoted">"dijkstra' <span class="main">≤</span> <span class="main">⇓</span>Id dijkstra"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> update'_refines
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span> <span class="bound">σ</span><span class="main">=</span><span class="bound">σ'</span> <span class="main">⟹</span> pop_min <span class="bound">σ</span> <span class="main">≤</span> <span class="main">⇓</span>Id <span class="main">(</span>pop_min <span class="bound">σ'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> dijkstra_def dijkstra'_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement to Cached Weights›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, we refine the data types of the workset and the result map.
  The workset becomes a map from nodes to their current weights.
  The result map stores, in addition to the shortest path, also the
  weight of the shortest path. Moreover, we store the shortest paths
  in reversed order, which makes appending new edges more effcient.

  These refinements allow to implement the workset as a priority queue,
  and save recomputation of the path weights in the inner loop of the
  algorithm.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mwl <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">⇀</span> <span class="tfree">'W</span> infty<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mres <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mwl <span class="main">×</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mres"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Map a path with cached weight to one without cached weight.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">mpath'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span> option <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpath'</span> None <span class="main">=</span> None"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">mpath'</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">mpath_weight'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span> option <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">)</span> infty"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpath_weight'</span> None <span class="main">=</span> top"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">mpath_weight'</span> <span class="main">(</span>Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Num <span class="free"><span class="bound"><span class="entity">w</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> Dijkstra
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">αw</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mwl <span class="main">⇒</span> <span class="tfree">'V</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">αw</span> <span class="main">≡</span> dom"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">αr</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mres <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">αr</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">res</span> <span class="bound">v</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">res</span> <span class="bound">v</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span>rev <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">αs</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="main">≡</span> map_prod αw αr"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Additional invariants for the new state. They guarantee that
    the cached weights are consistent.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">res_invarm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">⇀</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path<span class="main">×</span><span class="tfree">'W</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">res_invarm</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="bound">v</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> True <span class="main">|</span> 
        Some <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">w</span> <span class="main">=</span> path_weight <span class="main">(</span>rev <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">dinvarm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">dinvarm</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>dom <span class="bound">wl</span><span class="main">.</span> the <span class="main">(</span><span class="bound">wl</span> <span class="bound">v</span><span class="main">)</span> <span class="main">=</span> mpath_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> res_invarm <span class="bound">res</span>
    "</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> mpath_weight'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>dinvarm <span class="main">(</span><span class="free">wl</span><span class="main">,</span><span class="free">res</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span>
    mpath_weight' <span class="main">(</span><span class="free">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> path_weight' <span class="main">(</span>αr <span class="free">res</span> <span class="free">v</span><span class="main">)</span>
    "</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dinvarm_def res_invarm_def αr_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> mpath'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>dinvarm <span class="main">(</span><span class="free">wl</span><span class="main">,</span><span class="free">res</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span>
    mpath' <span class="main">(</span><span class="free">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> map_option rev <span class="main">(</span>αr <span class="free">res</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> dinvarm_def αr_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> wl_weight_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvarm <span class="main">(</span><span class="free">wl</span><span class="main">,</span><span class="free">res</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> WLV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wl</span> <span class="free">v</span> <span class="main">=</span> Some <span class="free">w</span>"</span></span> 
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span>αr <span class="free">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> INV WLV <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">=</span> mpath_weight' <span class="main">(</span><span class="free">res</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> dinvarm_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> mpath_weight'_correct<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> path_weight' <span class="main">(</span>αr <span class="free">res</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The initial state is constructed using an iterator:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mdinit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mdinit</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">wl</span> <span class="main">←</span> FOREACH V <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">wl</span><span class="main">.</span> RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">(</span><span class="bound">v</span><span class="main">↦</span>Infty<span class="main">)</span><span class="main">)</span><span class="main">)</span> Map.empty<span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">(</span><span class="free">v0</span><span class="main">↦</span>Num <span class="main">0</span><span class="main">)</span><span class="main">,</span><span class="main">[</span><span class="free">v0</span> <span class="main">↦</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> mdinit_refines<span class="main">:</span> <span class="quoted"><span class="quoted">"mdinit <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel αs dinvarm<span class="main">)</span> dinit"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mdinit_def dinit_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> build_rel_SPEC<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> FOREACH_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">wl</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">∈</span>V<span class="main">-</span><span class="bound">it</span><span class="main">.</span> <span class="bound">wl</span> <span class="bound">v</span> <span class="main">=</span> Some Infty<span class="main">)</span> <span class="main">∧</span> 
      dom <span class="bound">wl</span> <span class="main">=</span> V<span class="main">-</span><span class="bound">it</span>"</span></span><span class="main"><span class="main">]</span></span>
           <span class="dynamic"><span class="dynamic">refine_vcg</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> αs_def αw_def αr_def dinvarm_def res_invarm_def infty_unbox
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
    <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The new pop function:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> 
    <span class="entity">mpop_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span> <span class="main">×</span> <span class="tfree">'W</span> infty <span class="main">×</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate<span class="main">)</span> nres"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mpop_min</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span> 
      <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">wl'</span><span class="main">)</span><span class="main">←</span>prio_pop_min <span class="bound">wl</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="main">(</span><span class="bound">wl'</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> mpop_min_refines<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="main">(</span><span class="free">σ</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">∈</span> build_rel αs dinvarm <span class="main">⟧</span> <span class="main">⟹</span> 
      mpop_min <span class="free">σ</span> <span class="main">≤</span> 
       <span class="main">⇓</span><span class="main">(</span>build_rel 
          <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span>αs <span class="bound">σ</span><span class="main">)</span><span class="main">)</span> 
          <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">.</span> dinvarm <span class="bound">σ</span> <span class="main">∧</span> <span class="bound">w</span> <span class="main">=</span> mpath_weight' <span class="main">(</span>snd <span class="bound">σ</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span>pop_min <span class="free">σ'</span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹The two algorithms are structurally different, so we use the
      nofail/inres method to prove refinement.›</span>
    <span class="keyword1"><span class="command">unfolding</span></span> mpop_min_def pop_min_def prio_pop_min_def

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> pw_ref_I<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> αs_def αw_def <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span>
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split prod.split_asm<span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dinvarm_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpath_weight'_correct wl_weight_correct<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wl_weight_correct 
      <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> least_map.intros
    <span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> restrict_map_eq<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The new update function:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">uinvarm</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> 
    uinvar <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">wl</span></span></span> <span class="free"><span class="bound"><span class="entity">res</span></span></span> <span class="free"><span class="bound"><span class="entity">it</span></span></span> <span class="main">(</span>αs <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">∧</span> dinvarm <span class="free"><span class="bound"><span class="entity">σ</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mupdate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'W</span> infty <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> mstate nres"</span></span>
   <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">mupdate</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>update_pre <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>αs <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">wv</span></span></span><span class="main">=</span>mpath_weight' <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pv</span> <span class="main">=</span> mpath' <span class="main">(</span><span class="bound">res</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">FOREACH<span class="hidden">⇗</span><sup></sup></span>uinvarm <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>αw <span class="bound">wl</span><span class="main">)</span> <span class="main">(</span>αr <span class="bound">res</span><span class="main">)</span><span class="main"><span class="hidden">⇖</span></span> <span class="main">(</span>succ <span class="free">G</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> 
        <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">+</span> Num <span class="bound">w'</span> <span class="main">&lt;</span> mpath_weight' <span class="main">(</span><span class="bound">res</span> <span class="bound">v'</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          ASSERT <span class="main">(</span><span class="bound">v'</span><span class="main">∈</span>dom <span class="bound">wl</span> <span class="main">∧</span> <span class="bound">pv</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">;</span>
          ASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">≠</span> Infty<span class="main">)</span><span class="main">;</span>
          RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">(</span><span class="bound">v'</span><span class="main">↦</span><span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">+</span> Num <span class="bound">w'</span><span class="main">)</span><span class="main">,</span>
                    <span class="bound">res</span><span class="main">(</span><span class="bound">v'</span> <span class="main">↦</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">#</span>the <span class="bound">pv</span><span class="main">,</span>val <span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">+</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">)</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
        <span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> mupdate_refines<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> SREF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span><span class="main">∈</span>build_rel αs dinvarm"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> WV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wv</span> <span class="main">=</span> mpath_weight' <span class="main">(</span>snd <span class="free">σ</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> VV'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v'</span><span class="main">=</span><span class="free">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mupdate <span class="free">v</span> <span class="free">wv</span> <span class="free">σ</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel αs dinvarm<span class="main">)</span> <span class="main">(</span>update' <span class="free">v'</span> <span class="free">σ'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> VV'<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹Show that IF-condition is a refinement:›</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">wl'</span> <span class="skolem">res'</span> <span class="skolem">it</span> <span class="skolem">w'</span> <span class="skolem">v'</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"uinvarm <span class="free">v</span> <span class="main">(</span>αw <span class="skolem">wl</span><span class="main">)</span> <span class="main">(</span>αr <span class="skolem">res</span><span class="main">)</span> <span class="skolem">it</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"dinvarm <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> mpath_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span> <span class="main">⟷</span>
        path_weight' <span class="main">(</span>αr <span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span>αr <span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> uinvarm_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpath_weight'_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> COND_refine<span class="main">=</span>this

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹THEN-case:›</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">wl</span> <span class="skolem">res</span> <span class="skolem">wl'</span> <span class="skolem">res'</span> <span class="skolem">it</span> <span class="skolem">w'</span> <span class="skolem">v'</span>
      <span class="keyword3"><span class="command">assume</span></span> UINV<span class="main">:</span> <span class="quoted"><span class="quoted">"uinvarm <span class="free">v</span> <span class="main">(</span>αw <span class="skolem">wl</span><span class="main">)</span> <span class="main">(</span>αr <span class="skolem">res</span><span class="main">)</span> <span class="skolem">it</span> <span class="main">(</span><span class="skolem">wl'</span><span class="main">,</span><span class="skolem">res'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> DINV<span class="main">:</span> <span class="quoted"><span class="quoted">"dinvarm <span class="main">(</span><span class="skolem">wl</span><span class="main">,</span><span class="skolem">res</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> mpath_weight' <span class="main">(</span><span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"path_weight' <span class="main">(</span>αr <span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span> <span class="main">&lt;</span> path_weight' <span class="main">(</span>αr <span class="skolem">res'</span> <span class="skolem">v'</span><span class="main">)</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> V'MEM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>αw <span class="skolem">wl'</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> NN<span class="main">:</span> <span class="quoted"><span class="quoted">"αr <span class="skolem">res</span> <span class="free">v</span> <span class="main">≠</span> None"</span></span>
    
      <span class="keyword1"><span class="command">from</span></span> NN <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pv</span></span> <span class="skolem"><span class="skolem">wv</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        ARV<span class="main">:</span> <span class="quoted"><span class="quoted">"αr <span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="main">(</span>rev <span class="skolem">pv</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        RV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">res</span> <span class="free">v</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">pv</span><span class="main">,</span><span class="skolem">wv</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> αr_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>

      <span class="keyword1"><span class="command">with</span></span> DINV <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">wv</span> <span class="main">=</span> path_weight <span class="main">(</span>rev <span class="skolem">pv</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> dinvarm_def res_invarm_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
      
      <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> ARV RV

      <span class="keyword1"><span class="command">from</span></span> V'MEM NN <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">∈</span>dom <span class="skolem">wl'</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G1</span>"</span></span><span class="main">)</span> 
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mpath' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">≠</span> None"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?G2</span>"</span></span><span class="main">)</span> 
        <span class="keyword1"><span class="command">unfolding</span></span> αw_def αr_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> αw <span class="skolem">wl'</span> <span class="main">=</span> αw <span class="main">(</span><span class="skolem">wl'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> αw_def<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpath' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">=</span> map_option rev <span class="main">(</span>αr <span class="skolem">res</span> <span class="free">v</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> DINV 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpath'_correct<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"αw <span class="skolem">wl'</span> <span class="main">=</span> αw <span class="main">(</span><span class="skolem">wl'</span><span class="main">(</span><span class="skolem">v'</span> <span class="main">↦</span> mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">∧</span> <span class="main">(</span>αr <span class="skolem">res'</span><span class="main">)</span><span class="main">(</span><span class="skolem">v'</span> <span class="main">↦</span> the <span class="main">(</span>αr <span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">@</span><span class="main">[</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> 
           <span class="main">=</span> αr <span class="main">(</span><span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span> <span class="main">↦</span> <span class="main">(</span><span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="skolem">w'</span><span class="main">,</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">#</span>the <span class="main">(</span>mpath' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                 val <span class="main">(</span>mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">w'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αr_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span>dinvarm <span class="main">(</span><span class="skolem">wl'</span><span class="main">(</span><span class="skolem">v'</span><span class="main">↦</span>mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span> <span class="main">+</span> Num <span class="skolem">w'</span><span class="main">)</span><span class="main">,</span>
                           <span class="skolem">res'</span><span class="main">(</span><span class="skolem">v'</span> <span class="main">↦</span> <span class="main">(</span><span class="main">(</span><span class="free">v</span><span class="main">,</span><span class="skolem">w'</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span> <span class="main">#</span> the <span class="main">(</span>mpath' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                       val <span class="main">(</span>mpath_weight' <span class="main">(</span><span class="skolem">res</span> <span class="free">v</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">w'</span>
                                      <span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G4</span></span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> UINV <span class="keyword1"><span class="command">unfolding</span></span> uinvarm_def dinvarm_def res_invarm_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_unbox <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split option.split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?G1</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?G2</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?G3</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="var">?G4</span>›</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> THEN_refine<span class="main">=</span>this


    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine2</span><span class="main">]</span> <span class="main">=</span> inj_on_id

    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mupdate <span class="free">v</span> <span class="free">wv</span> <span class="free">σ</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel αs dinvarm<span class="main">)</span> <span class="main">(</span>update' <span class="free">v</span> <span class="free">σ'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> SREF WV
      <span class="keyword1"><span class="command">unfolding</span></span> mupdate_def update'_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αs_def uinvarm_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αs_def COND_refine THEN_refine<span class="main"><span class="main">(</span></span>1-2<span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="main"><span class="keyword3">[</span></span>3<span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> THEN_refine<span class="main">(</span>3<span class="main">,</span>4<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> αs_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command">txt</span></span> <span class="quoted"><span class="plain_text">‹The ELSE-case is trivial:›</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we assemble the refined algorithm:›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mdijkstra</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mdijkstra</span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">σ0</span> <span class="main">←</span> mdinit<span class="main">;</span> 
      <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup></sup></span>dinvarm<span class="main"><span class="hidden">⇖</span></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> dom <span class="bound">wl</span><span class="main">≠</span><span class="main">{}</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">wv</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> mpop_min <span class="bound">σ</span><span class="main">;</span> mupdate <span class="bound">v</span> <span class="bound">wv</span> <span class="bound">σ'</span> <span class="main">}</span> <span class="main">)</span>
            <span class="bound">σ0</span><span class="main">;</span>
      RETURN <span class="bound">res</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> mdijkstra_refines<span class="main">:</span> <span class="quoted"><span class="quoted">"mdijkstra <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel αr res_invarm<span class="main">)</span> dijkstra'"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> mdinit_refines mpop_min_refines mupdate_refines
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> mdijkstra_def dijkstra'_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split
        <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αs_def αw_def dinvarm_def <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="GraphSpec">
<div class="head">
<h1>Theory GraphSpec</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Graph Interface"</span></span>
<span class="keyword1"><span class="command">theory</span></span> GraphSpec
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <a href="Graph.html">Graph</a> 
  <a href="../Collections/Collections.html">Collections.Collections</a> 
  <span class="comment1">(*"../Collections/Lib/Proper_Iterator"*)</span>
  <span class="comment1">(*"../Refine_Monadic/Refine_Autodet"*)</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    This theory defines an ICF-style interface for graphs.
›</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_α <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> finite<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> finite <span class="main">(</span>nodes <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> finite <span class="main">(</span>edges <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> valid_graph <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_empty <span class="main">=</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_empty <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> empty_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">(</span><span class="free">empty</span> <span class="main">()</span><span class="main">)</span> <span class="main">=</span> Graph.empty"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span><span class="free">empty</span> <span class="main">()</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_node <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_add_node <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">add_node</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> add_node_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">add_node</span> <span class="free">v</span> <span class="free">g</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="main">(</span><span class="free">add_node</span> <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> Graph.add_node <span class="free">v</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_delete_node <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_delete_node <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">delete_node</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> delete_node_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">delete_node</span> <span class="free">v</span> <span class="free">g</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="main">(</span><span class="free">delete_node</span> <span class="free">v</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> Graph.delete_node <span class="free">v</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_edge <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span><span class="tfree">'W</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_add_edge <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'W</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> add_edge_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">add_edge</span> <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="main">(</span><span class="free">add_edge</span> <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> Graph.add_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_delete_edge <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span><span class="tfree">'W</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_delete_edge <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">delete_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'W</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> delete_edge_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="free">delete_edge</span> <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">α</span> <span class="main">(</span><span class="free">delete_edge</span> <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> Graph.delete_edge <span class="free">v</span> <span class="free">e</span> <span class="free">v'</span> <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_nodes_it <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> set_iterator"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_nodes_it_defs <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">)</span> set_iterator"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nodes_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> it_to_it <span class="main">(</span><span class="free">nodes_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_nodes_it <span class="main">=</span> graph <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="main">+</span> graph_nodes_it_defs <span class="quoted"><span class="free">nodes_list_it</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">)</span> set_iterator"</span></span>
    <span class="main">+</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> nodes_list_it_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span><span class="free">nodes_list_it</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span>Graph.nodes <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> nodes_it_correct<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>nodes_it <span class="free">g</span><span class="main">)</span> <span class="main">(</span>Graph.nodes <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> nodes_it_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_correct<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nodes_list_it_correct<span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> pi_nodes_it<span class="main">[</span><span class="operator">icf_proper_iteratorI</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"proper_it <span class="main">(</span>nodes_it <span class="free">S</span><span class="main">)</span> <span class="main">(</span>nodes_it <span class="free">S</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> nodes_it_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> nodes_it_proper<span class="main">[</span><span class="operator">proper_it</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"proper_it' nodes_it nodes_it"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> proper_it'I<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pi_nodes_it<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it 
    <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> set_iterator"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_edges_it_defs <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">edges_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> it_to_it <span class="main">(</span><span class="free">edges_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_edges_it <span class="main">=</span> graph <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="main">+</span> graph_edges_it_defs <span class="quoted"><span class="free">edges_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="free">edges_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span> 
    <span class="main">+</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> edges_list_it_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span><span class="free">edges_list_it</span> <span class="free">g</span><span class="main">)</span> <span class="main">(</span>Graph.edges <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> edges_it_correct<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>edges_it <span class="free">g</span><span class="main">)</span> <span class="main">(</span>Graph.edges <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edges_it_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_correct<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> edges_list_it_correct<span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> pi_edges_it<span class="main">[</span><span class="operator">icf_proper_iteratorI</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"proper_it <span class="main">(</span>edges_it <span class="free">S</span><span class="main">)</span> <span class="main">(</span>edges_it <span class="free">S</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> edges_it_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> edges_it_proper<span class="main">[</span><span class="operator">proper_it</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"proper_it' edges_it edges_it"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> proper_it'I<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pi_edges_it<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_succ_it <span class="main">=</span> 
    <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'σ</span><span class="main">)</span> set_iterator"</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_succ_it_defs <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">)</span> set_iterator"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> it_to_it <span class="main">(</span><span class="free">succ_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> graph_succ_it <span class="main">=</span> graph <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="main">+</span> graph_succ_it_defs <span class="quoted"><span class="free">succ_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="free">succ_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">)</span> set_iterator"</span></span> <span class="main">+</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> succ_list_it_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span><span class="free">succ_list_it</span> <span class="free">g</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>Graph.succ <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> succ_it_correct<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>succ_it <span class="free">g</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>Graph.succ <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> succ_it_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_correct<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> succ_list_it_correct<span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> pi_succ_it<span class="main">[</span><span class="operator">icf_proper_iteratorI</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"proper_it <span class="main">(</span>succ_it <span class="free">S</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>succ_it <span class="free">S</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> succ_it_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span><span class="main">)</span>

    <span class="keyword1"><span class="command">lemma</span></span> succ_it_proper<span class="main">[</span><span class="operator">proper_it</span><span class="main">]</span><span class="main">:</span>
      <span class="quoted"><span class="quoted">"proper_it' <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> succ_it <span class="bound">S</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">S</span><span class="main">.</span> succ_it <span class="bound">S</span> <span class="free">v</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> proper_it'I<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> pi_succ_it<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Adjacency Lists"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'V</span> list <span class="main">×</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">adjl_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">adjl_α</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">nl</span><span class="main">,</span><span class="bound">el</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span> <span class="main">⦇</span>
      nodes <span class="main">=</span> set <span class="bound">nl</span> <span class="main">∪</span> fst<span class="main">`</span>set <span class="bound">el</span> <span class="main">∪</span> snd<span class="main">`</span>snd<span class="main">`</span>set <span class="bound">el</span><span class="main">,</span>
      edges <span class="main">=</span> set <span class="bound">el</span>
    <span class="main">⦈</span>"</span></span>

  <span class="comment1">(* TODO: Do we have naming conventions for such a lemma ? *)</span>
  <span class="keyword1"><span class="command">lemma</span></span> adjl_is_graph<span class="main">:</span> <span class="quoted"><span class="quoted">"graph adjl_α <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> adjl_α_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_from_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_from_list <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">from_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list <span class="main">⇒</span> <span class="tfree">'G</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> from_list_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">(</span><span class="free">from_list</span> <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">(</span><span class="free">from_list</span> <span class="free">l</span><span class="main">)</span> <span class="main">=</span> adjl_α <span class="free">l</span>"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_to_list <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list"</span></span>
  <span class="keyword1"><span class="command">locale</span></span> graph_to_list <span class="main">=</span> graph <span class="main">+</span>
    <span class="keyword2"><span class="keyword">constrains</span></span> α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">to_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> adj_list"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> to_list_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> adjl_α <span class="main">(</span><span class="free">to_list</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">α</span> <span class="free">g</span>"</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Record Based Interface›</span></span>
  <span class="keyword1"><span class="command">record</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_ops <span class="main">=</span>
    gop_α <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_α"</span></span>
    gop_invar <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> bool"</span></span>
    gop_empty <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_empty"</span></span>
    gop_add_node <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_node"</span></span>
    gop_delete_node <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_delete_node"</span></span>
    gop_add_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_edge"</span></span>
    gop_delete_edge <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_delete_edge"</span></span>
    gop_from_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_from_list"</span></span>
    gop_to_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_to_list"</span></span>
    gop_nodes_list_it <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">)</span> set_iterator"</span></span>
    gop_edges_list_it <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span>
    gop_succ_list_it <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">)</span> set_iterator"</span></span>    

  <span class="keyword1"><span class="command">locale</span></span> StdGraphDefs <span class="main">=</span> 
    graph_nodes_it_defs <span class="quoted"><span class="quoted">"gop_nodes_list_it <span class="free">ops</span>"</span></span>
    <span class="main">+</span> graph_edges_it_defs <span class="quoted"><span class="quoted">"gop_edges_list_it <span class="free">ops</span>"</span></span>
    <span class="main">+</span> graph_succ_it_defs <span class="quoted"><span class="quoted">"gop_succ_list_it <span class="free">ops</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">,</span><span class="tfree">'m</span><span class="main">)</span> graph_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">α</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">≡</span> gop_α <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">invar</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">≡</span> gop_invar <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">empty</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">empty</span> <span class="main">≡</span> gop_empty <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">add_node</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">add_node</span> <span class="main">≡</span> gop_add_node <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">delete_node</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">delete_node</span> <span class="main">≡</span> gop_delete_node <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">add_edge</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">add_edge</span> <span class="main">≡</span> gop_add_edge <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">delete_edge</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">delete_edge</span> <span class="main">≡</span> gop_delete_edge <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">from_list</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">from_list</span> <span class="main">≡</span> gop_from_list <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">to_list</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">to_list</span> <span class="main">≡</span> gop_to_list <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">nodes_list_it</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nodes_list_it</span> <span class="main">≡</span> gop_nodes_list_it <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">edges_list_it</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">edges_list_it</span> <span class="main">≡</span> gop_edges_list_it <span class="free">ops</span>"</span></span>
    <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">succ_list_it</span>  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ_list_it</span> <span class="main">≡</span> gop_succ_list_it <span class="free">ops</span>"</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> StdGraph <span class="main">=</span> StdGraphDefs <span class="main">+</span>
    graph <span class="quoted">α</span> <span class="quoted">invar</span> <span class="main">+</span>
    graph_empty <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">empty</span> <span class="main">+</span>
    graph_add_node <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">add_node</span> <span class="main">+</span>
    graph_delete_node <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">delete_node</span> <span class="main">+</span>
    graph_add_edge <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">add_edge</span> <span class="main">+</span>
    graph_delete_edge <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">delete_edge</span> <span class="main">+</span>
    graph_from_list <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">from_list</span> <span class="main">+</span>
    graph_to_list <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">to_list</span> <span class="main">+</span>
    graph_nodes_it <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">nodes_list_it</span> <span class="main">+</span>
    graph_edges_it <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">edges_list_it</span> <span class="main">+</span>
    graph_succ_it <span class="quoted">α</span> <span class="quoted">invar</span> <span class="quoted">succ_list_it</span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">lemmas</span></span> correct <span class="main">=</span> empty_correct add_node_correct delete_node_correct 
      add_edge_correct delete_edge_correct
      from_list_correct to_list_correct 

  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement Framework Bindings›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph_nodes_it<span class="main">)</span> nodes_it_is_iterator<span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>nodes_it <span class="free">g</span><span class="main">)</span> <span class="main">(</span>nodes <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nodes_it_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph_edges_it<span class="main">)</span> edges_it_is_iterator<span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>edges_it <span class="free">g</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> edges_it_correct<span class="main">)</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph_succ_it<span class="main">)</span> succ_it_is_iterator<span class="main">[</span><span class="operator">refine_transfer</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="free">g</span> <span class="main">⟹</span> set_iterator <span class="main">(</span>succ_it <span class="free">g</span> <span class="free">v</span><span class="main">)</span> <span class="main">(</span>Graph.succ <span class="main">(</span><span class="free">α</span> <span class="free">g</span><span class="main">)</span> <span class="free">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> succ_it_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph<span class="main">)</span> drh<span class="main">[</span><span class="operator">refine_dref_RELATES</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"RELATES <span class="main">(</span>build_rel <span class="free">α</span> <span class="free">invar</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> RELATES_def<span class="main">)</span>

  <span class="comment1">(*text {* Autodet bindings: *}

  lemma (in graph_nodes_it) graph_nodes_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ 
      set_iterator (nodes_it g) (nodes g')"
    using nodes_it_correct by auto

  lemma (in graph_succ_it) graph_succ_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ DETREFe v Id v' ⟹
      set_iterator (succ_it g v) (succ g' v')"
    using succ_it_correct by auto

  lemma (in graph_edges_it) graph_edges_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ 
      set_iterator (edges_it g) (edges g')"
    using edges_it_correct by auto*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="GraphGA">
<div class="head">
<h1>Theory GraphGA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generic Algorithms for Graphs›</span></span>
<span class="keyword1"><span class="command">theory</span></span> GraphGA
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="GraphSpec.html">GraphSpec</a> 
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gga_from_list</span> <span class="main">::</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_empty <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_node 
      <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_add_edge 
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_from_list"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">gga_from_list</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">nl</span><span class="main">,</span><span class="bound">el</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span>
        <span class="bound">g1</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">v</span> <span class="bound">g</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">()</span><span class="main">)</span> <span class="bound">nl</span>
      <span class="keyword1">in</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="bound">v</span> <span class="bound">e</span> <span class="bound">v'</span> <span class="bound">g</span><span class="main">)</span> <span class="bound">g1</span> <span class="bound">el</span>"</span></span>
  
  <span class="keyword1"><span class="command">lemma</span></span> gga_from_list_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_empty <span class="free">α</span> <span class="free">invar</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_add_node <span class="free">α</span> <span class="free">invar</span> <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"graph_add_edge <span class="free">α</span> <span class="free">invar</span> <span class="free">u</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_from_list <span class="free">α</span> <span class="free">invar</span> <span class="main">(</span>gga_from_list <span class="free">e</span> <span class="free">a</span> <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> 
      graph_empty <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">e</span></span> <span class="main">+</span> 
      graph_add_node <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">a</span></span> <span class="main">+</span> 
      graph_add_edge <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">u</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">nl</span> <span class="skolem">el</span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">g1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g1</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="bound">v</span><span class="main">.</span> <span class="free">a</span> <span class="bound">v</span> <span class="bound">g</span><span class="main">)</span> <span class="main">(</span><span class="free">e</span> <span class="main">()</span><span class="main">)</span> <span class="skolem">nl</span>"</span></span>
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">g2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g2</span> <span class="main">=</span> foldl <span class="main">(</span><span class="main">λ</span><span class="bound">g</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">.</span> <span class="free">u</span> <span class="bound">v</span> <span class="bound">e</span> <span class="bound">v'</span> <span class="bound">g</span><span class="main">)</span> <span class="skolem">g1</span> <span class="skolem">el</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">g1</span> <span class="main">∧</span> <span class="free">α</span> <span class="skolem">g1</span> <span class="main">=</span> <span class="main">⦇</span> nodes <span class="main">=</span> set <span class="skolem">nl</span><span class="main">,</span> edges <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> g1_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">nl</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span>
           <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> empty_correct add_node_correct empty_def add_node_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">g2</span> 
        <span class="main">∧</span> <span class="free">α</span> <span class="skolem">g2</span> <span class="main">=</span> <span class="main">⦇</span> nodes <span class="main">=</span> set <span class="skolem">nl</span> <span class="main">∪</span> fst<span class="main">`</span>set <span class="skolem">el</span> <span class="main">∪</span> snd<span class="main">`</span>snd<span class="main">`</span>set <span class="skolem">el</span><span class="main">,</span>
                    edges <span class="main">=</span> set <span class="skolem">el</span> <span class="main">⦈</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> g2_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">el</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> add_edge_correct add_edge_def<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">g2</span> <span class="main">∧</span> adjl_α <span class="main">(</span><span class="skolem">nl</span><span class="main">,</span><span class="skolem">el</span><span class="main">)</span> <span class="main">=</span> <span class="free">α</span> <span class="skolem">g2</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> adjl_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gga_from_list_def <span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
      
  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">map_iterator_product</span>


  <span class="keyword1"><span class="command">locale</span></span> gga_edges_it_defs <span class="main">=</span>
    graph_nodes_it_defs <span class="quoted"><span class="free">nodes_list_it</span></span> <span class="main">+</span>
    graph_succ_it_defs <span class="quoted"><span class="free">succ_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_nodes_it"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">succ_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_succ_it"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gga_edges_list_it</span> <span class="main">::</span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">gga_edges_list_it</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">≡</span> set_iterator_product 
        <span class="main">(</span>nodes_it <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span> <span class="main">(</span>succ_it <span class="free"><span class="bound"><span class="entity">G</span></span></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Locale_Code.lc_decl_del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">gga_edges_list_it</span><span class="antiquote">}</span></span>›</span>
  <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
    <span class="main">(</span><span class="entity">Record_Intf.add_unf_thms_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> 
      gga_edges_it_defs.gga_edges_list_it_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
    <span class="antiquote">}</span></span></span><span class="main">)</span>
›</span> 

  <span class="keyword1"><span class="command">locale</span></span> gga_edges_it <span class="main">=</span> gga_edges_it_defs <span class="quoted"><span class="free">nodes_list_it</span></span> <span class="quoted"><span class="free">succ_list_it</span></span> 
    <span class="main">+</span> graph <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span>
    <span class="main">+</span> graph_nodes_it <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">nodes_list_it</span></span>
    <span class="main">+</span> graph_succ_it <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">succ_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_nodes_it"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">succ_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_succ_it"</span></span>  
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">lemma</span></span> gga_edges_list_it_impl<span class="main">:</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_edges_it <span class="free">α</span> <span class="free">invar</span> gga_edges_list_it"</span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
      <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">g</span>"</span></span>

      <span class="keyword1"><span class="command">from</span></span> set_iterator_product_correct<span class="main">[</span><span class="operator">OF</span> 
        nodes_it_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">]</span></span> succ_it_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>set_iterator_product <span class="main">(</span>nodes_it <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> succ_it <span class="skolem">g</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="keyword1">SIGMA</span> <span class="bound">v</span><span class="main">:</span>nodes <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span><span class="main">.</span> succ <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span> <span class="bound">v</span><span class="main">)</span>
        "</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">SIGMA</span> <span class="bound">v</span><span class="main">:</span>nodes <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span><span class="main">.</span> succ <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span> <span class="bound">v</span><span class="main">)</span> <span class="main">=</span> edges <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> succ_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> valid_graph.E_validD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> valid<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator"><span class="operator">OF</span></span> INV<span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>gga_edges_list_it <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span><span class="free">α</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> gga_edges_list_it_def <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> gga_to_list_defs_loc <span class="main">=</span> 
    graph_nodes_it_defs <span class="quoted"><span class="free">nodes_list_it</span></span>
    <span class="main">+</span> graph_edges_it_defs <span class="quoted"><span class="free">edges_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_nodes_it"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">edges_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span>  
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gga_to_list</span> <span class="main">::</span> 
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_to_list"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">gga_to_list</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> 
        <span class="main">(</span>nodes_it <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(#)</span> <span class="main">[]</span><span class="main">,</span> edges_it <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(#)</span> <span class="main">[]</span><span class="main">)</span>
      "</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> gga_to_list_loc <span class="main">=</span> gga_to_list_defs_loc <span class="quoted"><span class="free">nodes_list_it</span></span> <span class="quoted"><span class="free">edges_list_it</span></span> <span class="main">+</span>
    graph <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> 
    <span class="main">+</span> graph_nodes_it <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">nodes_list_it</span></span>
    <span class="main">+</span> graph_edges_it <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">invar</span></span> <span class="quoted"><span class="free">edges_list_it</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="free">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">invar</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">nodes_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_nodes_it"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">edges_list_it</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'G</span><span class="main">)</span> graph_edges_it"</span></span>  
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> gga_to_list_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_to_list <span class="free">α</span> <span class="free">invar</span> gga_to_list"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> 
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">g</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> valid_graph <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> valid<span class="main">)</span>

      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>nodes_it <span class="skolem">g</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(#)</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> V"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">σ</span><span class="main">.</span> set <span class="bound">σ</span> <span class="main">=</span> V <span class="main">-</span> <span class="bound">it</span>"</span></span> 
          <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> set_iterator_rule_P<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nodes_it_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>edges_it <span class="skolem">g</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(#)</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> E"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">it</span> <span class="bound">σ</span><span class="main">.</span> set <span class="bound">σ</span> <span class="main">=</span> E <span class="main">-</span> <span class="bound">it</span>"</span></span> 
          <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> set_iterator_rule_P<span class="main"><span class="main">[</span></span><span class="operator">OF</span> edges_it_correct<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"adjl_α <span class="main">(</span>gga_to_list <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">α</span> <span class="skolem">g</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> adjl_α_def gga_to_list_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> graph.equality<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> E_validD<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="GraphByMap">
<div class="head">
<h1>Theory GraphByMap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementing Graphs by Maps›</span></span>
<span class="keyword1"><span class="command">theory</span></span> GraphByMap
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="GraphSpec.html">GraphSpec</a> 
  <a href="GraphGA.html">GraphGA</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_Sigma</span> <span class="free"><span class="bound"><span class="entity">M1</span></span></span> <span class="free"><span class="bound"><span class="entity">F2</span></span></span> <span class="main">≡</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">v</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">M1</span></span></span> <span class="bound">x</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">∧</span> <span class="bound">y</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">F2</span></span></span> <span class="bound">v</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> map_Sigma_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"map_Sigma <span class="free">M1</span> <span class="free">F2</span> <span class="main">=</span> Sigma <span class="main">(</span>dom <span class="free">M1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span>
  <span class="free">F2</span> <span class="main">(</span>the <span class="main">(</span><span class="free">M1</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> map_Sigma_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="comment1">(* TODO: Move to Misc *)</span>
<span class="keyword1"><span class="command">lemma</span></span> ranE<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span><span class="main">∈</span>ran <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ran_restrictD restrict_map_self<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> option_bind_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Option.bind <span class="free">x</span> <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> GraphByMapDefs <span class="main">=</span> 
  m1<span class="main">:</span> StdMapDefs <span class="quoted"><span class="free">m1_ops</span></span> <span class="main">+</span>
  m2<span class="main">:</span> StdMapDefs <span class="quoted"><span class="free">m2_ops</span></span> <span class="main">+</span>
  s3<span class="main">:</span> StdSetDefs <span class="quoted"><span class="free">s3_ops</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m1_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'m2</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m2_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'s3</span><span class="main">,</span><span class="tfree">'m2</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s3_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'s3</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> set_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m1_mvif</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'m2</span> <span class="main">⇀</span> <span class="tfree">'m2</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_α"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_α</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="main">≡</span>
    <span class="main">⦇</span> nodes <span class="main">=</span> dom <span class="main">(</span>m1.α <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span><span class="main">,</span>
      edges <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">.</span> 
        <span class="main">∃</span><span class="bound">m2</span> <span class="bound">s3</span><span class="main">.</span> m1.α <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">m2</span> 
          <span class="main">∧</span> m2.α <span class="bound">m2</span> <span class="bound">v'</span> <span class="main">=</span> Some <span class="bound">s3</span>
          <span class="main">∧</span> <span class="bound">w</span><span class="main">∈</span>s3.α <span class="bound">s3</span>
      <span class="main">}</span>
    <span class="main">⦈</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">gbm_invar</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="main">≡</span>
    m1.invar <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">m2</span><span class="main">∈</span>ran <span class="main">(</span>m1.α <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span><span class="main">.</span> m2.invar <span class="bound">m2</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">s3</span><span class="main">∈</span>ran <span class="main">(</span>m2.α <span class="bound">m2</span><span class="main">)</span><span class="main">.</span> s3.invar <span class="bound">s3</span><span class="main">)</span>
    <span class="main">)</span> <span class="main">∧</span> valid_graph <span class="main">(</span>gbm_α <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_empty"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">gbm_empty</span> <span class="main">≡</span> m1.empty"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_add_node</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_add_node"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_add_node</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> m1.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> m1.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>m2.empty <span class="main">()</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">|</span>
    Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_delete_node</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_delete_node"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_delete_node</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">g</span><span class="main">=</span>m1.delete <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">in</span>
    <span class="free">m1_mvif</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">m2</span><span class="main">.</span> Some <span class="main">(</span>m2.delete <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">m2</span><span class="main">)</span><span class="main">)</span> <span class="bound">g</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_add_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_add_edge"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_add_edge</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> 
    <span class="keyword1">let</span> <span class="bound">g</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> m1.lookup <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> m1.update <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">(</span>m2.empty <span class="main">()</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">|</span> Some <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>
    <span class="main">)</span> <span class="keyword1">in</span>
    <span class="keyword1">case</span> m1.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">g</span> <span class="keyword1">of</span> 
      None <span class="main">⇒</span> <span class="main">(</span>m1.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>m2.sng <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">(</span>s3.sng <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span> <span class="main">|</span>
      Some <span class="bound">m2</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> m2.lookup <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="bound">m2</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> m1.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>m2.update <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">(</span>s3.sng <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="bound">m2</span><span class="main">)</span> <span class="bound">g</span> <span class="main">|</span>
        Some <span class="bound">s3</span> <span class="main">⇒</span> m1.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>m2.update <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">(</span>s3.ins <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="bound">s3</span><span class="main">)</span> <span class="bound">m2</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>
    "</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_delete_edge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_delete_edge"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_delete_edge</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span>
    <span class="keyword1">case</span> m1.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">|</span>
      Some <span class="bound">m2</span> <span class="main">⇒</span> <span class="main">(</span>
        <span class="keyword1">case</span> m2.lookup <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="bound">m2</span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">|</span>
          Some <span class="bound">s3</span> <span class="main">⇒</span> m1.update <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">(</span>m2.update <span class="free"><span class="bound"><span class="entity">v'</span></span></span> <span class="main">(</span>s3.delete <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="bound">s3</span><span class="main">)</span> <span class="bound">m2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span>
      <span class="main">)</span>
    "</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_nodes_list_it</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'V</span> list<span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_nodes_it"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_nodes_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> map_iterator_dom <span class="main">(</span>m1.iteratei <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Locale_Code.lc_decl_del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">gbm_nodes_list_it</span><span class="antiquote">}</span></span>›</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_edges_list_it</span> 
    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_edges_it"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">gbm_edges_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> set_iterator_image 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">v1</span><span class="main">,</span><span class="bound">m1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">v2</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v1</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">(</span>set_iterator_product <span class="main">(</span>m1.iteratei <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">.</span> set_iterator_product 
          <span class="main">(</span>m2.iteratei <span class="bound">m2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">s3</span><span class="main">)</span><span class="main">.</span> s3.iteratei <span class="bound">s3</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    "</span></span>
  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Locale_Code.lc_decl_del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">gbm_edges_list_it</span><span class="antiquote">}</span></span>›</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">gbm_succ_list_it</span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">,</span><span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list<span class="main">,</span><span class="tfree">'m1</span><span class="main">)</span> graph_succ_it"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">gbm_succ_list_it</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> m1.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> set_iterator_emp <span class="main">|</span>
    Some <span class="bound">m2</span> <span class="main">⇒</span> 
      set_iterator_image <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">(</span>set_iterator_product <span class="main">(</span>m2.iteratei <span class="bound">m2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> s3.iteratei <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
    "</span></span>
  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Locale_Code.lc_decl_del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">gbm_succ_list_it</span><span class="antiquote">}</span></span>›</span>

  <span class="keyword1"><span class="command">definition</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">gbm_from_list</span> <span class="main">≡</span> gga_from_list gbm_empty gbm_add_node gbm_add_edge"</span></span>


  <span class="keyword1"><span class="command">lemma</span></span> gbm_nodes_list_it_unf<span class="main">:</span>
    <span class="quoted"><span class="quoted">"it_to_it <span class="main">(</span>gbm_nodes_list_it <span class="free">g</span><span class="main">)</span> 
    <span class="main">≡</span> map_iterator_dom <span class="main">(</span>it_to_it <span class="main">(</span>m1.list_it <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_fold<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_nodes_list_it_def m1.iteratei_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_edges_list_it_unf<span class="main">:</span>
    <span class="quoted"><span class="quoted">"it_to_it <span class="main">(</span>gbm_edges_list_it <span class="free">g</span><span class="main">)</span> 
    <span class="main">≡</span> set_iterator_image 
      <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">v1</span><span class="main">,</span><span class="bound">m1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">v2</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v1</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v2</span><span class="main">)</span><span class="main">)</span> 
      <span class="main">(</span>set_iterator_product <span class="main">(</span>it_to_it <span class="main">(</span>m1.list_it <span class="free">g</span><span class="main">)</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">.</span> set_iterator_product 
          <span class="main">(</span>it_to_it <span class="main">(</span>m2.list_it <span class="bound">m2</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">s3</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>it_to_it <span class="main">(</span>s3.list_it <span class="bound">s3</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    "</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_fold<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_edges_list_it_def 
      m1.iteratei_def m2.iteratei_def s3.iteratei_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span> allI impI<span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_succ_list_it_unf<span class="main">:</span>
  <span class="quoted"><span class="quoted">"it_to_it <span class="main">(</span>gbm_succ_list_it <span class="free">g</span> <span class="free">v</span><span class="main">)</span> <span class="main">≡</span> 
    <span class="keyword1">case</span> m1.lookup <span class="free">v</span> <span class="free">g</span> <span class="keyword1">of</span>
      None <span class="main">⇒</span> set_iterator_emp <span class="main">|</span>
      Some <span class="bound">m2</span> <span class="main">⇒</span> 
        set_iterator_image <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">)</span> 
          <span class="main">(</span>set_iterator_product <span class="main">(</span>it_to_it <span class="main">(</span>m2.list_it <span class="bound">m2</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>it_to_it <span class="main">(</span>s3.list_it <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      "</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eq_reflection<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> it_to_it_fold<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_succ_list_it_def 
      m2.iteratei_def s3.iteratei_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic"><span class="dynamic">icf_proper_iteratorI</span></span> allI impI conjI<span class="main"><span class="keyword3">,</span></span> 
      <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split option.split<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> GraphByMapDefs <span class="main">&lt;</span> graph_nodes_it_defs <span class="quoted">gbm_nodes_list_it</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> GraphByMapDefs <span class="main">&lt;</span> graph_edges_it_defs <span class="quoted">gbm_edges_list_it</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> GraphByMapDefs <span class="main">&lt;</span> graph_succ_it_defs <span class="quoted">gbm_succ_list_it</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> GraphByMapDefs 
  <span class="main">&lt;</span> gga_to_list_defs_loc <span class="quoted">gbm_nodes_list_it</span> <span class="quoted">gbm_edges_list_it</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span> GraphByMapDefs
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">icf_rec_def</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">gbm_ops</span> <span class="main">≡</span> <span class="main">⦇</span>
    gop_α <span class="main">=</span> gbm_α<span class="main">,</span>
    gop_invar <span class="main">=</span> gbm_invar<span class="main">,</span>
    gop_empty <span class="main">=</span> gbm_empty<span class="main">,</span>
    gop_add_node <span class="main">=</span> gbm_add_node<span class="main">,</span>
    gop_delete_node <span class="main">=</span> gbm_delete_node<span class="main">,</span>
    gop_add_edge <span class="main">=</span> gbm_add_edge<span class="main">,</span>
    gop_delete_edge <span class="main">=</span> gbm_delete_edge<span class="main">,</span>
    gop_from_list <span class="main">=</span> gbm_from_list<span class="main">,</span>
    gop_to_list <span class="main">=</span> gga_to_list<span class="main">,</span>
    gop_nodes_list_it <span class="main">=</span> gbm_nodes_list_it<span class="main">,</span>
    gop_edges_list_it <span class="main">=</span> gbm_edges_list_it<span class="main">,</span>
    gop_succ_list_it  <span class="main">=</span> gbm_succ_list_it
    <span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">local_setup</span></span> <span class="quoted">‹<span class="entity">Locale_Code.lc_decl_del</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">gbm_ops</span><span class="antiquote">}</span></span>›</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> GraphByMap <span class="main">=</span> GraphByMapDefs <span class="quoted"><span class="free">m1_ops</span></span> <span class="quoted"><span class="free">m2_ops</span></span> <span class="quoted"><span class="free">s3_ops</span></span> <span class="quoted"><span class="free">m1_mvif</span></span> <span class="main">+</span>
  m1<span class="main">:</span> StdMap <span class="quoted"><span class="free">m1_ops</span></span> <span class="main">+</span>
  m2<span class="main">:</span> StdMap <span class="quoted"><span class="free">m2_ops</span></span> <span class="main">+</span>
  s3<span class="main">:</span> StdSet <span class="quoted"><span class="free">s3_ops</span></span> <span class="main">+</span>
  m1<span class="main">:</span> map_value_image_filter <span class="quoted">m1.α</span> <span class="quoted">m1.invar</span> <span class="quoted">m1.α</span> <span class="quoted">m1.invar</span> <span class="quoted"><span class="free">m1_mvif</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m1_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'m2</span><span class="main">,</span><span class="tfree">'m1</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m2_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'s3</span><span class="main">,</span><span class="tfree">'m2</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">s3_ops</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'W</span><span class="main">,</span><span class="tfree">'s3</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> set_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m1_mvif</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'m2</span> <span class="main">⇀</span> <span class="tfree">'m2</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m1</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> gbm_invar_split<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="free">g</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"m1.invar <span class="free">g</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">m2</span><span class="main">.</span> m1.α <span class="free">g</span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">m2</span> <span class="main">⟹</span> m2.invar <span class="bound">m2</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">m2</span> <span class="bound">v'</span> <span class="bound">s3</span><span class="main">.</span> m1.α <span class="free">g</span> <span class="bound">v</span> <span class="main">=</span> Some <span class="bound">m2</span> <span class="main">⟹</span> m2.α <span class="bound">m2</span> <span class="bound">v'</span> <span class="main">=</span> Some <span class="bound">s3</span> <span class="main">⟹</span> s3.invar <span class="bound">s3</span>"</span></span>
    <span class="quoted"><span class="quoted">"valid_graph <span class="main">(</span>gbm_α <span class="free">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ranI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> GraphByMap <span class="main">&lt;</span> graph <span class="quoted">gbm_α</span> <span class="quoted">gbm_invar</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
  <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> vg<span class="main">:</span> valid_graph <span class="quoted"><span class="quoted">"<span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gbm_invar_def<span class="main">)</span>
  
  <span class="keyword1"><span class="command">from</span></span> vg.E_valid
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fst <span class="main">`</span> edges <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span> <span class="main">⊆</span> nodes <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"snd <span class="main">`</span> snd <span class="main">`</span> edges <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span> <span class="main">⊆</span> nodes <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nodes <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def gbm_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>edges <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_imageD<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">e</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span>
      <span class="quoted"><span class="quoted">"map_Sigma <span class="main">(</span>m1.α <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m2</span><span class="main">.</span> map_Sigma <span class="main">(</span>m2.α <span class="bound">m2</span><span class="main">)</span> <span class="main">(</span>s3.α<span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_Sigma_def gbm_α_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> map_Sigma_alt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_SigmaI inj_onI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span> GraphByMap
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_empty_impl<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"graph_empty gbm_α gbm_invar gbm_empty"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_invar_def gbm_empty_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct Graph.empty_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_add_node_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"graph_add_node gbm_α gbm_invar gbm_add_node"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">=</span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"gbm_α <span class="main">(</span>gbm_add_node <span class="skolem">v</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> add_node <span class="skolem">v</span> <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_add_node_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct add_node_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm<span class="main">)</span>
    
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="main">(</span>gbm_add_node <span class="skolem">v</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_add_node_def add_node_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct add_node_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ranE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_delete_node_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"graph_delete_node gbm_α gbm_invar gbm_delete_node"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">=</span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"gbm_α <span class="main">(</span>gbm_delete_node <span class="skolem">v</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> delete_node <span class="skolem">v</span> <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_delete_node_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restrict_map_def option_bind_alt
        m1.correct m2.correct s3.correct m1.map_value_image_filter_correct
        delete_node_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm option.split_asm<span class="main">)</span>

    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="main">(</span>gbm_delete_node <span class="skolem">v</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_delete_node_def delete_node_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> restrict_map_def option_bind_alt
        m1.correct m2.correct s3.correct m1.map_value_image_filter_correct
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm option.split_asm <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ranE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_add_edge_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"graph_add_edge gbm_α gbm_invar gbm_add_edge"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">=</span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"gbm_α <span class="main">(</span>gbm_add_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> add_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_add_edge_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct 
        Let_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> add_edge_def
      <span class="comment1">(* Strange: This is at the limit of auto's capabilities:
        Iterated auto [] works., but auto on all goals seems not to
        terminate. Using fastforce instead.
        *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct 
      <span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="main">(</span>gbm_add_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_add_edge_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct
        Let_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ranE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_delete_edge_impl<span class="main">:</span>
    <span class="quoted"><span class="quoted">"graph_delete_edge gbm_α gbm_invar gbm_delete_edge"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">=</span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"gbm_α <span class="main">(</span>gbm_delete_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> delete_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_delete_edge_def delete_edge_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct 
        Let_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="main">(</span>gbm_delete_edge <span class="skolem">v</span> <span class="skolem">e</span> <span class="skolem">v'</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_α_def gbm_delete_edge_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.correct m2.correct s3.correct
        Let_def
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split if_split_asm <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ranE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_nodes_list_it_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_nodes_it gbm_α gbm_invar gbm_nodes_list_it"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> MINV<span class="main">:</span> <span class="quoted"><span class="quoted">"map_op_invar <span class="free">m1_ops</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> map_iterator_dom_correct<span class="main">[</span><span class="operator">OF</span> m1.iteratei_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> MINV<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>gbm_nodes_list_it <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span>nodes <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_nodes_list_it_def gbm_α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> gbm_edges_list_it_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_edges_it gbm_α gbm_invar gbm_edges_list_it"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>

    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> I1<span class="main">:</span> <span class="quoted"><span class="quoted">"m1.invar <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> I2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">m2</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">∈</span>map_to_set <span class="main">(</span>m1.α <span class="skolem">g</span><span class="main">)</span> <span class="main">⟹</span> m2.invar <span class="bound">m2</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def map_to_set_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> INV <span class="keyword1"><span class="command">have</span></span> I3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">m2</span> <span class="bound">v'</span> <span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span>
      <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">m2</span><span class="main">)</span><span class="main">∈</span>map_to_set <span class="main">(</span>m1.α <span class="skolem">g</span><span class="main">)</span><span class="main">;</span> 
      <span class="main">(</span><span class="bound">v'</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span>map_to_set <span class="main">(</span>m2.α <span class="bound">m2</span><span class="main">)</span><span class="main">⟧</span> 
      <span class="main">⟹</span> s3.invar <span class="bound">s</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def map_to_set_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main">)</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>gbm_edges_list_it <span class="skolem">g</span><span class="main">)</span> <span class="main">(</span>edges <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> gbm_edges_list_it_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_iterator_image_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_iterator_product_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> m1.iteratei_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> I1<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_iterator_product_correct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> I2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"map_iterator <span class="main">(</span>m2.iteratei <span class="improper">ba</span><span class="main">)</span> 
        <span class="main">(</span>map_op_α <span class="free">m2_ops</span> <span class="main">(</span>snd <span class="main">(</span><span class="improper">aa</span><span class="main">,</span><span class="improper">ba</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m2.iteratei_correct<span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>s3.iteratei <span class="improper">bb</span><span class="main">)</span> 
        <span class="main">(</span>s3.α <span class="main">(</span>snd <span class="main">(</span><span class="improper">ab</span><span class="main">,</span><span class="improper">bb</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> s3.iteratei_correct I3<span class="main">)</span>
      
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inj_on_def map_to_set_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> gbm_α_def map_to_set_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_succ_list_it_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_succ_it gbm_α gbm_invar gbm_succ_list_it"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">g</span> <span class="skolem">v</span>
    <span class="keyword3"><span class="command">assume</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"gbm_invar <span class="skolem">g</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> I1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"m1.invar <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>gbm_succ_list_it <span class="skolem">g</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">(</span>succ <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"m1.lookup <span class="skolem">v</span> <span class="skolem">g</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>succ <span class="main">(</span>gbm_α <span class="skolem">g</span><span class="main">)</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> succ_def gbm_α_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> m1.lookup_correct<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> None <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> gbm_succ_list_it_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_iterator_emp_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">m2</span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"m2.invar <span class="skolem">m2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> gbm_invar_split<span class="main">[</span><span class="operator">OF</span> INV<span class="main">]</span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m1.lookup_correct<span class="main">)</span>

      <span class="keyword1"><span class="command">from</span></span> INV Some <span class="keyword1"><span class="command">have</span></span> 
        I2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v'</span> <span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="bound">v'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> map_to_set <span class="main">(</span>map_op_α <span class="free">m2_ops</span> <span class="skolem">m2</span><span class="main">)</span> <span class="main">⟹</span> s3.invar <span class="bound">s</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> gbm_invar_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_to_set_def ran_def m1.lookup_correct<span class="main">)</span>
      
      <span class="keyword1"><span class="command">from</span></span> Some <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> gbm_succ_list_it_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_iterator_image_correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> set_iterator_product_correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> m2.iteratei_correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"set_iterator <span class="main">(</span>s3.iteratei <span class="improper">b</span><span class="main">)</span> <span class="main">(</span>s3.α <span class="main">(</span>snd <span class="main">(</span><span class="improper">aa</span><span class="main">,</span> <span class="improper">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> s3.iteratei_correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I2<span class="main">)</span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inj_on_def map_to_set_def<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>

        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> succ_def gbm_α_def map_to_set_def m1.lookup_correct<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
    
  <span class="keyword1"><span class="command">lemma</span></span> gbm_from_list_impl<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"graph_from_list gbm_α gbm_invar gbm_from_list"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> gbm_from_list_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gga_from_list_correct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gbm_empty_impl gbm_add_node_impl gbm_add_edge_impl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">sublocale</span></span> GraphByMap <span class="main">&lt;</span> graph_nodes_it <span class="quoted">gbm_α</span> <span class="quoted">gbm_invar</span> <span class="quoted">gbm_nodes_list_it</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gbm_nodes_list_it_impl<span class="main">)</span>
<span class="keyword1"><span class="command">sublocale</span></span> GraphByMap <span class="main">&lt;</span> graph_edges_it <span class="quoted">gbm_α</span> <span class="quoted">gbm_invar</span> <span class="quoted">gbm_edges_list_it</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gbm_edges_list_it_impl<span class="main">)</span>
<span class="keyword1"><span class="command">sublocale</span></span> GraphByMap <span class="main">&lt;</span> graph_succ_it <span class="quoted">gbm_α</span> <span class="quoted">gbm_invar</span> <span class="quoted">gbm_succ_list_it</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gbm_succ_list_it_impl<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> GraphByMap
  <span class="main">&lt;</span> gga_to_list_loc <span class="quoted">gbm_α</span> <span class="quoted">gbm_invar</span> <span class="quoted">gbm_nodes_list_it</span> <span class="quoted">gbm_edges_list_it</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1"><span class="command">context</span></span> GraphByMap
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> gbm_to_list_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"graph_to_list gbm_α gbm_invar gga_to_list"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> gga_to_list_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> gbm_ops_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"StdGraph gbm_ops"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> StdGraph.intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">icf_rec_unf</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">icf_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> gbm_empty_impl gbm_add_node_impl gbm_delete_node_impl 
      gbm_add_edge_impl gbm_delete_edge_impl gbm_from_list_impl
      gbm_to_list_impl<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  <span class="main">(</span><span class="entity">Record_Intf.add_unf_thms_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> 
    GraphByMapDefs.gbm_nodes_list_it_unf
    GraphByMapDefs.gbm_edges_list_it_unf
    GraphByMapDefs.gbm_succ_list_it_unf
  <span class="antiquote">}</span></span></span><span class="main">)</span>
›</span> 
   
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="HashGraphImpl">
<div class="head">
<h1>Theory HashGraphImpl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Graphs by Hashmaps›</span></span>
<span class="keyword1"><span class="command">theory</span></span> HashGraphImpl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="GraphByMap.html">GraphByMap</a> 
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Abbreviation: hlg
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'E</span><span class="main">)</span> hlg <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'E</span> ls<span class="main">)</span> HashMap.hashmap<span class="main">)</span> HashMap.hashmap"</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.open_block</span>
<span class="keyword1"><span class="command">interpretation</span></span> hh_mvif<span class="main">:</span> g_value_image_filter_loc <span class="quoted">hm_ops</span> <span class="quoted">hm_ops</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">interpretation</span></span> hlg_gbm<span class="main">:</span> GraphByMap <span class="quoted">hm_ops</span> <span class="quoted">hm_ops</span> <span class="quoted">ls_ops</span> 
  <span class="quoted"><span class="quoted">"hh_mvif.g_value_image_filter"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.close_block</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">icf_rec_def</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">hlg_ops</span> <span class="main">≡</span> hlg_gbm.gbm_ops"</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.open_block</span>
<span class="keyword1"><span class="command">interpretation</span></span> hlg<span class="main">:</span> StdGraph <span class="quoted">hlg_ops</span>
  <span class="keyword1"><span class="command">unfolding</span></span> hlg_ops_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hlg_gbm.gbm_ops_impl<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.close_block</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">ICF_Tools.revert_abbrevs</span> <span class="inner_quoted">"HashGraphImpl.hlg"</span>›</span>

<span class="keyword1"><span class="command">thm</span></span> map_iterator_dom_def set_iterator_image_def
  set_iterator_image_filter_def

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_codegen</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_codegen</span> <span class="main">≡</span> <span class="main">(</span>
  hlg.empty<span class="main">,</span>
  hlg.add_node<span class="main">,</span>
  hlg.delete_node<span class="main">,</span>
  hlg.add_edge<span class="main">,</span>
  hlg.delete_edge<span class="main">,</span>
  hlg.from_list<span class="main">,</span>
  hlg.to_list<span class="main">,</span>
  hlg.nodes_it<span class="main">,</span>
  hlg.edges_it<span class="main">,</span>
  hlg.succ_it
<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_codegen</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dijkstra_Impl">
<div class="head">
<h1>Theory Dijkstra_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Dijkstra's-Algorithm using the ICF›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Dijkstra.html">Dijkstra</a> 
  <a href="GraphSpec.html">GraphSpec</a> 
  <a href="HashGraphImpl.html">HashGraphImpl</a> 
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span> 
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
  In this second refinement step, we use interfaces from the 
  Isabelle Collection Framework (ICF) to implement the priority queue and
  the result map. Moreover, we use a graph interface (that is not contained 
  in the ICF, but in this development) to represent the graph.

  The data types of the first refinement step were designed to fit the
  abstract data types of the used ICF-interfaces, which makes this refinement
  quite straightforward.

  Finally, we instantiate the ICF-interfaces by concrete implementations, 
  obtaining an executable algorithm, for that we generate code using 
  Isabelle/HOL's code generator.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> dijkstraC <span class="main">=</span>
  g<span class="main">:</span> StdGraph <span class="quoted"><span class="free">g_ops</span></span> <span class="main">+</span> 
  mr<span class="main">:</span> StdMap <span class="quoted"><span class="free">mr_ops</span></span> <span class="main">+</span>
  qw<span class="main">:</span> StdUprio <span class="quoted"><span class="free">qw_ops</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">,</span><span class="tfree">'G</span><span class="main">,</span><span class="tfree">'moreg</span><span class="main">)</span> graph_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mr_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'mr</span><span class="main">,</span><span class="tfree">'more_mr</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">qw_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">,</span><span class="tfree">'W</span> infty<span class="main">,</span><span class="tfree">'qw</span><span class="main">,</span><span class="tfree">'more_qw</span><span class="main">)</span> uprio_ops_scheme"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">αsc</span> <span class="main">==</span> map_prod qw.α mr.α"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dinvarC_add</span> <span class="main">==</span> <span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span> qw.invar <span class="bound">wl</span> <span class="main">∧</span> mr.invar <span class="bound">res</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cdinit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'qw</span><span class="main">×</span><span class="tfree">'mr</span><span class="main">)</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cdinit</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">wl</span> <span class="main">←</span> FOREACH <span class="main">(</span>nodes <span class="main">(</span>g.α <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="bound">v</span> <span class="bound">wl</span><span class="main">.</span> RETURN <span class="main">(</span>qw.insert <span class="bound">wl</span> <span class="bound">v</span> Weight.Infty<span class="main">)</span><span class="main">)</span> <span class="main">(</span>qw.empty <span class="main">()</span><span class="main">)</span><span class="main">;</span>
      RETURN <span class="main">(</span>qw.insert <span class="bound">wl</span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span>Num <span class="main">0</span><span class="main">)</span><span class="main">,</span>mr.sng <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="main">0</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cpop_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'qw</span><span class="main">×</span><span class="tfree">'mr</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span> infty<span class="main">×</span><span class="main">(</span><span class="tfree">'qw</span><span class="main">×</span><span class="tfree">'mr</span><span class="main">)</span><span class="main">)</span> nres"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cpop_min</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span> 
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">wl'</span><span class="main">)</span><span class="main">=</span>qw.pop <span class="bound">wl</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="main">(</span><span class="bound">wl'</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cupdate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'G</span> <span class="main">⇒</span> <span class="tfree">'V</span> <span class="main">⇒</span> <span class="tfree">'W</span> infty <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'qw</span><span class="main">×</span><span class="tfree">'mr</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'qw</span><span class="main">×</span><span class="tfree">'mr</span><span class="main">)</span> nres"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cupdate</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      ASSERT <span class="main">(</span>dinvarC_add <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">pv</span><span class="main">=</span>mpath' <span class="main">(</span>mr.lookup <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="bound">res</span><span class="main">)</span><span class="main">;</span>
      FOREACH <span class="main">(</span>succ <span class="main">(</span>g.α <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span><span class="main">.</span>
        <span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">+</span> Num <span class="bound">w'</span> <span class="main">&lt;</span> mpath_weight' <span class="main">(</span>mr.lookup <span class="bound">v'</span> <span class="bound">res</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span>
          RETURN <span class="main">(</span>qw.insert <span class="bound">wl</span> <span class="bound">v'</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">wv</span></span></span><span class="main">+</span>Num <span class="bound">w'</span><span class="main">)</span><span class="main">,</span> 
                  mr.update <span class="bound">v'</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">,</span><span class="bound">w'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">#</span>the <span class="bound">pv</span><span class="main">,</span>val <span class="free"><span class="bound"><span class="entity">wv</span></span></span> <span class="main">+</span> <span class="bound">w'</span><span class="main">)</span> <span class="bound">res</span><span class="main">)</span>
        <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
      <span class="main">)</span> <span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="bound">res</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">cdijkstra</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cdijkstra</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">σ0</span> <span class="main">←</span> cdinit <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v0</span></span></span><span class="main">;</span> 
      <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">res</span><span class="main">)</span> <span class="main">←</span> <span class="keyword1">WHILE<span class="hidden">⇩</span><sub>T</sub></span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">wl</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> qw.isEmpty <span class="bound">wl</span><span class="main">)</span> 
            <span class="main">(</span><span class="main">λ</span><span class="bound">σ</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">wv</span><span class="main">,</span><span class="bound">σ'</span><span class="main">)</span> <span class="main">←</span> cpop_min <span class="bound">σ</span><span class="main">;</span> cupdate <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="bound">v</span> <span class="bound">wv</span> <span class="bound">σ'</span> <span class="main">}</span> <span class="main">)</span>
            <span class="bound">σ0</span><span class="main">;</span>
      RETURN <span class="bound">res</span>
    <span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dijkstraC_fixg <span class="main">=</span> dijkstraC <span class="quoted"><span class="free">g_ops</span></span> <span class="quoted"><span class="free">mr_ops</span></span> <span class="quoted"><span class="free">qw_ops</span></span> <span class="main">+</span>
  Dijkstra <span class="quoted"><span class="free">ga</span></span> <span class="quoted"><span class="free">v0</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">,</span><span class="tfree">'G</span><span class="main">,</span><span class="tfree">'moreg</span><span class="main">)</span> graph_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mr_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'mr</span><span class="main">,</span><span class="tfree">'more_mr</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">qw_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">,</span><span class="tfree">'W</span> infty<span class="main">,</span><span class="tfree">'qw</span><span class="main">,</span><span class="tfree">'more_qw</span><span class="main">)</span> uprio_ops_scheme"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ga</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">v0</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'V</span></span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">g</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'G</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> g_rel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">ga</span><span class="main">)</span><span class="main">∈</span>br g.α g.invar"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">schematic_goal</span></span> cdinit_refines<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> inj_on_id
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cdinit <span class="free">g</span> <span class="free">v0</span> <span class="main">≤</span><span class="main">⇓</span><span class="var">?R</span> mdinit"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g_rel
    <span class="keyword1"><span class="command">unfolding</span></span> cdinit_def mdinit_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αsc_def dinvarC_add_def <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span>
      qw.correct mr.correct <span class="dynamic"><span class="dynamic">refine_hsimp</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> cpop_min_refines<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span> <span class="main">∈</span> build_rel αsc dinvarC_add
      <span class="main">⟹</span> cpop_min <span class="free">σ</span> <span class="main">≤</span> <span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>mpop_min <span class="free">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cpop_min_def mpop_min_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αsc_def dinvarC_add_def <span class="dynamic"><span class="dynamic">refine_hsimp</span></span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αsc_def dinvarC_add_def <span class="dynamic"><span class="dynamic">refine_hsimp</span></span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">schematic_goal</span></span> cupdate_refines<span class="main">:</span>
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> inj_on_id
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">σ</span><span class="main">,</span><span class="free">σ'</span><span class="main">)</span><span class="main">∈</span>build_rel αsc dinvarC_add <span class="main">⟹</span> <span class="free">v</span><span class="main">=</span><span class="free">v'</span> <span class="main">⟹</span> <span class="free">wv</span><span class="main">=</span><span class="free">wv'</span> <span class="main">⟹</span> 
    cupdate <span class="free">g</span> <span class="free">v</span> <span class="free">wv</span> <span class="free">σ</span> <span class="main">≤</span> <span class="main">⇓</span><span class="var">?R</span> <span class="main">(</span>mupdate <span class="free">v'</span> <span class="free">wv'</span> <span class="free">σ'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cupdate_def mupdate_def
    <span class="keyword1"><span class="command">using</span></span> g_rel
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_dref_type</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> αsc_def dinvarC_add_def <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span> 
      qw.correct mr.correct <span class="dynamic"><span class="dynamic">refine_hsimp</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">lemma</span></span> cdijkstra_refines<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"cdijkstra <span class="free">g</span> <span class="free">v0</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel mr.α mr.invar<span class="main">)</span> mdijkstra"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> cdinit_refines cpop_min_refines cupdate_refines
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> cdijkstra_def mdijkstra_def
      <span class="keyword1"><span class="command">using</span></span> g_rel
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_rcg</span><span class="main">)</span>

      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split prod.split_asm 
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> qw.correct mr.correct dinvarC_add_def αsc_def <span class="dynamic"><span class="dynamic">refine_hsimp</span></span>
          <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> dijkstraC
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">thm</span></span> g.nodes_it_is_iterator

  <span class="keyword1"><span class="command">schematic_goal</span></span> idijkstra_refines_aux<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"g.invar <span class="free">g</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="var">?f</span> <span class="main">≤</span> cdijkstra <span class="free">g</span> <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> cdijkstra_def cdinit_def cpop_min_def cupdate_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_transfer</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">idijkstra</span> <span class="keyword2"><span class="keyword">for</span></span> g <span class="var">?v0.0</span> <span class="keyword2"><span class="keyword">uses</span></span> idijkstra_refines_aux 

  <span class="keyword1"><span class="command">lemma</span></span> idijkstra_refines<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"g.invar <span class="free">g</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span> <span class="main">≤</span> cdijkstra <span class="free">g</span> <span class="free">v0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> idijkstra.refine<span class="main">)</span> 

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following theorem states correctness of the algorithm independent
  from the refinement framework.

  Intuitively, the first goal states that the abstraction of the returned 
  result is correct, the second goal states that the result
  datastructure satisfies its invariant, and the third goal states 
  that the cached weights in the returned result are correct.

  Note that this is the main theorem for a user of Dijkstra's algorithm in some 
  bigger context. It may also be specialized for concrete instances of the
  implementation, as exemplarily done below.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dijkstraC_fixg<span class="main">)</span> idijkstra_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"weighted_graph.is_shortest_path_map <span class="free">ga</span> <span class="free">v0</span> <span class="main">(</span>αr <span class="main">(</span>mr.α <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mr.invar <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Dijkstra.res_invarm <span class="main">(</span>mr.α <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> g_rel <span class="keyword1"><span class="command">have</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"g.invar <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> idijkstra_refines<span class="main">[</span><span class="operator">OF</span> I<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> cdijkstra_refines
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> mdijkstra_refines
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> Z<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span> <span class="main">≤</span> 
    <span class="main">⇓</span><span class="main">(</span>build_rel <span class="main">(</span>αr <span class="main">∘</span> mr.α<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> mr.invar <span class="bound">m</span> <span class="main">∧</span> res_invarm <span class="main">(</span>mr.α <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
      dijkstra'"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> conc_fun_chain<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br_chain<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dijkstra'_refines<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dijkstra_correct 
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> RETURN_ref_SPECD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dijkstraC<span class="main">)</span> idijkstra_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"g.invar <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> V0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> nodes <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nonneg_weights<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span> <span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">0</span><span class="main">≤</span><span class="bound">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"weighted_graph.is_shortest_path_map <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span> <span class="free">v0</span> 
      <span class="main">(</span>Dijkstra.αr <span class="main">(</span>mr.α <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Dijkstra.res_invarm <span class="main">(</span>mr.α <span class="main">(</span>idijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> gv<span class="main">:</span> valid_graph <span class="quoted"><span class="quoted">"g.α <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g.valid INV <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> dcg<span class="main">:</span> dijkstraC_fixg <span class="quoted"><span class="free">g_ops</span></span> <span class="quoted"><span class="free">mr_ops</span></span> <span class="quoted"><span class="free">qw_ops</span></span> <span class="quoted"><span class="quoted">"g.α <span class="free">g</span>"</span></span> <span class="quoted"><span class="free">v0</span></span> <span class="quoted"><span class="free">g</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dijkstraC_fixg.intro<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hlg.finite INV V0 hlg_ops_def 
      nonneg_weights <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> dcg.idijkstra_correct <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Example instantiation with HashSet.based graph, 
  red-black-tree based result map, and finger-tree based priority queue.
›</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.open_block</span>
<span class="keyword1"><span class="command">interpretation</span></span> hrf<span class="main">:</span> dijkstraC <span class="quoted">hlg_ops</span> <span class="quoted">rm_ops</span> <span class="quoted">aluprioi_ops</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.close_block</span>



<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hrf_dijkstra</span> <span class="main">≡</span> hrf.idijkstra"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> hrf_dijkstra_correct <span class="main">=</span> hrf.idijkstra_correct<span class="main">[</span><span class="operator">folded</span> hrf_dijkstra_def<span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">in</span></span> OCaml
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">in</span></span> Haskell
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Scala

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hrfn_dijkstra</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> hlg <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hrfn_dijkstra</span> <span class="main">≡</span> hrf_dijkstra"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrfn_dijkstra</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML

<span class="keyword1"><span class="command">lemmas</span></span> hrfn_dijkstra_correct <span class="main">=</span> 
  hrf_dijkstra_correct<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">nat</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tvar">?'b</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="main">,</span> <span class="operator">folded</span> hrfn_dijkstra_def<span class="main">]</span>

<span class="keyword1"><span class="command">term</span></span> <span class="quoted">hrfn_dijkstra</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">hlg.from_list</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_hrfn_dijkstra</span> 
  <span class="main">≡</span> rm.to_list 
    <span class="main">(</span>hrfn_dijkstra <span class="main">(</span>hlg.from_list <span class="main">(</span><span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="numeral">4</span><span class="main">]</span><span class="main">,</span><span class="main">[</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">2</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="numeral">2</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="numeral">4</span><span class="main">,</span><span class="numeral">3</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_hrfn_dijkstra</span><span class="antiquote">}</span></span></span>

›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Dijkstra_Impl_Adet">
<div class="head">
<h1>Theory Dijkstra_Impl_Adet</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Dijkstra's-Algorithm using Automatic Determinization›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Dijkstra_Impl_Adet
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="Dijkstra.html">Dijkstra</a> 
  <a href="GraphSpec.html">GraphSpec</a> 
  <a href="HashGraphImpl.html">HashGraphImpl</a> 
  <a href="../Collections/Refine_Dflt_ICF.html">Collections.Refine_Dflt_ICF</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Numeral.html">HOL-Library.Code_Target_Numeral</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span> 


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Setup›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Infinity›</span></span>
<span class="keyword1"><span class="command">definition</span></span> infty_rel_internal_def<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">infty_rel</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span>Num <span class="bound">a</span><span class="main">,</span> Num <span class="bound">a'</span><span class="main">)</span><span class="main">|</span> <span class="bound">a</span> <span class="bound">a'</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span>Infty<span class="main">,</span>Infty<span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> infty_rel_def<span class="main">[</span><span class="operator">refine_rel_defs</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">=</span> <span class="main">{</span><span class="main">(</span>Num <span class="bound">a</span><span class="main">,</span> Num <span class="bound">a'</span><span class="main">)</span><span class="main">|</span> <span class="bound">a</span> <span class="bound">a'</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main">(</span>Infty<span class="main">,</span>Infty<span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_internal_def relAPP_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_relI<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Infty<span class="main">,</span>Infty<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">⟹</span> <span class="main">(</span>Num <span class="free">a</span><span class="main">,</span> Num <span class="free">a'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_relE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span>Infty"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span><span class="main">=</span>Infty"</span></span>
  <span class="main">|</span> <span class="free">a</span> <span class="free">a'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span>Num <span class="free">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span><span class="main">=</span>Num <span class="free">a'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemma</span></span> infty_rel_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Infty<span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">⟷</span> <span class="free">x'</span><span class="main">=</span>Infty"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span>Infty<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span>Infty"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Num <span class="free">a</span><span class="main">,</span> Num <span class="free">a'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"single_valued <span class="free">R</span> <span class="main">⟹</span> single_valued <span class="main">(</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> single_valuedI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> single_valuedD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_rel_id<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">⟩</span>infty_rel <span class="main">=</span> Id"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> infty_relE<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">consts</span></span> i_infty <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">infty_rel</span> <span class="quoted">i_infty</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> autoref_infty<span class="main">[</span><span class="operator">param</span><span class="main">,</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Infty<span class="main">,</span>Infty<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Num<span class="main">,</span>Num<span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>case_infty<span class="main">,</span>case_infty<span class="main">)</span><span class="main">∈</span><span class="free">Rr</span><span class="main">→</span><span class="main">(</span><span class="free">R</span><span class="main">→</span><span class="free">Rr</span><span class="main">)</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">→</span><span class="free">Rr</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rec_infty<span class="main">,</span>rec_infty<span class="main">)</span><span class="main">∈</span><span class="free">Rr</span><span class="main">→</span><span class="main">(</span><span class="free">R</span><span class="main">→</span><span class="free">Rr</span><span class="main">)</span><span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">→</span><span class="free">Rr</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_rel_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD<span class="main">)</span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">is_Infty</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Infty <span class="main">⇒</span> True <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> pat_is_Infty<span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span>Infty <span class="main">≡</span> <span class="main">(</span><span class="keyword1">OP</span> is_Infty <span class="keyword1">:::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_infty <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> i_bool<span class="main">)</span><span class="main">$</span><span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"Infty<span class="main">=</span><span class="free">x</span> <span class="main">≡</span> <span class="main">(</span><span class="keyword1">OP</span> is_Infty <span class="keyword1">:::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">I</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_infty <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> i_bool<span class="main">)</span><span class="main">$</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> eq_reflection <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> infty.splits<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> autoref_is_Infty<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>is_Infty<span class="main">,</span> is_Infty<span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> bool_rel"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> infty.splits<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">infty_eq</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="free"><span class="bound"><span class="entity">v1</span></span></span> <span class="free"><span class="bound"><span class="entity">v2</span></span></span> <span class="main">≡</span> 
  <span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">v2</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
    <span class="main">(</span>Infty<span class="main">,</span>Infty<span class="main">)</span> <span class="main">⇒</span> True
  <span class="main">|</span> <span class="main">(</span>Num <span class="bound">a1</span><span class="main">,</span> Num <span class="bound">a2</span><span class="main">)</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">eq</span></span></span> <span class="bound">a1</span> <span class="bound">a2</span>
  <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> infty_eq_autoref<span class="main">[</span><span class="operator">autoref_rules</span> <span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">overloaded</span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> GEN_OP <span class="free">eq</span> <span class="main">(=)</span> <span class="main">(</span><span class="free">R</span><span class="main">→</span><span class="free">R</span><span class="main">→</span>bool_rel<span class="main">)</span> <span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span>infty_eq <span class="free">eq</span><span class="main">,</span><span class="main">(=)</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">→</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">→</span>bool_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_eq_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> infty.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> fun_relD <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> infty_relE<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_eq_expand<span class="main">[</span><span class="operator">autoref_struct_expand</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(=)</span> <span class="main">=</span> infty_eq <span class="main">(=)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> infty_eq_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> infty.splits<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span> <span class="keyword1"><span class="command">interpretation</span></span> autoref_syn <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> infty_val_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>SIDE_PRECOND <span class="main">(</span><span class="free">x</span><span class="main">≠</span>Infty<span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="free">xi</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel<span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span>val <span class="free">xi</span><span class="main">,</span><span class="main">(</span><span class="keyword1">OP</span> val <span class="main">:::</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="free">R</span><span class="main">)</span> <span class="main">$</span> <span class="free">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> infty_relE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">infty_plus</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">infty_plus</span> <span class="free"><span class="bound"><span class="entity">pl</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Num <span class="bound">a</span><span class="main">,</span> Num <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> Num <span class="main">(</span><span class="free"><span class="bound"><span class="entity">pl</span></span></span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Infty "</span></span>

<span class="keyword1"><span class="command">lemma</span></span> infty_plus_param<span class="main">[</span><span class="operator">param</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>infty_plus<span class="main">,</span>infty_plus<span class="main">)</span> <span class="main">∈</span> <span class="main">(</span><span class="free">R</span><span class="main">→</span><span class="free">R</span><span class="main">→</span><span class="free">R</span><span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_plus_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">parametricity</span>

<span class="keyword1"><span class="command">lemma</span></span> infty_plus_eq_plus<span class="main">:</span> <span class="quoted"><span class="quoted">"infty_plus <span class="main">(+)</span> <span class="main">=</span> <span class="main">(+)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> infty_plus_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> infty.split<span class="main">)</span>
  

<span class="keyword1"><span class="command">lemma</span></span> infty_plus_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"GEN_OP <span class="free">pl</span> <span class="main">(+)</span> <span class="main">(</span><span class="free">R</span><span class="main">→</span><span class="free">R</span><span class="main">→</span><span class="free">R</span><span class="main">)</span> 
  <span class="main">⟹</span> <span class="main">(</span>infty_plus <span class="free">pl</span><span class="main">,</span><span class="main">(+)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span><span class="free">R</span><span class="main">⟩</span>infty_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> infty_plus_eq_plus<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">parametricity</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Graph›</span></span>
<span class="keyword1"><span class="command">consts</span></span> i_graph <span class="main">::</span> <span class="quoted"><span class="quoted">"interface <span class="main">⇒</span> interface <span class="main">⇒</span> interface"</span></span>

<span class="keyword1"><span class="command">definition</span></span> graph_more_rel_internal_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">graph_more_rel</span> <span class="free"><span class="bound"><span class="entity">Rm</span></span></span> <span class="free"><span class="bound"><span class="entity">Rv</span></span></span> <span class="free"><span class="bound"><span class="entity">Rw</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span><span class="main">.</span> 
    <span class="main">(</span>graph.nodes <span class="bound">g</span><span class="main">,</span> graph.nodes <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Rv</span></span></span><span class="main">⟩</span>set_rel     
  <span class="main">∧</span> <span class="main">(</span>graph.edges <span class="bound">g</span><span class="main">,</span> graph.edges <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Rv</span></span></span><span class="main">,</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Rw</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Rv</span></span></span><span class="main">⟩</span>prod_rel<span class="main">⟩</span>prod_rel<span class="main">⟩</span>set_rel
  <span class="main">∧</span> <span class="main">(</span>graph.more <span class="bound">g</span><span class="main">,</span> graph.more <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Rm</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> graph_more_rel_def<span class="main">[</span><span class="operator">refine_rel_defs</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>graph_more_rel <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">g'</span><span class="main">)</span><span class="main">.</span> 
    <span class="main">(</span>graph.nodes <span class="bound">g</span><span class="main">,</span> graph.nodes <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span>set_rel     
  <span class="main">∧</span> <span class="main">(</span>graph.edges <span class="bound">g</span><span class="main">,</span> graph.edges <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="main">⟨</span><span class="free">Rw</span><span class="main">,</span><span class="free">Rv</span><span class="main">⟩</span>prod_rel<span class="main">⟩</span>prod_rel<span class="main">⟩</span>set_rel
  <span class="main">∧</span> <span class="main">(</span>graph.more <span class="bound">g</span><span class="main">,</span> graph.more <span class="bound">g'</span><span class="main">)</span><span class="main">∈</span><span class="free">Rm</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> relAPP_def graph_more_rel_internal_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">graph_rel</span> <span class="main">≡</span> <span class="main">⟨</span>unit_rel<span class="main">⟩</span>graph_more_rel"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> graph_rel_def <span class="main">=</span> graph_more_rel_def<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Rm<span class="main"><span class="main">=</span></span><span class="quoted">unit_rel</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> graph_rel_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">,</span>Id<span class="main">⟩</span>graph_rel <span class="main">=</span> Id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_rel_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> graph_more_rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>single_valued <span class="free">Rm</span><span class="main">;</span> single_valued <span class="free">Rv</span><span class="main">;</span> single_valued <span class="free">Rw</span><span class="main">⟧</span> 
  <span class="main">⟹</span> single_valued <span class="main">(</span><span class="main">⟨</span><span class="free">Rm</span><span class="main">,</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>graph_more_rel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> graph_more_rel_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> single_valuedI<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> graph.equality<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> single_valuedD<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">tagged_solver</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"graph.nodes <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">Iv</span><span class="main">,</span><span class="free">Iw</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_graph <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">Iv</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_set"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">thm</span></span> is_map_to_sorted_list_def

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">nodes_to_list</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>graph.nodes <span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> nodes_to_list_itype<span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes_to_list <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">Iv</span><span class="main">,</span><span class="free">Iw</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_graph <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">Iv</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_nres"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nodes_to_list_pat<span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>graph.nodes <span class="free">g</span><span class="main">)</span> <span class="main">≡</span> nodes_to_list <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nodes_to_list_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">succ_to_list</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>Graph.succ <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lemma</span></span> succ_to_list_itype<span class="main">[</span><span class="operator">autoref_itype</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"succ_to_list <span class="keyword1">::<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="free">Iv</span><span class="main">,</span><span class="free">Iw</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_graph <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="free">Iv</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Iw</span><span class="main">,</span><span class="free">Iv</span><span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_prod<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_list<span class="keyword1">⟩<span class="hidden">⇩</span><sub>i</sub></span>i_nres"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> succ_to_list_pat<span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>Graph.succ <span class="free">g</span> <span class="free">v</span><span class="main">)</span> <span class="main">≡</span> succ_to_list <span class="free">g</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> succ_to_list_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span> graph <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> rel_def_internal<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">rel</span> <span class="free"><span class="bound"><span class="entity">Rv</span></span></span> <span class="free"><span class="bound"><span class="entity">Rw</span></span></span> <span class="main">≡</span> br <span class="free">α</span> <span class="free">invar</span> <span class="keyword1">O</span> <span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">Rv</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Rw</span></span></span><span class="main">⟩</span>graph_rel"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> rel_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel <span class="main">≡</span> br <span class="free">α</span> <span class="free">invar</span> <span class="keyword1">O</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>graph_rel"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> relAPP_def rel_def_internal <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">lemma</span></span> rel_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟨</span>Id<span class="main">,</span>Id<span class="main">⟩</span>rel <span class="main">=</span> br <span class="free">α</span> <span class="free">invar</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_def<span class="main">)</span>

  <span class="keyword1"><span class="command">lemma</span></span> rel_sv<span class="main">[</span><span class="operator">relator_props</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span>single_valued <span class="free">Rv</span><span class="main">;</span> single_valued <span class="free">Rw</span><span class="main">⟧</span> <span class="main">⟹</span> single_valued <span class="main">(</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> rel_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">tagged_solver</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">rel</span> <span class="quoted">i_graph</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph_nodes_it<span class="main">)</span> autoref_nodes_it<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> ID<span class="main">:</span> <span class="quoted"><span class="quoted">"PREFER_id <span class="free">Rv</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> RETURN <span class="main">(</span>it_to_list nodes_it <span class="bound">s</span><span class="main">)</span><span class="main">,</span>nodes_to_list<span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span>list_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nodes_to_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span>
  <span class="keyword1"><span class="command">from</span></span> ID <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rv</span> <span class="main">=</span> Id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nodes <span class="skolem">s'</span> <span class="main">=</span> nodes <span class="main">(</span><span class="free">α</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rel_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_def graph_rel_def<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">l</span>"</span></span> <span class="quoted"><span class="quoted">"nodes <span class="main">(</span><span class="free">α</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">=</span> set <span class="skolem">l</span>"</span></span> <span class="quoted"><span class="quoted">"it_to_list nodes_it <span class="skolem">s</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> it_to_list_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nodes_it_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> set_iterator_def set_iterator_genord_def<span class="main"><span class="main">]</span></span> 
      foldli_snoc_id self_append_conv2<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>it_to_list nodes_it <span class="skolem">s</span><span class="main">)</span>
          <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">⟩</span>list_rel<span class="main">)</span> <span class="main">(</span>it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>nodes <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> it_to_sorted_list_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> graph_succ_it<span class="main">)</span> autoref_succ_it<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> ID<span class="main">:</span> <span class="quoted"><span class="quoted">"PREFER_id <span class="free">Rv</span>"</span></span> <span class="quoted"><span class="quoted">"PREFER_id <span class="free">Rw</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="bound">v</span><span class="main">.</span> RETURN <span class="main">(</span>it_to_list <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> succ_it <span class="bound">s</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span>succ_to_list<span class="main">)</span> 
    <span class="main">∈</span> <span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel <span class="main">→</span> <span class="free">Rv</span> <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Rw</span><span class="main">,</span><span class="free">Rv</span><span class="main">⟩</span>prod_rel<span class="main">⟩</span>list_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> succ_to_list_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> fun_relI nres_relI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">v</span> <span class="skolem">v'</span>
  <span class="keyword1"><span class="command">from</span></span> ID <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rv</span> <span class="main">=</span> Id"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Rw</span><span class="main">=</span>Id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">v</span><span class="main">,</span><span class="skolem">v'</span><span class="main">)</span><span class="main">∈</span><span class="free">Rv</span>"</span></span> <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v'</span><span class="main">=</span><span class="skolem">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s'</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span><span class="free">Rv</span><span class="main">,</span><span class="free">Rw</span><span class="main">⟩</span>rel"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="skolem">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Graph.succ <span class="skolem">s'</span> <span class="main">=</span> Graph.succ <span class="main">(</span><span class="free">α</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rel_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> br_def graph_rel_def succ_def<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">l</span>"</span></span> <span class="quoted"><span class="quoted">"succ <span class="main">(</span><span class="free">α</span> <span class="skolem">s</span><span class="main">)</span> <span class="skolem">v</span> <span class="main">=</span> set <span class="skolem">l</span>"</span></span> <span class="quoted"><span class="quoted">"it_to_list <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> succ_it <span class="bound">s</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">s</span> <span class="main">=</span> <span class="skolem">l</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> it_to_list_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> succ_it_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> INV<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> set_iterator_def set_iterator_genord_def<span class="main"><span class="main">]</span></span> 
      foldli_snoc_id self_append_conv2<span class="main">)</span>
  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>it_to_list <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> succ_it <span class="bound">s</span> <span class="skolem">v</span><span class="main">)</span> <span class="skolem">s</span><span class="main">)</span>
          <span class="main">≤</span> <span class="main">⇓</span> <span class="main">(</span><span class="main">⟨</span><span class="main">⟨</span><span class="free">Rw</span><span class="main">,</span><span class="free">Rv</span><span class="main">⟩</span>prod_rel<span class="main">⟩</span>list_rel<span class="main">)</span> <span class="main">(</span>it_to_sorted_list <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span>succ <span class="skolem">s'</span> <span class="skolem">v'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> it_to_sorted_list_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Refinement›</span></span>

<span class="keyword1"><span class="command">locale</span></span> dijkstraC <span class="main">=</span>
  g<span class="main">:</span> StdGraph <span class="quoted"><span class="free">g_ops</span></span> <span class="main">+</span> 
  mr<span class="main">:</span> StdMap <span class="quoted"><span class="free">mr_ops</span></span> <span class="main">+</span>
  qw<span class="main">:</span> StdUprio <span class="quoted"><span class="free">qw_ops</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">,</span><span class="tfree">'G</span><span class="main">,</span><span class="tfree">'moreg</span><span class="main">)</span> graph_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mr_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'mr</span><span class="main">,</span><span class="tfree">'more_mr</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">qw_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">,</span><span class="tfree">'W</span> infty<span class="main">,</span><span class="tfree">'qw</span><span class="main">,</span><span class="tfree">'more_qw</span><span class="main">)</span> uprio_ops_scheme"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> dijkstraC_fixg <span class="main">=</span> dijkstraC <span class="quoted"><span class="free">g_ops</span></span> <span class="quoted"><span class="free">mr_ops</span></span> <span class="quoted"><span class="free">qw_ops</span></span> <span class="main">+</span>
  Dijkstra <span class="quoted"><span class="free">ga</span></span> <span class="quoted"><span class="free">v0</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">g_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">::</span>weight<span class="main">,</span><span class="tfree">'G</span><span class="main">,</span><span class="tfree">'moreg</span><span class="main">)</span> graph_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mr_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> path <span class="main">×</span> <span class="tfree">'W</span><span class="main">)</span><span class="main">,</span> <span class="tfree">'mr</span><span class="main">,</span><span class="tfree">'more_mr</span><span class="main">)</span> map_ops_scheme"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">qw_ops</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span> <span class="main">,</span><span class="tfree">'W</span> infty<span class="main">,</span><span class="tfree">'qw</span><span class="main">,</span><span class="tfree">'more_qw</span><span class="main">)</span> uprio_ops_scheme"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ga</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">,</span><span class="tfree">'W</span><span class="main">)</span> graph"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"<span class="free">v0</span>"</span><span class="main">::</span><span class="tfree"><span class="quoted"><span class="tfree">'V</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'G</span></span></span><span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ga_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">ga</span><span class="main">)</span><span class="main">∈</span>br g.α g.invar"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">v_rel</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> set"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">w_rel</span> <span class="main">≡</span> Id <span class="main">::</span> <span class="main">(</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'W</span><span class="main">)</span> set"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">i_node</span> <span class="main">::</span> <span class="quoted">interface</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">i_node</span> <span class="main">≡</span> undefined"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">i_weight</span> <span class="main">::</span> <span class="quoted">interface</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">i_weight</span> <span class="main">≡</span> undefined"</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">v_rel</span> <span class="quoted">i_node</span><span class="main">]</span>
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_rel_intf</span><span class="main">]</span> <span class="main">=</span> REL_INTFI<span class="main">[</span><span class="operator">of</span> <span class="quoted">w_rel</span> <span class="quoted">i_weight</span><span class="main">]</span>
  
  <span class="keyword1"><span class="command">lemma</span></span> weight_plus_autoref<span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">∈</span> w_rel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(+)</span><span class="main">,</span><span class="main">(+)</span><span class="main">)</span> <span class="main">∈</span> w_rel <span class="main">→</span> w_rel <span class="main">→</span> w_rel"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(+)</span><span class="main">,</span><span class="main">(+)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(&lt;)</span><span class="main">,</span><span class="main">(&lt;)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel <span class="main">→</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel <span class="main">→</span> bool_rel"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">g</span><span class="main">,</span><span class="free">ga</span><span class="main">)</span><span class="main">∈</span><span class="main">⟨</span>v_rel<span class="main">,</span>w_rel<span class="main">⟩</span>g.rel"</span></span> <span class="keyword1"><span class="command">using</span></span> ga_trans
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> g.rel_def<span class="main">)</span>
   
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">v0</span><span class="main">,</span><span class="free">v0</span><span class="main">)</span><span class="main">∈</span>v_rel"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">mpath_weight'</span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">autoref_rules</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span>mpath_weight'<span class="main">,</span>mpath_weight'<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span>v_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>v_rel<span class="main">⟩</span>list_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="main">⟩</span>option_rel <span class="main">→</span> <span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>mpath'<span class="main">,</span> mpath'<span class="main">)</span> 
      <span class="main">∈</span> <span class="main">⟨</span><span class="main">⟨</span>v_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>v_rel<span class="main">⟩</span>list_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="main">⟩</span>option_rel 
        <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span>v_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>v_rel<span class="main">⟩</span>list_rel<span class="main">⟩</span>option_rel"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">mdinit</span>

  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_tyrel</span><span class="main">]</span> <span class="main">=</span> 
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted">v_rel</span><span class="main">]</span>
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted">w_rel</span><span class="main">]</span>
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel"</span></span><span class="main">]</span>
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>v_rel<span class="main">,</span><span class="main">⟨</span>w_rel<span class="main">⟩</span>infty_rel<span class="main">⟩</span>qw.rel"</span></span><span class="main">]</span>
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>v_rel<span class="main">,</span><span class="main">⟨</span>v_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>v_rel<span class="main">⟩</span>list_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="main">⟩</span>mr.rel"</span></span><span class="main">]</span>
    ty_REL<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">⟨</span>v_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>w_rel<span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span>v_rel<span class="main">⟩</span>list_rel"</span></span><span class="main">]</span>
    
  <span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">autoref_op_pat</span><span class="main">]</span> <span class="main">=</span> uprio_pats<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'e</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span></span></span> <span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'V</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span></span></span></span></span></span> <span class="tfree">'a</span> <span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree"><span class="tfree"><span class="tfree"><span class="tfree"><span class="tfree"><span class="tfree">'W</span></span></span></span></span></span></span> infty"</span></span></span></span></span></span></span></span><span class="main">]</span>


  <span class="keyword1"><span class="command">schematic_goal</span></span> cdijkstra_refines_aux<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span><span class="main">::</span><span class="tvar">?'c</span><span class="main">,</span> 
      mdijkstra
    <span class="main">)</span> <span class="main">∈</span> <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mdijkstra_def mdinit_def mpop_min_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> mupdate_def<span class="main">)</span>

    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">goals_limit</span> <span class="main"><span class="main">=</span></span> 1<span class="main">]</span><span class="main">]</span>

    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> op_map_empty_def<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="tfree">'V</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'V</span><span class="main">×</span><span class="tfree">'W</span><span class="main">×</span><span class="tfree">'V</span><span class="main">)</span> list <span class="main">×</span> <span class="tfree">'W</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> op_uprio_empty_def<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="tfree">'V</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tfree">'b</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'W</span> infty"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

    <span class="comment1">(*using [[autoref_trace_intf_unif]]*)</span>
    <span class="keyword1"><span class="command">using</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">autoref_trace_failed_id</span><span class="main">]</span><span class="main">]</span>
  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">autoref_monadic</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">plain</span><span class="main"><span class="main">,</span></span><span class="quasi_keyword">trace</span><span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> dijkstraC 
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">concrete_definition</span></span> <span class="entity">cdijkstra</span> <span class="keyword2"><span class="keyword">for</span></span> g <span class="var">?v0.0</span>  
    <span class="keyword2"><span class="keyword">uses</span></span> dijkstraC_fixg.cdijkstra_refines_aux
    <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g_ops</span></span> <span class="quoted"><span class="free">mr_ops</span></span> <span class="quoted"><span class="free">qw_ops</span></span><span class="main">]</span>

    <span class="keyword1"><span class="command">term</span></span> <span class="quoted">cdijkstra</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> dijkstraC_fixg
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">cdijkstra</span>
  <span class="keyword1"><span class="command">term</span></span> <span class="quoted">mdijkstra</span>

  <span class="keyword1"><span class="command">lemma</span></span> cdijkstra_refines<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span> <span class="main">≤</span> <span class="main">⇓</span><span class="main">(</span>build_rel mr.α mr.invar<span class="main">)</span> mdijkstra"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cdijkstra.refine<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> nres_relD<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">theorem</span></span> cdijkstra_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"weighted_graph.is_shortest_path_map <span class="free">ga</span> <span class="free">v0</span> <span class="main">(</span>αr <span class="main">(</span>mr.α <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mr.invar <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"res_invarm <span class="main">(</span>mr.α <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">note</span></span> cdijkstra_refines
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> mdijkstra_refines
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> Z<span class="main">:</span> <span class="quoted"><span class="quoted">"RETURN <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span> <span class="main">≤</span> 
      <span class="main">⇓</span><span class="main">(</span>build_rel <span class="main">(</span>αr <span class="main">∘</span> mr.α<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> mr.invar <span class="bound">m</span> <span class="main">∧</span> res_invarm <span class="main">(</span>mr.α <span class="bound">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
        dijkstra'"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> conc_fun_chain<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> br_chain<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dijkstra'_refines<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> dijkstra_correct 
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="var"><span class="quoted"><span class="var">?G3</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> RETURN_ref_SPECD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> dijkstraC<span class="main">)</span> cdijkstra_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INV<span class="main">:</span> <span class="quoted"><span class="quoted">"g.invar <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> V0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v0</span> <span class="main">∈</span> nodes <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nonneg_weights<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">w</span> <span class="bound">v'</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">∈</span>edges <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">0</span><span class="main">≤</span><span class="bound">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"weighted_graph.is_shortest_path_map <span class="main">(</span>g.α <span class="free">g</span><span class="main">)</span> <span class="free">v0</span> 
      <span class="main">(</span>Dijkstra.αr <span class="main">(</span>mr.α <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"Dijkstra.res_invarm <span class="main">(</span>mr.α <span class="main">(</span>cdijkstra <span class="free">g</span> <span class="free">v0</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> hlgv<span class="main">:</span> valid_graph <span class="quoted"><span class="quoted">"g.α <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g.valid INV <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">interpret</span></span> dc<span class="main">:</span> dijkstraC_fixg <span class="quoted"><span class="free">g_ops</span></span> <span class="quoted"><span class="free">mr_ops</span></span> <span class="quoted"><span class="free">qw_ops</span></span> <span class="quoted"><span class="quoted">"g.α <span class="free">g</span>"</span></span> <span class="quoted"><span class="free">v0</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> 
      <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hlg.finite INV V0 hlg_ops_def nonneg_weights <span class="dynamic"><span class="dynamic">refine_rel_defs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> dc.cdijkstra_correct <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?G1</span></span></span> <span class="var"><span class="quoted"><span class="var">?G2</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Example instantiation with HashSet.based graph, 
  red-black-tree based result map, and finger-tree based priority queue.
›</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.open_block</span>
<span class="keyword1"><span class="command">interpretation</span></span> hrf<span class="main">:</span> dijkstraC <span class="quoted">hlg_ops</span> <span class="quoted">rm_ops</span> <span class="quoted">aluprioi_ops</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="entity">Locale_Code.close_block</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">hrf_dijkstra</span> <span class="main">≡</span> hrf.cdijkstra"</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> hrf_dijkstra_correct <span class="main">=</span> hrf.cdijkstra_correct<span class="main">[</span><span class="operator">folded</span> hrf_dijkstra_def<span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">in</span></span> OCaml
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">in</span></span> Haskell
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrf_dijkstra</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Scala

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hrfn_dijkstra</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> hlg <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hrfn_dijkstra</span> <span class="main">≡</span> hrf_dijkstra"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">hrfn_dijkstra</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">lemmas</span></span> hrfn_dijkstra_correct <span class="main">=</span> 
  hrf_dijkstra_correct<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">nat</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="tvar">?'b</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="main">,</span> <span class="operator">folded</span> hrfn_dijkstra_def<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Test">
<div class="head">
<h1>Theory Test</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Performance Test›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Test
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Dijkstra_Impl_Adet.html">Dijkstra_Impl_Adet</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In this theory, we test our implementation of Dijkstra's algorithm for larger,
  randomly generated graphs.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Simple linear congruence generator for (low-quality) random numbers:"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lcg_next</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="numeral">81</span><span class="main">::</span>nat<span class="main">)</span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">+</span> <span class="numeral">173</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="numeral">268435456</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Generate a complete graph over the given number of vertices,
    with random weights:"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ran_graph</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>nat list<span class="main">×</span><span class="main">(</span>nat <span class="main">×</span> nat <span class="main">×</span> nat<span class="main">)</span> list<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ran_graph</span> <span class="free"><span class="bound"><span class="entity">vertices</span></span></span> <span class="free"><span class="bound"><span class="entity">seed</span></span></span> <span class="main">==</span> 
    <span class="main">(</span><span class="main">[</span><span class="main">0</span><span class="main">::</span>nat<span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">vertices</span></span></span><span class="main">]</span><span class="main">,</span>fst 
     <span class="main">(</span>while <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">vertices</span></span></span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> 
     <span class="keyword1">let</span> <span class="main">(</span><span class="bound">g''</span><span class="main">,</span><span class="bound">v''</span><span class="main">,</span><span class="bound">s''</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>while <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="bound">v'</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">vertices</span></span></span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">g'</span><span class="main">,</span><span class="bound">v'</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">v</span><span class="main">,</span><span class="bound">s'</span><span class="main">,</span><span class="bound">v'</span><span class="main">)</span><span class="main">#</span><span class="bound">g'</span><span class="main">,</span><span class="bound">v'</span><span class="main">+</span><span class="main">1</span><span class="main">,</span>lcg_next <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="bound">g</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>
     <span class="keyword1">in</span> <span class="main">(</span><span class="bound">g''</span><span class="main">,</span><span class="bound">v</span><span class="main">+</span><span class="main">1</span><span class="main">,</span><span class="bound">s''</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">[]</span><span class="main">,</span><span class="main">0</span><span class="main">,</span>lcg_next <span class="free"><span class="bound"><span class="entity">seed</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  To experiment with the exported code, we fix the node type to natural numbers,
  and add a from-list conversion:
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> nat_res <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span><span class="main">(</span><span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> path <span class="main">×</span> nat<span class="main">)</span><span class="main">)</span> rm"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> nat_list_res <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> <span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> path <span class="main">×</span> nat<span class="main">)</span> list"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">nat_dijkstra</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> hlg <span class="main">⇒</span> nat <span class="main">⇒</span> nat_res"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">nat_dijkstra</span> <span class="main">≡</span> hrfn_dijkstra"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hlg_from_list_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> adj_list <span class="main">⇒</span><span class="main">(</span>nat<span class="main">,</span>nat<span class="main">)</span> hlg"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">hlg_from_list_nat</span> <span class="main">≡</span> hlg.from_list"</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">nat_res_to_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat_res <span class="main">⇒</span> nat_list_res"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">nat_res_to_list</span> <span class="main">≡</span> rm.to_list"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"nat_res_to_list <span class="main">(</span>nat_dijkstra <span class="main">(</span>hlg_from_list_nat <span class="main">(</span>ran_graph <span class="numeral">4</span> <span class="numeral">8912</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="comment1">(* Configuration of test: *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vertices</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">1000</span><span class="main">;</span> <span class="comment1">(* Number of vertices *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seed</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">123454</span><span class="main">;</span> <span class="comment1">(* Seed for random number generator *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cfg_print_paths</span> <span class="main">=</span> true<span class="main">;</span> <span class="comment1">(* Whether to output complete paths *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cfg_print_res</span> <span class="main">=</span> true<span class="main">;</span> <span class="comment1">(* Whether to output result at all *)</span>

  <span class="comment1">(* Internals *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_edge</span> <span class="main">(</span><span class="entity">u</span><span class="main">,</span><span class="main">(</span><span class="entity">w</span><span class="main">,</span><span class="entity">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">u</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">w</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">w</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">v</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">v</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="inner_quoted">"("</span> ^ string_of_int <span class="entity">u</span> ^ <span class="inner_quoted">","</span> ^ string_of_int <span class="entity">w</span> ^ <span class="inner_quoted">","</span> ^ string_of_int <span class="entity">v</span> ^ <span class="inner_quoted">")"</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_entry</span> <span class="main">(</span><span class="entity">dest</span><span class="main">,</span><span class="main">(</span><span class="entity">path</span><span class="main">,</span><span class="entity">weight</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">dest</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">weight</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">weight</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    writeln <span class="main">(</span>string_of_int <span class="entity">dest</span> ^ <span class="inner_quoted">": "</span> ^ string_of_int <span class="entity">weight</span> ^
      <span class="main">(</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">cfg_print_paths</span> <span class="keyword2"><span class="keyword">then</span></span> 
          <span class="inner_quoted">" via ["</span> ^ commas <span class="main">(</span>map <span class="entity">string_of_edge</span> <span class="main">(</span>rev <span class="entity">path</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">"]"</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span>
      <span class="main">)</span>
    <span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_res</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">print_res</span> <span class="main">(</span><span class="entity">a</span>::<span class="entity">l</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">print_entry</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">print_res</span> <span class="entity">l</span> <span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> Time.now<span class="main">(</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">graph</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">hlg_from_list_nat</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">ran_graph</span><span class="antiquote">}</span></span></span> <span class="entity">vertices</span> <span class="entity">seed</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rt1</span> <span class="main">=</span> Time.toMilliseconds <span class="main">(</span>Time.now<span class="main">(</span><span class="main">)</span> - <span class="entity">start</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> Time.now<span class="main">(</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_dijkstra</span><span class="antiquote">}</span></span></span> <span class="entity">graph</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_of_integer</span><span class="antiquote">}</span></span></span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rt2</span> <span class="main">=</span> Time.toMilliseconds <span class="main">(</span>Time.now<span class="main">(</span><span class="main">)</span> - <span class="entity">start</span><span class="main">)</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  writeln <span class="main">(</span>string_of_int <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">vertices</span><span class="main">)</span> ^ <span class="inner_quoted">" vertices: "</span> 
  ^ string_of_int <span class="entity">rt2</span> ^ <span class="inner_quoted">" ms + "</span>
  ^ string_of_int <span class="entity">rt1</span> ^ <span class="inner_quoted">" ms to create graph = "</span> 
  ^ string_of_int <span class="main">(</span><span class="entity">rt1</span>+<span class="entity">rt2</span><span class="main">)</span> ^ <span class="inner_quoted">" ms"</span><span class="main">)</span><span class="main">;</span>

  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">cfg_print_res</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="entity">print_res</span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">nat_res_to_list</span><span class="antiquote">}</span></span></span> <span class="entity">res</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>