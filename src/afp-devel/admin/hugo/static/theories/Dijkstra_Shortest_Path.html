<div id="Introduction">
<div class="head"><h1>Theory Introduction</h1>
<span class="command">theory</span> <span class="name">Introduction</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title: A efficiently computable formalisation of Dijkstra's algorithm       
    Author: Benedikt Nordhoff &lt;bnord01 at gmail.com&gt;, 
            Peter Lammich &lt;lammich at in.tum.de&gt;
    Maintainer: lammich@in.tum.de
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Introduction and Overview"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Introduction</span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\label{thy:Introduction}›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  
  Dijkstra's algorithm \cite{Dijk59} is an algorithm used to
  find shortest paths from one given vertex to all other vertices in a
  non-negatively weighted graph.  
  
  The implementation of the algorithm is meant to be an application
  of our extensions to the Isabelle Collections Framework (ICF)
  \cite{L09_collections,LL10,NKP10}. Moreover, it serves as a test case 
  for our data refinement framework \cite{refinement_framework}.
  We use ICF-Maps to efficiently represent the graph and
  result and the newly introduced unique priority queues for the work
  list.

  For a documentation of the refinement framework see \cite{refinement_framework},
  that also contains a userguide and some simpler examples.

  The development utilizes a stepwise refinement approach. Starting from an
  abstract algorithm that has a nice correctness proof, we stepwise refine
  the algorithm until we end up with an efficient implementation, for that 
  we generate code using Isabelle/HOL's code generator\cite{Haft09,HaNi10}.
  
  \paragraph{Structure of the Submission.}
  The abstract version of the algorithm with the correctness proof, as well
  as the main refinement steps are contained in the theory \texttt{Dijkstra}.
  The refinement steps involving the ICF and code generation are contained in
  \texttt{Dijkstra-Impl}. 
  The theory \texttt{Infty} contains an extension of numbers with an infinity
  element. 
  The theory \texttt{Graph} contains a formalization of graphs, paths, and
  related concepts.
  The theories \texttt{GraphSpec,GraphGA,GraphByMap,HashGraphImpl} contain an
  ICF-style specification of graphs.
  The theory \texttt{Test} contains a small performance test on random graphs.
  It uses the ML-code generated by the code generator.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra_Misc">
<div class="head"><h1>Theory Dijkstra_Misc</h1>
<span class="command">theory</span> <span class="name">Dijkstra_Misc</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Miscellaneous Lemmas›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra_Misc</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>least_map</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ x∈S; ∀x'∈S. f x ≤ f x' ⟧ ⟹ x ∈ least_map f S"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least_map f S ⊆ S"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>least_map.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>least_map_elemD</span><span> </span><span class="delimiter">=</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>least_map_subset</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_leD</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ least_map f S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈S"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f x ≤ f y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>least_map.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least_map f {} = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>least_map.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"least_map (f::'a⇒'b::order) {x} = {x}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>least_map.cases</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>least_map.intros</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_insert_min</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a⇒'b::order"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈S. f x ≤ f y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ least_map f (insert x S)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>least_map.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>least_map_insert_nmin</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ x∈least_map f S; f x ≤ f a ⟧ ⟹ x∈least_map f (insert a S)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>least_map.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>least_map.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>semilattice_inf</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>inf_absorb1</span><span> </span><span>inf_absorb2</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_absorb_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟹ inf a b = a"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟹ inf b a = a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_iff_inf</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inf_commute</span><span> </span><span>le_iff_inf</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Graph">
<div class="head"><h1>Theory Graph</h1>
<span class="command">theory</span> <span class="name">Graph</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graphs›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory defines a notion of graphs. A graph is a record that
  contains a set of nodes ‹V› and a set of labeled edges 
  ‹E ⊆ V×W×V›, where ‹W› are the edge labels.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definitions›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A graph is represented by a record.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'v</span><span class="delimiter">,</span><span class="tfree">'w</span><span class="delimiter">)</span><span> </span><span>graph</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>nodes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v set"</span></span></span><span>
</span><span>    </span><span>edges</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v × 'w × 'v) set"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In a valid graph, edges only go from nodes to nodes.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>valid_graph</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v,'w) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>E_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst`edges G ⊆ nodes G"</span></span></span><span>
</span><span>                     </span><span class="string"><span class="delete"><span class="delete">"snd`snd`edges G ⊆ nodes G"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ≡ nodes G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ≡ edges G"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>E_validD</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,e,v')∈E"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>E_valid</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>E_valid</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic operations on Graphs›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The empty graph.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"empty ≡ ⦇ nodes = {}, edges = {} ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adds a node to a graph.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>add_node</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"add_node v g ≡ ⦇ nodes = insert v (nodes g), edges=edges g⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletes a node from a graph. Also deletes all adjacent edges.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>delete_node</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_node v g ≡ ⦇ 
    nodes = nodes g - {v},   
    edges = edges g ∩ (-{v})×UNIV×(-{v})
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adds an edge to a graph.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>add_edge</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_edge v e v' g ≡ ⦇
    nodes = {v,v'} ∪ nodes g,
    edges = insert (v,e,v') (edges g)
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Deletes an edge from a graph.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>delete_edge</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_edge v e v' g ≡ ⦇
    nodes = nodes g, edges = edges g - {(v,e,v')} ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Successors of a node.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>succ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v,'w) graph ⇒ 'v ⇒ ('w×'v) set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ G v ≡ {(w,v'). (v,w,v')∈edges G}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Now follow some simplification lemmas.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_node_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph g"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph (add_node v g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>valid_graph</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_node_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_node_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph g"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph (delete_node v g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>valid_graph</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>delete_node_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_edge_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph g"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph (add_edge v e v' g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>valid_graph</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_edge_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph g"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_graph (delete_edge v e v' g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>valid_graph</span><span> </span><span>g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>delete_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (edges G) ⟹ finite (succ G v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"snd`edges G"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes empty = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edges_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"edges empty = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ empty v = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_def</span><span> </span><span>succ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_add_node</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes (add_node v g) = insert v (nodes g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_node_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_add_edge</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"nodes (add_edge v e v' g) = insert v (insert v' (nodes g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_edge_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edges_add_edge</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"edges (add_edge v e v' g) = insert (v,e,v') (edges g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_edge_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edges_add_node</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"edges (add_node v g) = edges g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_node_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_graph</span><span class="delimiter">)</span><span> </span><span>succ_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ G v ⊆ UNIV×V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_valid</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paths›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A path is represented by a list of adjacent edges.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'v</span><span class="delimiter">,</span><span class="tfree">'w</span><span class="delimiter">)</span><span> </span><span>path</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v×'w×'v) list"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>valid_graph</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following predicate describes a valid path:›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'v ⇒ ('v,'w) path ⇒ 'v ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v [] v' ⟷ v=v' ∧ v'∈V"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v ((v1,w,v2)#p) v' ⟷ v=v1 ∧ (v1,w,v2)∈E ∧ is_path v2 p v'"</span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v [] v ⟷ v∈V"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v [(v,w,v')] v' ⟷ (v,w,v')∈E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_memb</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v p v' ⟹ v∈V ∧ v'∈V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_split</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v (p1@p2) v' ⟷ (∃u. is_path v p1 u ∧ is_path u p2 v')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_path_split'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_path v (p1@(u,w,u')#p2) v' 
        ⟷ is_path v p1 u ∧ (u,w,u')∈E ∧ is_path u' p2 v'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_path_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set of intermediate vertices of a path. These are all vertices but
    the last one. Note that, if the last vertex also occurs earlier on the path,
    it is contained in ‹int_vertices›.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>int_vertices</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v,'w) path ⇒ 'v set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ≡ set (map fst p)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_vertices_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices [] = {}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices (vv#p) = insert (fst vv) (int_vertices p)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices (p1@p2) = int_vertices p1 ∪ int_vertices p2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>int_vertices_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_graph</span><span class="delimiter">)</span><span> </span><span>int_vertices_subset</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_path v p v' ⟹ int_vertices p ⊆ V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_vertices_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices p = {} ⟷ p=[]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Splitting Paths›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Split a path at the point where it first leaves the set ‹W›:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_graph</span><span class="delimiter">)</span><span> </span><span>path_split_set</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v p v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈W"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∉W"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>u</span><span> </span><span>w</span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p=p1@(u,w,u')#p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices p1 ⊆ W"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈W"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∉W"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>vv</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∈W›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v'∉W›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv=(v,w,u')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>REST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path u' p v'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vv</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distinguish wether the second node ‹u'› of the path is 
      in ‹W›. If yes, the proposition follows by the 
      induction hypothesis, otherwise it is straightforward, as
      the split takes place at the first edge of the path.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∈W"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>REST</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>uu</span><span> </span><span>ww</span><span> </span><span>uu'</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"p=p1@(uu,ww,uu')#p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices p1 ⊆ W"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uu ∈ W"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uu' ∉ W"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv#p1"</span></span></span><span> </span><span>uu</span><span> </span><span>ww</span><span> </span><span>uu'</span><span> </span><span>p2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∉W"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>u'</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Split a path at the point where it first enters the set ‹W›:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_graph</span><span class="delimiter">)</span><span> </span><span>path_split_set'</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v p v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈W"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_path v p1 u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_path u p2 v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"int_vertices p1 ⊆ -W"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈W"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈W"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>vv</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v'∈W›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹v∉W›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv=(v,w,u')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w,u')∈E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>REST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path u' p v'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vv</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Distinguish wether the second node ‹u'› of the path is 
        in ‹W›. If yes, the proposition is straightforward, otherwise,
        it follows by the induction hypothesis.
›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∈W"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[vv]"</span></span></span><span> </span><span>p</span><span> </span><span>u'</span><span class="delimiter">]</span><span> </span><span>REST</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u'∉W"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.hyps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>REST</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>u''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"is_path u' p1 u''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"is_path u'' p2 v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"int_vertices p1 ⊆ -W"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"u''∈W"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv#p1"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Split a path at the point where a given vertex is first visited:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>valid_graph</span><span class="delimiter">)</span><span> </span><span>path_split_vertex</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v p v'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈int_vertices p"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_path v p1 u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"u ∉ int_vertices p1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>thesis</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>vv</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span>u'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv=(v,w,u')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w,u')∈E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>REST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path u' p v'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vv</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u=v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vv#p"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u≠v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>REST</span><span class="delimiter">]</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"p=p1@p2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path u' p1 u"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u∉int_vertices p1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"vv#p1"</span></span></span><span> </span><span>p2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Weighted Graphs›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>valid_mgraph</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_graph</span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>G</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('v,'w::monoid_add) graph"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>path_weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('v,'w::monoid_add) path ⇒ 'w"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight p ≡ sum_list (map (fst ∘ snd) p)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
    lemma path_weight_alt: "path_weight p ≡ sum_list (map (fst ∘ snd) p)"
    unfolding path_weight_def foldl_conv_fold
    by (simp add: sum_list_foldl)
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_split</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(path_weight (p1@p2)::'w::monoid_add) = path_weight p1 + path_weight p2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>path_weight_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight [] = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>path_weight_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_weight_cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(path_weight (e#p)::'w::monoid_add) = fst (snd e) + path_weight p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>path_weight_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Weight">
<div class="head"><h1>Theory Weight</h1>
<span class="command">theory</span> <span class="name">Weight</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Complex_Main.html"><span class="name">Complex_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Weights for Dijkstra's Algorithm"</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Weight</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Complex_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we set up a type class for weights, and
  a typeclass for weights with an infinity element. The latter
  one is used internally in Dijkstra's algorithm.

  Moreover, we provide a datatype that adds an infinity element to a given
  base type.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Type Classes Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">=</span><span> </span><span>ordered_ab_semigroup_add</span><span> </span><span class="delimiter">+</span><span> </span><span>comm_monoid_add</span><span> </span><span class="delimiter">+</span><span> </span><span>linorder</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_nonneg_nonneg</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ a + b"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 + 0 ≤ a + b"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_nonpos_nonpos</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≤ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≤ 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b ≤ 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a + b ≤ 0 + 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_nonneg_eq_0_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x + y = 0 ⟷ x = 0 ∧ y = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.comm_neutral</span><span> </span><span>add.left_neutral</span><span> </span><span>add_left_mono</span><span> </span><span>antisym</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_incr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0≤b ⟹ a ≤ a+b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.comm_neutral</span><span> </span><span>add_left_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_incr_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0≤b ⟹ a ≤ b + a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_incr</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_not_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"0≤b ⟹ ¬ (a+b &lt; a)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"0≤a ⟹ ¬ (a+b &lt; b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_incr</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_incr_left</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>int</span><span> </span><span class="delimiter">::</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>rat</span><span> </span><span class="delimiter">::</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>real</span><span> </span><span class="delimiter">::</span><span> </span><span>weight</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>top</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>top_weight</span><span> </span><span class="delimiter">=</span><span> </span><span>order_top</span><span> </span><span class="delimiter">+</span><span> </span><span>weight</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inf_add_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a + top = top"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_add_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"top + a = top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>inf_add_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>top_unique</span><span> </span><span>less_top</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_less_inf</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ (a &lt; top) ⟷ a=top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Adding Infinity›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We provide a standard way to add an infinity element to any type.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>infty</span><span> </span><span class="delimiter">=</span><span> </span><span>Infty</span><span> </span><span class="delimiter">|</span><span> </span><span>Num</span><span> </span><span class="tfree">'a</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>val</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"val (Num d) = d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>num_val_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e≠Infty ⟹ Num (val e) = e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>NatB</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat infty"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>infty</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>weight</span><span class="delimiter">)</span><span> </span><span>top_weight</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0::'a infty) == Num 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"top ≡ Infty"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>less_eq_infty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less_eq Infty (Num _) ⟷ False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less_eq _ Infty ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less_eq (Num a) (Num b) ⟷ a≤b"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Infty≤a ⟷ a=Infty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>less_infty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less Infty _ ⟷ False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less (Num _) Infty ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"less (Num a) (Num b) ⟷ a&lt;b"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"less a Infty ⟷ a ≠ Infty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>plus_infty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plus _ Infty = Infty"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plus Infty _ = Infty"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"plus (Num a) (Num b) = Num (a+b)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"plus Infty a = Infty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro_classes</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>top_infty_def</span><span> </span><span>zero_infty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>add_right_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,y)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_eq_infty.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>linear</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Unboxing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Conversion between the constants defined by the
  typeclass, and the concrete functions on the @{typ "'a infty"} type. 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_inf_unbox</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num a ≠ top"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"top ≠ Num a"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Infty = top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>top_infty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_ord_unbox</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num a ≤ Num b ⟷ a ≤ b"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num a &lt; Num b ⟷ a &lt; b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_plus_unbox</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num a + Num b = Num (a+b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_zero_unbox</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num a = 0 ⟷ a = 0"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Num 0 = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zero_infty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>infty_unbox</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>infty_inf_unbox</span><span> </span><span>infty_zero_unbox</span><span> </span><span>infty_ord_unbox</span><span> </span><span>infty_plus_unbox</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_not_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"top≠(0::_ infty)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(0::_ infty)≠top"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>zero_infty_def</span><span> </span><span>top_infty_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>num_val_iff'</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e≠top ⟹ Num (val e) = e"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_neE</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦a≠Infty; ⋀d. a=Num d ⟹ P⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦a≠top; ⋀d. a=Num d ⟹ P⟧ ⟹ P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra">
<div class="head"><h1>Theory Dijkstra</h1>
<span class="command">theory</span> <span class="name">Dijkstra</span><br/>
<span class="keyword">imports</span> <a href="Graph.html"><span class="name">Graph</span></a> <a href="Dijkstra_Misc.html"><span class="name">Dijkstra_Misc</span></a> <a href="../Collections/Refine_Dflt_ICF.html"><span class="name">Refine_Dflt_ICF</span></a> <a href="Weight.html"><span class="name">Weight</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Dijkstra's Algorithm›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Graph</span><span> 
</span><span>  </span><span>Dijkstra_Misc</span><span> 
</span><span>  </span><span>Collections.Refine_Dflt_ICF</span><span>
</span><span>  </span><span>Weight</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory defines Dijkstra's algorithm. First, a correct result of 
  Dijkstra's algorithm w.r.t. a graph and a start vertex is specified. 
  Then, the refinement 
  framework is used to specify Dijkstra's Algorithm, prove it correct, and
  finally refine it to datatypes that are closer to an implementation than
  the original specification.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph's for Dijkstra's Algorithm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A graph annotated with weights.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>weighted_graph</span><span> </span><span class="delimiter">=</span><span> </span><span>valid_graph</span><span> </span><span>G</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight) graph"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Specification of Correct Result"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> </span><span>weighted_graph</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
      A result of Dijkstra's algorithm is correct, if it is a map from nodes 
      ‹v› to the shortest path from the start node ‹v0› to 
      ‹v›. Iff there is no such path, the node is not in the map.
›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_shortest_path_map</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ ('V ⇀ ('V,'W) path) ⇒ bool"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_map v0 res ≡ ∀v∈V. (case res v of
        None ⇒ ¬(∃p. is_path v0 p v) |
        Some p ⇒ is_path v0 p v 
                  ∧ (∀p'. is_path v0 p' v ⟶ path_weight p ≤ path_weight p')
      )"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    The following function returns the weight of an optional path,
    where ‹None› is interpreted as infinity.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>path_weight'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"path_weight' None = top"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"path_weight' (Some p) = Num (path_weight p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dijkstra's Algorithm"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    The state in the main loop of the algorithm consists of a workset 
    ‹wl› of vertexes that still need to be explored, and a map 
    ‹res› that contains the current shortest path for each vertex.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">)</span><span> </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V set) × ('V ⇀ ('V,'W) path)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    The preconditions of Dijkstra's algorithm, i.e., that it operates on a 
    valid and finite graph, and that the start node is a node of the graph,
    are summarized in a locale.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>Dijkstra</span><span> </span><span class="delimiter">=</span><span> </span><span>weighted_graph</span><span> </span><span>G</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight) graph"</span></span></span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>v0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'V</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite V"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite E"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>v0_in_V</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v0∈V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonneg_weights</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w,v')∈edges G ⟹ 0≤w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Paths have non-negative weights.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_nonneg_weight</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v p v' ⟹ 0 ≤ path_weight p"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>is_path.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Invariant of the main loop: 
    \begin{itemize}
      \item The workset only contains nodes of the graph.
      \item If the result set contains a path for a node, it is actually a path,
        and uses only intermediate vertices outside the workset.
      \item For all vertices outside the workset, the result map contains the 
        shortest path.
      \item For all vertices in the workset, the result map contains the
        shortest path among all paths that only use intermediate vertices outside
        the workset.
    \end{itemize}
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar σ ≡ let (wl,res)=σ in
    wl ⊆ V ∧
    (∀v∈V. ∀p. res v = Some p ⟶ is_path v0 p v ∧ int_vertices p ⊆ V-wl) ∧
    (∀v∈V-wl. ∀p. is_path v0 p v 
       ⟶ path_weight' (res v) ≤ path_weight' (Some p)) ∧
    (∀v∈wl. ∀p. is_path v0 p v ∧ int_vertices p ⊆ V-wl
       ⟶ path_weight' (res v) ≤ path_weight' (Some p)
    )
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sanity check: The invariant is strong enough to imply correctness 
    of result.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invar_imp_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar ({},res) ⟹ is_shortest_path_map v0 res"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvar_def</span><span> </span><span>is_shortest_path_map_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    The initial workset contains all vertices. The initial result maps
    ‹v0› to the empty path, and all other vertices to ‹None›.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dinit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) state nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dinit ≡ SPEC ( λ(wl,res) . 
        wl=V ∧ res v0 = Some [] ∧ (∀v∈V-{v0}. res v = None))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    The initial state satisfies the invariant.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dinit_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinit ≤ SPEC dinvar"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dinvar_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    In each iteration, the main loop of the algorithm pops a minimal node from
    the workset, and then updates the result map accordingly.
›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Pop a minimal node from the workset. The node is minimal in the sense that
    the length of the current path for that node is minimal.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pop_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) state ⇒ ('V × ('V,'W) state) nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"pop_min σ ≡ do {
      let (wl,res)=σ;
      ASSERT (wl≠{}); 
      v ← RES (least_map (path_weight' ∘ res) wl);
      RETURN (v,(wl-{v},res))
    }"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Updating the result according to a node ‹v› is done by checking, 
    for each successor node, whether the path over ‹v› is shorter than 
    the path currently stored into the result map.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>update_spec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ ('V,'W) state ⇒ ('V,'W) state ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ ∀v'∈V. 
      res' v' ∈ least_map path_weight' (
        { res v' } ∪ { Some (p@[(v,w,v')]) | p w. res v = Some p ∧ (v,w,v')∈E }
      )
     ⟧ ⟹ update_spec v (wl,res) (wl,res')"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    In order to ease the refinement proof, we will assert the following 
    precondition for updating.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_pre</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ ('V,'W) state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"update_pre v σ ≡ let (wl,res)=σ in v∈V 
      ∧ (∀v'∈V-wl. v'≠v ⟶ (∀p. is_path v0 p v' 
          ⟶ path_weight' (res v') ≤ path_weight' (Some p)))
      ∧ (∀v'∈V. ∀p. res v' = Some p ⟶ is_path v0 p v')"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ ('V,'W) state ⇒ ('V,'W) state nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"update v σ ≡ do {ASSERT (update_pre v σ); SPEC (update_spec v σ)}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we define Dijkstra's algorithm:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dijkstra</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dijkstra ≡ do {
       σ0←dinit; 
       (_,res) ← WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup>dinvar<span class="hidden">⇖</span></sup> (λ(wl,_). wl≠{}) 
            (λσ. 
              do { (v,σ') ← pop_min σ; update v σ' }
            )
            σ0;
       RETURN res }
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following theorem states (total) correctness of Dijkstra's 
    algorithm.›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dijkstra_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dijkstra ≤ SPEC (is_shortest_path_map v0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dijkstra_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pop_min_def</span><span> </span><span>update_def</span><span> </span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>refine_vcg</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span>
</span><span>      </span><span>WHILEIT_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"inv_image {(x,y). x&lt;y} (card ∘ fst)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>refine_vcg</span><span> 
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO/FIXME: Should we built in such massaging of the goal into 
        refine_rcg ?*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split_asm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
      ALLGOALS ((REPEAT_DETERM o Hypsubst.bound_hyp_subst_tac @{context})
      THEN' asm_full_simp_tac @{context}
      )›</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar (wl,res)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈least_map (path_weight' ∘ res) wl"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_elemD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ∀v'∈V - (wl-{v}). v' ≠ v ⟶ 
      (∀p. is_path v0 p v' ⟶ path_weight' (res v') ≤ Num (path_weight p))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dinvar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v'∈V. ∀p. res v'=Some p ⟶ is_path v0 p v'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dinvar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_pre v (wl-{v},res)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_pre_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>res</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar ({}, res)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_shortest_path_map v0 res"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>invar_imp_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf (inv_image {(x, y). x &lt; y} (card ∘ fst))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wf_less</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>v</span><span> </span><span>σ''</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>      </span><span>LM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈least_map (path_weight' ∘ res) wl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>UD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"update_spec v (wl-{v},res) σ''"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar (wl,res)"</span></span></span><span> 
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LM</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_elemD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>UD</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst σ'' = wl-{v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>update_spec.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite wl"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (fst σ'') &lt; card wl"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_gt_0_iff</span><span> </span><span>diff_Suc_less</span><span> </span><span>empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>res</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇀ ('V,'W) path"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = V ∧ res v0 = Some [] ∧ (∀v∈V-{v0}. res v = None)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar (V,res)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dinvar_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar (wl,res)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span>  
</span><span>      </span><span>WL_SUBSET</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wl ⊆ V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>PATH_VALID</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈V. ∀p. res v = Some p 
        ⟶ is_path v0 p v ∧ int_vertices p ⊆ V - wl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>NWL_MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈V - wl. ∀p. is_path v0 p v 
        ⟶ path_weight' (res v) ≤ Num (path_weight p)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>WL_MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈wl. ∀p. is_path v0 p v ∧ int_vertices p ⊆ V - wl 
        ⟶ path_weight' (res v) ≤ Num (path_weight p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span>σ''</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>V_LEAST</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈least_map (path_weight' o res) wl"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_spec v (wl-{v},res) σ''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>res'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ''=(wl-{v},res')"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CONSIDERED_NEW_PATHS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v'∈V. res' v' ∈ least_map path_weight' 
        (insert (res v') 
              ({ Some (p@[(v,w,v')]) | p w. res v = Some p ∧ (v,w,v')∈E }))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>update_spec.cases</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V_LEAST</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>V_MEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>least_map_elemD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvar σ''"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>dinvar_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>WL_SUBSET</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wl-{v} ⊆ V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀va∈V. ∀p. res' va = Some p 
        ⟶ is_path v0 p va ∧ int_vertices p ⊆ V - (wl - {v})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ballI</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v'</span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>V'_MEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v' = Some p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The new paths that we have added are valid and only use 
          intermediate vertices outside the workset. 
          
          This proof works as follows: A path @{term "res' v'"} is either
          the old path, or has been assembled as a path over node @{term v}.
          In the former case the proposition follows straightforwardly from the
          invariant for the old state. In the latter case we get, by the invariant
          for the old state, that the path over node @{term v} is valid. 
          Then, we observe that appending an edge to a valid path yields a valid 
          path again. Also, adding @{term v} as intermediate node is legal, as we 
          just removed @{term v} from the workset.
›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CONSIDERED_NEW_PATHS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v' ∈ (insert (res v') 
          ({ Some (p@[(v,w,v')]) | p w. res v = Some p ∧ (v,w,v')∈E }))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>least_map_elemD</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v' = res v'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V'_MEM</span><span> </span><span>PATH_VALID</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p v'"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ⊆ V - (wl-{v})"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>pv</span><span> </span><span>w</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v' = Some (pv@[(v,w,v')])"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res v = Some pv"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EDGE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w,v')∈E"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = pv@[(v,w,v')]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH_VALID</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>V_MEM</span><span> </span><span>WL_SUBSET</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span>PATHV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 pv v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IVV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices pv ⊆ V - wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p v'"</span></span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ⊆ V - (wl-{v})"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>EDGE</span><span> </span><span>V'_MEM</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p v'"</span></span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ⊆ V - (wl-{v})"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
        We show that already the {\em original} result stores the minimal 
        path for all vertices not in the {\em new} workset. 
        For vertices also not in the original workset, this follows 
        straightforwardly from the invariant.
        
        For the vertex ‹v›, that has been removed from the
        workset, we split a path ‹p'› to ‹v› at the point
        ‹u› where it first enters the original workset.  

        As we chose ‹v› to be the vertex in the workset with the
        minimal weight, its weight is less than the current weight of
        ‹u›.  As the vertices of the prefix of ‹p'› up to
        ‹u› are not in the workset, the current weight of
        ‹u› is less than the weight of the prefix of ‹p'›, and thus less than the weight of ‹p'›. 
        Together, the current weight of ‹v› is less than the weight of
        ‹p'›.›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>RES_MIN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈V - (wl - {v}). ∀p. is_path v0 p v 
        ⟶ path_weight' (res v) ≤ Num (path_weight p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ballI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v'</span><span> </span><span>p'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NOT_IN_WL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v' ∈ V - (wl - {v})"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p' v'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight p')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v' = v"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NE</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'≠v"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NWL_MIN</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v'</span><span class="delimiter">]</span><span> </span><span>NOT_IN_WL</span><span> </span><span>PATH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight p')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>EQ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'=v"</span></span></span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>path_split_set'</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>wl</span><span class="delimiter">]</span><span> </span><span>V_MEM</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p'=p1@p2"</span></span></span><span> 
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p1 u"</span></span></span><span> 
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path u p2 v'"</span></span></span><span> 
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P1V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices p1 ⊆ -wl"</span></span></span><span> 
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈wl"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>least_map_leD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>V_LEAST</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ path_weight' (res u)"</span></span></span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>WL_MIN</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span>P1</span><span> </span><span>P1V</span><span> </span><span>int_vertices_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P1</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res u) ≤ Num (path_weight p1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ≤ Num (path_weight p')"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>path_nonneg_weight</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P2</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span> </span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_0_right</span><span> </span><span>add_left_mono</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹With the previous statement, we easily show the
        third part of the invariant, as the new paths are not longer than the
        old ones.
›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v∈V - (wl - {v}). ∀p. is_path v0 p v 
        ⟶ path_weight' (res' v) ≤ Num (path_weight p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v'</span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NOT_IN_WL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v' ∈ V - (wl - {v})"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p v'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CONSIDERED_NEW_PATHS</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v'</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' (res v')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>RES_MIN</span><span> </span><span>NOT_IN_WL</span><span class="delimiter">]</span><span> </span><span>PATH</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ Num (path_weight p)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
        Finally, we have to show that for nodes on the worklist,
        the stored paths are not longer than any path using only nodes not
        on the worklist. Compared to the situation before the step, those
        path may also use the node ‹v›.
›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀va∈wl - {v}. ∀p. 
        is_path v0 p va ∧ int_vertices p ⊆ V - (wl - {v}) 
        ⟶ path_weight' (res' va) ≤ Num (path_weight p)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>ballI</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v'</span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IWS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈wl - {v}"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PATH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p v'"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VERTICES</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ⊆ V - (wl - {v})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IWS</span><span> </span><span>WL_SUBSET</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
            If the path is empty, the proposition follows easily from the
            invariant for the original states, as no intermediate nodes are 
            used at all.
›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p=[]"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CONSIDERED_NEW_PATHS</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' (res v')"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IWS</span><span> </span><span>WL_SUBSET</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices p ⊆ V-wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>WL_MIN</span><span> </span><span>IWS</span><span> </span><span>PATH</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight p)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>path_weight_empty</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ Num (path_weight p)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p1</span><span> </span><span>u</span><span> </span><span>w</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p = p1@[(u,w,v')]"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If the path is not empty, we pick the last but one vertex, and
            call it @{term u}.›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PATH</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PATH1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 p1 u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>EDGE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(u,w,v')∈E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>VERTICES</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V - (wl-{v})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>U_MEM</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹From @{thm [source] RES_MIN}, we know that @{term "res u"} holds
            the shortest path to @{term u}. Thus ‹p› is longer than the 
            path that is constructed by replacing the prefix of @{term p} by 
            {term "res u"}›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NIV</span><span> </span><span>RES_MIN</span><span> </span><span>PATH1</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Num (path_weight p1) ≥ path_weight' (res u)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pu</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res u = Some pu"</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"res u"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Num (path_weight p) ≥ path_weight' (res u) + Num w"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span> </span><span>add_right_mono</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res u) + Num w ≥ path_weight' (res' v')"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
              The remaining argument depends on wether @{term u} 
              equals @{term v}. 
              In the case @{term "u≠v"}, all vertices of @{term "res u"} are
              outside the original workset. Thus, appending the edge 
              @{term "(u,w,v')"} to @{term "res u"} yields a path to @{term v}
              over intermediate nodes only outside the workset. By the invariant
              for the original state, @{term "res v'"} is shorter than this path.
              As a step does not replace paths by longer ones, also 
              @{term "res' v'"} is shorter.

              In the case @{term "u=v"}, the step has
              considered the path to ‹v'› over ‹v›, and thus the
              result path is not longer.
›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"u=v"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"u≠v"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>NIV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NIV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u∈V-wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PATH_VALID</span><span> </span><span>U_MEM</span><span class="delimiter">]</span><span> </span><span>NIV'</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 pu u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>VU</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"int_vertices (pu@[(u,w,v')]) ⊆ V-wl"</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>EDGE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 (pu@[(u,w,v')]) v'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bspec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>WL_MIN</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>v'</span><span class="delimiter">]</span><span> </span><span>IWS</span><span> </span><span>VU</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight (pu@[(u,w,v')]))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res u) + Num w ≥ path_weight' (res v')"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CONSIDERED_NEW_PATHS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≥ path_weight' (res' v')"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="delimiter">(</span><span>order_trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"u=v"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CONSIDERED_NEW_PATHS</span><span> </span><span>EDGE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' (Some (pu@[(v,w,v')]))"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="delimiter">(</span><span>order_trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ Num (path_weight p)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ Num (path_weight p)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PATH</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Structural Refinement of Update›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Now that we have proved correct the initial version of the algorithm, we start
    refinement towards an efficient implementation.
›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    First, the update function is refined to iterate over each successor of the
    selected node, and update the result on demand.
›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uinvar</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'V set ⇒ _ ⇒ ('W×'V) set ⇒ ('V,'W) state ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res it σ ≡ let (wl',res')=σ in wl'=wl 
    ∧ (∀v'∈V. 
      res' v' ∈ least_map path_weight' (
        { res v' } ∪ { Some (p@[(v,w,v')]) | p w. res v = Some p 
          ∧ (w,v') ∈ succ G v - it }
      ))
    ∧ (∀v'∈V. ∀p. res' v' = Some p ⟶ is_path v0 p v')
    ∧ res' v = res v
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ ('V,'W) state ⇒ ('V,'W) state nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"update' v σ ≡ do {
      ASSERT (update_pre v σ);
      let (wl,res) = σ;
      let wv = path_weight' (res v);
      let pv = res v;
      FOREACH<span class="hidden">⇗</span><sup>uinvar v wl res<span class="hidden">⇖</span></sup> (succ G v) (λ(w',v') (wl,res). 
        if (wv + Num w' &lt; path_weight' (res v')) then do {
            ASSERT (v'∈wl ∧ pv≠None); 
            RETURN (wl,res(v' ↦ the pv@[(v,w',v')]))
        } else RETURN (wl,res)
      ) (wl,res)}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>update'_refines</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v'=v"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ'=σ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update' v' σ' ≤ ⇓Id (update v σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update'_def</span><span> </span><span>update_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (intro refine_vcg conjI)*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_pre v (wl,res)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res (succ G v) (wl,res)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uinvar_def</span><span> </span><span>update_pre_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>it</span><span> </span><span>wl'</span><span> </span><span>res'</span><span> </span><span>v'</span><span> </span><span>w'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>PRE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"update_pre v (wl,res)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res it (wl',res')"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>MEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(w',v')∈it"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>IT_SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it⊆ succ G v"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>LESS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v) + Num w' &lt; path_weight' (res' v')"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>update_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MEM</span><span> </span><span>IT_SS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_subset</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LESS</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res v = Some pv"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"res v"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"res v ≠ None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wl'=wl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v = res v"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>MEM</span><span> </span><span>IT_SS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EDGE</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,w',v')∈E"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 pv v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0≤w'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonneg_weights</span><span class="delimiter">[</span><span>OF</span><span> </span><span>EDGE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'≠v"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LESS</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v≠v'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈wl'"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∉wl'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V-wl"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∉wl"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>LESS</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' (res v')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PRE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>PW</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. is_path v0 p v' ⟹ 
        path_weight' (res v') ≤ path_weight' (Some p)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_pre_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_path v0 (pv@[(v,w',v')]) v'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PW</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res v') ≤ Num (path_weight (pv@[(v,w',v')]))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res (it-{(w',v')}) (wl',res'(v'↦the (res v)@[(v,w',v')]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(res'(v'↦the (res v)@[(v,w',v')])) v = res' v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v''</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>VMEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v''∈V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(res'(v'↦the (res v)@[(v,w',v')])) v'' ∈ least_map path_weight' (
          { res v'' } ∪ { Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - (it - {(w',v')}) }
          ) ∧ (∀p. (res'(v'↦the (res v)@[(v,w',v')])) v'' = Some p 
                ⟶ is_path v0 p v'')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v''=v'"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{ Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - (it - {(w',v')}) } = 
            { Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - it }"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>INV</span><span> </span><span>VMEM</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{ res v'' } ∪ { Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - (it - {(w',v')}) } =
          insert (Some (pv@[(v,w',v')])) (
            { res v'' } ∪ { Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - it })"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MEM</span><span> </span><span>IT_SS</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>EQ</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>least_map_insert_min</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r'</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"r' ∈ insert (res v') 
               {Some (pv @ [(v, w, v')]) |w. (w, v') ∈ succ G v ∧ (w, v') ∉ it}"</span></span></span><span>
</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LESS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"path_weight' (Some (pv @ [(v, w', v')])) &lt; path_weight' (res' v')"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>uinvar_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"res' v' ∈ least_map path_weight' (
                insert (res v') 
                {Some (pv @ [(v, w, v')]) |w. (w, v') ∈ succ G v ∧ (w, v') ∉ it}
              )"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' r'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>least_map_leD</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"path_weight' (Some (pv @ [(v, w', v')])) ≤ path_weight' r'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span>Let_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>it</span><span> </span><span>w'</span><span> </span><span>v'</span><span> </span><span>wl'</span><span> </span><span>res'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res it (wl',res')"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NLESS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ path_weight' (res v) + Num w' &lt; path_weight' (res' v')"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IN_IT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(w',v')∈it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IT_SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it ⊆ succ G v"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IN_IT</span><span> </span><span>IT_SS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(w',v')∈succ G v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈V"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_subset</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res (it - {(w',v')}) (wl',res')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"res v"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v''</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v''∈V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"res' v'' ∈ least_map path_weight' (
          { res v'' } ∪ { Some (p@[(v,w,v'')]) | p w. res v = Some p 
          ∧ (w,v'') ∈ succ G v - (it - {(w',v')}) }
          )"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ∈ least_map path_weight' ?S"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v''=v'"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>INV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>EQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?S = insert (Some (p@[(v,w',v')])) (
            { res v' } ∪ { Some (p@[(v,w,v'')]) | p w. res v = Some p 
                            ∧ (w,v'') ∈ succ G v - it }
            )"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NLESS</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"path_weight' (res' v') ≤ path_weight' (Some (p@[(v,w',v')]))"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>EQ</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>least_map_insert_nmin</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>INV</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>σ'</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvar v wl res {} σ'"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"update_spec v (wl,res) σ'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>σ'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>update_spec.intros</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (succ G v)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We integrate the new update function into the main algorithm:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dijkstra'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dijkstra' ≡ do {
      σ0 ← dinit; 
      (_,res) ← WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup>dinvar<span class="hidden">⇖</span></sup> (λ(wl,_). wl≠{}) 
            (λσ. do {(v,σ') ← pop_min σ; update' v σ'})
            σ0;
      RETURN res
    }"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dijkstra'_refines</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dijkstra' ≤ ⇓Id dijkstra"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>update'_refines</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ σ'. σ=σ' ⟹ pop_min σ ≤ ⇓Id (pop_min σ')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dijkstra_def</span><span> </span><span>dijkstra'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement to Cached Weights›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Next, we refine the data types of the workset and the result map.
  The workset becomes a map from nodes to their current weights.
  The result map stores, in addition to the shortest path, also the
  weight of the shortest path. Moreover, we store the shortest paths
  in reversed order, which makes appending new edges more effcient.

  These refinements allow to implement the workset as a priority queue,
  and save recomputation of the path weights in the inner loop of the
  algorithm.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">)</span><span> </span><span>mwl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ⇀ 'W infty)"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">)</span><span> </span><span>mres</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ⇀ (('V,'W) path × 'W))"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">)</span><span> </span><span>mstate</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) mwl × ('V,'W) mres"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Map a path with cached weight to one without cached weight.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mpath'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('V,'W) path × 'W) option ⇀ ('V,'W) path"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mpath' None = None"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mpath' (Some (p,w)) = Some p"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mpath_weight'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('V,'W) path × 'W) option ⇒ ('W::weight) infty"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mpath_weight' None = top"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mpath_weight' (Some (p,w)) = Num w"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>Dijkstra</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>αw</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'W) mwl ⇒ 'V set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"αw ≡ dom"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>αr</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'W) mres ⇒ 'V ⇀ ('V,'W) path"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"αr ≡ λres v. case res v of None ⇒ None | Some (p,w) ⇒ Some (rev p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>αs</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) mstate ⇒ ('V,'W) state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"αs ≡ map_prod αw αr"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Additional invariants for the new state. They guarantee that
    the cached weights are consistent.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>res_invarm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ⇀ (('V,'W) path×'W)) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"res_invarm res ≡ (∀v. case res v of 
        None ⇒ True | 
        Some (p,w) ⇒ w = path_weight (rev p))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dinvarm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) mstate ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"dinvarm σ ≡ let (wl,res) = σ in
      (∀v∈dom wl. the (wl v) = mpath_weight' (res v)) ∧ res_invarm res
    "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mpath_weight'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦dinvarm (wl,res)⟧ ⟹
    mpath_weight' (res v) = path_weight' (αr res v)
    "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvarm_def</span><span> </span><span>res_invarm_def</span><span> </span><span>αr_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mpath'_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦dinvarm (wl,res)⟧ ⟹
    mpath' (res v) = map_option rev (αr res v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvarm_def</span><span> </span><span>αr_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wl_weight_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvarm (wl,res)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WLV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wl v = Some w"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (αr res v) = w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span>WLV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w = mpath_weight' (res v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvarm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mpath_weight'_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"… = path_weight' (αr res v)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The initial state is constructed using an iterator:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mdinit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) mstate nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mdinit ≡ do {
      wl ← FOREACH V (λv wl. RETURN (wl(v↦Infty))) Map.empty;
      RETURN (wl(v0↦Num 0),[v0 ↦ ([],0)])
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mdinit_refines</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mdinit ≤ ⇓(build_rel αs dinvarm) dinit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mdinit_def</span><span> </span><span>dinit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>build_rel_SPEC</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>FOREACH_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λit wl. (∀v∈V-it. wl v = Some Infty) ∧ 
      dom wl = V-it"</span></span></span><span class="delimiter">]</span><span>
</span><span>           </span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>αs_def</span><span> </span><span>αw_def</span><span> </span><span>αr_def</span><span> </span><span>dinvarm_def</span><span> </span><span>res_invarm_def</span><span> </span><span>infty_unbox</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The new pop function:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>    </span><span>mpop_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) mstate ⇒ ('V × 'W infty × ('V,'W) mstate) nres"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mpop_min σ ≡ do {
      let (wl,res) = σ; 
      (v,w,wl')←prio_pop_min wl;
      RETURN (v,w,(wl',res))
    }"</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mpop_min_refines</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ (σ,σ') ∈ build_rel αs dinvarm ⟧ ⟹ 
      mpop_min σ ≤ 
       ⇓(build_rel 
          (λ(v,w,σ). (v,αs σ)) 
          (λ(v,w,σ). dinvarm σ ∧ w = mpath_weight' (snd σ v)))
      (pop_min σ')"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹The two algorithms are structurally different, so we use the
      nofail/inres method to prove refinement.›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mpop_min_def</span><span> </span><span>pop_min_def</span><span> </span><span>prio_pop_min_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pw_ref_I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span> </span><span>αs_def</span><span> </span><span>αw_def</span><span> </span><span>refine_rel_defs</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>prod.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dinvarm_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mpath_weight'_correct</span><span> </span><span>wl_weight_correct</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wl_weight_correct</span><span> 
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>least_map.intros</span><span>
</span><span>    </span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>restrict_map_eq</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The new update function:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvarm v wl res it σ ≡ 
    uinvar v wl res it (αs σ) ∧ dinvarm σ"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mupdate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'W infty ⇒ ('V,'W) mstate ⇒ ('V,'W) mstate nres"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mupdate v wv σ ≡ do {
      ASSERT (update_pre v (αs σ) ∧ wv=mpath_weight' (snd σ v));
      let (wl,res) = σ;
      let pv = mpath' (res v);
      FOREACH<span class="hidden">⇗</span><sup>uinvarm v (αw wl) (αr res)<span class="hidden">⇖</span></sup> (succ G v) (λ(w',v') (wl,res). 
        if (wv + Num w' &lt; mpath_weight' (res v')) then do {
          ASSERT (v'∈dom wl ∧ pv ≠ None);
          ASSERT (wv ≠ Infty);
          RETURN (wl(v'↦wv + Num w'),
                    res(v' ↦ ((v,w',v')#the pv,val wv + w') ))
        } else RETURN (wl,res)
        ) (wl,res)
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mupdate_refines</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SREF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ,σ')∈build_rel αs dinvarm"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wv = mpath_weight' (snd σ v)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>VV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'=v"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mupdate v wv σ ≤ ⇓(build_rel αs dinvarm) (update' v' σ')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>VV'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Show that IF-condition is a refinement:›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>wl'</span><span> </span><span>res'</span><span> </span><span>it</span><span> </span><span>w'</span><span> </span><span>v'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvarm v (αw wl) (αr res) it (wl',res')"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvarm (wl,res)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mpath_weight' (res v) + Num w' &lt; mpath_weight' (res' v') ⟷
        path_weight' (αr res v) + Num w' &lt; path_weight' (αr res' v')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvarm_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mpath_weight'_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>COND_refine</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹THEN-case:›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>wl</span><span> </span><span>res</span><span> </span><span>wl'</span><span> </span><span>res'</span><span> </span><span>it</span><span> </span><span>w'</span><span> </span><span>v'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>UINV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uinvarm v (αw wl) (αr res) it (wl',res')"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DINV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvarm (wl,res)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mpath_weight' (res v) + Num w' &lt; mpath_weight' (res' v')"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"path_weight' (αr res v) + Num w' &lt; path_weight' (αr res' v')"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V'MEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈αw wl'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"αr res v ≠ None"</span></span></span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NN</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pv</span><span> </span><span>wv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>ARV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"αr res v = Some (rev pv)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>RV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"res v = Some (pv,wv)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>αr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>DINV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wv = path_weight (rev pv)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dinvarm_def</span><span> </span><span>res_invarm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ARV</span><span> </span><span>RV</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V'MEM</span><span> </span><span>NN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v'∈dom wl'"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G1"</span></span></span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mpath' (res v) ≠ None"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G2"</span></span></span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>αw_def</span><span> </span><span>αr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. αw wl' = αw (wl'(v'↦x))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>αw_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mpath' (res v) = map_option rev (αr res v)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DINV</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mpath'_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"αw wl' = αw (wl'(v' ↦ mpath_weight' (res v) + Num w')) 
        ∧ (αr res')(v' ↦ the (αr res v)@[(v, w', v')]) 
           = αr (res'(v' ↦ ((v, w', v')#the (mpath' (res v)), 
                 val (mpath_weight' (res v)) + w')))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αr_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(dinvarm (wl'(v'↦mpath_weight' (res v) + Num w'),
                           res'(v' ↦ ((v,w',v') # the (mpath' (res v)),
                                       val (mpath_weight' (res v)) + w'
                                      ))))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UINV</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uinvarm_def</span><span> </span><span>dinvarm_def</span><span> </span><span>res_invarm_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_unbox</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?G1›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?G2›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?G3›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?G4›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>THEN_refine</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>refine2</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>inj_on_id</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>refine_rel_defs</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mupdate v wv σ ≤ ⇓(build_rel αs dinvarm) (update' v σ')"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SREF</span><span> </span><span>WV</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mupdate_def</span><span> </span><span>update'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αs_def</span><span> </span><span>uinvarm_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αs_def</span><span> </span><span>COND_refine</span><span> </span><span>THEN_refine</span><span class="delimiter">(</span><span>1</span><span>-</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>THEN_refine</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>αs_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">txt</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ELSE-case is trivial:›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we assemble the refined algorithm:›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mdijkstra</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"mdijkstra ≡ do {
      σ0 ← mdinit; 
      (_,res) ← WHILE<span class="hidden">⇩</span><sub>T</sub><span class="hidden">⇗</span><sup>dinvarm<span class="hidden">⇖</span></sup> (λ(wl,_). dom wl≠{}) 
            (λσ. do { (v,wv,σ') ← mpop_min σ; mupdate v wv σ' } )
            σ0;
      RETURN res
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mdijkstra_refines</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mdijkstra ≤ ⇓(build_rel αr res_invarm) dijkstra'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>mdinit_refines</span><span> </span><span>mpop_min_refines</span><span> </span><span>mupdate_refines</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mdijkstra_def</span><span> </span><span>dijkstra'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span>
</span><span>        </span><span>add</span><span class="delimiter">:</span><span> </span><span>αs_def</span><span> </span><span>αw_def</span><span> </span><span>dinvarm_def</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="GraphSpec">
<div class="head"><h1>Theory GraphSpec</h1>
<span class="command">theory</span> <span class="name">GraphSpec</span><br/>
<span class="keyword">imports</span> <a href="Graph.html"><span class="name">Graph</span></a> <a href="../Collections/Collections.html"><span class="name">Collections</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph Interface"</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GraphSpec</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span>Graph</span><span> 
</span><span>  </span><span>Collections.Collections</span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*"../Collections/Lib/Proper_Iterator"*)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*"../Refine_Monadic/Refine_Autodet"*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    This theory defines an ICF-style interface for graphs.
›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_α</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ bool"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ finite (nodes (α g))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ finite (edges (α g))"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ valid_graph (α g)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_empty</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_empty</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>empty_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"α (empty ()) = Graph.empty"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar (empty ())"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_add_node</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_add_node</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>add_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>add_node_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ invar (add_node v g)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ α (add_node v g) = Graph.add_node v (α g)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_delete_node</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_delete_node</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>delete_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>delete_node_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ invar (delete_node v g)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ α (delete_node v g) = Graph.delete_node v (α g)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_add_edge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒'W ⇒ 'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_add_edge</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>add_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'W ⇒ 'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>add_edge_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ invar (add_edge v e v' g)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ α (add_edge v e v' g) = Graph.add_edge v e v' (α g)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_delete_edge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒'W ⇒ 'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_delete_edge</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>delete_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V ⇒ 'W ⇒ 'V ⇒ 'G ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>delete_edge_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ invar (delete_edge v e v' g)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ α (delete_edge v e v' g) = Graph.delete_edge v e v' (α g)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'σ</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_nodes_it</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'σ) set_iterator"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_nodes_it_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'V list) set_iterator"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes_it g ≡ it_to_it (nodes_list_it g)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_nodes_it</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span class="delimiter">+</span><span> </span><span>graph_nodes_it_defs</span><span> </span><span>nodes_list_it</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invar</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'V list) set_iterator"</span></span></span><span>
</span><span>    </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nodes_list_it_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (nodes_list_it g) (Graph.nodes (α g))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_it_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (nodes_it g) (Graph.nodes (α g))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nodes_it_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nodes_list_it_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pi_nodes_it</span><span class="delimiter">[</span><span>icf_proper_iteratorI</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it (nodes_it S) (nodes_it S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nodes_it_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_it_proper</span><span class="delimiter">[</span><span>proper_it</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it' nodes_it nodes_it"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>proper_it'I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pi_nodes_it</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'σ</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_edges_it</span><span> 
</span><span>    </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ (('V×'W×'V),'σ) set_iterator"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_edges_it_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>edges_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges_it g ≡ it_to_it (edges_list_it g)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_edges_it</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span class="delimiter">+</span><span> </span><span>graph_edges_it_defs</span><span> </span><span>edges_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invar</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>edges_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span> 
</span><span>    </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>edges_list_it_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (edges_list_it g) (Graph.edges (α g))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edges_it_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (edges_it g) (Graph.edges (α g))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edges_it_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>edges_list_it_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pi_edges_it</span><span class="delimiter">[</span><span>icf_proper_iteratorI</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it (edges_it S) (edges_it S)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>edges_it_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>edges_it_proper</span><span class="delimiter">[</span><span>proper_it</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it' edges_it edges_it"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>proper_it'I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pi_edges_it</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'σ</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_succ_it</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ ('W×'V,'σ) set_iterator"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_succ_it_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>succ_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ ('W×'V,('W×'V) list) set_iterator"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ_it g v ≡ it_to_it (succ_list_it g v)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_succ_it</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span class="delimiter">+</span><span> </span><span>graph_succ_it_defs</span><span> </span><span>succ_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invar</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>succ_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ ('W×'V,('W×'V) list) set_iterator"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>succ_list_it_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (succ_list_it g v) (Graph.succ (α g) v)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_it_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (succ_it g v) (Graph.succ (α g) v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_it_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>succ_list_it_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pi_succ_it</span><span class="delimiter">[</span><span>icf_proper_iteratorI</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it (succ_it S v) (succ_it S v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_it_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_it_proper</span><span class="delimiter">[</span><span>proper_it</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"proper_it' (λS. succ_it S v) (λS. succ_it S v)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>proper_it'I</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pi_succ_it</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Adjacency Lists"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">)</span><span> </span><span>adj_list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'V list × ('V×'W×'V) list"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>adjl_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) adj_list ⇒ ('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"adjl_α l ≡ let (nl,el) = l in ⦇
      nodes = set nl ∪ fst`set el ∪ snd`snd`set el,
      edges = set el
    ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Do we have naming conventions for such a lemma ? *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adjl_is_graph</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph adjl_α (λ_. True)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjl_α_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_from_list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) adj_list ⇒ 'G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_from_list</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>from_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) adj_list ⇒ 'G"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>from_list_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar (from_list l)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"α (from_list l) = adjl_α l"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_to_list</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) adj_list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>graph_to_list</span><span> </span><span class="delimiter">=</span><span> </span><span>graph</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">constrains</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>to_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) adj_list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_list_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ adjl_α (to_list g) = α g"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Record Based Interface›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'W</span><span class="delimiter">,</span><span class="tfree">'G</span><span class="delimiter">)</span><span> </span><span>graph_ops</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>gop_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_α"</span></span></span><span>
</span><span>    </span><span>gop_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ bool"</span></span></span><span>
</span><span>    </span><span>gop_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_empty"</span></span></span><span>
</span><span>    </span><span>gop_add_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_add_node"</span></span></span><span>
</span><span>    </span><span>gop_delete_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_delete_node"</span></span></span><span>
</span><span>    </span><span>gop_add_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_add_edge"</span></span></span><span>
</span><span>    </span><span>gop_delete_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_delete_edge"</span></span></span><span>
</span><span>    </span><span>gop_from_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_from_list"</span></span></span><span>
</span><span>    </span><span>gop_to_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_to_list"</span></span></span><span>
</span><span>    </span><span>gop_nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'V list) set_iterator"</span></span></span><span>
</span><span>    </span><span>gop_edges_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span>
</span><span>    </span><span>gop_succ_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ ('W×'V,('W×'V) list) set_iterator"</span></span></span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>StdGraphDefs</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>graph_nodes_it_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"gop_nodes_list_it ops"</span></span></span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_edges_it_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"gop_edges_list_it ops"</span></span></span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_succ_it_defs</span><span> </span><span class="string"><span class="delete"><span class="delete">"gop_succ_list_it ops"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G,'m) graph_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ≡ gop_α ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>invar</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar ≡ gop_invar ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"empty ≡ gop_empty ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>add_node</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_node ≡ gop_add_node ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>delete_node</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_node ≡ gop_delete_node ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>add_edge</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_edge ≡ gop_add_edge ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>delete_edge</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delete_edge ≡ gop_delete_edge ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>from_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"from_list ≡ gop_from_list ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>to_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"to_list ≡ gop_to_list ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes_list_it ≡ gop_nodes_list_it ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>edges_list_it</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"edges_list_it ≡ gop_edges_list_it ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>succ_list_it</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ_list_it ≡ gop_succ_list_it ops"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>StdGraph</span><span> </span><span class="delimiter">=</span><span> </span><span>StdGraphDefs</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_empty</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>empty</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_add_node</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>add_node</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_delete_node</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>delete_node</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_add_edge</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>add_edge</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_delete_edge</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>delete_edge</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_from_list</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>from_list</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_to_list</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>to_list</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_nodes_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_edges_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>edges_list_it</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_succ_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>succ_list_it</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>correct</span><span> </span><span class="delimiter">=</span><span> </span><span>empty_correct</span><span> </span><span>add_node_correct</span><span> </span><span>delete_node_correct</span><span> 
</span><span>      </span><span>add_edge_correct</span><span> </span><span>delete_edge_correct</span><span>
</span><span>      </span><span>from_list_correct</span><span> </span><span>to_list_correct</span><span> 
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement Framework Bindings›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph_nodes_it</span><span class="delimiter">)</span><span> </span><span>nodes_it_is_iterator</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (nodes_it g) (nodes (α g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nodes_it_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph_edges_it</span><span class="delimiter">)</span><span> </span><span>edges_it_is_iterator</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (edges_it g) (edges (α g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>edges_it_correct</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph_succ_it</span><span class="delimiter">)</span><span> </span><span>succ_it_is_iterator</span><span class="delimiter">[</span><span>refine_transfer</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"invar g ⟹ set_iterator (succ_it g v) (Graph.succ (α g) v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>succ_it_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph</span><span class="delimiter">)</span><span> </span><span>drh</span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RELATES (build_rel α invar)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*text {* Autodet bindings: *}

  lemma (in graph_nodes_it) graph_nodes_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ 
      set_iterator (nodes_it g) (nodes g')"
    using nodes_it_correct by auto

  lemma (in graph_succ_it) graph_succ_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ DETREFe v Id v' ⟹
      set_iterator (succ_it g v) (succ g' v')"
    using succ_it_correct by auto

  lemma (in graph_edges_it) graph_edges_it_t[trans_uc]:
    "DETREFe g (build_rel α invar) g' ⟹ 
      set_iterator (edges_it g) (edges g')"
    using edges_it_correct by auto*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="GraphGA">
<div class="head"><h1>Theory GraphGA</h1>
<span class="command">theory</span> <span class="name">GraphGA</span><br/>
<span class="keyword">imports</span> <a href="GraphSpec.html"><span class="name">GraphSpec</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic Algorithms for Graphs›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GraphGA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>GraphSpec</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gga_from_list</span><span> </span><span class="delimiter">::</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_empty ⇒ ('V,'W,'G) graph_add_node 
      ⇒ ('V,'W,'G) graph_add_edge 
    ⇒ ('V,'W,'G) graph_from_list"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gga_from_list e a u l ≡ 
      let (nl,el) = l;
        g1 = foldl (λg v. a v g) (e ()) nl
      in foldl (λg (v,e,v'). u v e v' g) g1 el"</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gga_from_list_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_empty α invar e"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_add_node α invar a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_add_edge α invar u"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_from_list α invar (gga_from_list e a u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> 
</span><span>      </span><span>graph_empty</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>e</span><span> </span><span class="delimiter">+</span><span> 
</span><span>      </span><span>graph_add_node</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>a</span><span> </span><span class="delimiter">+</span><span> 
</span><span>      </span><span>graph_add_edge</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>u</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nl</span><span> </span><span>el</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g1 = foldl (λg v. a v g) (e ()) nl"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g2 = foldl (λg (v,e,v'). u v e v' g) g1 el"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g1 ∧ α g1 = ⦇ nodes = set nl, edges = {} ⦈"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g1_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nl</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>empty_correct</span><span> </span><span>add_node_correct</span><span> </span><span>empty_def</span><span> </span><span>add_node_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g2 
        ∧ α g2 = ⦇ nodes = set nl ∪ fst`set el ∪ snd`snd`set el,
                    edges = set el ⦈"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g2_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>el</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_edge_correct</span><span> </span><span>add_edge_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g2 ∧ adjl_α (nl,el) = α g2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjl_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gga_from_list_def</span><span> </span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>map_iterator_product</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gga_edges_it_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>graph_nodes_it_defs</span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph_succ_it_defs</span><span> </span><span>succ_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'V list,'G) graph_nodes_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>succ_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('W×'V) list,'G) graph_succ_it"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gga_edges_list_it</span><span> </span><span class="delimiter">::</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gga_edges_list_it G ≡ set_iterator_product 
        (nodes_it G) (succ_it G)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale_Code.lc_decl_del @{term gga_edges_list_it}›</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    (Record_Intf.add_unf_thms_global @{thms 
      gga_edges_it_defs.gga_edges_list_it_def[abs_def]
    })
›</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gga_edges_it</span><span> </span><span class="delimiter">=</span><span> </span><span>gga_edges_it_defs</span><span> </span><span>nodes_list_it</span><span> </span><span>succ_list_it</span><span> 
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_nodes_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>nodes_list_it</span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_succ_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>succ_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invar</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'V list,'G) graph_nodes_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>succ_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('W×'V) list,'G) graph_succ_it"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gga_edges_list_it_impl</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_edges_it α invar gga_edges_list_it"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_iterator_product_correct</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>        </span><span>nodes_it_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span> </span><span>succ_it_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (set_iterator_product (nodes_it g) (λv. succ_it g v))
        (SIGMA v:nodes (α g). succ (α g) v)
        "</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(SIGMA v:nodes (α g). succ (α g) v) = edges (α g)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>valid_graph.E_validD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>valid</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (gga_edges_list_it g) (edges (α g))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gga_edges_list_it_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gga_to_list_defs_loc</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>graph_nodes_it_defs</span><span> </span><span>nodes_list_it</span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_edges_it_defs</span><span> </span><span>edges_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'V list,'G) graph_nodes_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>edges_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gga_to_list</span><span> </span><span class="delimiter">::</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'G) graph_to_list"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"gga_to_list g ≡ 
        (nodes_it g (λ_. True) (#) [], edges_it g (λ_. True) (#) [])
      "</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>gga_to_list_loc</span><span> </span><span class="delimiter">=</span><span> </span><span>gga_to_list_defs_loc</span><span> </span><span>nodes_list_it</span><span> </span><span>edges_list_it</span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span>graph</span><span> </span><span>α</span><span> </span><span>invar</span><span> 
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_nodes_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>nodes_list_it</span><span>
</span><span>    </span><span class="delimiter">+</span><span> </span><span>graph_edges_it</span><span> </span><span>α</span><span> </span><span>invar</span><span> </span><span>edges_list_it</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ ('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invar</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nodes_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'V list,'G) graph_nodes_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>edges_list_it</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'G) graph_edges_it"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gga_to_list_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_to_list α invar gga_to_list"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar g"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>valid_graph</span><span> </span><span class="string"><span class="delete"><span class="delete">"α g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (nodes_it g (λ_. True) (#) []) = V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λit σ. set σ = V - it"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>set_iterator_rule_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nodes_it_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (edges_it g (λ_. True) (#) []) = E"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λit σ. set σ = E - it"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>set_iterator_rule_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>edges_it_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adjl_α (gga_to_list g) = α g"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>adjl_α_def</span><span> </span><span>gga_to_list_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>graph.equality</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>E_validD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="GraphByMap">
<div class="head"><h1>Theory GraphByMap</h1>
<span class="command">theory</span> <span class="name">GraphByMap</span><br/>
<span class="keyword">imports</span> <a href="GraphGA.html"><span class="name">GraphGA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementing Graphs by Maps›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>GraphByMap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>GraphSpec</span><span> 
</span><span>  </span><span>GraphGA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map_Sigma M1 F2 ≡ {
  (x,y). ∃v. M1 x = Some v ∧ y∈F2 v
}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_Sigma_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_Sigma M1 F2 = Sigma (dom M1) (λx.
  F2 (the (M1 x)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_Sigma_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to Misc *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ranE</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v∈ran m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m k = Some v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ran_restrictD</span><span> </span><span>restrict_map_self</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_bind_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Option.bind x f = (case x of None ⇒ None | Some v ⇒ f v)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>GraphByMapDefs</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>m1</span><span class="delimiter">:</span><span> </span><span>StdMapDefs</span><span> </span><span>m1_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>m2</span><span class="delimiter">:</span><span> </span><span>StdMapDefs</span><span> </span><span>m2_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>s3</span><span class="delimiter">:</span><span> </span><span>StdSetDefs</span><span> </span><span>s3_ops</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m1_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'m2,'m1,_) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m2_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'s3,'m2,_) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s3_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('W,'s3,_) set_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m1_mvif</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ⇒ 'm2 ⇀ 'm2) ⇒ 'm1 ⇒ 'm1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_α</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_α m1 ≡
    ⦇ nodes = dom (m1.α m1),
      edges = {(v,w,v'). 
        ∃m2 s3. m1.α m1 v = Some m2 
          ∧ m2.α m2 v' = Some s3
          ∧ w∈s3.α s3
      }
    ⦈"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar m1 ≡
    m1.invar m1 ∧
    (∀m2∈ran (m1.α m1). m2.invar m2 ∧
      (∀s3∈ran (m2.α m2). s3.invar s3)
    ) ∧ valid_graph (gbm_α m1)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_empty"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_empty ≡ m1.empty"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_add_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_add_node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_add_node v g ≡ case m1.lookup v g of
    None ⇒ m1.update v (m2.empty ()) g |
    Some _ ⇒ g"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_delete_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_delete_node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_delete_node v g ≡ let g=m1.delete v g in
    m1_mvif (λ_ m2. Some (m2.delete v m2)) g"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_add_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_add_edge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_add_edge v e v' g ≡ 
    let g = (case m1.lookup v' g of 
      None ⇒ m1.update v' (m2.empty ()) g | Some _ ⇒ g
    ) in
    case m1.lookup v g of 
      None ⇒ (m1.update v (m2.sng v' (s3.sng e)) g) |
      Some m2 ⇒ (case m2.lookup v' m2 of
        None ⇒ m1.update v (m2.update v' (s3.sng e) m2) g |
        Some s3 ⇒ m1.update v (m2.update v' (s3.ins e s3) m2) g)
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_delete_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'m1) graph_delete_edge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_delete_edge v e v' g ≡
    case m1.lookup v g of
      None ⇒ g |
      Some m2 ⇒ (
        case m2.lookup v' m2 of
          None ⇒ g |
          Some s3 ⇒ m1.update v (m2.update v' (s3.delete e s3) m2) g
      )
    "</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_nodes_list_it</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,'V list,'m1) graph_nodes_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_nodes_list_it g ≡ map_iterator_dom (m1.iteratei g)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale_Code.lc_decl_del @{term gbm_nodes_list_it}›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_edges_list_it</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('V×'W×'V) list,'m1) graph_edges_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_edges_list_it g ≡ set_iterator_image 
      (λ((v1,m1),(v2,m2),w). (v1,w,v2)) 
      (set_iterator_product (m1.iteratei g) 
        (λ(v,m2). set_iterator_product 
          (m2.iteratei m2) (λ(w,s3). s3.iteratei s3)))
    "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale_Code.lc_decl_del @{term gbm_edges_list_it}›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>gbm_succ_list_it</span><span> </span><span class="delimiter">::</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"('V,'W,('W×'V) list,'m1) graph_succ_it"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gbm_succ_list_it g v ≡ case m1.lookup v g of
    None ⇒ set_iterator_emp |
    Some m2 ⇒ 
      set_iterator_image (λ((v',m2),w). (w,v')) 
        (set_iterator_product (m2.iteratei m2) (λ(v',s). s3.iteratei s))
    "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale_Code.lc_decl_del @{term gbm_succ_list_it}›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gbm_from_list ≡ gga_from_list gbm_empty gbm_add_node gbm_add_edge"</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_nodes_list_it_unf</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"it_to_it (gbm_nodes_list_it g) 
    ≡ map_iterator_dom (it_to_it (m1.list_it g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_fold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_nodes_list_it_def</span><span> </span><span>m1.iteratei_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_edges_list_it_unf</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"it_to_it (gbm_edges_list_it g) 
    ≡ set_iterator_image 
      (λ((v1,m1),(v2,m2),w). (v1,w,v2)) 
      (set_iterator_product (it_to_it (m1.list_it g)) 
        (λ(v,m2). set_iterator_product 
          (it_to_it (m2.list_it m2)) (λ(w,s3). (it_to_it (s3.list_it s3)))))
    "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_fold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_edges_list_it_def</span><span> 
</span><span>      </span><span>m1.iteratei_def</span><span> </span><span>m2.iteratei_def</span><span> </span><span>s3.iteratei_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_succ_list_it_unf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"it_to_it (gbm_succ_list_it g v) ≡ 
    case m1.lookup v g of
      None ⇒ set_iterator_emp |
      Some m2 ⇒ 
        set_iterator_image (λ((v',m2),w). (w,v')) 
          (set_iterator_product (it_to_it (m2.list_it m2)) 
            (λ(v',s). (it_to_it (s3.list_it s))))
      "</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>it_to_it_fold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_succ_list_it_def</span><span> 
</span><span>      </span><span>m2.iteratei_def</span><span> </span><span>s3.iteratei_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>icf_proper_iteratorI</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> 
</span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMapDefs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_nodes_it_defs</span><span> </span><span>gbm_nodes_list_it</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMapDefs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_edges_it_defs</span><span> </span><span>gbm_edges_list_it</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMapDefs</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_succ_it_defs</span><span> </span><span>gbm_succ_list_it</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMapDefs</span><span> 
</span><span>  </span><span class="delimiter">&lt;</span><span> </span><span>gga_to_list_defs_loc</span><span> </span><span>gbm_nodes_list_it</span><span> </span><span>gbm_edges_list_it</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>GraphByMapDefs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>icf_rec_def</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_ops ≡ ⦇
    gop_α = gbm_α,
    gop_invar = gbm_invar,
    gop_empty = gbm_empty,
    gop_add_node = gbm_add_node,
    gop_delete_node = gbm_delete_node,
    gop_add_edge = gbm_add_edge,
    gop_delete_edge = gbm_delete_edge,
    gop_from_list = gbm_from_list,
    gop_to_list = gga_to_list,
    gop_nodes_list_it = gbm_nodes_list_it,
    gop_edges_list_it = gbm_edges_list_it,
    gop_succ_list_it  = gbm_succ_list_it
    ⦈"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Locale_Code.lc_decl_del @{term gbm_ops}›</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>GraphByMap</span><span> </span><span class="delimiter">=</span><span> </span><span>GraphByMapDefs</span><span> </span><span>m1_ops</span><span> </span><span>m2_ops</span><span> </span><span>s3_ops</span><span> </span><span>m1_mvif</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>m1</span><span class="delimiter">:</span><span> </span><span>StdMap</span><span> </span><span>m1_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>m2</span><span class="delimiter">:</span><span> </span><span>StdMap</span><span> </span><span>m2_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>s3</span><span class="delimiter">:</span><span> </span><span>StdSet</span><span> </span><span>s3_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>m1</span><span class="delimiter">:</span><span> </span><span>map_value_image_filter</span><span> </span><span>m1.α</span><span> </span><span>m1.invar</span><span> </span><span>m1.α</span><span> </span><span>m1.invar</span><span> </span><span>m1_mvif</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m1_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'m2,'m1,_) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m2_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'s3,'m2,_) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s3_ops</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('W,'s3,_) set_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m1_mvif</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ⇒ 'm2 ⇀ 'm2) ⇒ 'm1 ⇒ 'm1"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_invar_split</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"m1.invar g"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀v m2. m1.α g v = Some m2 ⟹ m2.invar m2"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀v m2 v' s3. m1.α g v = Some m2 ⟹ m2.α m2 v' = Some s3 ⟹ s3.invar s3"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"valid_graph (gbm_α g)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMap</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph</span><span> </span><span>gbm_α</span><span> </span><span>gbm_invar</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>vg</span><span class="delimiter">:</span><span> </span><span>valid_graph</span><span> </span><span class="string"><span class="delete"><span class="delete">"(gbm_α g)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gbm_invar_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>vg.E_valid</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` edges (gbm_α g) ⊆ nodes (gbm_α g)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"snd ` snd ` edges (gbm_α g) ⊆ nodes (gbm_α g)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (nodes (gbm_α g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span>gbm_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (edges (gbm_α g))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_imageD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λ(v,e,v'). (v,v',e)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"map_Sigma (m1.α g) (λm2. map_Sigma (m2.α m2) (s3.α))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_Sigma_def</span><span> </span><span>gbm_α_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>map_Sigma_alt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>finite_SigmaI</span><span> </span><span>inj_onI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>GraphByMap</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_empty_impl</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_empty gbm_α gbm_invar gbm_empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_invar_def</span><span> </span><span>gbm_empty_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>Graph.empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_add_node_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_add_node gbm_α gbm_invar gbm_add_node"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_α (gbm_add_node v g) = add_node v (gbm_α g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_add_node_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> </span><span>add_node_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar (gbm_add_node v g)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_add_node_def</span><span> </span><span>add_node_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> </span><span>add_node_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_delete_node_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_delete_node gbm_α gbm_invar gbm_delete_node"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_α (gbm_delete_node v g) = delete_node v (gbm_α g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_delete_node_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>restrict_map_def</span><span> </span><span>option_bind_alt</span><span>
</span><span>        </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> </span><span>m1.map_value_image_filter_correct</span><span>
</span><span>        </span><span>delete_node_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span> </span><span>option.split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar (gbm_delete_node v g)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_delete_node_def</span><span> </span><span>delete_node_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>restrict_map_def</span><span> </span><span>option_bind_alt</span><span>
</span><span>        </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> </span><span>m1.map_value_image_filter_correct</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span> </span><span>option.split_asm</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_add_edge_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_add_edge gbm_α gbm_invar gbm_add_edge"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>v</span><span> </span><span>e</span><span> </span><span>v'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_α (gbm_add_edge v e v' g) = add_edge v e v' (gbm_α g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_add_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> 
</span><span>        </span><span>Let_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>add_edge_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Strange: This is at the limit of auto's capabilities:
        Iterated auto [] works., but auto on all goals seems not to
        terminate. Using fastforce instead.
        *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> 
</span><span>      </span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar (gbm_add_edge v e v' g)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_add_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span>
</span><span>        </span><span>Let_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_delete_edge_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"graph_delete_edge gbm_α gbm_invar gbm_delete_edge"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>v</span><span> </span><span>e</span><span> </span><span>v'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_α (gbm_delete_edge v e v' g) = delete_edge v e v' (gbm_α g)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_delete_edge_def</span><span> </span><span>delete_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span> 
</span><span>        </span><span>Let_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar (gbm_delete_edge v e v' g)"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_α_def</span><span> </span><span>gbm_delete_edge_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.correct</span><span> </span><span>m2.correct</span><span> </span><span>s3.correct</span><span>
</span><span>        </span><span>Let_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>if_split_asm</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ranE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_nodes_list_it_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_nodes_it gbm_α gbm_invar gbm_nodes_list_it"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>MINV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_op_invar m1_ops g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>map_iterator_dom_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>m1.iteratei_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>MINV</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (gbm_nodes_list_it g) (nodes (gbm_α g))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_nodes_list_it_def</span><span> </span><span>gbm_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_edges_list_it_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_edges_it gbm_α gbm_invar gbm_edges_list_it"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m1.invar g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v m2. (v,m2)∈map_to_set (m1.α g) ⟹ m2.invar m2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span>map_to_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v m2 v' s. ⟦
      (v,m2)∈map_to_set (m1.α g); 
      (v',s)∈map_to_set (m2.α m2)⟧ 
      ⟹ s3.invar s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span>map_to_set_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (gbm_edges_list_it g) (edges (gbm_α g))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_edges_list_it_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_iterator_image_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_iterator_product_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>m1.iteratei_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>I1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_iterator_product_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>I2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_iterator (m2.iteratei ba) 
        (map_op_α m2_ops (snd (aa,ba)))"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>m2.iteratei_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (s3.iteratei bb) 
        (s3.α (snd (ab,bb)))"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s3.iteratei_correct</span><span> </span><span>I3</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>map_to_set_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>gbm_α_def</span><span> </span><span>map_to_set_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_succ_list_it_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_succ_it gbm_α gbm_invar gbm_succ_list_it"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>g</span><span> </span><span>v</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gbm_invar g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>I1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m1.invar g"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (gbm_succ_list_it g v) (succ (gbm_α g) v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m1.lookup v g"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(succ (gbm_α g) v) = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span> </span><span>gbm_α_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m1.lookup_correct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>None</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_succ_list_it_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_iterator_emp_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>m2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m2.invar m2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gbm_invar_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>m1.lookup_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>I2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v' s. (v', s) ∈ map_to_set (map_op_α m2_ops m2) ⟹ s3.invar s"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_invar_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_to_set_def</span><span> </span><span>ran_def</span><span> </span><span>m1.lookup_correct</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Some</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_succ_list_it_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_iterator_image_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_iterator_product_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>m2.iteratei_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_iterator (s3.iteratei b) (s3.α (snd (aa, b)))"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>s3.iteratei_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>I2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>map_to_set_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>succ_def</span><span> </span><span>gbm_α_def</span><span> </span><span>map_to_set_def</span><span> </span><span>m1.lookup_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_from_list_impl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_from_list gbm_α gbm_invar gbm_from_list"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gbm_from_list_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gga_from_list_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gbm_empty_impl</span><span> </span><span>gbm_add_node_impl</span><span> </span><span>gbm_add_edge_impl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMap</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_nodes_it</span><span> </span><span>gbm_α</span><span> </span><span>gbm_invar</span><span> </span><span>gbm_nodes_list_it</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gbm_nodes_list_it_impl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMap</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_edges_it</span><span> </span><span>gbm_α</span><span> </span><span>gbm_invar</span><span> </span><span>gbm_edges_list_it</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gbm_edges_list_it_impl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMap</span><span> </span><span class="delimiter">&lt;</span><span> </span><span>graph_succ_it</span><span> </span><span>gbm_α</span><span> </span><span>gbm_invar</span><span> </span><span>gbm_succ_list_it</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gbm_succ_list_it_impl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>GraphByMap</span><span>
</span><span>  </span><span class="delimiter">&lt;</span><span> </span><span>gga_to_list_loc</span><span> </span><span>gbm_α</span><span> </span><span>gbm_invar</span><span> </span><span>gbm_nodes_list_it</span><span> </span><span>gbm_edges_list_it</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>GraphByMap</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_to_list_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_to_list gbm_α gbm_invar gga_to_list"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gga_to_list_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gbm_ops_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"StdGraph gbm_ops"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>StdGraph.intro</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>icf_rec_unf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>icf_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>gbm_empty_impl</span><span> </span><span>gbm_add_node_impl</span><span> </span><span>gbm_delete_node_impl</span><span> 
</span><span>      </span><span>gbm_add_edge_impl</span><span> </span><span>gbm_delete_edge_impl</span><span> </span><span>gbm_from_list_impl</span><span>
</span><span>      </span><span>gbm_to_list_impl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  (Record_Intf.add_unf_thms_global @{thms 
    GraphByMapDefs.gbm_nodes_list_it_unf
    GraphByMapDefs.gbm_edges_list_it_unf
    GraphByMapDefs.gbm_succ_list_it_unf
  })
›</span></span></span><span> 
</span><span>   
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="HashGraphImpl">
<div class="head"><h1>Theory HashGraphImpl</h1>
<span class="command">theory</span> <span class="name">HashGraphImpl</span><br/>
<span class="keyword">imports</span> <a href="GraphByMap.html"><span class="name">GraphByMap</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graphs by Hashmaps›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HashGraphImpl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>GraphByMap</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Abbreviation: hlg
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'V</span><span class="delimiter">,</span><span class="tfree">'E</span><span class="delimiter">)</span><span> </span><span>hlg</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('V,('V,'E ls) HashMap.hashmap) HashMap.hashmap"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hh_mvif</span><span class="delimiter">:</span><span> </span><span>g_value_image_filter_loc</span><span> </span><span>hm_ops</span><span> </span><span>hm_ops</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hlg_gbm</span><span class="delimiter">:</span><span> </span><span>GraphByMap</span><span> </span><span>hm_ops</span><span> </span><span>hm_ops</span><span> </span><span>ls_ops</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hh_mvif.g_value_image_filter"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>icf_rec_def</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hlg_ops ≡ hlg_gbm.gbm_ops"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hlg</span><span class="delimiter">:</span><span> </span><span>StdGraph</span><span> </span><span>hlg_ops</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hlg_ops_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hlg_gbm.gbm_ops_impl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ICF_Tools.revert_abbrevs "HashGraphImpl.hlg"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>map_iterator_dom_def</span><span> </span><span>set_iterator_image_def</span><span>
</span><span>  </span><span>set_iterator_image_filter_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>test_codegen</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test_codegen ≡ (
  hlg.empty,
  hlg.add_node,
  hlg.delete_node,
  hlg.add_edge,
  hlg.delete_edge,
  hlg.from_list,
  hlg.to_list,
  hlg.nodes_it,
  hlg.edges_it,
  hlg.succ_it
)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>test_codegen</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra_Impl">
<div class="head"><h1>Theory Dijkstra_Impl</h1>
<span class="command">theory</span> <span class="name">Dijkstra_Impl</span><br/>
<span class="keyword">imports</span> <a href="Dijkstra.html"><span class="name">Dijkstra</span></a> <a href="HashGraphImpl.html"><span class="name">HashGraphImpl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Dijkstra's-Algorithm using the ICF›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra_Impl</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Dijkstra</span><span> 
</span><span>  </span><span>GraphSpec</span><span> 
</span><span>  </span><span>HashGraphImpl</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this second refinement step, we use interfaces from the 
  Isabelle Collection Framework (ICF) to implement the priority queue and
  the result map. Moreover, we use a graph interface (that is not contained 
  in the ICF, but in this development) to represent the graph.

  The data types of the first refinement step were designed to fit the
  abstract data types of the used ICF-interfaces, which makes this refinement
  quite straightforward.

  Finally, we instantiate the ICF-interfaces by concrete implementations, 
  obtaining an executable algorithm, for that we generate code using 
  Isabelle/HOL's code generator.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dijkstraC</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>g</span><span class="delimiter">:</span><span> </span><span>StdGraph</span><span> </span><span>g_ops</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span>mr</span><span class="delimiter">:</span><span> </span><span>StdMap</span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>qw</span><span class="delimiter">:</span><span> </span><span>StdUprio</span><span> </span><span>qw_ops</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight,'G,'moreg) graph_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V, (('V,'W) path × 'W), 'mr,'more_mr) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"αsc == map_prod qw.α mr.α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dinvarC_add == λ(wl,res). qw.invar wl ∧ mr.invar res"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdinit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ ('qw×'mr) nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cdinit g v0 ≡ do {
      wl ← FOREACH (nodes (g.α g)) 
        (λv wl. RETURN (qw.insert wl v Weight.Infty)) (qw.empty ());
      RETURN (qw.insert wl v0 (Num 0),mr.sng v0 ([],0))
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cpop_min</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('qw×'mr) ⇒ ('V×'W infty×('qw×'mr)) nres"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cpop_min σ ≡ do {
      let (wl,res) = σ; 
      let (v,w,wl')=qw.pop wl;
      RETURN (v,w,(wl',res))
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cupdate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'G ⇒ 'V ⇒ 'W infty ⇒ ('qw×'mr) ⇒ ('qw×'mr) nres"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cupdate g v wv σ = do {
      ASSERT (dinvarC_add σ);
      let (wl,res)=σ;
      let pv=mpath' (mr.lookup v res);
      FOREACH (succ (g.α g) v) (λ(w',v') (wl,res).
        if (wv + Num w' &lt; mpath_weight' (mr.lookup v' res)) then do {
          RETURN (qw.insert wl v' (wv+Num w'), 
                  mr.update v' ((v,w',v')#the pv,val wv + w') res)
        } else RETURN (wl,res)
      ) (wl,res)
    }"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdijkstra</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cdijkstra g v0 ≡ do {
      σ0 ← cdinit g v0; 
      (_,res) ← WHILE<span class="hidden">⇩</span><sub>T</sub> (λ(wl,_). ¬ qw.isEmpty wl) 
            (λσ. do { (v,wv,σ') ← cpop_min σ; cupdate g v wv σ' } )
            σ0;
      RETURN res
    }"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dijkstraC_fixg</span><span> </span><span class="delimiter">=</span><span> </span><span>dijkstraC</span><span> </span><span>g_ops</span><span> </span><span>mr_ops</span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>Dijkstra</span><span> </span><span>ga</span><span> </span><span>v0</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight,'G,'moreg) graph_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V, (('V,'W) path × 'W), 'mr,'more_mr) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ga</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W) graph"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'V</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'G</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>g_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g,ga)∈br g.α g.invar"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>cdinit_refines</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>inj_on_id</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cdinit g v0 ≤⇓?R mdinit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_rel</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdinit_def</span><span> </span><span>mdinit_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αsc_def</span><span> </span><span>dinvarC_add_def</span><span> </span><span>refine_rel_defs</span><span>
</span><span>      </span><span>qw.correct</span><span> </span><span>mr.correct</span><span> </span><span>refine_hsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>cpop_min_refines</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(σ,σ') ∈ build_rel αsc dinvarC_add
      ⟹ cpop_min σ ≤ ⇓?R (mpop_min σ')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cpop_min_def</span><span> </span><span>mpop_min_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αsc_def</span><span> </span><span>dinvarC_add_def</span><span> </span><span>refine_hsimp</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αsc_def</span><span> </span><span>dinvarC_add_def</span><span> </span><span>refine_hsimp</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>cupdate_refines</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>inj_on_id</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(σ,σ')∈build_rel αsc dinvarC_add ⟹ v=v' ⟹ wv=wv' ⟹ 
    cupdate g v wv σ ≤ ⇓?R (mupdate v' wv' σ')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cupdate_def</span><span> </span><span>mupdate_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_rel</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_dref_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>αsc_def</span><span> </span><span>dinvarC_add_def</span><span> </span><span>refine_rel_defs</span><span> 
</span><span>      </span><span>qw.correct</span><span> </span><span>mr.correct</span><span> </span><span>refine_hsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdijkstra_refines</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cdijkstra g v0 ≤ ⇓(build_rel mr.α mr.invar) mdijkstra"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cdinit_refines</span><span> </span><span>cpop_min_refines</span><span> </span><span>cupdate_refines</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdijkstra_def</span><span> </span><span>mdijkstra_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_rel</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>prod.split_asm</span><span> 
</span><span>        </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qw.correct</span><span> </span><span>mr.correct</span><span> </span><span>dinvarC_add_def</span><span> </span><span>αsc_def</span><span> </span><span>refine_hsimp</span><span>
</span><span>          </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>dijkstraC</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>g.nodes_it_is_iterator</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>idijkstra_refines_aux</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g.invar g"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN ?f ≤ cdijkstra g v0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdijkstra_def</span><span> </span><span>cdinit_def</span><span> </span><span>cpop_min_def</span><span> </span><span>cupdate_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_transfer</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>idijkstra</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="var">?v0.0</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>idijkstra_refines_aux</span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idijkstra_refines</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g.invar g"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (idijkstra g v0) ≤ cdijkstra g v0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>idijkstra.refine</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  The following theorem states correctness of the algorithm independent
  from the refinement framework.

  Intuitively, the first goal states that the abstraction of the returned 
  result is correct, the second goal states that the result
  datastructure satisfies its invariant, and the third goal states 
  that the cached weights in the returned result are correct.

  Note that this is the main theorem for a user of Dijkstra's algorithm in some 
  bigger context. It may also be specialized for concrete instances of the
  implementation, as exemplarily done below.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dijkstraC_fixg</span><span class="delimiter">)</span><span> </span><span>idijkstra_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weighted_graph.is_shortest_path_map ga v0 (αr (mr.α (idijkstra g v0)))"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mr.invar (idijkstra g v0)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dijkstra.res_invarm (mr.α (idijkstra g v0))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>g_rel</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.invar g"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>idijkstra_refines</span><span class="delimiter">[</span><span>OF</span><span> </span><span>I</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cdijkstra_refines</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mdijkstra_refines</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (idijkstra g v0) ≤ 
    ⇓(build_rel (αr ∘ mr.α) (λm. mr.invar m ∧ res_invarm (mr.α m))) 
      dijkstra'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>conc_fun_chain</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>br_chain</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dijkstra'_refines</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dijkstra_correct</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span> </span><span class="var">?G2</span><span> </span><span class="var">?G3</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>RETURN_ref_SPECD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dijkstraC</span><span class="delimiter">)</span><span> </span><span>idijkstra_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.invar g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ nodes (g.α g)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonneg_weights</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v w v'. (v,w,v')∈edges (g.α g) ⟹ 0≤w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weighted_graph.is_shortest_path_map (g.α g) v0 
      (Dijkstra.αr (mr.α (idijkstra g v0)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dijkstra.res_invarm (mr.α (idijkstra g v0))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>gv</span><span class="delimiter">:</span><span> </span><span>valid_graph</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.α g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g.valid</span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>dcg</span><span class="delimiter">:</span><span> </span><span>dijkstraC_fixg</span><span> </span><span>g_ops</span><span> </span><span>mr_ops</span><span> </span><span>qw_ops</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.α g"</span></span></span><span> </span><span>v0</span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dijkstraC_fixg.intro</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hlg.finite</span><span> </span><span>INV</span><span> </span><span>V0</span><span> </span><span>hlg_ops_def</span><span> 
</span><span>      </span><span>nonneg_weights</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dcg.idijkstra_correct</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span> </span><span class="var">?G2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Example instantiation with HashSet.based graph, 
  red-black-tree based result map, and finger-tree based priority queue.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hrf</span><span class="delimiter">:</span><span> </span><span>dijkstraC</span><span> </span><span>hlg_ops</span><span> </span><span>rm_ops</span><span> </span><span>aluprioi_ops</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrf_dijkstra ≡ hrf.idijkstra"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hrf_dijkstra_correct</span><span> </span><span class="delimiter">=</span><span> </span><span>hrf.idijkstra_correct</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hrf_dijkstra_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>OCaml</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>Scala</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrfn_dijkstra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat) hlg ⇒ _"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrfn_dijkstra ≡ hrf_dijkstra"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrfn_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hrfn_dijkstra_correct</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>hrf_dijkstra_correct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tvar">?'a</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tvar">?'b</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>hrfn_dijkstra_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>hrfn_dijkstra</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>hlg.from_list</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"test_hrfn_dijkstra 
  ≡ rm.to_list 
    (hrfn_dijkstra (hlg.from_list ([0..&lt;4],[(0,3,1),(0,4,2),(2,1,3),(1,4,3)])) 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  @{code test_hrfn_dijkstra}

›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Dijkstra_Impl_Adet">
<div class="head"><h1>Theory Dijkstra_Impl_Adet</h1>
<span class="command">theory</span> <span class="name">Dijkstra_Impl_Adet</span><br/>
<span class="keyword">imports</span> <a href="Dijkstra.html"><span class="name">Dijkstra</span></a> <a href="HashGraphImpl.html"><span class="name">HashGraphImpl</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Implementation of Dijkstra's-Algorithm using Automatic Determinization›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Dijkstra_Impl_Adet</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>Dijkstra</span><span> 
</span><span>  </span><span>GraphSpec</span><span> 
</span><span>  </span><span>HashGraphImpl</span><span> 
</span><span>  </span><span>Collections.Refine_Dflt_ICF</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinity›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>infty_rel_internal_def</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"infty_rel R ≡ {(Num a, Num a')| a a'. (a,a')∈R} ∪ {(Infty,Infty)}"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_rel_def</span><span class="delimiter">[</span><span>refine_rel_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨R⟩infty_rel = {(Num a, Num a')| a a'. (a,a')∈R} ∪ {(Infty,Infty)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_internal_def</span><span> </span><span>relAPP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_relI</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Infty,Infty)∈⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a,a')∈R ⟹ (Num a, Num a')∈⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_relE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(x,x')∈⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=Infty"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x'=Infty"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x=Num a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x'=Num a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,a')∈R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_rel_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Infty,x')∈⟨R⟩infty_rel ⟷ x'=Infty"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x,Infty)∈⟨R⟩infty_rel ⟷ x=Infty"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Num a, Num a')∈⟨R⟩infty_rel ⟷ (a,a')∈R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_rel_sv</span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"single_valued R ⟹ single_valued (⟨R⟩infty_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>single_valuedI</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>single_valuedD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_rel_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Id⟩infty_rel = Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>infty_relE</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>i_infty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interface ⇒ interface"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rel_intf</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>REL_INTFI</span><span class="delimiter">[</span><span>of</span><span> </span><span>infty_rel</span><span> </span><span>i_infty</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>autoref_infty</span><span class="delimiter">[</span><span>param</span><span class="delimiter">,</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Infty,Infty)∈⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(Num,Num)∈R→⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(case_infty,case_infty)∈Rr→(R→Rr)→⟨R⟩infty_rel→Rr"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(rec_infty,rec_infty)∈Rr→(R→Rr)→⟨R⟩infty_rel→Rr"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_relD</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_Infty x ≡ case x of Infty ⇒ True | _ ⇒ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pat_is_Infty</span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x=Infty ≡ (OP is_Infty :::<span class="hidden">⇩</span><sub>i</sub> ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_infty →<span class="hidden">⇩</span><sub>i</sub> i_bool)$x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Infty=x ≡ (OP is_Infty :::<span class="hidden">⇩</span><sub>i</sub> ⟨I⟩<span class="hidden">⇩</span><sub>i</sub>i_infty →<span class="hidden">⇩</span><sub>i</sub> i_bool)$x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_reflection</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>infty.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>autoref_is_Infty</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(is_Infty, is_Infty)∈⟨R⟩infty_rel → bool_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>infty.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"infty_eq eq v1 v2 ≡ 
  case (v1,v2) of
    (Infty,Infty) ⇒ True
  | (Num a1, Num a2) ⇒ eq a1 a2
  | _ ⇒ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_eq_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ GEN_OP eq (=) (R→R→bool_rel) ⟧ 
  ⟹ (infty_eq eq,(=))∈⟨R⟩infty_rel→⟨R⟩infty_rel→bool_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_eq_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>infty.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_relD</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>infty_relE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_eq_expand</span><span class="delimiter">[</span><span>autoref_struct_expand</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(=) = infty_eq (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>infty_eq_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>infty.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>autoref_syn</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_val_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦SIDE_PRECOND (x≠Infty); (xi,x)∈⟨R⟩infty_rel⟧ 
  ⟹ (val xi,(OP val ::: ⟨R⟩infty_rel → R) $ x)∈R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>infty_relE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>infty_plus</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"infty_plus pl a b ≡ case (a,b) of (Num a, Num b) ⇒ Num (pl a b) | _ ⇒ Infty "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_plus_param</span><span class="delimiter">[</span><span>param</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(infty_plus,infty_plus) ∈ (R→R→R) → ⟨R⟩infty_rel → ⟨R⟩infty_rel → ⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_plus_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_plus_eq_plus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"infty_plus (+) = (+)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infty_plus_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>infty.split</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infty_plus_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"GEN_OP pl (+) (R→R→R) 
  ⟹ (infty_plus pl,(+)) ∈ ⟨R⟩infty_rel → ⟨R⟩infty_rel → ⟨R⟩infty_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>infty_plus_eq_plus</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>parametricity</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Graph›</span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>i_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"interface ⇒ interface ⇒ interface"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>graph_more_rel_internal_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"graph_more_rel Rm Rv Rw ≡ { (g,g'). 
    (graph.nodes g, graph.nodes g')∈⟨Rv⟩set_rel     
  ∧ (graph.edges g, graph.edges g')∈⟨⟨Rv,⟨Rw,Rv⟩prod_rel⟩prod_rel⟩set_rel
  ∧ (graph.more g, graph.more g')∈Rm}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>graph_more_rel_def</span><span class="delimiter">[</span><span>refine_rel_defs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨Rm,Rv,Rw⟩graph_more_rel ≡ { (g,g'). 
    (graph.nodes g, graph.nodes g')∈⟨Rv⟩set_rel     
  ∧ (graph.edges g, graph.edges g')∈⟨⟨Rv,⟨Rw,Rv⟩prod_rel⟩prod_rel⟩set_rel
  ∧ (graph.more g, graph.more g')∈Rm}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>relAPP_def</span><span> </span><span>graph_more_rel_internal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"graph_rel ≡ ⟨unit_rel⟩graph_more_rel"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>graph_rel_def</span><span> </span><span class="delimiter">=</span><span> </span><span>graph_more_rel_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Rm</span><span class="delimiter">=</span><span>unit_rel</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>graph_rel_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Id,Id⟩graph_rel = Id"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_rel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>graph_more_rel_sv</span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦single_valued Rm; single_valued Rv; single_valued Rw⟧ 
  ⟹ single_valued (⟨Rm,Rv,Rw⟩graph_more_rel)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>graph_more_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>single_valuedI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>graph.equality</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>single_valuedD</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>tagged_solver</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_itype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"graph.nodes ::<span class="hidden">⇩</span><sub>i</sub> ⟨Iv,Iw⟩<span class="hidden">⇩</span><sub>i</sub>i_graph →<span class="hidden">⇩</span><sub>i</sub> ⟨Iv⟩<span class="hidden">⇩</span><sub>i</sub>i_set"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>is_map_to_sorted_list_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes_to_list g ≡ it_to_sorted_list (λ_ _. True) (graph.nodes g)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_to_list_itype</span><span class="delimiter">[</span><span>autoref_itype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes_to_list ::<span class="hidden">⇩</span><sub>i</sub> ⟨Iv,Iw⟩<span class="hidden">⇩</span><sub>i</sub>i_graph →<span class="hidden">⇩</span><sub>i</sub> ⟨⟨Iv⟩<span class="hidden">⇩</span><sub>i</sub>i_list⟩<span class="hidden">⇩</span><sub>i</sub>i_nres"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_to_list_pat</span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it_to_sorted_list (λ_ _. True) (graph.nodes g) ≡ nodes_to_list g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nodes_to_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ_to_list g v ≡ it_to_sorted_list (λ_ _. True) (Graph.succ g v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_to_list_itype</span><span class="delimiter">[</span><span>autoref_itype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"succ_to_list ::<span class="hidden">⇩</span><sub>i</sub> ⟨Iv,Iw⟩<span class="hidden">⇩</span><sub>i</sub>i_graph →<span class="hidden">⇩</span><sub>i</sub> Iv →<span class="hidden">⇩</span><sub>i</sub> ⟨⟨⟨Iw,Iv⟩<span class="hidden">⇩</span><sub>i</sub>i_prod⟩<span class="hidden">⇩</span><sub>i</sub>i_list⟩<span class="hidden">⇩</span><sub>i</sub>i_nres"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>succ_to_list_pat</span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"it_to_sorted_list (λ_ _. True) (Graph.succ g v) ≡ succ_to_list g v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_to_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>graph</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_def_internal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel Rv Rw ≡ br α invar O ⟨Rv,Rw⟩graph_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Rv,Rw⟩rel ≡ br α invar O ⟨Rv,Rw⟩graph_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>relAPP_def</span><span> </span><span>rel_def_internal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨Id,Id⟩rel = br α invar"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_sv</span><span class="delimiter">[</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦single_valued Rv; single_valued Rw⟧ ⟹ single_valued (⟨Rv,Rw⟩rel)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>tagged_solver</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rel_intf</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>REL_INTFI</span><span class="delimiter">[</span><span>of</span><span> </span><span>rel</span><span> </span><span>i_graph</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph_nodes_it</span><span class="delimiter">)</span><span> </span><span>autoref_nodes_it</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ID</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id Rv"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs. RETURN (it_to_list nodes_it s),nodes_to_list) ∈ ⟨Rv,Rw⟩rel → ⟨⟨Rv⟩list_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nodes_to_list_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ID</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rv = Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,s')∈⟨Rv,Rw⟩rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes s' = nodes (α s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>br_def</span><span> </span><span>graph_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodes (α s) = set l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it_to_list nodes_it s = l"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>it_to_list_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nodes_it_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>set_iterator_def</span><span> </span><span>set_iterator_genord_def</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>foldli_snoc_id</span><span> </span><span>self_append_conv2</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (it_to_list nodes_it s)
          ≤ ⇓ (⟨Rv⟩list_rel) (it_to_sorted_list (λ_ _. True) (nodes s'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>it_to_sorted_list_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>graph_succ_it</span><span class="delimiter">)</span><span> </span><span>autoref_succ_it</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ID</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id Rv"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PREFER_id Rw"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λs v. RETURN (it_to_list (λs. succ_it s v) s),succ_to_list) 
    ∈ ⟨Rv,Rw⟩rel → Rv → ⟨⟨⟨Rw,Rv⟩prod_rel⟩list_rel⟩nres_rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_to_list_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>v</span><span> </span><span>v'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ID</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rv = Id"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rw=Id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(v,v')∈Rv"</span></span></span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v'=v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s,s')∈⟨Rv,Rw⟩rel"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invar s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Graph.succ s' = Graph.succ (α s)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>br_def</span><span> </span><span>graph_rel_def</span><span> </span><span>succ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ (α s) v = set l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"it_to_list (λs. succ_it s v) s = l"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>it_to_list_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>succ_it_correct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>set_iterator_def</span><span> </span><span>set_iterator_genord_def</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>foldli_snoc_id</span><span> </span><span>self_append_conv2</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (it_to_list (λs. succ_it s v) s)
          ≤ ⇓ (⟨⟨Rw,Rv⟩prod_rel⟩list_rel) (it_to_sorted_list (λ_ _. True) (succ s' v'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>it_to_sorted_list_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Refinement›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dijkstraC</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>g</span><span class="delimiter">:</span><span> </span><span>StdGraph</span><span> </span><span>g_ops</span><span> </span><span class="delimiter">+</span><span> 
</span><span>  </span><span>mr</span><span class="delimiter">:</span><span> </span><span>StdMap</span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>qw</span><span class="delimiter">:</span><span> </span><span>StdUprio</span><span> </span><span>qw_ops</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight,'G,'moreg) graph_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V, (('V,'W) path × 'W), 'mr,'more_mr) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dijkstraC_fixg</span><span> </span><span class="delimiter">=</span><span> </span><span>dijkstraC</span><span> </span><span>g_ops</span><span> </span><span>mr_ops</span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>Dijkstra</span><span> </span><span>ga</span><span> </span><span>v0</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V,'W::weight,'G,'moreg) graph_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mr_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V, (('V,'W) path × 'W), 'mr,'more_mr) map_ops_scheme"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>qw_ops</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ga</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('V,'W) graph"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v0"</span></span></span><span class="delimiter">::</span><span class="tfree">'V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'G</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ga_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g,ga)∈br g.α g.invar"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v_rel ≡ Id :: ('V×'V) set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w_rel ≡ Id :: ('W×'W) set"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>i_node</span><span> </span><span class="delimiter">::</span><span> </span><span>interface</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i_node ≡ undefined"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>i_weight</span><span> </span><span class="delimiter">::</span><span> </span><span>interface</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i_weight ≡ undefined"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rel_intf</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>REL_INTFI</span><span class="delimiter">[</span><span>of</span><span> </span><span>v_rel</span><span> </span><span>i_node</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_rel_intf</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>REL_INTFI</span><span class="delimiter">[</span><span>of</span><span> </span><span>w_rel</span><span> </span><span>i_weight</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_plus_autoref</span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(0,0) ∈ w_rel"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((+),(+)) ∈ w_rel → w_rel → w_rel"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((+),(+)) ∈ ⟨w_rel⟩infty_rel → ⟨w_rel⟩infty_rel → ⟨w_rel⟩infty_rel"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"((&lt;),(&lt;)) ∈ ⟨w_rel⟩infty_rel → ⟨w_rel⟩infty_rel → bool_rel"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(g,ga)∈⟨v_rel,w_rel⟩g.rel"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ga_trans</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>g.rel_def</span><span class="delimiter">)</span><span>
</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(v0,v0)∈v_rel"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>mpath_weight'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>autoref_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(mpath_weight',mpath_weight') 
      ∈ ⟨⟨v_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel×<span class="hidden">⇩</span><sub>r</sub>v_rel⟩list_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel⟩option_rel → ⟨w_rel⟩infty_rel"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(mpath', mpath') 
      ∈ ⟨⟨v_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel×<span class="hidden">⇩</span><sub>r</sub>v_rel⟩list_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel⟩option_rel 
        → ⟨⟨v_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel×<span class="hidden">⇩</span><sub>r</sub>v_rel⟩list_rel⟩option_rel"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>mdinit</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_tyrel</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span>v_rel</span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span>w_rel</span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨w_rel⟩infty_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨v_rel,⟨w_rel⟩infty_rel⟩qw.rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨v_rel,⟨v_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel×<span class="hidden">⇩</span><sub>r</sub>v_rel⟩list_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel⟩mr.rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>ty_REL</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⟨v_rel×<span class="hidden">⇩</span><sub>r</sub>w_rel×<span class="hidden">⇩</span><sub>r</sub>v_rel⟩list_rel"</span></span></span><span class="delimiter">]</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>autoref_op_pat</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>uprio_pats</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'e</span><span> </span><span class="delimiter">=</span><span> </span><span class="tfree">'V</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'W infty"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span>cdijkstra_refines_aux</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?c::?'c, 
      mdijkstra
    ) ∈ ?R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>mdijkstra_def</span><span> </span><span>mdinit_def</span><span> </span><span>mpop_min_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>mupdate_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span> </span><span class="delimiter">=</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>op_map_empty_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">'b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('V×'W×'V) list × 'W"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>op_uprio_empty_def</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"'V"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">'b</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'W infty"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*using [[autoref_trace_intf_unif]]*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>autoref_trace_failed_id</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>autoref_monadic</span><span> </span><span class="delimiter">(</span><span>plain</span><span class="delimiter">,</span><span>trace</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>dijkstraC</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>cdijkstra</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="var">?v0.0</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>dijkstraC_fixg.cdijkstra_refines_aux</span><span>
</span><span>    </span><span class="delimiter">[</span><span>of</span><span> </span><span>g_ops</span><span> </span><span>mr_ops</span><span> </span><span>qw_ops</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>cdijkstra</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>dijkstraC_fixg</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>cdijkstra</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>mdijkstra</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdijkstra_refines</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"RETURN (cdijkstra g v0) ≤ ⇓(build_rel mr.α mr.invar) mdijkstra"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdijkstra.refine</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdijkstra_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"weighted_graph.is_shortest_path_map ga v0 (αr (mr.α (cdijkstra g v0)))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mr.invar (cdijkstra g v0)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"res_invarm (mr.α (cdijkstra g v0))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cdijkstra_refines</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>mdijkstra_refines</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RETURN (cdijkstra g v0) ≤ 
      ⇓(build_rel (αr ∘ mr.α) (λm. mr.invar m ∧ res_invarm (mr.α m))) 
        dijkstra'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>conc_fun_chain</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>br_chain</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dijkstra'_refines</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dijkstra_correct</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span> </span><span class="var">?G2</span><span> </span><span class="var">?G3</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>RETURN_ref_SPECD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>dijkstraC</span><span class="delimiter">)</span><span> </span><span>cdijkstra_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.invar g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v0 ∈ nodes (g.α g)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nonneg_weights</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v w v'. (v,w,v')∈edges (g.α g) ⟹ 0≤w"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weighted_graph.is_shortest_path_map (g.α g) v0 
      (Dijkstra.αr (mr.α (cdijkstra g v0)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dijkstra.res_invarm (mr.α (cdijkstra g v0))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>hlgv</span><span class="delimiter">:</span><span> </span><span>valid_graph</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.α g"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g.valid</span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>dc</span><span class="delimiter">:</span><span> </span><span>dijkstraC_fixg</span><span> </span><span>g_ops</span><span> </span><span>mr_ops</span><span> </span><span>qw_ops</span><span> </span><span class="string"><span class="delete"><span class="delete">"g.α g"</span></span></span><span> </span><span>v0</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> 
</span><span>      </span><span>add</span><span class="delimiter">:</span><span> </span><span>hlg.finite</span><span> </span><span>INV</span><span> </span><span>V0</span><span> </span><span>hlg_ops_def</span><span> </span><span>nonneg_weights</span><span> </span><span>refine_rel_defs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dc.cdijkstra_correct</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?G1</span><span> </span><span class="var">?G2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Example instantiation with HashSet.based graph, 
  red-black-tree based result map, and finger-tree based priority queue.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.open_block</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>hrf</span><span class="delimiter">:</span><span> </span><span>dijkstraC</span><span> </span><span>hlg_ops</span><span> </span><span>rm_ops</span><span> </span><span>aluprioi_ops</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span>Locale_Code.close_block</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrf_dijkstra ≡ hrf.cdijkstra"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hrf_dijkstra_correct</span><span> </span><span class="delimiter">=</span><span> </span><span>hrf.cdijkstra_correct</span><span class="delimiter">[</span><span>folded</span><span> </span><span>hrf_dijkstra_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>OCaml</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrf_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>Scala</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrfn_dijkstra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat) hlg ⇒ _"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hrfn_dijkstra ≡ hrf_dijkstra"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>hrfn_dijkstra</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hrfn_dijkstra_correct</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>hrf_dijkstra_correct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tvar">?'a</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tvar">?'b</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>hrfn_dijkstra_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Test">
<div class="head"><h1>Theory Test</h1>
<span class="command">theory</span> <span class="name">Test</span><br/>
<span class="keyword">imports</span> <a href="Dijkstra_Impl_Adet.html"><span class="name">Dijkstra_Impl_Adet</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Performance Test›</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Test</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Dijkstra_Impl_Adet</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this theory, we test our implementation of Dijkstra's algorithm for larger,
  randomly generated graphs.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Simple linear congruence generator for (low-quality) random numbers:"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lcg_next s = ((81::nat)*s + 173) mod 268435456"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Generate a complete graph over the given number of vertices,
    with random weights:"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ran_graph</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat ⇒ (nat list×(nat × nat × nat) list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ran_graph vertices seed == 
    ([0::nat..&lt;vertices],fst 
     (while (λ (g,v,s). v &lt; vertices)
     (λ (g,v,s). 
     let (g'',v'',s'') = (while (λ (g',v',s'). v' &lt; vertices)
      (λ (g',v',s'). ((v,s',v')#g',v'+1,lcg_next s'))
      (g,0,s))
     in (g'',v+1,s''))
     ([],0,lcg_next seed)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  To experiment with the exported code, we fix the node type to natural numbers,
  and add a from-list conversion:
›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>nat_res</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,((nat,nat) path × nat)) rm"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>nat_list_res</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat × (nat,nat) path × nat) list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nat_dijkstra</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat) hlg ⇒ nat ⇒ nat_res"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat_dijkstra ≡ hrfn_dijkstra"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hlg_from_list_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat,nat) adj_list ⇒(nat,nat) hlg"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hlg_from_list_nat ≡ hlg.from_list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>nat_res_to_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_res ⇒ nat_list_res"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_res_to_list ≡ rm.to_list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nat_res_to_list (nat_dijkstra (hlg_from_list_nat (ran_graph 4 8912)) 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
let
  (* Configuration of test: *)
  val vertices = @{code nat_of_integer} 1000; (* Number of vertices *)
  val seed = @{code nat_of_integer} 123454; (* Seed for random number generator *)
  val cfg_print_paths = true; (* Whether to output complete paths *)
  val cfg_print_res = true; (* Whether to output result at all *)

  (* Internals *)
  fun string_of_edge (u,(w,v)) = let
    val u = @{code integer_of_nat} u;
    val w = @{code integer_of_nat} w;
    val v = @{code integer_of_nat} v;
  in
    "(" ^ string_of_int u ^ "," ^ string_of_int w ^ "," ^ string_of_int v ^ ")"
  end

  fun print_entry (dest,(path,weight)) = let
    val dest = @{code integer_of_nat} dest;
    val weight = @{code integer_of_nat} weight;
  in
    writeln (string_of_int dest ^ ": " ^ string_of_int weight ^
      ( if cfg_print_paths then 
          " via [" ^ commas (map string_of_edge (rev path)) ^ "]"
        else ""
      )
    )
  end

  fun print_res [] = ()
    | print_res (a::l) = let val _ = print_entry a in print_res l end;

  val start = Time.now();
  val graph = @{code hlg_from_list_nat} (@{code ran_graph} vertices seed);
  val rt1 = Time.toMilliseconds (Time.now() - start);

  val start = Time.now();
  val res = @{code nat_dijkstra} graph (@{code nat_of_integer} 0);
  val rt2 = Time.toMilliseconds (Time.now() - start);
in
  writeln (string_of_int (@{code integer_of_nat} vertices) ^ " vertices: " 
  ^ string_of_int rt2 ^ " ms + "
  ^ string_of_int rt1 ^ " ms to create graph = " 
  ^ string_of_int (rt1+rt2) ^ " ms");

  if cfg_print_res then
    print_res (@{code nat_res_to_list} res)
  else ()
end;
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>