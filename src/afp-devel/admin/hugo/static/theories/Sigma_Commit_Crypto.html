<div id="Commitment_Schemes">
<div class="head">
<h1>Theory Commitment_Schemes</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Commitment Schemes›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A commitment scheme is a two party Cryptographic protocol run between a committer and a verifier.
They allow the committer to commit to a chosen value while at a later time reveal the value. A commitment
scheme is composed of three algorithms, the key generation, the commitment and the verification algorithms.
 
The two main properties of commitment schemes are hiding and binding.›</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Hiding is the property that the commitment leaks no information about the committed value, and 
binding is the property that the committer cannot reveal their a different message to the one they
committed to; that is they are bound to their commitment. We follow the game based approach \cite{DBLP:journals/iacr/Shoup04} to
define security. A game is played between an adversary and a challenger.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Commitment_Schemes <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Defining security›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Here we define the hiding, binding and correctness properties of commitment schemes.›</span></span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We provide the types of the adversaries that take part in the hiding and binding games. We consider 
two variants of the hiding property, one stronger than the other --- thus we provide two hiding adversaries.
The first hiding property we consider is analogous to the IND-CPA property for encryption schemes, the second, 
weaker notion, does not allow the adversary to choose the messages used in the game, instead they are sampled 
from a set distribution.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'vk'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'commit'</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> hid_adv <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vk'</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'plain'</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'state</span><span class="main">)</span> spmf<span class="main">)</span>
   <span class="main">×</span> <span class="main">(</span><span class="tfree">'commit'</span> <span class="main">⇒</span> <span class="tfree">'state</span> <span class="main">⇒</span> bool spmf<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'commit'</span> hid <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'commit'</span> <span class="main">⇒</span> bool spmf"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'ck'</span><span class="main">,</span> <span class="tfree">'plain'</span><span class="main">,</span> <span class="tfree">'commit'</span><span class="main">,</span> <span class="tfree">'opening'</span><span class="main">)</span>  bind_adversary <span class="main">=</span> 
  <span class="quoted"><span class="quoted">"<span class="tfree">'ck'</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'commit'</span> <span class="main">×</span> <span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'opening'</span> <span class="main">×</span> <span class="tfree">'plain'</span> <span class="main">×</span> <span class="tfree">'opening'</span><span class="main">)</span> spmf"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We fix the algorithms that make up a commitment scheme in the locale.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> abstract_commitment <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ck</span> <span class="main">×</span> <span class="tfree">'vk</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹outputs the keys received by the two parties›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">commit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ck</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'commit</span> <span class="main">×</span> <span class="tfree">'opening</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹outputs the commitment as well as the opening values sent by the committer in the reveal phase›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">verify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'vk</span> <span class="main">⇒</span> <span class="tfree">'plain</span> <span class="main">⇒</span> <span class="tfree">'commit</span> <span class="main">⇒</span> <span class="tfree">'opening</span> <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_msg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> bool"</span></span> <span class="comment1">― ‹checks whether a message is valid, used in the hiding game›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_msg_set</span> <span class="main">=</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="free">valid_msg</span> <span class="bound">m</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lossless</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_key</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> hid_adv <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lossless</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">⟷</span>
   <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">pk</span><span class="main">.</span> lossless_spmf <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">pk</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
        <span class="main">(</span><span class="main">∀</span><span class="bound">commit</span> <span class="bound">σ</span><span class="main">.</span> lossless_spmf <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">commit</span> <span class="bound">σ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The correct game runs the three algorithms that make up commitment schemes and outputs the output
of the verification algorithm.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">correct_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'plain</span> <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">correct_game</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> <span class="free">commit</span> <span class="bound">ck</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="free">verify</span> <span class="bound">vk</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span>   <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless_spmf <span class="free">key_gen</span><span class="main">;</span> lossless_spmf <span class="free">TI</span><span class="main">;</span>
          <span class="main">⋀</span><span class="bound">pk</span> <span class="bound">m</span><span class="main">.</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">commit</span> <span class="bound">pk</span> <span class="bound">m</span><span class="main">)</span> <span class="main">⟧</span>
              <span class="main">⟹</span> <span class="free">valid_msg</span> <span class="free">m</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>correct_game <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def correct_game_def split_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">correct</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">correct</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">⟶</span> spmf <span class="main">(</span>correct_game <span class="bound">m</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The hiding property is defined using the hiding game. Here the adversary is asked to output two
messages, the challenger flips a coin to decide which message to commit and hand to the adversary.
The adversary's challenge is to guess which commitment it was handed. Note we must check the two 
messages outputted by the adversary are valid.›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">hiding_game_ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vk</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> hid_adv <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hiding_game_ind_cpa</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
  <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜1</span></span></span> <span class="bound">vk</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">valid_msg</span> <span class="bound">m0</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span> 
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> <span class="free">commit</span> <span class="bound">ck</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
  <span class="bound">b'</span> <span class="main">::</span> bool <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜2</span></span></span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The adversary wins the game if <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>b = b'›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_hiding_game<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> lossless <span class="free">𝒜</span><span class="main">;</span> lossless_spmf <span class="free">key_gen</span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">pk</span> <span class="bound">plain</span><span class="main">.</span> <span class="free">valid_msg</span> <span class="bound">plain</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span><span class="free">commit</span> <span class="bound">pk</span> <span class="bound">plain</span><span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> lossless_spmf <span class="main">(</span>hiding_game_ind_cpa <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_def hiding_game_ind_cpa_def split_def Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹To define security we consider the advantage an adversary has of winning the game over a tossing 
a coin to determine their output.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">hiding_advantage_ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vk</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> hid_adv <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">hiding_advantage_ind_cpa</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> <span class="main">¦</span>spmf <span class="main">(</span>hiding_game_ind_cpa <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">¦</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">perfect_hiding_ind_cpa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'vk</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'state</span><span class="main">)</span> hid_adv <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">perfect_hiding_ind_cpa</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> <span class="main">(</span>hiding_advantage_ind_cpa <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The binding game challenges an adversary to bind two messages to the same committed value. Both
opening values and messages are verified with respect to the same committed value, the adversary wins
if the game outputs true. We must check some conditions of the adversaries output are met;
we will always require that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m ≠ m'›</span></span></span></span>, other conditions will be dependent on the protocol for example 
we may require group or field membership.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ck</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'opening</span><span class="main">)</span> bind_adversary <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_game</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">ck</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="bound">d'</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">∧</span> <span class="bound">b'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We proof the binding game is equivalent to the following game which is easier to work with. In particular 
we assert b and b' in the game and return True.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_game_alt_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind_game <span class="free">𝒜</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">ck</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="bound">d'</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">∧</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span> 
  return_spmf True<span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">ck</span><span class="main">;</span>
        <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">TRY</span> return_spmf <span class="main">(</span><span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m</span> <span class="bound">c</span> <span class="bound">d</span> <span class="main">∧</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="bound">d'</span><span class="main">)</span> <span class="keyword1">ELSE</span> return_spmf False
        <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False
      <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False
    <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> split_def bind_game_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> try_bind_spmf_lossless2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lossless_return_spmf<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> <span class="free">key_gen</span><span class="main">;</span>
      <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">ck</span><span class="main">;</span>
        <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
          <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m</span> <span class="main">∧</span> <span class="free">valid_msg</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
          <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
            <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m</span> <span class="bound">c</span> <span class="bound">d</span> <span class="main">∧</span> <span class="free">verify</span> <span class="bound">vk</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="bound">d'</span><span class="main">)</span><span class="main">;</span>
            return_spmf True
          <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False
        <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False
      <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False
    <span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> try_bind_assert_spmf try_spmf_return_spmf1 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> try_spmf_cong bind_spmf_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> split_def Let_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> try_bind_spmf_lossless2<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lossless_return_spmf<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_binding_game<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>bind_game <span class="free">𝒜</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_game_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ck</span><span class="main">,</span> <span class="tfree">'plain</span><span class="main">,</span> <span class="tfree">'commit</span><span class="main">,</span> <span class="tfree">'opening</span><span class="main">)</span> bind_adversary <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> spmf <span class="main">(</span>bind_game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Cyclic_Group_Ext">
<div class="head">
<h1>Theory Cyclic_Group_Ext</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Cyclic_Group_Ext <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> cyclic_group <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> generator_pow_order<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> order <span class="free">G</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>carrier <span class="free">G</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> order_gt_0_iff_finite<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span><span class="main">)</span> <span class="main">`</span> carrier <span class="free">G</span> <span class="main">=</span> carrier <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_multc<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">G</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> Suc <span class="bound">n</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span>order <span class="free">G</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> carrier_conv_generator image_image<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">𝟭</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> Suc <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> order <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> order <span class="free">G</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n inj_onD<span class="main">[</span><span class="operator">OF</span> inj_on_generator<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="main">0</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">with</span></span> True n <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> generator_pow_mult_order<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">G</span> <span class="main">*</span> order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> generator_pow_order 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generator_closed nat_pow_one nat_pow_pow<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pow_generator_mod<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">*</span> order <span class="free">G</span> <span class="main">+</span> <span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> div_mult_mod_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> order <span class="free">G</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> n<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult nat_pow_pow mult_ac<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generator_pow_order<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> pow_carrier_mod<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">[^]</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms pow_generator_mod 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generatorE generator_closed mod_mult_right_eq nat_pow_pow<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> pow_generator_mod_int<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">k</span><span class="main">::</span>int<span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">*</span> order <span class="free">G</span> <span class="main">+</span> <span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span>"</span></span>   
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> div_mult_mod_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> order <span class="free">G</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">k</span> <span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> n<span class="main">)</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_pow_mult int_pow_pow mult_ac<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generator_closed int_pow_int int_pow_pow mult.commute<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> generator_pow_order<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> pow_generator_eq_iff_cong<span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="main">(</span>carrier <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">y</span> <span class="main">⟷</span> <span class="main">[</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> pow_generator_mod<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def order_gt_0_iff_finite <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> inj_onD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_on_generator<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> power_distrib<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">e</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">)</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">x</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">e</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult mult.commute nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generator_closed mult.commute nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> x One_nat_def generator_closed l_one monoid.nat_pow_Suc monoid_axioms nat_pow_0 nat_pow_mult<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> neg_power_inverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> order <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">G</span> <span class="main">-</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">g</span> <span class="main">[^]</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">inv</span> <span class="main">(</span><span class="free">g</span> <span class="main">[^]</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">-</span> int <span class="free">x</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_pow_int int_pow_neg assms<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">G</span> <span class="main">-</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">-</span> int <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">G</span> <span class="main">-</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">-</span> int <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>order <span class="free">G</span> <span class="main">-</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> int <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> zmod_zminus1_eq_if <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_pow_int<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> f1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">[^]</span> int <span class="main">0</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> f2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="bound">na</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">na</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="bound">na</span> <span class="main">=</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="bound">na</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">have</span></span> f3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="bound">aa</span><span class="main">.</span> <span class="bound">aa</span> <span class="main">⊗</span> <span class="bound">a</span> <span class="main">[^]</span> int <span class="main">0</span> <span class="main">=</span> <span class="bound">aa</span> <span class="main">∨</span> <span class="bound">aa</span> <span class="main">∉</span> carrier <span class="free">G</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">have</span></span> f4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span> <span class="bound">a</span> <span class="bound">aa</span><span class="main">.</span> <span class="bound">a</span> <span class="main">[^]</span> int <span class="main">0</span> <span class="main">⊗</span> <span class="bound">aa</span> <span class="main">[^]</span> <span class="bound">i</span> <span class="main">=</span> <span class="bound">aa</span> <span class="main">[^]</span> <span class="main">(</span>int <span class="main">0</span> <span class="main">+</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">aa</span> <span class="main">∉</span> carrier <span class="free">G</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">[^]</span> int <span class="main">(</span><span class="bound">n</span> <span class="main">*</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="bound">a</span> <span class="main">[^]</span> <span class="main">(</span>int <span class="main">0</span> <span class="main">+</span> int <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">a</span> <span class="main">∉</span> carrier <span class="free">G</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> f5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="bound">aa</span><span class="main">.</span> <span class="bound">aa</span> <span class="main">[^]</span> int <span class="main">(</span>order <span class="free">G</span><span class="main">)</span> <span class="main">=</span> <span class="bound">a</span> <span class="main">[^]</span> int <span class="main">0</span> <span class="main">∨</span> <span class="bound">aa</span> <span class="main">∉</span> carrier <span class="free">G</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> f4 f3 f2 f1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_pow_closed int_pow_int mod_mult_self2 pow_carrier_mod<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="bound">na</span><span class="main">.</span> int <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="bound">na</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> int <span class="bound">na</span> <span class="main">+</span> int <span class="bound">n</span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">na</span> <span class="main">≤</span> <span class="bound">n</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> f5 f3 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> int_pow_closed int_pow_int int_pow_mult less_imp_le_nat<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> int_nat_pow<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>int <span class="main">(</span><span class="free">a</span> <span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>int<span class="main">)</span>  <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">*</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&gt;</span><span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> int_pow_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span> <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>int <span class="main">(</span><span class="free">a</span> <span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>int<span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">*</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> pow_gen_mod_mult<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">::</span>int<span class="main">)</span><span class="main">*</span>int <span class="main">(</span><span class="free">d</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">b</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">*</span>int <span class="free">d</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monoid.nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">=</span> <span class="free">c</span><span class="main">*</span>int <span class="free">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">::</span>int<span class="main">)</span><span class="main">*</span>int <span class="main">(</span><span class="free">d</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n r <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">r</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> pow_generator_mod_int pow_generator_mod 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_nat_pow int_pow_int mod_mult_right_eq zero_le<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span>  <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">b</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">c</span><span class="main">*</span>int <span class="free">d</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> r n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 2 3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cyclic_group_commute<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> <span class="free">b</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⊗</span> <span class="free">a</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generatorE assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span>  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generatorE assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult n k<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> cyclic_group_assoc<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">⊗</span> <span class="free">b</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⊗</span> <span class="main">(</span><span class="free">b</span> <span class="main">⊗</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generatorE assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generatorE assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generatorE assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n k j <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">k</span> <span class="main">+</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult add.assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult n k j<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">lemma</span></span> l_cancel_inv<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">=</span> <span class="free">h</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="free">a</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">-</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> int_pow_neg<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>int <span class="free">a</span> <span class="main">-</span> <span class="free">a</span><span class="main">)</span>  <span class="main">⊗</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span><span class="main">::</span> int<span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="free">h</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inverse_split<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">inv</span> <span class="main">(</span><span class="free">a</span> <span class="main">⊗</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">inv</span> <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  assms comm_group.inv_mult cyclic_group_commute group_comm_groupI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> inverse_pow_pow<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">inv</span> <span class="main">(</span><span class="free">a</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">r</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="free">a</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">[^]</span> <span class="free">r</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms nat_pow_inv<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> l_neq_1_exp_neq_0<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">∈</span> carrier <span class="free">G</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≠</span> <span class="main">𝟭</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">t</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">t</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">t</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> order_gt_1_gen_not_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">≠</span> <span class="main">𝟭</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">≠</span> <span class="main">𝟭</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> g_pow_eq_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">n</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"range <span class="main">(</span><span class="main">λ</span><span class="bound">n</span> <span class="main">::</span> nat<span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">𝟭</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">G</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">𝟭</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> generator <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&lt;</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> inj_onD inj_on_generator lessThan_iff g_pow_eq_1 assms less_one neq0_conv<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> power_swap<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">α0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">r</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">r</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">α0</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">α0</span> <span class="main">*</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nat_pow_pow mult.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">r</span> <span class="main">*</span> <span class="free">α0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> mult.commute<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> nat_pow_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> gen_power_0<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">r</span> <span class="main">::</span> <span class="quoted">nat</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">r</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">&lt;</span> order <span class="free">G</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms inj_onD inj_on_generator <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> group_eq_pow_eq_mod<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted">nat</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">b</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"order <span class="free">G</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">a</span> <span class="main">=</span> <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&gt;</span> <span class="free">b</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> True add_Suc_right assms diff_add_inverse generator_closed group.l_cancel_one' group_l_invI l_inv_ex less_imp_Suc_add nat_pow_closed nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> pow_generator_mod <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> gen_power_0 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>2<span class="main">)</span> order_gt_0_iff_finite pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">a</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">b</span> <span class="main">-</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> False Group.group.axioms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Units_eq add_diff_inverse_nat assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> generator_closed group_l_invI l_inv_ex l_neq_1_exp_neq_0 monoid.Units_l_cancel nat_pow_closed nat_pow_mult r_one<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">b</span> <span class="main">-</span> <span class="free">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">𝟭</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> pow_generator_mod <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> gen_power_0 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>2<span class="main">)</span> order_gt_0_iff_finite pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Discrete_Log">
<div class="head">
<h1>Theory Discrete_Log</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Discrete_Log <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> dis_log <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> order_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> dislog_adv <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">⇒</span> nat spmf"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> dislog_adv' <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> spmf"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> dislog_adv2 <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> <span class="tfree">'grp'</span> <span class="main">⇒</span> nat spmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dis_log</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dislog_adv <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_log</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">x</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">;</span> 
  <span class="bound">x'</span><span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">h</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">[</span><span class="bound">x</span> <span class="main">=</span> <span class="bound">x'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dislog_adv <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> spmf <span class="main">(</span>dis_log <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> lossless_dis_log<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">0</span> <span class="main">&lt;</span> order <span class="free">𝒢</span><span class="main">;</span> <span class="main">∀</span> <span class="bound">h</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free">𝒜</span> <span class="bound">h</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> lossless_spmf <span class="main">(</span>dis_log <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  dis_log_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> dis_log_alt <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> order_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> dis_log<span class="main">:</span> dis_log <span class="quoted"><span class="free">𝒢</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">g'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dis_log2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dis_log.dislog_adv' <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_log2</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">[</span><span class="bound">w</span> <span class="main">=</span> <span class="main">(</span><span class="bound">w1'</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">]</span>  <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dis_log.dislog_adv' <span class="main">⇒</span> real"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage2</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> spmf <span class="main">(</span>dis_log2 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adversary2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> spmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adversary2</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">w1</span><span class="main">,</span><span class="bound">w2</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">w1</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">w2</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dis_log3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dis_log.dislog_adv2 <span class="main">⇒</span> bool spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_log3</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="bound">w</span><span class="main">)</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w'</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">[</span><span class="bound">w</span> <span class="main">=</span> <span class="bound">w'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">advantage3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dis_log.dislog_adv2 <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">advantage3</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> spmf <span class="main">(</span>dis_log3 <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adversary3</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> dis_log.dislog_adv2 <span class="main">⇒</span> <span class="tfree">'grp</span> <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adversary3</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">g</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">[^]</span> <span class="free">x</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> dis_log_alt_reductions <span class="main">=</span> dis_log_alt <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> dis_log_adv3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"advantage3 <span class="free">𝒜</span> <span class="main">=</span> dis_log.advantage <span class="main">(</span>adversary3 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_alt.advantage3_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage3_def dis_log.advantage_def adversary3_def dis_log.dis_log_def dis_log3_def Let_def g'_def power_swap<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dis_log_adv2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"advantage2 <span class="free">𝒜</span> <span class="main">=</span> dis_log.advantage <span class="main">(</span>adversary2 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_alt.advantage2_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> advantage2_def dis_log2_def dis_log.advantage_def dis_log.dis_log_def adversary2_def split_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Number_Theory_Aux">
<div class="head">
<h1>Theory Number_Theory_Aux</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Number_Theory_Aux <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Residues.html">HOL-Number_Theory.Residues</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">inverse</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">inverse</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inverse<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"gcd <span class="free">x</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span> <span class="main">*</span> inverse <span class="free">x</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="free">x</span> <span class="main">+</span> snd <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> int <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> bezw_aux assms int_minus 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Num.of_nat_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="free">x</span> <span class="main">+</span> snd <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> int <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms bezw_aux of_nat_mod<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>fst <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">hence</span></span> 5<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>fst <span class="main">(</span>bezw <span class="free">x</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="free">x</span>  <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> 2 3 cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult.commute<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prod_not_prime<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">y</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;</span> <span class="numeral">2</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">&gt;</span> <span class="numeral">2</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> prime <span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">*</span><span class="main">(</span><span class="free">y</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms One_nat_def Suc_diff_1 nat_neq_iff numeral_2_eq_2 prime_gt_0_nat prime_product<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_inverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">e</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">*</span><span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">P</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">Q</span>"</span></span>   
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">≠</span> <span class="free">Q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">d</span><span class="main">.</span> <span class="main">[</span><span class="free">e</span><span class="main">*</span><span class="bound">d</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">d</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coprime <span class="free">e</span> <span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">e</span><span class="main">*</span><span class="skolem">d</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cong_solve_coprime_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong_0_1_nat cong_1 mult_0_right zero_neq_one<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ex_k1_k2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">e</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">*</span><span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">" <span class="main">[</span><span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">k1</span> <span class="bound">k2</span><span class="main">.</span> <span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">+</span> <span class="bound">k1</span><span class="main">*</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">k2</span><span class="main">*</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> cong_iff_lin_nat<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&gt;</span> <span class="free">b</span> <span class="main">⟹</span>int <span class="free">a</span> <span class="main">-</span> int <span class="free">b</span> <span class="main">=</span> int <span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> ex_k_mod<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">e</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">*</span><span class="main">(</span><span class="free">Q</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">≠</span> <span class="free">Q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">P</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">Q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">d</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">" <span class="main">[</span><span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">k</span><span class="main">.</span> <span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">k</span><span class="main">*</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>2<span class="main">)</span> prime_gt_0_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">≥</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span><span class="main">*</span><span class="free">d</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="skolem">k</span><span class="main">*</span><span class="main">(</span><span class="free">P</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>6<span class="main">)</span> cong_to_1'_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> fermat_little_theorem<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span><span class="free">P</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span><span class="main">^</span><span class="free">P</span> <span class="main">=</span> <span class="free">x</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">P</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="keyword1">dvd</span> <span class="free">x</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">P</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">^</span> <span class="free">P</span> <span class="keyword1">mod</span> <span class="free">P</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True assms prime_dvd_power_nat_iff prime_gt_0_nat<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span> <span class="main">^</span> <span class="main">(</span><span class="free">P</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">P</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fermat_theorem assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_diff_1 assms cong_scalar_left nat_mult_1_right not_gr_zero not_prime_0 power_Suc<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prime_field<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coprime <span class="free">a</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms coprime_commute dvd_imp_le linorder_not_le neq0_conv prime_imp_coprime<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Uniform_Sampling">
<div class="head">
<h1>Theory Uniform_Sampling</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Uniform_Sampling <span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_uniform_units</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_uniform_units</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> spmf_of_set <span class="main">(</span><span class="main">{..&lt;</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_spmf_sample_uniform_units <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_spmf <span class="main">(</span>sample_uniform_units <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_units_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_sample_uniform_units<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>sample_uniform_units <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> sample_uniform_units_def
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> weight_sample_uniform_units<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"weight_spmf <span class="main">(</span>sample_uniform_units <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms lossless_sample_uniform_units 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_weight_spmfD<span class="main">)</span>

<span class="comment1">(*General lemma for mapping using sample_uniform*)</span>

<span class="keyword1"><span class="command">lemma</span></span> one_time_pad'<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> inj_on<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> sur<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="free">f</span> <span class="main">(</span>sample_uniform_units <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>sample_uniform_units <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> rhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> spmf_of_set <span class="main">(</span><span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_units_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> spmf_of_set <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sur<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> rhs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> one_time_pad<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> inj_on<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> sur<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="free">f</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> rhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> spmf_of_set <span class="main">(</span><span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf<span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> spmf_of_set <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">`</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sur<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> rhs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*(y + b)*)</span>

<span class="keyword1"><span class="command">lemma</span></span> plus_inj_eq<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> map<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">y</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>  
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">x'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">y</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">y</span><span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="free">y</span><span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="free">y</span><span class="main">::</span> nat<span class="main">)</span> <span class="main">+</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">[</span><span class="free">x</span> <span class="main">=</span> <span class="free">x'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_add_lcancel_nat<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span> <span class="main">=</span> <span class="free">x'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x x'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_uni_samp_plus<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> plus_inj_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> surj_uni_samp_plus<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">=</span>  <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> samp_uni_plus_one_time_pad<span class="main">:</span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> sample_uniform <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inj_uni_samp_plus surj_uni_samp_plus one_time_pad <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*x*b*)</span> 

<span class="keyword1"><span class="command">lemma</span></span> mult_inj_eq<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> map<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">y'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">*</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">*</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="main">[</span><span class="free">x</span><span class="main">*</span><span class="free">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span><span class="main">*</span><span class="free">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="free">y</span> <span class="main">=</span> <span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_mult_lcancel_nat coprime<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">y</span> <span class="main">=</span> <span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> y y'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_on_mult<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> coprime <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mult_inj_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> surj_on_mult<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> coprime inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> mult_one_time_pad<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> sample_uniform <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inj_on_mult surj_on_mult one_time_pad coprime <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">lemma</span></span> inj_on_mult'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> coprime <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mult_inj_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> surj_on_mult'<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">" finite <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>  
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">nn</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> nat<span class="main">)</span> <span class="main">⇒</span> nat set <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x0</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v3</span><span class="main">.</span> <span class="bound">v3</span> <span class="main">∈</span> <span class="bound">x2</span> <span class="main">∧</span> <span class="bound">x1</span> <span class="bound">v3</span> <span class="main">∉</span> <span class="bound">x0</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">nn</span> <span class="bound">x0</span> <span class="bound">x1</span> <span class="bound">x2</span> <span class="main">∈</span> <span class="bound">x2</span> <span class="main">∧</span> <span class="bound">x1</span> <span class="main">(</span><span class="skolem">nn</span> <span class="bound">x0</span> <span class="bound">x1</span> <span class="bound">x2</span><span class="main">)</span> <span class="main">∉</span> <span class="bound">x0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">moura</span>
    <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">N</span> <span class="bound">f</span> <span class="bound">Na</span><span class="main">.</span> <span class="skolem">nn</span> <span class="bound">Na</span> <span class="bound">f</span> <span class="bound">N</span> <span class="main">∈</span> <span class="bound">N</span> <span class="main">∧</span> <span class="bound">f</span> <span class="main">(</span><span class="skolem">nn</span> <span class="bound">Na</span> <span class="bound">f</span> <span class="bound">N</span><span class="main">)</span> <span class="main">∉</span> <span class="bound">Na</span> <span class="main">∨</span> <span class="bound">f</span> <span class="main">`</span> <span class="bound">N</span> <span class="main">⊆</span> <span class="bound">Na</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> image_subsetI<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∉</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> insert <span class="main">0</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> insert <span class="main">0</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="main">0</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span> <span class="main">≤</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">=</span> <span class="free">q</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">∉</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">∨</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">∉</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym_conv1 insertCI lessThan_iff local.coprime mult_inj_eq<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span> 
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">moreover</span></span> 
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> insert <span class="main">0</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∉</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> 3 1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Diff_iff<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span> 
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∨</span> <span class="main">(</span><span class="main">0</span> <span class="main">≤</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">=</span> <span class="free">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> antisym_conv1 lessThan_iff mod_less_divisor singletonD<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span> 
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∨</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">∉</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">nn</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∈</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span> 
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">n</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span> 
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mult_one_time_pad'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform_units <span class="free">q</span><span class="main">)</span> <span class="main">=</span> sample_uniform_units <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inj_on_mult' surj_on_mult' one_time_pad' coprime <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*y + x*b*)</span>

<span class="keyword1"><span class="command">lemma</span></span> samp_uni_add_mult<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> x'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> map<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">=</span> <span class="free">y'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">x'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">x'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="main">[</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="free">x'</span> <span class="main">=</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span><span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="free">x'</span> <span class="main">=</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span><span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">[</span><span class="free">x'</span> <span class="main">=</span> <span class="free">y'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_add_lcancel_nat<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coprime cong_mult_lcancel_nat<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def map<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="free">y'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">x'</span> <span class="main">=</span> <span class="free">y'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x' y'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> inj_on_add_mult<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> coprime <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> samp_uni_add_mult<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> surj_on_add_mult<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="main">(</span><span class="free">q</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> coprime inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> add_mult_one_time_pad<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> coprime<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">x</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">x</span><span class="main">*</span><span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inj_on_add_mult surj_on_add_mult one_time_pad coprime <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*(y - b) *)</span>

<span class="keyword1"><span class="command">lemma</span></span> inj_on_minus<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">q</span> <span class="main">-</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold</span> inj_on_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">y'</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> y'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> map<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">q</span> <span class="main">-</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="free">q</span> <span class="main">-</span> <span class="skolem">y'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">n</span> <span class="bound">na</span> <span class="bound">p</span><span class="main">.</span> <span class="main">∃</span><span class="bound">nb</span><span class="main">.</span> <span class="main">∀</span><span class="bound">nc</span> <span class="bound">nd</span> <span class="bound">pa</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span> <span class="main">(</span><span class="bound">nc</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="bound">nd</span> <span class="main">∨</span> <span class="main">¬</span> <span class="bound">pa</span> <span class="main">(</span><span class="bound">nc</span> <span class="main">-</span> <span class="bound">nd</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">pa</span> <span class="main">0</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">p</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">∨</span> <span class="bound">p</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="bound">na</span><span class="main">)</span> <span class="main">∨</span> <span class="bound">na</span> <span class="main">+</span> <span class="bound">nb</span> <span class="main">=</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> nat_diff_split<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="skolem">y'</span> <span class="main">-</span> <span class="free">q</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">y</span> <span class="main">&lt;</span> <span class="skolem">x</span> <span class="main">-</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> y' x <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.commute less_diff_conv not_add_less2<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="main">(</span><span class="skolem">y'</span> <span class="main">+</span> <span class="bound">n</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> map <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.commute add_diff_inverse_nat less_diff_conv mod_add_left_eq<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y'</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> plus_inj_eq  x y' add.commute<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> surj_on_minus<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on  <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">q</span> <span class="main">-</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">)</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">q</span> <span class="main">-</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> endo_inj_surj<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> inj <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> samp_uni_minus_one_time_pad<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">q</span> <span class="main">-</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> sample_uniform <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> inj_on_minus surj_on_minus one_time_pad <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> not_coin_spmf<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">a</span><span class="main">)</span> coin_spmf <span class="main">=</span> coin_spmf"</span></span> 
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj_on Not <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"Not <span class="main">`</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> one_time_pad 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bool<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> xor_uni_samp<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">y</span> <span class="main">⊕</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span>coin_spmf<span class="main">)</span> <span class="main">=</span> map_spmf<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span>coin_spmf<span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> rhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> spmf_of_set <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> UNIV_bool insert_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_spmf<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">y</span> <span class="main">⊕</span> <span class="bound">b</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span><span class="main">)</span> <span class="main">=</span> spmf_of_set<span class="main">(</span><span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="free">y</span> <span class="main">⊕</span> <span class="bound">b</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> xor <span class="free">y</span> <span class="bound">b</span><span class="main">)</span> <span class="main">`</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span> <span class="main">=</span> <span class="main">{</span>True<span class="main">,</span> False<span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> xor_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> rhs <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ped_inv_mapping<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">m</span> <span class="main">≠</span> <span class="main">0</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">d</span> <span class="main">+</span> <span class="free">a</span> <span class="main">*</span> <span class="main">(</span><span class="free">m</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="bound">d</span> <span class="main">+</span> <span class="free">q</span> <span class="main">*</span> <span class="free">m</span> <span class="main">-</span> <span class="free">a</span> <span class="main">*</span> <span class="free">m</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> ineq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">*</span> <span class="free">m</span> <span class="main">-</span> <span class="free">a</span> <span class="main">*</span> <span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms gr0I <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="free">a</span> <span class="main">*</span> <span class="free">m</span> <span class="main">+</span> <span class="bound">d</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> add.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> sample_uniform <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> samp_uni_plus_one_time_pad <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">d</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">q</span> <span class="main">*</span> <span class="free">m</span> <span class="main">-</span> <span class="free">a</span> <span class="main">*</span> <span class="free">m</span><span class="main">)</span> <span class="main">+</span> <span class="bound">d</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> ineq samp_uni_plus_one_time_pad <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> add.commute ineq  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Groups.add_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Pedersen">
<div class="head">
<h1>Theory Pedersen</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Pedersen Commitment Scheme›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The Pedersen commitment scheme \cite{BLP:conf/crypto/Pedersen91} is a commitment scheme based on a cyclic group. We use the 
construction of cyclic groups from CryptHOL to formalise the commitment scheme. We prove perfect hiding
and computational binding, with a reduction to the discrete log problem. We a proof of the Pedersen commitment scheme
is realised in the instantiation of the Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol with the general construction of commitment schemes 
from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols. The commitment scheme that is realised there however take the inverse of the message in the commitment 
phase due to the construction of the simulator in the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol proof. The two schemes are in some way equal however
as we do not have a well defined notion of equality for commitment schemes we keep this section of the formalisation. This 
also serves as reference to the formal proof of the Pedersen commitment scheme we provide in \cite{DBLP:conf/post/ButlerAG19}.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Pedersen <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
  <a href="Discrete_Log.html">Discrete_Log</a>
  <a href="Number_Theory_Aux.html">Number_Theory_Aux</a>
  <a href="Uniform_Sampling.html">Uniform_Sampling</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> pedersen_base <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prime_order<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> order_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prime_gt_0_nat prime_order<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> ck <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> vk <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> commit <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="quoted">"opening"</span> <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> ck <span class="main">×</span> <span class="tfree">'grp</span> vk<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h</span><span class="main">)</span> 
  <span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">commit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> ck <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> commit <span class="main">×</span> opening<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">commit</span> <span class="free"><span class="bound"><span class="entity">ck</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">d</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ck</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> 
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">commit_inv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> ck <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> commit <span class="main">×</span> opening<span class="main">)</span> spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">commit_inv</span> <span class="free"><span class="bound"><span class="entity">ck</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">d</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="free"><span class="bound"><span class="entity">ck</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> 
  <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">verify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> vk <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="tfree">'grp</span> commit <span class="main">⇒</span> opening <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">verify</span> <span class="free"><span class="bound"><span class="entity">v_key</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">⊗</span>  <span class="free"><span class="bound"><span class="entity">v_key</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_msg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plain <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_msg</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">&lt;</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dis_log_𝒜</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> ck<span class="main">,</span> plain<span class="main">,</span> <span class="tfree">'grp</span> commit<span class="main">,</span> opening<span class="main">)</span> bind_adversary <span class="main">⇒</span> <span class="tfree">'grp</span> ck <span class="main">⇒</span> nat spmf"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_log_𝒜</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span>  <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d'</span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span> 
  return_spmf  <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">m</span> <span class="main">&gt;</span> <span class="bound">m'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">d'</span> <span class="main">-</span> int <span class="bound">d</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">m</span> <span class="main">-</span> <span class="bound">m'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
                  <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">d</span> <span class="main">-</span> int <span class="bound">d'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">m'</span> <span class="main">-</span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> ped_commit<span class="main">:</span> abstract_commitment <span class="quoted">key_gen</span> <span class="quoted">commit</span> <span class="quoted">verify</span> <span class="quoted">valid_msg</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> discrete_log<span class="main">:</span> dis_log _ 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> pedersen <span class="main">=</span> pedersen_base <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> mod_one_cancel<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">*</span> <span class="free">z</span> <span class="main">*</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y'</span> <span class="main">*</span> <span class="free">x</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z</span> <span class="main">*</span> <span class="free">x</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">=</span> <span class="free">y'</span> <span class="main">*</span> <span class="free">x</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms Groups.mult_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> cong_scalar_right cong_sym_eq cong_trans more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> dis_log_break<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">d</span> <span class="free">d'</span> <span class="free">m</span> <span class="free">m'</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">d'</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">y</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">m'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">d</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">y</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">m</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> y_less_order<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> m_ge_m'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&gt;</span> <span class="free">m'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> mm'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">[</span><span class="free">m</span> <span class="main">=</span> <span class="free">m'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> m m_ge_m' basic_trans_rules<span class="main">(</span>19<span class="main">)</span> cong_less_modulus_unique_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"int <span class="main">(</span>gcd <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> assms<span class="main">(</span>4<span class="main">)</span> prime_field prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">d</span> <span class="main">+</span> <span class="free">y</span> <span class="main">*</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">d'</span> <span class="main">+</span> <span class="free">y</span> <span class="main">*</span> <span class="free">m'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">d</span> <span class="main">+</span> <span class="free">y</span> <span class="main">*</span> <span class="free">m</span> <span class="main">=</span> <span class="free">d'</span> <span class="main">+</span> <span class="free">y</span> <span class="main">*</span> <span class="free">m'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pow_generator_eq_iff_cong finite_carrier<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">d</span> <span class="main">+</span> int <span class="free">y</span> <span class="main">*</span> int <span class="free">m</span> <span class="main">=</span> int <span class="free">d'</span> <span class="main">+</span> int <span class="free">y</span> <span class="main">*</span> int <span class="free">m'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">from</span></span> cong_diff<span class="main">[</span><span class="operator">OF</span> this cong_refl<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"int <span class="free">d</span> <span class="main">+</span> int <span class="free">y</span> <span class="main">*</span> int <span class="free">m'</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">*</span> int <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m_ge_m'
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_distrib of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">*</span> int <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_scalar_right<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">*</span> <span class="main">1</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inverse gcd 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Groups.mult_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Number_Theory_Aux.inverse Totient.of_nat_eq_1_iff * cong_def int_ops<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span> mod_mult_right_eq mod_one_cancel<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">y</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">d'</span> <span class="main">-</span> int <span class="free">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_def zmod_int <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> y_less_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> dis_log_break'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">m'</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="free">m'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">d</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">y</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">m</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">d'</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">y</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">d</span> <span class="main">-</span> int <span class="free">d'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">m'</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">&gt;</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms 
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod nat_neq_iff order_gt_0  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> dis_log_break<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">d</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">d'</span></span> <span class="quoted"><span class="free">m'</span></span> <span class="main">]</span>assms cong_sym_eq assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>  
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_spmf_samp_uni <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_spmf <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> order <span class="free">𝒢</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>ped_commit.correct_game <span class="free">m</span><span class="main">)</span> True  <span class="main">=</span> <span class="main">1</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> finite_carrier order_gt_0_iff_finite  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_commitment.correct_game_def Let_def commit_def verify_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def Let_def bind_spmf_const <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> abstract_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ped_commit.correct"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abstract_commitment.correct_def <span class="keyword1"><span class="command">using</span></span> correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> perfect_hiding<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>ped_commit.hiding_game_ind_cpa <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Let_def split_def 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ped_commit.hiding_game_ind_cpa <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">ck</span><span class="main">,</span><span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="bound">vk</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span> <span class="main">←</span> commit <span class="bound">ck</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_commitment.hiding_game_ind_cpa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="bound">h</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
     <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span> 
    <span class="bound">d</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> commit_def key_gen_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="bound">h</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">z</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf<span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="bound">h</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">z</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf<span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_uniform_one_time_pad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="bound">h</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span><span class="main">)</span>  <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">z</span> <span class="bound">σ</span><span class="main">;</span>
    map_spmf<span class="main">(</span><span class="main">(=)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf<span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> coin_spmf"</span></span>
     <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const map_eq_const_coin_spmf try_bind_spmf_lossless2' scale_bind_spmf weight_spmf_le_1 scale_scale_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> abstract_perfect_hiding<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ped_commit.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>ped_commit.hiding_game_ind_cpa <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_commitment.perfect_hiding_ind_cpa_def abstract_commitment.hiding_advantage_ind_cpa_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_output_cong<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">=</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">ab</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">aa</span> <span class="main">-</span> <span class="free">ac</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="main">⟷</span> <span class="main">[</span><span class="free">x</span> <span class="main">=</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">ab</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">aa</span> <span class="main">-</span> <span class="free">ac</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms cong_less_modulus_unique_nat nat_less_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_game_eq_dis_log<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ped_commit.bind_game <span class="free">𝒜</span> <span class="main">=</span> discrete_log.dis_log <span class="main">(</span>dis_log_𝒜 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Let_def split_def
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ped_commit.bind_game <span class="free">𝒜</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">ck</span><span class="main">,</span><span class="bound">vk</span><span class="main">)</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">ck</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf<span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> verify <span class="bound">vk</span> <span class="bound">m</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> verify <span class="bound">vk</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="bound">d'</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">∧</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
    return_spmf True<span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_commitment.bind_game_alt_def<span class="main">)</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>Coset.order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span> 
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span> <span class="main">⊗</span>  <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">[^]</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d'</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">[^]</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
    return_spmf True<span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> verify_def key_gen_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span> 
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d</span> <span class="main">⊗</span>  <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">[^]</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">d'</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">x</span><span class="main">)</span> <span class="main">[^]</span> <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">m</span> <span class="main">&gt;</span> <span class="bound">m'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">d'</span> <span class="main">-</span> int <span class="bound">d</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="bound">m</span> <span class="main">-</span> <span class="bound">m'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
                  <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">d</span> <span class="main">-</span> int <span class="bound">d'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="bound">m'</span> <span class="main">-</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_msg_def<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_break<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_break'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> discrete_log.dis_log_def dis_log_𝒜_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">using</span></span> bind_output_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> pedersen_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"ped_commit.bind_advantage <span class="free">𝒜</span> <span class="main">=</span> discrete_log.advantage <span class="main">(</span>dis_log_𝒜 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abstract_commitment.bind_advantage_def discrete_log.advantage_def 
  <span class="keyword1"><span class="command">using</span></span> bind_game_eq_dis_log <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> pedersen_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> pedersen<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> pedersen <span class="main">(</span><span class="free">𝒢</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
  
<span class="keyword1"><span class="command">sublocale</span></span> pedersen <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pedersen<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> pedersen_correct_asym<span class="main">:</span> 
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ped_commit.correct <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> abstract_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
              
<span class="keyword1"><span class="command">theorem</span></span> pedersen_perfect_hiding_asym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ped_commit.perfect_hiding_ind_cpa <span class="free">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_perfect_hiding<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> pedersen_bind_asym<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> ped_commit.bind_advantage <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">⟷</span> negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> discrete_log.advantage <span class="bound">n</span> <span class="main">(</span>dis_log_𝒜 <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pedersen_bind<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Rivest">
<div class="head">
<h1>Theory Rivest</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Rivest Commitment Scheme›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The Rivest commitment scheme was first introduced in \cite{rivest1999}. We note however the original
scheme did not allow for perfect hiding. This was pointed out by Blundo and Masucci in \cite{DBLP:journals/dcc/BlundoMSW02}
who alightly ammended the commitment scheme so that is provided perfect hiding.

The Rivest commitment scheme uses a trusted initialiser to provide correlated randomness to the two parties 
before an execution of the protocol. In our framework we set these as keys that held by the respective parties.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Rivest <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
  <a href="Discrete_Log.html">Discrete_Log</a>
  <a href="Number_Theory_Aux.html">Number_Theory_Aux</a>
  <a href="Uniform_Sampling.html">Uniform_Sampling</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> rivest <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prime_q<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">q</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> q_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prime_q prime_gt_0_nat<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> ck <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> vk <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> commit <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="quoted">"opening"</span> <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>ck <span class="main">×</span> vk<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">commit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ck <span class="main">⇒</span> plain <span class="main">⇒</span> <span class="main">(</span>commit <span class="main">×</span> opening<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">commit</span> <span class="free"><span class="bound"><span class="entity">ck</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ck</span></span></span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">,</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">verify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"vk <span class="main">⇒</span> plain <span class="main">⇒</span> commit <span class="main">⇒</span> opening <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">verify</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">y1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y1</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_msg</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plain <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_msg</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">msg</span></span></span> <span class="main">∈</span> <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> rivest_commit<span class="main">:</span> abstract_commitment <span class="quoted">key_gen</span> <span class="quoted">commit</span> <span class="quoted">verify</span> <span class="quoted">valid_msg</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemma</span></span> abstract_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"rivest_commit.correct"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abstract_commitment.correct_def abstract_commitment.correct_game_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def commit_def bind_spmf_const lossless_weight_spmfD<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rivest_hiding<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>spmf <span class="main">(</span>rivest_commit.hiding_game_ind_cpa <span class="free">𝒜</span><span class="main">)</span> True <span class="main">-</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> Let_def split_def 
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"rivest_commit.hiding_game_ind_cpa <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">y1</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">d</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if</span> <span class="bound">d</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">d</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abstract_commitment.hiding_game_ind_cpa_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> commit_def key_gen_def o_def bind_map_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">y1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">d</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if</span> <span class="bound">d</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">d</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> samp_uni_plus_one_time_pad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">y1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">d</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="bound">c</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">if</span> <span class="bound">d</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">d</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def bind_map_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">y1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">d</span> <span class="main">←</span> coin_spmf<span class="main">;</span>  
    <span class="bound">c</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">d</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> samp_uni_plus_one_time_pad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">y1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">c</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">c</span> <span class="bound">σ</span><span class="main">;</span>
    map_spmf<span class="main">(</span><span class="main">(=)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf<span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> coin_spmf"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_eq_const_coin_spmf bind_spmf_const try_bind_spmf_lossless2' 
        scale_bind_spmf weight_spmf_le_1 scale_scale_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rivest_perfect_hiding<span class="main">:</span> <span class="quoted"><span class="quoted">"rivest_commit.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> abstract_commitment.perfect_hiding_ind_cpa_def abstract_commitment.hiding_advantage_ind_cpa_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rivest_hiding<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> samp_uni_break'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fst_cond<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="free">m'</span> <span class="main">∧</span> valid_msg <span class="free">m</span> <span class="main">∧</span> valid_msg <span class="free">m'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="free">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="free">y1</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">+</span> <span class="free">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span>  c'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">(</span><span class="free">m'</span> <span class="main">+</span> <span class="free">a'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="free">y1</span> <span class="main">=</span> <span class="main">(</span><span class="free">a'</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">+</span> <span class="free">b'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> x1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">&gt;</span> <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">then</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>  <span class="keyword1">else</span> 
          nat <span class="main">(</span><span class="main">(</span>int <span class="free">b</span><span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">q</span> <span class="main">∧</span> <span class="free">m'</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fst_cond valid_msg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> a_a'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">[</span><span class="free">a</span> <span class="main">=</span> <span class="free">a'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">m</span> <span class="main">+</span> <span class="free">a</span> <span class="main">=</span> <span class="free">m'</span> <span class="main">+</span> <span class="free">a'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> assms cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> m fst_cond c c' add.commute cong_less_modulus_unique_nat cong_add_rcancel_nat cong_mod_right<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">have</span></span> cong_y1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">a</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">+</span> int <span class="free">b</span> <span class="main">=</span> int <span class="free">a'</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">+</span> int <span class="free">b'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> c c' cong_def Num.of_nat_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> Num.of_nat_simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> cong_int_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">&gt;</span> <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> True comm_monoid_add_class.add_0 diff_add_cancel mod_add_left_eq mod_diff_eq nat_mod_as_int order_less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>   
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> prime_field<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="quoted">"nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span>"</span></span><span class="main">]</span> prime_q 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Euclidean_Division.pos_mod_sign coprime_imp_gcd_eq_1 int_nat_eq nat_less_iff of_nat_0_less_iff q_gt_0<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">a</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">-</span> int <span class="free">a'</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">=</span> int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0 cong_y1 cong_diff cong_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">=</span> int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span> <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a</span> <span class="main">-</span> int <span class="free">a'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> cong_def cong_mult cong_refl mod_diff_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="main">[</span>int <span class="free">a</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">-</span> int <span class="free">a'</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">=</span> int <span class="free">b'</span> <span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span>›</span></span> cong_def mod_diff_left_eq mod_diff_right_eq mod_mult_right_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> int_distrib<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> mult.commute<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> True cong_def mod_mult_right_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> 
              <span class="main">=</span> <span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> 
              <span class="main">=</span> <span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">1</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> inverse gcd 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> cong_scalar_left cong_sym_eq cong_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"int <span class="free">x1</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>int <span class="free">b'</span><span class="main">-</span> int <span class="free">b</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> x1 True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> aa'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">&lt;</span> <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> a_a' cong_refl nat_neq_iff 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> aa' comm_monoid_add_class.add_0 diff_add_cancel mod_add_left_eq mod_diff_eq nat_mod_as_int order_less_irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>   
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> prime_field<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">q</span></span> <span class="quoted"><span class="quoted">"nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span>"</span></span><span class="main">]</span> prime_q
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Euclidean_Division.pos_mod_sign coprime_imp_gcd_eq_1 int_nat_eq nat_less_iff of_nat_0_less_iff q_gt_0<span class="main">)</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span> <span class="main">=</span> int <span class="free">a'</span> <span class="main">*</span> int <span class="free">x1</span> <span class="main">-</span> int <span class="free">a</span> <span class="main">*</span> int <span class="free">x1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0 cong_y1 cong_diff cong_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span> <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a'</span> <span class="main">-</span> int <span class="free">a</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> int_distrib mult.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span> <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cong_def mod_diff_eq mod_mult_right_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span> <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> 
               <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">*</span>  inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> <span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> 
               <span class="main">=</span> int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">*</span>  inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cong_def mod_mult_left_eq mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> 
              <span class="main">=</span> <span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_sym_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">*</span> <span class="main">1</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">*</span> Number_Theory_Aux.inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> int <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="free">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Euclidean_Division.pos_mod_sign inverse gcd int_nat_eq of_nat_0_less_iff q_gt_0<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> * cong_scalar_left cong_sym_eq cong_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x1</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"int <span class="free">x1</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span>int <span class="free">b</span> <span class="main">-</span> int <span class="free">b'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="free">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> cong_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> x1 aa' <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">lemma</span></span> samp_uni_spmf_mod_q<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">/</span><span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"indicator <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> q_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"real <span class="main">(</span>card <span class="main">{..&lt;</span> <span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set sample_uniform_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> spmf_samp_uni_eq_return_bool_mod<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span> 
          <span class="bound">x1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
          return_spmf <span class="main">(</span>int <span class="bound">x1</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span><span class="main">/</span><span class="free">q</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span> 
          <span class="bound">x1</span> <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
          return_spmf <span class="main">(</span><span class="bound">x1</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>sample_uniform <span class="free">q</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x1</span><span class="main">.</span> return_spmf <span class="bound">x1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> spmf_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⟶</span> indicator <span class="main">{</span>True<span class="main">}</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>indicator <span class="main">{</span><span class="main">(</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">}</span> <span class="skolem">x</span><span class="main">::</span>real<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"indicator <span class="main">{</span>True<span class="main">}</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>indicator <span class="main">{</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">}</span> <span class="skolem">x</span><span class="main">::</span>real<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>return_spmf <span class="main">(</span><span class="skolem">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>return_spmf <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="free">y</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> pmf_return spmf_of_pmf_return_pmf spmf_spmf_of_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> samp_uni_spmf_mod_q <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_game_le_inv_q<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>rivest_commit.bind_game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">≤</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?eq</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="bound">a'</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">.</span> <span class="main">(=)</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">&gt;</span> <span class="bound">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">then</span> nat <span class="main">(</span><span class="main">(</span>int <span class="bound">b'</span><span class="main">-</span> int <span class="bound">b</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">a</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="bound">a'</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span>
    <span class="keyword1">else</span> nat <span class="main">(</span><span class="main">(</span>int <span class="bound">b</span> <span class="main">-</span> int <span class="bound">b'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>inverse <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">a'</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">-</span> int <span class="bound">a</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>rivest_commit.bind_game <span class="free">𝒜</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">ck</span><span class="main">,</span><span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> key_gen<span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">ck</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf<span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>  
    <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> verify <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span> <span class="bound">m</span> <span class="bound">c</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> verify <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">y1</span><span class="main">)</span> <span class="bound">m'</span> <span class="bound">c</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">∧</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
    return_spmf True<span class="main">}</span><span class="main">)</span> True"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_commitment.bind_game_alt_def split_def spmf_try_spmf <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> verify.simps<span class="main">)</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a'</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a'</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>  
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="bound">m</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="bound">m'</span> <span class="main">+</span> <span class="bound">a'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a'</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">;</span>
    return_spmf True<span class="main">}</span><span class="main">)</span> True"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a''</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">b''</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">x1</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a''</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b''</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="main">(</span><span class="bound">a''</span><span class="main">,</span><span class="bound">b''</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> valid_msg <span class="bound">m</span> <span class="main">∧</span> valid_msg <span class="bound">m'</span><span class="main">)</span><span class="main">;</span>  
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="bound">m</span> <span class="main">+</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">=</span> <span class="main">(</span><span class="bound">m'</span> <span class="main">+</span> <span class="bound">a'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span> <span class="main">∧</span> <span class="bound">y1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a'</span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">b'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="free">q</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="var">?eq</span> <span class="bound">a</span> <span class="bound">a'</span> <span class="bound">b</span> <span class="bound">b'</span> <span class="bound">x1</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> True"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> split_def Let_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted">spmf</span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> _ refl<span class="main"><span class="main">]</span></span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_commute samp_uni_break' Let_def split_def valid_msg_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> spmf <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">a''</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="bound">b''</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="free">q</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="main">(</span><span class="bound">b</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="main">(</span><span class="bound">a''</span><span class="main">,</span><span class="bound">b''</span><span class="main">)</span><span class="main">;</span>
    map_spmf <span class="main">(</span><span class="var">?eq</span> <span class="bound">a</span> <span class="bound">a'</span> <span class="bound">b</span> <span class="bound">b'</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">unfolding</span></span> split_def Let_def assert_spmf_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ord_spmf_eq_leD ord_spmf_bind_reflI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">≤</span> <span class="main">1</span><span class="main">/</span><span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="main">(</span><span class="operator">rule</span> spmf_bind_leI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">a'</span> <span class="skolem">b</span> <span class="skolem">b'</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> Collect <span class="main">(</span><span class="var">?eq</span> <span class="skolem">a</span> <span class="skolem">a'</span> <span class="skolem">b</span> <span class="skolem">b'</span><span class="main">)</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x1</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x1</span> <span class="main">=</span> The <span class="main">(</span><span class="var">?eq</span> <span class="skolem">a</span> <span class="skolem">a'</span> <span class="skolem">b</span> <span class="skolem">b'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> q_gt_0<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">⊆</span> <span class="main">{</span><span class="skolem">x1</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> A_def x1_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span><span class="skolem">A</span> <span class="main">∩</span> <span class="main">{..&lt;</span><span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">{</span><span class="skolem">x1</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> card_mono<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> q_gt_0 <span class="keyword1"><span class="command">unfolding</span></span> sample_uniform_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> map_mem_spmf_of_set<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>map_spmf <span class="main">(</span><span class="var">?eq</span> <span class="skolem">a</span> <span class="skolem">a'</span> <span class="skolem">b</span> <span class="skolem">b'</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="free">q</span><span class="main">)</span><span class="main">)</span> True <span class="main">≤</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> A_def mem_Collect_eq <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> rivest_bind<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rivest_commit.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> <span class="main">1</span> <span class="main">/</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bind_game_le_inv_q rivest_commit.bind_advantage_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> rivest_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rivest<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> rivest <span class="main">(</span><span class="free">q</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> rivest <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rivest<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> rivest_correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rivest_commit.correct <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> abstract_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> rivest_perfect_hiding_asym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless_𝒜<span class="main">:</span> <span class="quoted"><span class="quoted">"rivest_commit.lossless <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rivest_commit.perfect_hiding_ind_cpa <span class="free">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_𝒜 rivest_perfect_hiding<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> rivest_binding_asym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">1</span> <span class="main">/</span> <span class="main">(</span><span class="free">q</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> rivest_commit.bind_advantage <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> negligible_le rivest_bind assms rivest_commit.bind_advantage_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Sigma_Protocols">
<div class="head">
<h1>Theory Sigma_Protocols</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-Protocols›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols were first introduced as an abstract notion by Cramer \cite{Cramerthesis}. 
We point the reader to \cite{sigma_protocols} for a good introduction to the primitive as well as informal proofs
of many of the constructions we formalise in this work. In particular the construction of commitment schemes from 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols and the construction of compound AND and OR statements.

In this section we define <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols then provide a general proof that they can be used to construct commitment schemes.
Defining security for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols uses a mixture of the game-based and simulation-based paradigms. The honest verifier 
zero knowledge property is considered using simulation-based proof, thus we follow the follow the simulation-based formalisation 
of \cite{DBLP:journals/afp/AspinallB19} and \cite{DBLP:conf/itp/Butler0G17}.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Defining <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Sigma_Protocols <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../CryptHOL/CryptHOL.html">CryptHOL.CryptHOL</a>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'msg'</span><span class="main">,</span> <span class="tfree">'challenge'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">)</span> conv_tuple <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'msg'</span> <span class="main">×</span> <span class="tfree">'challenge'</span> <span class="main">×</span> <span class="tfree">'response'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'msg'</span><span class="main">,</span><span class="tfree">'response'</span><span class="main">)</span> sim_out <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'msg'</span> <span class="main">×</span> <span class="tfree">'response'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'pub_input'</span><span class="main">,</span> <span class="tfree">'msg'</span><span class="main">,</span> <span class="tfree">'challenge'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">,</span> <span class="tfree">'witness'</span><span class="main">)</span> prover_adversary 
                  <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input'</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg'</span><span class="main">,</span> <span class="tfree">'challenge'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">)</span> conv_tuple 
                        <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg'</span><span class="main">,</span> <span class="tfree">'challenge'</span><span class="main">,</span> <span class="tfree">'response'</span><span class="main">)</span> conv_tuple <span class="main">⇒</span> <span class="tfree">'witness'</span> spmf"</span></span>

<span class="keyword1"><span class="command">locale</span></span> Σ_protocols_base <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand</span> <span class="main">×</span> <span class="tfree">'msg</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹initial message in <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Σ›</span></span>-protocol›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="tfree">'challenge</span>  <span class="main">⇒</span> <span class="tfree">'response</span> spmf"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'msg</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="tfree">'response</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span> <span class="tfree">'witness</span><span class="main">)</span> set"</span></span> <span class="comment1">― ‹The relation the <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Σ›</span></span> protocol is considered over›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> sim_out spmf"</span></span> <span class="comment1">― ‹Simulator for the HVZK property›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span><span class="main">,</span> <span class="tfree">'msg</span><span class="main">,</span> <span class="tfree">'challenge</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">,</span> <span class="tfree">'witness</span><span class="main">)</span> prover_adversary"</span></span> <span class="comment1">― ‹Special soundness adversary›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'challenge</span> set"</span></span> <span class="comment1">― ‹The set of valid challenges›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> domain_subset_valid_pub<span class="main">:</span> <span class="quoted"><span class="quoted">"Domain <span class="free">Rel</span> <span class="main">⊆</span> <span class="free">valid_pub</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> Domain <span class="free">Rel</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The language defined by the relation is the set of all public inputs such that there exists a witness that satisfies the relation.›</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">L</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The first property of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols we consider is completeness, we define a probabilistic programme 
that runs the components of the protocol and outputs the boolean defined by the check algorithm.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">completeness_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">completeness_game</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="free">response</span> <span class="bound">r</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">check</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We define completeness as the probability that the completeness-game returns true for all challenges assuming the relation holds on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>h›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>w›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">completeness</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">h</span> <span class="bound">w</span> <span class="bound">e</span> <span class="main">.</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span> <span class="main">⟶</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> spmf <span class="main">(</span>completeness_game <span class="bound">h</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Second we consider the honest verifier zero knowledge property (HVZK). To reason about this we construct the real view of the 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol given a challenge <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>e›</span></span></span></span> as input.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg</span><span class="main">,</span> <span class="tfree">'challenge</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> conv_tuple spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="free">response</span> <span class="bound">r</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">S</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">S_raw</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_S_raw_imp_lossless_S<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">S_raw</span> <span class="free">h</span> <span class="free">e</span><span class="main">)</span> <span class="main">⟶</span> lossless_spmf <span class="main">(</span>S <span class="free">h</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The HVZK property requires that the simulator's output distribution is equal to the real views output distribution.›</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">HVZK</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span><span class="main">.</span> 
                      <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">∈</span><span class="free">Rel</span><span class="main">.</span> R <span class="bound">h</span> <span class="bound">w</span> <span class="bound">e</span> <span class="main">=</span> S <span class="bound">h</span> <span class="bound">e</span><span class="main">)</span>
                        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">h</span> <span class="main">∈</span> <span class="free">valid_pub</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">S_raw</span> <span class="bound">h</span> <span class="bound">e</span><span class="main">)</span><span class="main">.</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The final property to consider is that of special soundness. This says that given two valid transcripts such that the challenges 
are not equal there exists an adversary <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>𝒜ss›</span></span></span></span> that can output the witness.›</span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">special_soundness</span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">h</span> <span class="bound">e</span> <span class="bound">e'</span> <span class="bound">a</span> <span class="bound">z</span> <span class="bound">z'</span><span class="main">.</span> <span class="bound">h</span> <span class="main">∈</span> <span class="free">valid_pub</span> <span class="main">⟶</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span>  <span class="bound">e</span> <span class="main">≠</span> <span class="bound">e'</span> 
              <span class="main">⟶</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span> <span class="main">⟶</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e'</span> <span class="bound">z'</span> <span class="main">⟶</span> <span class="main">(</span>lossless_spmf <span class="main">(</span><span class="free">𝒜ss</span> <span class="bound">h</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="bound">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
                  <span class="main">(</span><span class="main">∀</span><span class="bound">w'</span><span class="main">∈</span>set_spmf <span class="main">(</span><span class="free">𝒜ss</span> <span class="bound">h</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e'</span><span class="main">,</span><span class="bound">z'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness_alt<span class="main">:</span>
  <span class="quoted"><span class="quoted">"special_soundness <span class="main">⟷</span>
      <span class="main">(</span><span class="main">∀</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span> <span class="bound">e'</span> <span class="bound">z'</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> <span class="bound">h</span> <span class="main">∈</span> <span class="free">valid_pub</span> 
          <span class="main">⟶</span> <span class="bound">e</span> <span class="main">≠</span> <span class="bound">e'</span> <span class="main">⟶</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span> <span class="main">∧</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e'</span> <span class="bound">z'</span> 
              <span class="main">⟶</span> bind_spmf <span class="main">(</span><span class="free">𝒜ss</span> <span class="bound">h</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e'</span><span class="main">,</span><span class="bound">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">w'</span><span class="main">.</span> return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> return_spmf True<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> special_soundness_def map_spmf_conv_bind_spmf<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> map_pmf_eq_return_pmf_iff in_set_spmf lossless_iff_set_pmf_None<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">metis</span> Domain.DomainI in_set_spmf not_Some_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> Domain.intros <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Σ_protocol</span> <span class="main">≡</span> completeness <span class="main">∧</span> special_soundness <span class="main">∧</span> HVZK"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹General lemmas›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_complete_game<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">h</span> <span class="bound">w</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free">init</span> <span class="bound">h</span> <span class="bound">w</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">r</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free">response</span> <span class="bound">r</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>completeness_game <span class="free">h</span> <span class="free">w</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeness_game_def lossless_init lossless_response split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> complete_game_return_true<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"completeness"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">h</span> <span class="bound">w</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free">init</span> <span class="bound">h</span> <span class="bound">w</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">r</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">.</span> lossless_spmf <span class="main">(</span><span class="free">response</span> <span class="bound">r</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> <span class="free">challenge_space</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"completeness_game <span class="free">h</span> <span class="free">w</span> <span class="free">e</span> <span class="main">=</span> return_spmf True"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>completeness_game <span class="free">h</span> <span class="free">w</span> <span class="free">e</span><span class="main">)</span> True <span class="main">=</span> spmf <span class="main">(</span>return_spmf True<span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms Σ_protocol_def completeness_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"completeness_game <span class="free">h</span> <span class="free">w</span> <span class="free">e</span> <span class="main">=</span> return_spmf True"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> lossless_complete_game lossless_init lossless_response lossless_return_spmf spmf_False_conv_True spmf_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeness_game_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> HVZK_unfold1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Σ_protocol"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">h</span> <span class="bound">w</span> <span class="bound">e</span><span class="main">.</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span> <span class="main">⟶</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> R <span class="bound">h</span> <span class="bound">w</span> <span class="bound">e</span> <span class="main">=</span> S <span class="bound">h</span> <span class="bound">e</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol_def HVZK_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK_unfold2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Σ_protocol"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">h</span> <span class="bound">e</span> <span class="bound">out</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> <span class="bound">h</span> <span class="main">∈</span> <span class="free">valid_pub</span> <span class="main">⟶</span> <span class="bound">out</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">S_raw</span> <span class="bound">h</span> <span class="bound">e</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">check</span> <span class="bound">h</span> <span class="main">(</span>fst <span class="bound">out</span><span class="main">)</span> <span class="bound">e</span> <span class="main">(</span>snd <span class="bound">out</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol_def HVZK_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK_unfold2_alt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Σ_protocol"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">⟶</span> <span class="bound">h</span> <span class="main">∈</span> <span class="free">valid_pub</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">S_raw</span> <span class="bound">h</span> <span class="bound">e</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">check</span> <span class="bound">h</span> <span class="bound">a</span> <span class="bound">e</span> <span class="bound">z</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol_def HVZK_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Commitments from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In this section we provide a general proof that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocols can be used to construct commitment schemes. 
We follow  the construction given by Damgard in \cite{sigma_protocols}.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> Σ_protocols_to_commitments <span class="main">=</span> Σ_protocols_base <span class="quoted"><span class="free">init</span></span> <span class="quoted"><span class="free">response</span></span> <span class="quoted"><span class="free">check</span></span> <span class="quoted"><span class="free">Rel</span></span> <span class="quoted"><span class="free">S_raw</span></span> <span class="quoted"><span class="free">𝒜ss</span></span> <span class="quoted"><span class="free">challenge_space</span></span> <span class="quoted"><span class="free">valid_pub</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand</span> <span class="main">×</span> <span class="tfree">'msg</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand</span> <span class="main">⇒</span> <span class="tfree">'witness</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="tfree">'response</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'msg</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="tfree">'response</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span> <span class="tfree">'witness</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">)</span> sim_out spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span><span class="main">,</span> <span class="tfree">'msg</span><span class="main">,</span> <span class="tfree">'challenge</span><span class="main">,</span> <span class="tfree">'response</span><span class="main">,</span> <span class="tfree">'witness</span><span class="main">)</span> prover_adversary"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'challenge</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span> <span class="tfree">'witness</span><span class="main">)</span> spmf"</span></span> <span class="comment1">― ‹generates pairs that satisfy the relation›</span>
    <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Σ_prot<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ_protocol"</span></span> <span class="comment1">― ‹assume we have a <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Σ›</span></span>-protocol›</span>
    <span class="keyword2"><span class="keyword">and</span></span> set_spmf_G_rel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span>"</span></span> <span class="comment1">― ‹the generator has the desired property›</span>  
    <span class="keyword2"><span class="keyword">and</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">init</span> <span class="free">h</span> <span class="free">w</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">response</span> <span class="free">r</span> <span class="free">w</span> <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_spmf_G_domain_rel <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="free">h</span> <span class="main">∈</span> Domain <span class="free">Rel</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> set_spmf_G_rel <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

<span class="keyword1"><span class="command">lemma</span></span> set_spmf_G_L <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="free">h</span> <span class="main">∈</span> L"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq set_spmf_G_rel L_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We define the advantage associated with the hard relation, this is used in the proof of the binding property where
we reduce the binding advantage to the relation advantage.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_game</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> spmf<span class="main">)</span> <span class="main">⇒</span> bool spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_game</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="bound">w'</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_advantage</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> spmf<span class="main">)</span> <span class="main">⇒</span> real"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_advantage</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="main">≡</span> spmf <span class="main">(</span>rel_game <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span><span class="main">)</span> True"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We now define the algorithms that define the commitment scheme constructed from a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">key_gen</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span>  <span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span> <span class="tfree">'witness</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
   <span class="quoted"><span class="quoted">"<span class="free">key_gen</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">commit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg</span> <span class="main">×</span>  <span class="tfree">'response</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">commit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> S <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">verify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">×</span> <span class="tfree">'witness</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'challenge</span> <span class="main">⇒</span> <span class="tfree">'msg</span> <span class="main">⇒</span>  <span class="tfree">'response</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">verify</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free">check</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We allow the adversary to output any message, so this means the type constraint is enough›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_msg</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∈</span> <span class="free">challenge_space</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Showing the construction of a commitment scheme from a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol is a  valid commitment scheme is trivial.›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> abstract_com<span class="main">:</span> abstract_commitment <span class="quoted">key_gen</span> <span class="quoted">commit</span> <span class="quoted">verify</span> <span class="quoted">valid_msg</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">paragraph</span></span><span class="quoted"><span class="plain_text">‹Correctness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> commit_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">m</span> <span class="main">∈</span> <span class="free">challenge_space</span><span class="main">.</span> abstract_com.correct_game <span class="bound">m</span> <span class="main">=</span> return_spmf True"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span>
    <span class="keyword3"><span class="command">assume</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> <span class="free">challenge_space</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"abstract_com.correct_game <span class="skolem">m</span> <span class="main">=</span> return_spmf True"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"abstract_com.correct_game <span class="skolem">m</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="main">(</span><span class="bound">vk1</span><span class="main">,</span><span class="bound">vk2</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> key_gen<span class="main">;</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> S <span class="bound">ck</span> <span class="skolem">m</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="free">check</span> <span class="bound">vk1</span> <span class="bound">a</span> <span class="skolem">m</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> abstract_com.correct_game_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> commit_def verify_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="main">(</span><span class="bound">ck</span><span class="main">,</span> <span class="main">(</span><span class="bound">vk1</span><span class="main">,</span><span class="bound">vk2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> S <span class="bound">ck</span> <span class="skolem">m</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="free">check</span> <span class="bound">vk1</span> <span class="bound">a</span> <span class="skolem">m</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> S <span class="bound">x</span> <span class="skolem">m</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="free">check</span> <span class="bound">x</span> <span class="bound">a</span> <span class="skolem">m</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> R <span class="bound">x</span> <span class="bound">w</span> <span class="skolem">m</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="free">check</span> <span class="bound">x</span> <span class="bound">a</span> <span class="skolem">m</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> Σ_prot HVZK_unfold1 m
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
      <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="bound">x</span> <span class="bound">w</span><span class="main">;</span>
      <span class="bound">z</span> <span class="main">←</span> <span class="free">response</span> <span class="bound">r</span> <span class="bound">w</span> <span class="skolem">m</span><span class="main">;</span>
      return_spmf <span class="main">(</span><span class="free">check</span> <span class="bound">x</span> <span class="bound">a</span> <span class="skolem">m</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
      return_spmf True<span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> complete_game_return_true lossless_init lossless_response Σ_prot Σ_protocol_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def completeness_game_def Σ_protocols_base.Σ_protocol_def m <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"abstract_com.correct_game <span class="skolem">m</span> <span class="main">=</span> return_spmf True"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const lossless_G lossless_weight_spmfD split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> abstract_com.correct_def abstract_com.valid_msg_set_def valid_msg_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">paragraph</span></span><span class="quoted"><span class="plain_text">‹The hiding property›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We first show we have perfect hiding with respect to the hiding game that allows the adversary to choose
the messages that are committed to, this is akin to the ind-cpa game for encryption schemes.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> perfect_hiding<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">𝒜1</span></span> <span class="skolem"><span class="skolem">𝒜2</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">𝒜</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"abstract_com.hiding_game_ind_cpa <span class="main">(</span><span class="skolem">𝒜1</span><span class="main">,</span> <span class="skolem">𝒜2</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span> 
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> S <span class="bound">x</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">a</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_com.hiding_game_ind_cpa_def commit_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> key_gen_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">::</span> bool <span class="main">←</span> coin_spmf<span class="main">;</span> 
    <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">←</span> R <span class="bound">x</span> <span class="bound">w</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b'</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">a</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">b'</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_prot  HVZK_unfold1 valid_msg_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span> 
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="bound">x</span> <span class="bound">w</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">::</span> <span class="tfree">'response</span> <span class="main">←</span> <span class="free">response</span> <span class="bound">r</span> <span class="bound">w</span> <span class="main">(</span><span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="bound">m0</span> <span class="keyword1">else</span> <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">a</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf<span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Σ_protocols_base.R_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def R_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">b</span> <span class="main">←</span> coin_spmf<span class="main">;</span> 
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="bound">x</span> <span class="bound">w</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">a</span> <span class="bound">σ</span><span class="main">;</span>
    return_spmf<span class="main">(</span><span class="bound">guess</span> <span class="main">=</span> <span class="bound">b</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const lossless_response lossless_weight_spmfD<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">m0</span><span class="main">,</span> <span class="bound">m1</span><span class="main">)</span><span class="main">,</span> <span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> <span class="skolem">𝒜1</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span>valid_msg <span class="bound">m0</span> <span class="main">∧</span> valid_msg <span class="bound">m1</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">←</span> <span class="free">init</span> <span class="bound">x</span> <span class="bound">w</span><span class="main">;</span>
    <span class="bound">guess</span> <span class="main">::</span> bool <span class="main">←</span> <span class="skolem">𝒜2</span> <span class="bound">a</span> <span class="bound">σ</span><span class="main">;</span>
    map_spmf<span class="main">(</span> <span class="main">(=)</span> <span class="bound">guess</span><span class="main">)</span> coin_spmf<span class="main">}</span> <span class="keyword1">ELSE</span> coin_spmf"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_spmf_conv_bind_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> coin_spmf"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_eq_const_coin_spmf try_bind_spmf_lossless2' Let_def split_def bind_spmf_const scale_bind_spmf weight_spmf_le_1 scale_scale_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>abstract_com.hiding_game_ind_cpa <span class="free">𝒜</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span><span class="main">/</span><span class="numeral">2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_of_set<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abstract_com.perfect_hiding_ind_cpa_def abstract_com.hiding_advantage_ind_cpa_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We reduce the security of the binding property to the relation advantage. To do this we first construct 
an adversary that interacts with the relation game. This adversary succeeds if the binding adversary succeeds.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg</span> <span class="main">×</span> <span class="tfree">'challenge</span> <span class="main">×</span> <span class="tfree">'response</span> <span class="main">×</span> <span class="tfree">'challenge</span> <span class="main">×</span> <span class="tfree">'response</span><span class="main">)</span> spmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'pub_input</span> <span class="main">⇒</span> <span class="tfree">'witness</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">adversary</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span> <span class="bound">ez</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="bound">ez'</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span>
    <span class="free">𝒜ss</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">e</span><span class="main">,</span><span class="bound">ez</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">e'</span><span class="main">,</span><span class="bound">ez'</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_advantage<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> rel_advantage <span class="main">(</span>adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"abstract_com.bind_game <span class="free">𝒜</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">x</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">m</span> <span class="main">≠</span> <span class="bound">m'</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">∈</span> <span class="free">challenge_space</span> <span class="main">∧</span> <span class="bound">m'</span> <span class="main">∈</span> <span class="free">challenge_space</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b</span> <span class="main">=</span> <span class="free">check</span> <span class="bound">x</span> <span class="bound">c</span> <span class="bound">m</span> <span class="bound">d</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">b'</span> <span class="main">=</span> <span class="free">check</span> <span class="bound">x</span> <span class="bound">c</span> <span class="bound">m'</span> <span class="bound">d'</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">b</span> <span class="main">∧</span> <span class="bound">b'</span><span class="main">)</span><span class="main">;</span> 
  <span class="bound">w'</span> <span class="main">←</span> <span class="free">𝒜ss</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abstract_com.bind_game_alt_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  key_gen_def verify_def Let_def split_def valid_msg_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">using</span></span> special_soundness_def Σ_prot Σ_protocol_def special_soundness_alt special_soundness_def set_spmf_G_rel set_spmf_G_domain_rel 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> basic_trans_rules<span class="main"><span class="main">(</span></span>31<span class="main"><span class="main">)</span></span> bind_spmf_cong domain_subset_valid_pub<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> spmf <span class="main">(</span><span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">←</span> <span class="free">G</span><span class="main">;</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">x</span><span class="main">;</span>
  <span class="bound">w'</span> <span class="main">←</span> <span class="free">𝒜ss</span> <span class="bound">x</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">m</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">m'</span><span class="main">,</span> <span class="bound">d'</span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False<span class="main">)</span> True"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> abstract_com.bind_advantage_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spmf_try_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ord_spmf_eq_leD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ord_spmf_bind_reflI<span class="main"><span class="keyword3">;</span></span><span class="operator">clarsimp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_spmf_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_game_def adversary_def split_def rel_advantage_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Schnorr_Sigma_Commit">
<div class="head">
<h1>Theory Schnorr_Sigma_Commit</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In this section we show the Schnoor protocol \cite{DBLP:journals/joc/Schnorr91} is a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol and then use it to construct a commitment scheme.
The security statements for the resulting commitment scheme come for free from our general proof of the construction.›</span></span> 

<span class="keyword1"><span class="command">theory</span></span> Schnorr_Sigma_Commit <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
  <a href="Sigma_Protocols.html">Sigma_Protocols</a>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
  <a href="Discrete_Log.html">Discrete_Log</a>
  <a href="Number_Theory_Aux.html">Number_Theory_Aux</a>
  <a href="Uniform_Sampling.html">Uniform_Sampling</a> 
  <span class="quoted">"<a href="../../HOL/HOL-Number_Theory/Cong.html">HOL-Number_Theory.Cong</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> schnorr_base <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prime_order<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> order_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> prime_order prime_gt_0_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The types for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> witness <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> rand <span class="main">=</span> <span class="quoted">nat</span> 
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> msg <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> response <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> challenge <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_in <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R_DL</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_in <span class="main">×</span> witness<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R_DL</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> witness <span class="main">⇒</span> <span class="main">(</span>rand <span class="main">×</span> <span class="tfree">'grp</span> msg<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">r</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>init <span class="free">h</span> <span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">response</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>response <span class="free">r</span> <span class="free">w</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> response_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_in <span class="main">×</span> witness<span class="main">)</span> spmf"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf G"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">challenge_space</span> <span class="main">=</span> <span class="main">{..&lt;</span> order <span class="free">𝒢</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">check</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> <span class="tfree">'grp</span> msg <span class="main">⇒</span> challenge <span class="main">⇒</span> response <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">check</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⊗</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">S2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> challenge <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> response<span class="main">)</span> sim_out spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S2</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="bound">c</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">c</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ss_adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ss_adversary</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="bound">z'</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">e</span> <span class="main">&gt;</span> <span class="bound">e'</span><span class="main">)</span> <span class="keyword1">then</span> 
                    <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z</span> <span class="main">-</span> int <span class="bound">z'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="main">(</span><span class="bound">e</span> <span class="main">-</span> <span class="bound">e'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
                        <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z'</span> <span class="main">-</span> int <span class="bound">z</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="main">(</span><span class="bound">e'</span> <span class="main">-</span> <span class="bound">e</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_pub</span> <span class="main">=</span> carrier <span class="free">𝒢</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We now use the Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol use Schnorr to construct a commitment scheme.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> ck <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span> 
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> vk <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> plain <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> commit <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="quoted">"opening"</span> <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The adversary we use in the discrete log game to reduce the binding property to the discrete log assumption.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dis_log_𝒜</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> ck<span class="main">,</span> plain<span class="main">,</span> <span class="tfree">'grp</span> commit<span class="main">,</span> opening<span class="main">)</span> bind_adversary <span class="main">⇒</span> <span class="tfree">'grp</span> ck <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">dis_log_𝒜</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span> <span class="bound">z</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="bound">z'</span><span class="main">)</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">𝒜</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="bound">e</span> <span class="main">&gt;</span> <span class="bound">e'</span> <span class="main">∧</span> <span class="main">¬</span> <span class="main">[</span><span class="bound">e</span> <span class="main">=</span> <span class="bound">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span>gcd <span class="main">(</span><span class="bound">e</span> <span class="main">-</span> <span class="bound">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">c</span> <span class="main">∈</span> carrier <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">c</span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="bound">e</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">c</span> <span class="main">⊗</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="bound">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z'</span><span class="main">)</span><span class="main">;</span> 
  return_spmf  <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z</span> <span class="main">-</span> int <span class="bound">z'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="main">(</span><span class="bound">e</span> <span class="main">-</span> <span class="bound">e'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> discrete_log<span class="main">:</span> dis_log <span class="quoted"><span class="free">𝒢</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> schnorr_sigma_protocol <span class="main">=</span> schnorr_base <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Schnorr_Σ<span class="main">:</span> Σ_protocols_base <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R_DL</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_DL_def valid_pub_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol is complete.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> completeness<span class="main">:</span> <span class="quoted"><span class="quoted">"Schnorr_Σ.completeness"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">+</span> <span class="skolem">w'</span> <span class="main">*</span> <span class="skolem">e</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">e</span> <span class="skolem">w'</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">using</span></span> nat_pow_pow nat_pow_mult <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> Schnorr_Σ.completeness_game_def Schnorr_Σ.completeness_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def response_def check_def pow_generator_mod R_DL_def add.commute bind_spmf_const<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The next two lemmas help us rewrite terms in the proof  of honest verfier zero knowledge.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> zr_rewrite<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> x_neq_0<span class="main">:</span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="free">r</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def mult.assoc z<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">=</span> <span class="free">r</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">&gt;</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def mult_less_cancel2 n_less_m_mult_n neq0_conv prime_gt_1_nat prime_order trans_less_add2 x_neq_0 False<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong add_diff_inverse_nat cong_add_lcancel_nat less_imp_le linorder_not_le<span class="main">)</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def r<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> h_sub_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> x_neq_0<span class="main">:</span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_imp_le_nat mult_le_mono<span class="main">)</span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> lhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span>  <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms x_neq_0 prime_gt_1_nat prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_pow_int<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bound generator_closed int_ops<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> int_pow_int of_nat_eq_0_iff of_nat_less_0_iff of_nat_less_iff int_pow_diff<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_pow_int<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_pow<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">𝟭</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> generator_pow_order
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generator_closed mult_is_0 nat_pow_0 nat_pow_pow<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> lhs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_R_rewrite_grp<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">c</span> <span class="free">r</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">inv</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">r</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">=</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span>  
              <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_def One_nat_def add_diff_inverse_nat cong_diff_nat less_imp_le_nat linorder_not_less mod_add_left_eq mult.assoc n_less_m_mult_n prime_gt_1_nat prime_order trans_less_add2 zero_less_diff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span>  
              <span class="main">=</span>  order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_def mult.assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">x</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_carrier pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> neg_power_inverse 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms inverse_pow_pow pow_generator_mod<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hv_zk<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">∈</span> R_DL"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.R <span class="free">h</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> Schnorr_Σ.S <span class="free">h</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.R <span class="free">h</span> <span class="free">x</span> <span class="free">c</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">r</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
      return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def Schnorr_Σ.R_def init_def response_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms zr_rewrite R_DL_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
      return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">z</span> <span class="main">←</span>  <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">x</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">x</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
      return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> samp_uni_plus_one_time_pad pow_generator_mod<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
      <span class="bound">z</span> <span class="main">←</span>  <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">;</span> 
      return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h_sub_rewrite assms R_DL_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Schnorr_Σ.S_def S2_def map_spmf_conv_bind_spmf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We can now prove that honest verifier zero knowledge holds for the Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> honest_verifier_ZK<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.HVZK"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Schnorr_Σ.HVZK_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hv_zk R_DL_def S2_def check_def valid_pub_def challenge_space_def cyclic_group_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹It is left to prove the special soundness property. First we prove a lemma we use to rewrite a 
term in the special soundness proof and then prove the property itself.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ss_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="main">&lt;</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a_mem<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">a</span>  <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> h_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> prime_field 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Primes.prime_nat_def assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> coprime_imp_gcd_eq_1 diff_is_0_eq less_imp_diff_less 
            mod_less nat_minus_as_int not_less schnorr_base.prime_order schnorr_base_axioms<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> a a_mem 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h_mem group.inv_solve_right<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> a' a_mem 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h_mem group.inv_solve_right<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span>  <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h_mem 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> a a' h_mem a_mem cyclic_group_assoc cyclic_group_commute nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span>  t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span>  <span class="main">[^]</span> <span class="skolem">t</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> h_mem generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span>  <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z'</span> <span class="main">+</span>  <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span> "</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monoid.nat_pow_mult nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">z'</span> <span class="main">+</span>  <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod order_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span> <span class="main">=</span> int <span class="free">z'</span> <span class="main">+</span>  int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_iff_lin<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>›</span></span> right_diff_distrib<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> cong_diff cong_mod_left cong_mult cong_refl cong_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_ops<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span> of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
              <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span>
                  <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="quoted"><span class="quoted">‹<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>›</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
          cong_scalar_right int_nat_eq less_imp_of_nat_less mod_less more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> nat_less_iff of_nat_0_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> gcd inverse assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> cong_scalar_left cong_trans less_imp_diff_less mod_less mult.comm_neutral nat_minus_as_int<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
              <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="keyword1">mod</span> order <span class="free">𝒢</span> 
              <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_mod_left <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span>  **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>nat <span class="main">(</span><span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>
              <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span>  order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Euclidean_Division.pos_mod_sign cong_int_iff int_nat_eq of_nat_0_less_iff order_gt_0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span>nat <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cyclic_group.pow_generator_eq_iff_cong cyclic_group_axioms order_gt_0 order_gt_0_iff_finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Euclidean_Division.pos_mod_sign discrete_log.order_gt_0 int_pow_def2 nat_minus_as_int of_nat_0_less_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The special soundness property for the Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.special_soundness"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Schnorr_Σ.special_soundness_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_pub_def ss_rewrite challenge_space_def split_def ss_adversary_def check_def R_DL_def Let_def<span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We are now able to prove that the Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol is a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol, the proof comes from the properties of
completeness, HVZK and special soundness we have previously proven.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> sigma_protocol<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.Σ_protocol"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Schnorr_Σ.Σ_protocol_def completeness honest_verifier_ZK special_soundness<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Having proven the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol property is satisfied we can show the commitment scheme we construct from the 
Schnorr <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol has the desired properties. This result comes with very little proof effort as we can instantiate
our general proof.›</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Schnorr_Σ_commit<span class="main">:</span> Σ_protocols_to_commitments <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R_DL</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> <span class="quoted">G</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_protocols_to_commitments_def Σ_protocols_to_commitments_axioms_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocols_base_def<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_DL_def valid_pub_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sigma_protocol lossless_G lossless_init lossless_response<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_DL_def G_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> Schnorr_Σ_commit.commit_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> Schnorr_Σ_commit.perfect_hiding<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> rel_adv_eq_dis_log_adv<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.rel_advantage <span class="free">𝒜</span> <span class="main">=</span> discrete_log.advantage <span class="free">𝒜</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.rel_game <span class="free">𝒜</span> <span class="main">=</span> discrete_log.dis_log <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Schnorr_Σ_commit.rel_game_def discrete_log.dis_log_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> 
       <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_def R_DL_def cong_less_modulus_unique_nat group_eq_pow_eq_mod finite_carrier pow_generator_eq_iff_cong<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Schnorr_Σ_commit.rel_advantage_def discrete_log.advantage_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> bind_advantage_bound_dis_log<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> discrete_log.advantage <span class="main">(</span>Schnorr_Σ_commit.adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Schnorr_Σ_commit.bind_advantage rel_adv_eq_dis_log_adv <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> schnorr_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> schnorr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> schnorr_sigma_protocol <span class="main">(</span><span class="free">𝒢</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> schnorr_sigma_protocol <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> schnorr<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol statement comes easily in the asymptotic setting.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> sigma_protocol<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Schnorr_Σ.Σ_protocol <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sigma_protocol<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that
we are able to show the binding advantage is negligible in the security parameter.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.abstract_com.correct <span class="free">n</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span>  Schnorr_Σ_commit.commit_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_perfect_hiding<span class="main">:</span> <span class="quoted"><span class="quoted">"Schnorr_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Schnorr_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_computational_binding<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> discrete_log.advantage <span class="bound">n</span> <span class="main">(</span>Schnorr_Σ_commit.adversary <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> Schnorr_Σ_commit.abstract_com.bind_advantage <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Schnorr_Σ_commit.bind_advantage assms Schnorr_Σ_commit.abstract_com.bind_advantage_def negligible_le bind_advantage_bound_dis_log <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Chaum_Pedersen_Sigma_Commit">
<div class="head">
<h1>Theory Chaum_Pedersen_Sigma_Commit</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Chaum-Pedersen <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The Chaum-Pedersen <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol \cite{DBLP:conf/crypto/ChaumP92} considers a relation of equality of discrete logs.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Chaum_Pedersen_Sigma_Commit <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
  <a href="Sigma_Protocols.html">Sigma_Protocols</a>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
  <a href="Discrete_Log.html">Discrete_Log</a>
  <a href="Number_Theory_Aux.html">Number_Theory_Aux</a>
  <a href="Uniform_Sampling.html">Uniform_Sampling</a> 
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> chaum_ped_Σ_base <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  prime_order<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">g'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> or_gt_1<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> prime_order 
  <span class="keyword1"><span class="command">using</span></span> prime_gt_1_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> or_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> or_gt_1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">type_synonym</span></span> witness <span class="main">=</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> rand <span class="main">=</span> <span class="quoted">nat</span> 
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> msg <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> <span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> response <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> challenge <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_in <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span> <span class="main">×</span> <span class="tfree">'grp'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="bound">w</span><span class="main">)</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf G"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">challenge_space</span> <span class="main">=</span> <span class="main">{..&lt;</span> order <span class="free">𝒢</span><span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> witness <span class="main">⇒</span> <span class="main">(</span>rand <span class="main">×</span> <span class="tfree">'grp</span> msg<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span><span class="main">;</span>  
    <span class="bound">r</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">r</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="bound">r</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>init <span class="free">h</span> <span class="free">w</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  init_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">response</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> return_spmf <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">*</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>response <span class="free">r</span> <span class="free">w</span>  <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> response_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">check</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> <span class="tfree">'grp</span> msg <span class="main">⇒</span> challenge <span class="main">⇒</span> response <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">check</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span>  <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⊗</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">∧</span> snd <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⊗</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">∧</span> fst <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span> <span class="main">∧</span> snd <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_in <span class="main">×</span> witness<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>fst <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span> <span class="main">∧</span> snd <span class="bound">h</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="bound">w</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">S2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> challenge <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> response<span class="main">)</span> sim_out spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S2</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">;</span>
  <span class="bound">z</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">;</span> 
  <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span>  g' <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h'</span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ss_adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> nat spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ss_adversary</span> <span class="free"><span class="bound"><span class="entity">x'</span></span></span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span><span class="bound">b'</span><span class="main">)</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="bound">z'</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="bound">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z</span> <span class="main">-</span> int <span class="bound">z'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="bound">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="bound">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
<span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z'</span> <span class="main">-</span> int <span class="bound">z</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="bound">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="bound">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_pub</span> <span class="main">=</span> carrier <span class="free">𝒢</span> <span class="main">×</span> carrier <span class="free">𝒢</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> chaum_ped_Σ <span class="main">=</span> chaum_ped_Σ_base <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> g'_in_carrier <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"g' <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> g'_def<span class="main">)</span> 

<span class="keyword1"><span class="command">sublocale</span></span> chaum_ped_sigma<span class="main">:</span> Σ_protocols_base <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def valid_pub_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> completeness<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.completeness"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="main">(</span>g' <span class="main">[^]</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">w'</span> <span class="main">*</span> <span class="skolem">e</span> <span class="main">+</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">e</span> <span class="skolem">w'</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Groups.add_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> pow_carrier_mod nat_pow_pow nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">w'</span> <span class="main">*</span> <span class="skolem">e</span> <span class="main">+</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">e</span> <span class="skolem">w'</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.commute nat_pow_pow nat_pow_mult pow_generator_mod generator_closed mod_mult_right_eq<span class="main">)</span>  
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chaum_ped_sigma.completeness_def chaum_ped_sigma.completeness_game_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def challenge_space_def init_def check_def response_def split_def bind_spmf_const<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_xr'_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="free">r</span>  <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Nat.add_diff_assoc Num.of_nat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> One_nat_def add_less_same_cancel2 less_imp_le_nat 
        mod_add_left_eq mult.assoc mult_0_right n_less_m_mult_n nat_neq_iff not_add_less2 of_nat_0_le_iff prime_gt_1_nat prime_order<span class="main">)</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> r 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ab_semigroup_add_class.add_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ab_semigroup_mult_class.mult_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> diff_add_inverse mod_if mod_mult_self2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_h_sub_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">w</span>"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> w_gt_0<span class="main">:</span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">-</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_imp_le_nat mult_le_mono<span class="main">)</span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> lhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span>  <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> lhs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span> <span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms w_gt_0 
        <span class="keyword1"><span class="command">using</span></span> gr0I mult_less_cancel2 n_less_m_mult_n numeral_nat<span class="main">(</span>7<span class="main">)</span> prime_gt_1_nat prime_order zero_less_diff <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_pow_int<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> int <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> int_pow_diff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span>"</span></span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">*</span> <span class="free">c</span>"</span></span><span class="main">]</span> * generator_closed int_ops<span class="main">(</span>6<span class="main">)</span> int_pow_neg int_pow_neg_int <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_pow_int<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">w</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_pow<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">𝟭</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> generator_pow_order
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> generator_closed mult_is_0 nat_pow_0 nat_pow_pow<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> lhs <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_h_sub2_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  <span class="quoted"><span class="quoted">"<span class="free">h'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">w</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h'</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span> 
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">w</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> g'_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> w_gt_0<span class="main">:</span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> g'_carrier<span class="main">:</span> <span class="quoted"><span class="quoted">"g' <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h'</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> assms mult_strict_mono w_gt_0 prime_gt_1_nat prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">" g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span>int <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span><span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_ops<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> int_pow_int of_nat_0_less_iff order.irrefl<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>g' <span class="main">[^]</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> g'_carrier int_pow_diff int_pow_int<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h'</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_pow assms<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">𝟭</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h'</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> g'_carrier nat_pow_one nat_pow_pow pow_order_eq_1<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">z</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span> <span class="main">-</span> <span class="free">w</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_imp_le_nat mult_le_mono<span class="main">)</span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> lhs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hv_zk2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">H</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> R"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.R <span class="free">H</span> <span class="free">w</span> <span class="free">c</span> <span class="main">=</span> chaum_ped_sigma.S <span class="free">H</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> H<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">w</span><span class="main">::</span>nat<span class="main">)</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="free">w</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms R_def  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod.expand<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> g'_carrier<span class="main">:</span> <span class="quoted"><span class="quoted">"g' <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.R <span class="free">H</span> <span class="free">w</span> <span class="free">c</span>  <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">r</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chaum_ped_sigma.R_def Let_def response_def split_def init_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms hvzk_xr'_rewrite 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf Let_def o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> samp_uni_plus_one_time_pad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">*</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hvzk_h_sub_rewrite assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def H<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pow_generator_mod<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">*</span><span class="free">w</span><span class="main">*</span><span class="free">c</span> <span class="main">-</span> <span class="free">w</span><span class="main">*</span><span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> g'_carrier pow_carrier_mod<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"g'"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">h'</span><span class="main">)</span> <span class="main">=</span> <span class="free">H</span><span class="main">;</span>
    <span class="bound">z</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">a'</span> <span class="main">=</span>  g' <span class="main">[^]</span> <span class="bound">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="bound">h'</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">a'</span><span class="main">)</span><span class="main">,</span><span class="free">c</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> hvzk_h_sub2_rewrite assms H
     <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
   <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
     <span class="keyword1"><span class="command">unfolding</span></span> chaum_ped_sigma.S_def chaum_ped_sigma.R_def
     <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def S2_def split_def Let_def Σ_protocols_base.S_def bind_map_spmf map_spmf_conv_bind_spmf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.HVZK"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chaum_ped_sigma.HVZK_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hv_zk2 R_def valid_pub_def   S2_def check_def cyclic_group_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ss_rewrite1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span>"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> e'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="main">&lt;</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> e e' prime_field prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms inv_solve_right<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms inv_solve_right<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms cyclic_group_assoc cyclic_group_commute nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> nat_pow_pow 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod or_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span> <span class="main">=</span> int <span class="free">z'</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> right_diff_distrib<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> cong_scalar_left cong_trans inverse gcd<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span>  <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>  <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong_def int_ops<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span> mod_mod_trivial nat_int<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> order_gt_0 order_gt_0_iff_finite pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ss_rewrite2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="main">&lt;</span> <span class="free">e</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊗</span> fst <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> prime_field assms prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms inv_solve_right<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>10<span class="main"><span class="main">)</span></span> g'_def generator_closed group.inv_solve_right' group_l_invI l_inv_ex nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms cyclic_group_assoc cyclic_group_commute nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g'_def nat_pow_pow
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span> <span class="main">*</span> <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod order_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> int <span class="free">z</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span> <span class="main">=</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z'</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Groups.add_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> cong_int_iff int_ops<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> int_plus<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> int <span class="free">z</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_distrib<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> cong_scalar_left cong_trans gcd inverse<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong_def cong_mod_right more_arith_simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> nat_int zmod_int<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> order_gt_0 order_gt_0_iff_finite pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> * cong_def g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> pow_generator_mod_int<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> ss_rewrite_snd_h<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e_e'_mod<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">&lt;</span> <span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> h_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> a_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">a</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> a1<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">a</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a2<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">a</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> prime_field 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms less_imp_diff_less linorder_not_le prime_order<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">a</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a1 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Group.group.axioms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> h_mem a_mem group.inv_closed group_l_invI l_inv_ex monoid.m_assoc nat_pow_closed r_inv r_one<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"snd <span class="free">a</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span>snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> a2 h_mem a_mem g'_def generator_closed group.inv_solve_right' group_l_invI l_inv_ex nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="free">z</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="free">z'</span> <span class="main">⊗</span> snd <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> a2 h_mem a_mem a1 cyclic_group_assoc cyclic_group_commute nat_pow_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"snd <span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g'_def nat_pow_pow
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">x</span> <span class="main">*</span> <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod order_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> int <span class="free">z</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span> <span class="main">=</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z'</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Groups.add_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> cong_int_iff int_ops<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> int_plus<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> int <span class="free">z</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_distrib<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> int <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cong_def mod_diff_eq mod_mod_trivial mod_mult_right_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> int_ops<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span> less_imp_le_nat of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
                  <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cong_mod_right cong_scalar_right less_imp_diff_less mod_if more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> or_gt_0 unique_euclidean_semiring_numeral_class.pos_mod_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
               <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Number_Theory_Aux.inverse * gcd cong_scalar_left cong_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z</span> <span class="main">-</span> int <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong_def int_pow_int more_arith_simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> pow_generator_mod_int<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> pow_generator_mod_int<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.special_soundness"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> chaum_ped_sigma.special_soundness_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> challenge_space_def check_def ss_adversary_def R_def valid_pub_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> ss_rewrite2 ss_rewrite1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> Σ_protocol<span class="main">:</span>  <span class="quoted"><span class="quoted">"chaum_ped_sigma.Σ_protocol"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chaum_ped_sigma.Σ_protocol_def completeness HVZK special_soundness<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> chaum_ped_Σ_commit<span class="main">:</span> Σ_protocols_to_commitments <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> <span class="quoted">G</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol lossless_init lossless_response lossless_G<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def G_def<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> dis_log<span class="main">:</span> dis_log <span class="quoted"><span class="free">𝒢</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">sublocale</span></span> dis_log_alt<span class="main">:</span> dis_log_alt <span class="quoted"><span class="free">𝒢</span></span> <span class="quoted"><span class="free">x</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_alt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> reduction_to_dis_log<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.rel_advantage <span class="free">𝒜</span> <span class="main">=</span> dis_log.advantage <span class="main">(</span>dis_log_alt.adversary3 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.rel_game <span class="free">𝒜</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="bound">w</span><span class="main">)</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w'</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span>fst <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w'</span> <span class="main">∧</span> snd <span class="bound">h</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="bound">w'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> chaum_ped_Σ_commit.rel_game_def 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  G_def R_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>    
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">h</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">,</span> g' <span class="main">[^]</span> <span class="bound">w</span><span class="main">)</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w'</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">[</span><span class="bound">w</span> <span class="main">=</span> <span class="bound">w'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">[</span><span class="free">x</span><span class="main">*</span><span class="bound">w</span> <span class="main">=</span> <span class="free">x</span><span class="main">*</span><span class="bound">w'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_alt.dis_log3_def dis_log_alt.g'_def g'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_carrier nat_pow_pow pow_generator_eq_iff_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> dis_log_alt.dis_log3 <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  dis_log_alt.dis_log3_def dis_log_alt.g'_def g'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong  bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cong_scalar_left<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.rel_advantage <span class="free">𝒜</span> <span class="main">=</span> dis_log_alt.advantage3 <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chaum_ped_Σ_commit.rel_advantage_def dis_log_alt.advantage3_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_alt_reductions.dis_log_adv3 cyclic_group_axioms dis_log_alt.dis_log_alt_axioms dis_log_alt_reductions.intro<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> commitment_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> chaum_ped_Σ_commit.commit_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chaum_ped_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> binding<span class="main">:</span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> dis_log.advantage <span class="main">(</span>dis_log_alt.adversary3 <span class="main">(</span><span class="main">(</span>chaum_ped_Σ_commit.adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chaum_ped_Σ_commit.bind_advantage reduction_to_dis_log <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> chaum_ped_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cp_Σ<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> chaum_ped_Σ <span class="main">(</span><span class="free">𝒢</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> chaum_ped_Σ <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cp_Σ<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol statement comes easily in the asympotic setting.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> sigma_protocol<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"chaum_ped_sigma.Σ_protocol <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that
we are able to show the binding advantage is negligible in the security parameter.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.abstract_com.correct <span class="free">n</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span>  chaum_ped_Σ_commit.commit_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_perfect_hiding<span class="main">:</span> <span class="quoted"><span class="quoted">"chaum_ped_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chaum_ped_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_computational_binding<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> dis_log.advantage <span class="bound">n</span> <span class="main">(</span>dis_log_alt.adversary3 <span class="bound">n</span> <span class="main">(</span><span class="main">(</span>chaum_ped_Σ_commit.adversary <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> chaum_ped_Σ_commit.abstract_com.bind_advantage <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> chaum_ped_Σ_commit.bind_advantage assms chaum_ped_Σ_commit.abstract_com.bind_advantage_def negligible_le binding <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Okamoto_Sigma_Commit">
<div class="head">
<h1>Theory Okamoto_Sigma_Commit</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Okamoto <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Okamoto_Sigma_Commit <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Commitment_Schemes.html">Commitment_Schemes</a>
  <a href="Sigma_Protocols.html">Sigma_Protocols</a>
  <a href="Cyclic_Group_Ext.html">Cyclic_Group_Ext</a>
  <a href="Discrete_Log.html">Discrete_Log</a>
  <span class="quoted">"<a href="../../HOL/HOL/GCD.html">HOL.GCD</a>"</span>
  <a href="Number_Theory_Aux.html">Number_Theory_Aux</a>
  <a href="Uniform_Sampling.html">Uniform_Sampling</a> 
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> okamoto_base <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> cyclic_group"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> prime_order<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">g'</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> order_gt_1<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> prime_order 
  <span class="keyword1"><span class="command">using</span></span> prime_gt_1_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> order_gt_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> order_gt_1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">response</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">x2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">z1</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">r1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">z2</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">*</span> <span class="bound">x2</span> <span class="main">+</span> <span class="bound">r2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>response <span class="free">r</span> <span class="free">w</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> response_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> witness <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> rand <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> msg <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> response <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> challenge <span class="main">=</span> <span class="quoted">nat</span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'grp'</span> pub_in <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp'</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> witness <span class="main">⇒</span> <span class="main">(</span>rand <span class="main">×</span> <span class="tfree">'grp</span> msg<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">x2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">;</span> 
    <span class="bound">r1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">r2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span><span class="bound">r2</span><span class="main">)</span><span class="main">,</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">r1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">r2</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>init <span class="free">h</span>  <span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">check</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> <span class="tfree">'grp</span> msg <span class="main">⇒</span> challenge <span class="main">⇒</span> response <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">check</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">⊗</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∈</span> carrier <span class="free">𝒢</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_in <span class="main">×</span> witness<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">h</span><span class="main">,</span> <span class="bound">w</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>fst <span class="bound">w</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span>snd <span class="bound">w</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'grp</span> pub_in <span class="main">×</span> witness<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2</span> <span class="main">,</span> <span class="main">(</span><span class="bound">w1</span><span class="main">,</span><span class="bound">w2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">challenge_space</span> <span class="main">=</span> <span class="main">{..&lt;</span> order <span class="free">𝒢</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf G"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">S2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> challenge <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> response<span class="main">)</span> sim_out spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S2</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">z1</span> <span class="main">←</span> sample_uniform  <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z2</span> <span class="main">←</span> sample_uniform  <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
  <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span>  <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">z2</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">[^]</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">;</span> 
  return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> pub_in <span class="main">⇒</span> witness <span class="main">⇒</span> challenge <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R2</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">x2</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">;</span> 
    <span class="bound">r1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">r2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z1</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">*</span> <span class="bound">x1</span> <span class="main">+</span> <span class="bound">r1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z2</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">*</span> <span class="bound">x2</span> <span class="main">+</span> <span class="bound">r2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">r1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">r2</span> <span class="main">,</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ss_adversary</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'grp</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'grp</span> msg<span class="main">,</span> challenge<span class="main">,</span> response<span class="main">)</span> conv_tuple <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ss_adversary</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">e</span><span class="main">,</span> <span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c1</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a'</span><span class="main">,</span> <span class="bound">e'</span><span class="main">,</span> <span class="main">(</span><span class="bound">z1'</span><span class="main">,</span><span class="bound">z2'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="bound">e</span> <span class="main">&gt;</span> <span class="bound">e'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z1</span> <span class="main">-</span> int <span class="bound">z1'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">e</span> <span class="main">-</span> <span class="bound">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
                      <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z1'</span> <span class="main">-</span> int <span class="bound">z1</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">e'</span> <span class="main">-</span> <span class="bound">e</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> 
                 <span class="keyword1">if</span> <span class="main">(</span><span class="bound">e</span> <span class="main">&gt;</span> <span class="bound">e'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z2</span>  <span class="main">-</span> int <span class="bound">z2'</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">e</span> <span class="main">-</span> <span class="bound">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> 
                      <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="bound">z2'</span> <span class="main">-</span> int <span class="bound">z2</span><span class="main">)</span> <span class="main">*</span> inverse <span class="main">(</span><span class="bound">e'</span> <span class="main">-</span> <span class="bound">e</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_pub</span> <span class="main">=</span> carrier <span class="free">𝒢</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> okamoto <span class="main">=</span> okamoto_base <span class="main">+</span> cyclic_group <span class="quoted"><span class="free">𝒢</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> g'_in_carrier <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"g' <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">sublocale</span></span> Σ_protocols_base<span class="main">:</span> Σ_protocols_base <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def valid_pub_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.R <span class="free">h</span> <span class="free">w</span> <span class="free">c</span> <span class="main">=</span> R2 <span class="free">h</span> <span class="free">w</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocols_base.R_def R2_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def split_def response_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> completeness<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.completeness"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> fst <span class="skolem">w'</span> <span class="main">+</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> snd <span class="skolem">w'</span> <span class="main">+</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">ya</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="skolem">w'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">e</span> <span class="skolem">y</span> <span class="skolem">ya</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">w'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">×</span> nat"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> fst <span class="skolem">w'</span> <span class="main">+</span> <span class="skolem">y</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> snd <span class="skolem">w'</span> <span class="main">+</span> <span class="skolem">ya</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y</span> <span class="main">+</span> <span class="skolem">e</span> <span class="main">*</span> fst <span class="skolem">w'</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="skolem">ya</span> <span class="main">+</span> <span class="skolem">e</span> <span class="main">*</span> snd <span class="skolem">w'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cyclic_group.pow_carrier_mod cyclic_group_axioms g'_def add.commute pow_generator_mod<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> fst <span class="skolem">w'</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">ya</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> snd <span class="skolem">w'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> g'_def m_assoc nat_pow_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">ya</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> fst <span class="skolem">w'</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="skolem">e</span> <span class="main">*</span> snd <span class="skolem">w'</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> add.commute g'_def generator_closed m_assoc nat_pow_closed nat_pow_mult nat_pow_pow<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">ya</span> <span class="main">⊗</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span> <span class="main">⊗</span> <span class="main">(</span>g' <span class="main">[^]</span> snd <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_assoc mult.commute nat_pow_pow<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">y</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">ya</span> <span class="main">⊗</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="skolem">w'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="skolem">w'</span><span class="main">)</span> <span class="main">[^]</span> <span class="skolem">e</span><span class="main">)</span>"</span></span>   
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> power_distrib g'_def generator_closed mult.commute nat_pow_closed nat_pow_mult nat_pow_pow<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_protocols_base.completeness_def Σ_protocols_base.completeness_game_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def challenge_space_def init_def check_def response_def split_def bind_spmf_const<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_z_r<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> r1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r1</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r1</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="main">(</span><span class="free">x1</span> <span class="main">::</span> nat<span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> r1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> x1_neq_0<span class="main">:</span> False
  <span class="keyword1"><span class="command">have</span></span> z1_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">=</span> <span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> gr_implies_not_zero order_gt_1
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> cong_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">=</span> <span class="free">r1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> z1_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> x1_neq_0 False 
      <span class="keyword1"><span class="command">using</span></span> prime_gt_1_nat prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Groups.add_ac<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> add_diff_inverse_nat cong_add_lcancel_nat diff_is_0_eq le_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> neq0_conv trans_less_add2 z1_eq zero_less_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> r1 cong_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_z1_r1_tuple_rewrite<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> r1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r1</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">r1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">r2</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">,</span> <span class="main">(</span><span class="free">r2</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> 
              <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>  
                  <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">r2</span><span class="main">,</span> <span class="free">c</span><span class="main">,</span> <span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">,</span> <span class="main">(</span><span class="free">r2</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">r1</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms hvzk_z_r <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">argo</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_z2_r2_tuple_rewrite<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xb</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">x'</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> 
            <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">xb</span><span class="main">,</span> <span class="free">xa</span><span class="main">,</span> <span class="main">(</span><span class="free">x'</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">,</span> <span class="main">(</span><span class="free">xb</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span>
               <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">x'</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> 
                <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">xb</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">,</span> <span class="free">xa</span><span class="main">,</span> <span class="main">(</span><span class="free">x'</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">,</span> <span class="main">(</span><span class="free">xb</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"g' <span class="main">[^]</span> <span class="free">xb</span> <span class="main">=</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">xb</span> <span class="main">+</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">xa</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> hvzk_z_r assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">argo</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk_sim_inverse_rewrite<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x1</span> <span class="main">::</span> nat<span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="free">x2</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">z1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">z2</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>
                <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> in_carrier1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>g' <span class="main">[^]</span> <span class="free">x2</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">have</span></span> in_carrier2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x1</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> pow_distrib1<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">=</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> pow_distrib2<span class="main">:</span> <span class="quoted"><span class="quoted">"order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">=</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> diff_mult_distrib<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z1</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="free">z2</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span>  <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pow_carrier_mod<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z1</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="free">z2</span> <span class="main">+</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> h 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Nat.add_diff_assoc diff_zero le_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nat_0_less_mult_iff neq0_conv pow_distrib1 pow_distrib2 prime_gt_1_nat prime_order zero_less_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nat_pow_mult 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m_assoc<span class="main">)</span> 
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> add.commute g'_def generator_closed m_assoc nat_pow_closed nat_pow_mult nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> pow_distrib1 pow_distrib2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">argo</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span>g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>order <span class="free">𝒢</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="main">(</span><span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">x1</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span>g' <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">x2</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms neg_power_inverse  inverse_pow_pow nat_pow_pow prime_gt_1_nat prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">x1</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span>g' <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">x2</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inverse_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="main">(</span><span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x1</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span>g' <span class="main">[^]</span> <span class="free">x2</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult.commute cyclic_group_assoc nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x1</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span> <span class="main">⊗</span> <span class="main">(</span>g' <span class="main">[^]</span> <span class="free">x2</span><span class="main">)</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inverse_split in_carrier2 in_carrier1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> h  cyclic_group_commute monoid_comm_monoidI 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pow_mult_distrib<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> h inverse_pow_pow<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hv_zk<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">x1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">x2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.R <span class="free">h</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">x2</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> Σ_protocols_base.S <span class="free">h</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.R <span class="free">h</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">x2</span><span class="main">)</span> <span class="free">c</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">r1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">r2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z1</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z2</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r2</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">r1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">r2</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocols_base.R_def R2_def<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute init_def split_def response_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">r2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z1</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r1</span><span class="main">.</span> <span class="main">(</span><span class="bound">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z2</span> <span class="main">=</span> <span class="main">(</span><span class="bound">r2</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z1</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">r2</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def Let_def hvzk_z1_r1_tuple_rewrite assms <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">z1</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r1</span><span class="main">.</span> <span class="main">(</span><span class="bound">r1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z2</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r2</span><span class="main">.</span> <span class="main">(</span><span class="bound">r2</span> <span class="main">+</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z1</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z2</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def Let_def hvzk_z2_r2_tuple_rewrite <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">z1</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r1</span><span class="main">.</span> <span class="main">(</span><span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">+</span> <span class="bound">r1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z2</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">r2</span><span class="main">.</span> <span class="main">(</span><span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">+</span> <span class="bound">r2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z1</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z2</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">z1</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z2</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z1</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="bound">z2</span> <span class="main">+</span> order <span class="free">𝒢</span> <span class="main">*</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span> <span class="main">-</span> <span class="free">c</span> <span class="main">*</span> <span class="free">x2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> samp_uni_plus_one_time_pad<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> 
    <span class="bound">z1</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">z2</span> <span class="main">←</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">z2</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1">inv</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">c</span><span class="main">)</span> <span class="main">,</span><span class="free">c</span><span class="main">,</span><span class="main">(</span><span class="bound">z1</span><span class="main">,</span><span class="bound">z2</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hvzk_sim_inverse_rewrite assms <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span> 
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocols_base.S_def S2_def bind_map_spmf map_spmf_conv_bind_spmf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.HVZK"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_protocols_base.HVZK_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def challenge_space_def hv_zk S2_def check_def valid_pub_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cyclic_group_commute g'_in_carrier generator_closed inv_closed inv_solve_left inverse_pow_pow m_closed nat_pow_closed<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> ss_rewrite<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">&lt;</span> order <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z1'</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="main">&lt;</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2'</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span> "</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> prime_field assms prime_order <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z1'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_solve_right' assms<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms inv_solve_right'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z2'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="free">z1'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z2</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z2'</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="free">z1</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">z1'</span><span class="main">)</span> <span class="main">⊗</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> assms<span class="main">(</span>4<span class="main">)</span> cyclic_group_commute m_assoc g'_def nat_pow_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z2</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z2'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">z1</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z1'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">z2</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z2'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span> <span class="main">=</span> <span class="free">z1</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="free">z1'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod order_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">=</span> int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0 cong_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> int_distrib<span class="main">(</span>4<span class="main">)</span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult.assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> cong_scalar_left cong_trans inverse gcd<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">smt</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rings.ring_distribs<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> add_diff_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>nat <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff finite_carrier pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> pow_generator_mod_int <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Rings.ring_distribs<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> t<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">z1</span> <span class="main">-</span> int <span class="free">z2</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">z1'</span> <span class="main">-</span> int <span class="free">z2'</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="free">e</span> <span class="main">-</span> <span class="free">e'</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> int_pow_mult <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> g'_def generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> pow_generator_mod_int t<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> h_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a_mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> carrier <span class="free">𝒢</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="free">z</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> a'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="free">z'</span> <span class="main">=</span> <span class="free">a</span> <span class="main">⊗</span> <span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> e_e'_mod<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">&lt;</span> <span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> 
              <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> gcd<span class="main">:</span> <span class="quoted"><span class="quoted">"gcd <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> prime_field 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms less_imp_diff_less linorder_not_le prime_order<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> a h_mem a_mem <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_solve_right'<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> snd <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> a h_mem a_mem <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> inv_solve_right'<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z'</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1">inv</span> <span class="main">(</span><span class="free">h</span> <span class="main">[^]</span> <span class="free">e'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_pow<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> h_mem generatorE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> fst <span class="free">z'</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z'</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> a_mem assms<span class="main">(</span>3<span class="main">)</span> assms<span class="main">(</span>4<span class="main">)</span> cyclic_group_assoc cyclic_group_commute g'_def nat_pow_pow <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>fst <span class="free">z</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> snd <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span>fst <span class="free">z'</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> snd <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>fst <span class="free">z</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> snd <span class="free">z</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e'</span> <span class="main">=</span> fst <span class="free">z'</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> snd <span class="free">z'</span> <span class="main">+</span> <span class="skolem">t</span> <span class="main">*</span> <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> group_eq_pow_eq_mod order_gt_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span> <span class="main">=</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_int_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span> <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span>  <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> cong_diff_iff_cong_0<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span>  int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>int <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="main">(</span><span class="free">x</span> <span class="main">*</span> snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rings.ring_distribs<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> <span class="quoted"><span class="quoted">‹<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e</span> <span class="main">-</span> int <span class="skolem">t</span> <span class="main">*</span> int <span class="free">e'</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>›</span></span> add_diff_add add_diff_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span>int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> <span class="bound">i</span> <span class="main">*</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span> <span class="main">+</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> add.commute arith_simps<span class="main"><span class="main">(</span></span>49<span class="main"><span class="main">)</span></span> cancel_comm_monoid_add_class.diff_cancel int_ops<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> mult_eq_0_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="main">-</span> int <span class="free">e'</span><span class="main">)</span> <span class="main">+</span> <span class="bound">i</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> add_diff_add add_diff_eq mult_diff_mult mult_of_nat_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> add.assoc cong_add_rcancel<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span>int <span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> int <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> cong_def mod_diff_eq mod_mod_trivial mod_mult_right_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> e_e'_mod 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_ops<span class="main"><span class="main">(</span></span>9<span class="main"><span class="main">)</span></span> of_nat_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
               <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
                  <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cong_cong_mod_int cong_scalar_right <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
               <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
                  <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> cong_mod_right less_imp_diff_less mod_less mod_mult_left_eq mod_mult_right_eq order_gt_0 unique_euclidean_semiring_numeral_class.pos_mod_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
               <span class="main">=</span>  int <span class="skolem">t</span> <span class="main">*</span> <span class="main">1</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inverse gcd 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> Num.of_nat_simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> Number_Theory_Aux.inverse cong_def mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> of_nat_1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> 
               <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> 
               <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> cong_mod_left distrib_right mod_mult_right_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> 
               <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> cong_def mod_mult_right_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted"><span class="quoted">‹<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>›</span></span> cong_add_rcancel cong_mod_left cong_trans<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span>
               <span class="main">=</span> <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> mod_mod_trivial mod_mult_right_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> cong_def<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> cong_add cong_refl<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">[</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span> <span class="main">+</span> int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">t</span><span class="main">]</span> <span class="main">(</span><span class="keyword1">mod</span> int <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>›</span></span> cong_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">)</span></span> Groups.mult_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">+</span> <span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>
               <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cong_def int_pow_int pow_generator_mod_int<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span>
               <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> int_pow_mult <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">⊗</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="free">x</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>
               <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span>int <span class="main">(</span>fst <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>fst <span class="free">z'</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>int <span class="main">(</span>snd <span class="free">z</span><span class="main">)</span> <span class="main">-</span> int <span class="main">(</span>snd <span class="free">z'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
            <span class="main">*</span> fst <span class="main">(</span>bezw <span class="main">(</span><span class="main">(</span><span class="free">e</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span> <span class="main">-</span> <span class="free">e'</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">mod</span> order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span>
               <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> g'_def cyclic_group.generator_closed int_pow_int int_pow_pow mod_mult_right_eq more_arith_simps<span class="main"><span class="main">(</span></span>11<span class="main"><span class="main">)</span></span> okamoto_axioms okamoto_def pow_generator_mod_int<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> t <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.special_soundness"</span></span>       
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_protocols_base.special_soundness_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_pub_def check_def R_def ss_adversary_def Let_def ss_rewrite challenge_space_def split_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> Σ_protocol<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.Σ_protocol"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocols_base.Σ_protocol_def completeness HVZK special_soundness<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> okamoto_Σ_commit<span class="main">:</span> Σ_protocols_to_commitments <span class="quoted">init</span> <span class="quoted">response</span> <span class="quoted">check</span> <span class="quoted">R</span> <span class="quoted">S2</span> <span class="quoted">ss_adversary</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub</span> <span class="quoted">G</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> G_def R_def lossless_init lossless_response<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> dis_log<span class="main">:</span> dis_log <span class="quoted"><span class="free">𝒢</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">sublocale</span></span> dis_log_alt<span class="main">:</span> dis_log_alt <span class="quoted"><span class="free">𝒢</span></span> <span class="quoted"><span class="free">x</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> dis_log_alt_def 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> reduction_to_dis_log<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.rel_advantage <span class="free">𝒜</span> <span class="main">=</span> dis_log.advantage <span class="main">(</span>dis_log_alt.adversary2 <span class="free">𝒜</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> exp_rewrite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="skolem">w1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="skolem">w2</span> <span class="main">=</span>  <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="main">(</span><span class="skolem">w1</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="skolem">w2</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w1</span> <span class="skolem">w2</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_pow_mult nat_pow_pow g'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.rel_game <span class="free">𝒜</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> okamoto_Σ_commit.rel_game_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def split_def R_def G_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w1</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">w</span> <span class="main">=</span> <span class="main">(</span><span class="bound">w1</span> <span class="main">+</span> <span class="free">x</span> <span class="main">*</span> <span class="bound">w2</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">using</span></span> g'_def exp_rewrite pow_generator_mod <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w2</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">w1</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="bound">w2</span> <span class="main">+</span> <span class="bound">w1</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">including</span></span> monad_normalisation
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def Let_def add.commute<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w2</span> <span class="main">::</span> nat <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">using</span></span> samp_uni_plus_one_time_pad add.commute <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w</span> <span class="main">←</span> sample_uniform <span class="main">(</span>order <span class="free">𝒢</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">w1'</span><span class="main">,</span><span class="bound">w2'</span><span class="main">)</span> <span class="main">←</span> <span class="free">𝒜</span> <span class="bound">h</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">h</span> <span class="main">=</span> <span class="keyword1"><span class="hidden">❙</span><b>g</b></span> <span class="main">[^]</span> <span class="bound">w1'</span> <span class="main">⊗</span> g' <span class="main">[^]</span> <span class="bound">w2'</span><span class="main">)</span><span class="main">}</span> <span class="keyword1">ELSE</span> return_spmf False"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> dis_log_alt.dis_log2 <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_alt.dis_log2_def Let_def dis_log_alt.g'_def g'_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> try_spmf_cong<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">using</span></span> exp_rewrite pow_generator_mod g'_def 
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> group_eq_pow_eq_mod okamoto_axioms okamoto_base.order_gt_0 okamoto_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> exp_rewrite g'_def order_gt_0_iff_finite pow_generator_eq_iff_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.rel_game <span class="free">𝒜</span> <span class="main">=</span> dis_log_alt.dis_log2 <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.rel_advantage <span class="free">𝒜</span> <span class="main">=</span> dis_log_alt.advantage2 <span class="free">𝒜</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> okamoto_Σ_commit.rel_advantage_def dis_log_alt.advantage2_def<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dis_log_alt_reductions.dis_log_adv2 cyclic_group_axioms dis_log_alt.dis_log_alt_axioms dis_log_alt_reductions.intro<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> commitment_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> okamoto_Σ_commit.commit_correct<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> okamoto_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> binding<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.abstract_com.bind_advantage <span class="free">𝒜</span> 
          <span class="main">≤</span> dis_log.advantage <span class="main">(</span>dis_log_alt.adversary2 <span class="main">(</span>okamoto_Σ_commit.adversary <span class="free">𝒜</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> okamoto_Σ_commit.bind_advantage reduction_to_dis_log <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> okamoto_asymp <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">𝒢</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'grp</span> cyclic_group"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> okamoto<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">η</span><span class="main">.</span> okamoto <span class="main">(</span><span class="free">𝒢</span> <span class="bound">η</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> okamoto <span class="quoted"><span class="quoted">"<span class="free">𝒢</span> <span class="free">η</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">η</span> 
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> okamoto<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-protocol statement comes easily in the asympotic setting.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> sigma_protocol<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_protocols_base.Σ_protocol <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We now show the statements of security for the commitment scheme in the asymptotic setting, the main difference is that
we are able to show the binding advantage is negligible in the security parameter.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.abstract_com.correct <span class="free">n</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span>  okamoto_Σ_commit.commit_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_perfect_hiding<span class="main">:</span> <span class="quoted"><span class="quoted">"okamoto_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> okamoto_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> asymp_computational_binding<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> dis_log.advantage <span class="bound">n</span> <span class="main">(</span>dis_log_alt.adversary2 <span class="main">(</span>okamoto_Σ_commit.adversary <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"negligible <span class="main">(</span><span class="main">λ</span> <span class="bound">n</span><span class="main">.</span> okamoto_Σ_commit.abstract_com.bind_advantage <span class="bound">n</span> <span class="main">(</span><span class="free">𝒜</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> okamoto_Σ_commit.bind_advantage assms okamoto_Σ_commit.abstract_com.bind_advantage_def negligible_le binding <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Xor">
<div class="head">
<h1>Theory Xor</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Xor <span class="keyword2"><span class="keyword">imports</span></span> 
  <span class="quoted">"<a href="../../HOL/HOL-Algebra/Complete_Lattice.html">HOL-Algebra.Complete_Lattice</a>"</span> 
  <span class="quoted">"<a href="../CryptHOL/Misc_CryptHOL.html">CryptHOL.Misc_CryptHOL</a>"</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* disable lattice syntax for type class lattices *)</span>
<span class="keyword1"><span class="command">no_notation</span></span>
  bot_class.bot <span class="main">(</span><span class="quoted">"<span class="keyword1">⊥</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  top_class.top <span class="main">(</span><span class="quoted">"<span class="keyword1">⊤</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span> 
  inf  <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊓</span>"</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">and</span></span>
  sup  <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊔</span>"</span> 65<span class="main">)</span> 

<span class="keyword1"><span class="command">context</span></span> bounded_lattice <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> top_join <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main">⊤</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eq_is_equal top_join <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> join_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_iff_meet <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> bot_join <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main">⊥</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_iff_meet <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> join_bot <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">⊥</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bot_join join_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bot_meet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main">⊥</span> <span class="main">⊓</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bottom_meet <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_bot <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bot_meet meet_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> top_meet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main">⊤</span> <span class="main">⊓</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le_iff_join meet_comm top_closed top_higher<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">⊤</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> meet_comm top_meet<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> join_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_iff_meet <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_iff_join le_refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_leftcomm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> meet_assoc meet_comm that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> join_leftcomm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> join_assoc join_comm that<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> meet_ac <span class="main">=</span> meet_assoc meet_comm meet_leftcomm
<span class="keyword1"><span class="command">lemmas</span></span> join_ac <span class="main">=</span> join_assoc join_comm join_leftcomm

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> boolean_algebra <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> gorder"</span></span> <span class="main">+</span>
  compl <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>-</b></span>ı"</span> 1000<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">xor</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> boolean_algebra_scheme <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">⊕</span>ı"</span> 100<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="free">⊕</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊔</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⊓</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">L</span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> boolean_algebra <span class="main">=</span> bounded_lattice <span class="quoted"><span class="free">L</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">L</span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> compl_closed <span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> meet_compl_bot <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> join_compl_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> join_meet_distrib1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span><span class="main">;</span> <span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> join_meet_distrib2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span> <span class="main">⊔</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">z</span> <span class="main">⊔</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_comm join_meet_distrib1 that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_join_distrib1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> join_left le_iff_join <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">z</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_comm join_meet_distrib1 meet_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> join_comm le_iff_meet meet_closed meet_left that<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">z</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_meet_distrib1<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> meet_join_distrib2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="free">z</span><span class="main">)</span> <span class="main">⊓</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">z</span> <span class="main">⊓</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> meet_comm meet_join_distrib1<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> join_meet_distrib <span class="main">=</span> join_meet_distrib1 join_meet_distrib2

<span class="keyword1"><span class="command">lemmas</span></span> meet_join_distrib <span class="main">=</span> meet_join_distrib1 meet_join_distrib2

<span class="keyword1"><span class="command">lemmas</span></span> distrib <span class="main">=</span> join_meet_distrib meet_join_distrib

<span class="keyword1"><span class="command">lemma</span></span> meet_compl2_bot <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> meet_comm meet_compl_bot<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> join_compl2_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> join_comm join_compl_top<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_unique<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> inf_compl_bot assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="free">x</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> meet_comm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> assms<span class="main">(</span>4<span class="main">)</span> compl_closed meet_join_distrib1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">⊤</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊓</span> <span class="main">⊤</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> le_iff_join top_higher <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> double_compl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> compl_unique<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_eq_compl_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> double_compl that that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_bot_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_iff_join le_iff_meet local.compl_unique top_higher <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_top_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">⊤</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bottom_closed compl_bot_eq double_compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_inf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> compl_unique<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> compl_closed meet_assoc meet_closed meet_comm meet_join_distrib1 that<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bottom_closed bottom_lower le_iff_join le_iff_meet meet_comm meet_compl2_bot that<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊓</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> compl_closed join_meet_distrib2 join_assoc join_comm local.boolean_algebra_axioms that join_closed<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> compl_closed join_compl2_top join_right le_iff_join le_iff_meet that top_closed<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_sup <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> compl_closed compl_inf double_compl meet_closed that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_mono<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊑</span> <span class="free">y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span> <span class="main">⊑</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> compl_closed join_comm le_iff_join le_iff_meet compl_inf<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_le_compl_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊑</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">⊑</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> compl_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_le_swap1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">⊑</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊑</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms compl_closed compl_le_compl_iff double_compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> compl_le_swap2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">y</span> <span class="main">⊑</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊑</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms compl_closed compl_le_compl_iff double_compl<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> join_compl_top_left1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> join_compl_top_left2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊔</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊔</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊤</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> join_compl_top_left1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_compl_bot_left1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> meet_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_compl_bot_left2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span> <span class="main">⊓</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> meet_compl_bot_left1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="free">y</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> meet_compl_bot_right <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊓</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊓</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> meet_compl_bot_left2 meet_comm that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_closed <span class="main">[</span><span class="operator">intro</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊕</span> <span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_comm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span><span class="main">;</span> <span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">⊕</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊕</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def meet_join_distrib join_comm<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">⊕</span> <span class="free">y</span><span class="main">)</span> <span class="main">⊕</span> <span class="free">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⊕</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊕</span> <span class="free">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> meet_join_distrib meet_ac join_ac<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_left_comm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="main">(</span><span class="free">y</span> <span class="main">⊕</span> <span class="free">z</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⊕</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊕</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that xor_assoc xor_comm <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> xor_bot<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="main">⊥</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bot_xor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">⊕</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> xor_top<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="main">⊤</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> top_xor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⊤</span> <span class="main">⊕</span> <span class="free">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>-</b></span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def assms<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xor_def that<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> xor_left_inverse <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="free">x</span> <span class="main">⊕</span> <span class="free">y</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> that xor_assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemmas</span></span> xor_ac <span class="main">=</span> xor_assoc xor_comm xor_left_comm

<span class="keyword1"><span class="command">lemma</span></span> inj_on_xor<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span><span class="main">(⊕</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> that xor_left_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> surj_xor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(⊕</span><span class="main">)</span> <span class="free">x</span> <span class="main">`</span> carrier <span class="free">L</span> <span class="main">=</span> carrier <span class="free">L</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> Set.set_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> iffI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊕</span> <span class="skolem">y</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="free">x</span> <span class="main">⊕</span> <span class="main">(</span><span class="free">x</span> <span class="main">⊕</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">(⊕</span><span class="main">)</span> <span class="free">x</span> <span class="main">`</span> carrier <span class="free">L</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rev_image_eqI<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> one_time_pad<span class="main">:</span> <span class="quoted"><span class="quoted">"map_spmf <span class="main">(</span><span class="main">(⊕</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> map_spmf_of_set_inj_on<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> inj_on_xor<span class="main"><span class="main">[</span></span><span class="operator">OF</span> that<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> surj_xor that<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Sigma_AND">
<div class="head">
<h1>Theory Sigma_AND</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-AND statements›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Sigma_AND <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Sigma_Protocols.html">Sigma_Protocols</a>
  <a href="Xor.html">Xor</a>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> Σ_AND_base <span class="main">=</span> Σ0<span class="main">:</span> Σ_protocols_base <span class="quoted"><span class="free">init0</span></span> <span class="quoted"><span class="free">response0</span></span> <span class="quoted"><span class="free">check0</span></span> <span class="quoted"><span class="free">Rel0</span></span> <span class="quoted"><span class="free">S0_raw</span></span> <span class="quoted"><span class="free">𝒜ss0</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="free">valid_pub0</span></span>
  <span class="main">+</span> Σ1<span class="main">:</span> Σ_protocols_base <span class="quoted"><span class="free">init1</span></span> <span class="quoted"><span class="free">response1</span></span> <span class="quoted"><span class="free">check1</span></span> <span class="quoted"><span class="free">Rel1</span></span> <span class="quoted"><span class="free">S1_raw</span></span> <span class="quoted"><span class="free">𝒜ss1</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="free">valid_pub1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">init1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand1</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> <span class="main">⇒</span> <span class="tfree">'bool</span>  <span class="main">⇒</span> <span class="tfree">'response1</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response1</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub1</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S1_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">init0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'msg0</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response0</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response0</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'witness0</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S0_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span>  <span class="main">×</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">L</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> boolean_algebra"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
    <span class="main">+</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> Σ_prot1<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ1.Σ_protocol"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> Σ_prot0<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ0.Σ_protocol"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">init0</span> <span class="free">h0</span> <span class="free">w0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">init1</span> <span class="free">h1</span> <span class="free">w1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">response0</span> <span class="free">r0</span> <span class="free">w0</span> <span class="free">e0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">response1</span> <span class="free">r1</span> <span class="free">w1</span> <span class="free">e1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_S<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">S0</span> <span class="free">h0</span> <span class="free">e0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">S1</span> <span class="free">h1</span> <span class="free">e1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_𝒜ss<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">𝒜ss0</span> <span class="free">x0</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">𝒜ss1</span> <span class="free">x1</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">G</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> set_spmf_G <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">h</span><span class="main">,</span><span class="free">w</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="free">Rel</span> <span class="free">h</span> <span class="free">w</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">challenge_space</span> <span class="main">=</span> carrier <span class="free">L</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rel_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'witness0</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> set"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Rel_AND</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">x0</span><span class="main">,</span><span class="bound">x1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">w0</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">x0</span><span class="main">,</span><span class="bound">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'rand1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> spmf"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_AND</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x0</span><span class="main">,</span> <span class="bound">x1</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">w0</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span> <span class="bound">a0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="bound">x0</span> <span class="bound">w0</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="bound">x1</span> <span class="bound">w1</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>   

<span class="keyword1"><span class="command">lemma</span></span> lossless_init_AND<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>init_AND <span class="free">X</span> <span class="free">W</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_init init_AND_def split_def<span class="main">)</span>
    
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">response_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'rand1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'response0</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">response_AND</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">w0</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span><span class="main">;</span>  
    <span class="bound">z0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r0</span> <span class="bound">w0</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    <span class="bound">z1</span>  <span class="main">::</span> <span class="tfree">'response1</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r1</span> <span class="bound">w1</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> lossless_response_AND<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>response_AND <span class="free">R</span> <span class="free">W</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> response_AND_def lossless_response split_def<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">check_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'response0</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">check_AND</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">check0</span> <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="free"><span class="bound"><span class="entity">a0</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">z0</span></span></span> <span class="main">∧</span> <span class="free">check1</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">S_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S_AND</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x0</span><span class="main">,</span><span class="bound">x1</span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">←</span> <span class="free">S0_raw</span> <span class="bound">x0</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> <span class="free">S1_raw</span> <span class="bound">x1</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">𝒜ss_AND</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">𝒜ss_AND</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">a0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a1</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">a0'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">a1'</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">e'</span></span></span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z0'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1'</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">w0</span> <span class="main">::</span> <span class="tfree">'witness0</span> <span class="main">←</span> <span class="free">𝒜ss0</span> <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z0</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a0'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z0'</span></span></span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w1</span> <span class="main">←</span> <span class="free">𝒜ss1</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a1'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">e'</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1'</span></span></span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">w0</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_pub_AND</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x0</span><span class="main">,</span><span class="bound">x1</span><span class="main">)</span><span class="main">.</span> <span class="bound">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span> <span class="main">∧</span> <span class="bound">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Σ_AND<span class="main">:</span> Σ_protocols_base <span class="quoted">init_AND</span> <span class="quoted">response_AND</span> <span class="quoted">check_AND</span> <span class="quoted">Rel_AND</span> <span class="quoted">S_AND</span> <span class="quoted">𝒜ss_AND</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub_AND</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rel_AND_def valid_pub_AND_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> Σ1.domain_subset_valid_pub Σ0.domain_subset_valid_pub <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> Σ_AND <span class="main">=</span> Σ_AND_base <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> set_spmf_G_L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="free">w0</span><span class="main">,</span> <span class="free">w1</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> Rel_AND"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> hvzk<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> Rel_AND<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> Rel_AND"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> challenge_space"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_AND.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> Σ_AND.S <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> x_in_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x0</span> <span class="main">∈</span> Domain <span class="free">Rel0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">∈</span> Domain <span class="free">Rel1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> Rel_AND Rel_AND_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Σ_AND.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> init_AND <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> response_AND <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_AND.R_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span> <span class="bound">a0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free">x0</span> <span class="free">w0</span><span class="main">;</span>
    <span class="bound">z0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r0</span> <span class="free">w0</span> <span class="free">e</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free">x1</span> <span class="free">w1</span><span class="main">;</span>
    <span class="bound">z1</span> <span class="main">::</span> <span class="tfree">'f</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r1</span> <span class="free">w1</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_AND_def response_AND_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">response0</span> <span class="main">_</span> <span class="free">w0</span> <span class="free">e</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">c0</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">←</span> Σ0.R <span class="free">x0</span> <span class="free">w0</span> <span class="free">e</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a1</span><span class="main">,</span> <span class="bound">c1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> Σ1.R <span class="free">x1</span> <span class="free">w1</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ0.R_def Σ1.R_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">c0</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="free">e</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a1</span><span class="main">,</span> <span class="bound">c1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Rel_AND_def S_AND_def Σ_prot1 Σ_prot0 assms  Σ0.HVZK_unfold1 Σ1.HVZK_unfold1 
          valid_pub_AND_def split_def challenge_space_def x_in_dom
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ0.S_def Σ1.S_def bind_map_spmf o_def split_def Let_def Σ_AND.S_def map_spmf_conv_bind_spmf S_AND_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ_AND.HVZK"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Σ_AND.HVZK_def hvzk challenge_space_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> S_AND_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> Σ_prot1 Σ_prot0 Σ0.HVZK_unfold2 Σ1.HVZK_unfold2 valid_pub_AND_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> correct<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> Rel_AND<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> Rel_AND"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> challenge_space"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_AND.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> return_spmf True"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Σ_AND.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span><span class="main">)</span> <span class="main">←</span> init_AND <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> response_AND <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">r1</span><span class="main">)</span> <span class="main">(</span><span class="free">w0</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span>check_AND <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="bound">a0</span><span class="main">,</span><span class="bound">a1</span><span class="main">)</span> <span class="free">e</span> <span class="main">(</span><span class="bound">z0</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_AND.completeness_game_def split_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> check_AND.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span> <span class="bound">a0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free">x0</span> <span class="free">w0</span><span class="main">;</span>
    <span class="bound">z0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r0</span> <span class="free">w0</span> <span class="free">e</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free">x1</span> <span class="free">w1</span><span class="main">;</span>
    <span class="bound">z1</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r1</span> <span class="free">w1</span> <span class="free">e</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">a0</span> <span class="free">e</span> <span class="bound">z0</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="bound">a1</span> <span class="free">e</span> <span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_AND_def response_AND_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">response0</span> <span class="main">_</span> <span class="free">w0</span> <span class="free">e</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Σ1.complete_game_return_true Σ_prot1 Σ1.Σ_protocol_def Σ1.completeness_game_def assms
          Σ0.complete_game_return_true Σ_prot0 Σ0.Σ_protocol_def Σ0.completeness_game_def challenge_space_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def split_def bind_eq_return_spmf lossless_init lossless_response Rel_AND_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> fst_conv snd_conv<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> completeness<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ_AND.completeness"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Σ_AND.completeness_def correct challenge_space_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> ss<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> e_neq_e'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> valid_pub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">∈</span> valid_pub_AND"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> challenge_space<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> challenge_space"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s'</span> <span class="main">∈</span> challenge_space"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"check_AND <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span> <span class="free">s</span> <span class="main">(</span><span class="free">z0</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"check_AND  <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span> <span class="free">s'</span> <span class="main">(</span><span class="free">z0'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>𝒜ss_AND  <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="main">(</span><span class="free">z0</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span> <span class="free">s'</span><span class="main">,</span> <span class="main">(</span><span class="free">z0'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> 
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">w'</span><span class="main">∈</span>set_spmf <span class="main">(</span>𝒜ss_AND  <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="main">(</span><span class="free">z0</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span> <span class="free">s'</span><span class="main">,</span> <span class="main">(</span><span class="free">z0'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> Rel_AND<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> x0_in_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x1_in_dom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> valid_pub valid_pub_AND_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check0</span> <span class="free">x0</span> <span class="free">a0</span> <span class="free">s</span> <span class="free">z0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check1</span> <span class="free">x1</span> <span class="free">a1</span> <span class="free">s'</span> <span class="free">z1'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w0</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">𝒜ss0</span> <span class="free">x0</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="free">z0</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span> <span class="free">s'</span><span class="main">,</span> <span class="free">z0'</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="skolem">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w0</span>
    <span class="keyword1"><span class="command">using</span></span> 3 4 Σ0.special_soundness_def Σ_prot0 Σ0.Σ_protocol_def x0_in_dom challenge_space_def assms valid_pub_AND_def valid_pub <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">w1</span> <span class="main">∈</span> set_spmf <span class="main">(</span><span class="free">𝒜ss1</span> <span class="free">x1</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">s</span><span class="main">,</span> <span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span> <span class="free">s'</span><span class="main">,</span> <span class="free">z1'</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="skolem">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w1</span>
     <span class="keyword1"><span class="command">using</span></span> 3 4 Σ1.special_soundness_def Σ_prot1 Σ1.Σ_protocol_def x1_in_dom challenge_space_def assms valid_pub_AND_def valid_pub <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_𝒜ss Rel_AND_def<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_AND.special_soundness"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Σ_AND.special_soundness_def ss <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span>

<span class="keyword1"><span class="command">theorem</span></span> Σ_protocol<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_AND.Σ_protocol"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_AND.Σ_protocol_def completeness HVZK special_soundness<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> AND_Σ_commit<span class="main">:</span> Σ_protocols_to_commitments <span class="quoted">init_AND</span> <span class="quoted">response_AND</span> <span class="quoted">check_AND</span> <span class="quoted">Rel_AND</span> <span class="quoted">S_AND</span> <span class="quoted">𝒜ss_AND</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub_AND</span> <span class="quoted"><span class="free">G</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol set_spmf_G_L lossless_G lossless_init_AND lossless_response_AND<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"AND_Σ_commit.abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">using</span></span> AND_Σ_commit.commit_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"AND_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> AND_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_advantage_bound_dis_log<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"AND_Σ_commit.abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> AND_Σ_commit.rel_advantage <span class="main">(</span>AND_Σ_commit.adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> AND_Σ_commit.bind_advantage <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Sigma_OR">
<div class="head">
<h1>Theory Sigma_OR</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Σ›</span></span></span></span>-OR statements›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Sigma_OR <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Sigma_Protocols.html">Sigma_Protocols</a>
  <a href="Xor.html">Xor</a>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">locale</span></span> Σ_OR_base <span class="main">=</span> Σ0<span class="main">:</span> Σ_protocols_base <span class="quoted"><span class="free">init0</span></span> <span class="quoted"><span class="free">response0</span></span> <span class="quoted"><span class="free">check0</span></span> <span class="quoted"><span class="free">Rel0</span></span> <span class="quoted"><span class="free">S0_raw</span></span> <span class="quoted"><span class="free">𝒜ss0</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="free">valid_pub0</span></span>
  <span class="main">+</span> Σ1<span class="main">:</span> Σ_protocols_base <span class="quoted"><span class="free">init1</span></span> <span class="quoted"><span class="free">response1</span></span> <span class="quoted"><span class="free">check1</span></span> <span class="quoted"><span class="free">Rel1</span></span> <span class="quoted"><span class="free">S1_raw</span></span> <span class="quoted"><span class="free">𝒜ss1</span></span> <span class="quoted"><span class="quoted">"carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="free">valid_pub1</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">init1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand1</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> <span class="main">⇒</span> <span class="tfree">'bool</span>  <span class="main">⇒</span> <span class="tfree">'response1</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response1</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub1</span> <span class="main">×</span> <span class="tfree">'witness1</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S1_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="tfree">'msg1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="tfree">'witness1</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub1</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">init0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'msg0</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">response0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'rand0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response0</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">check0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="tfree">'response0</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">Rel0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'witness0</span><span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">S0_raw</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">𝒜ss0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">⇒</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span> <span class="main">⇒</span> <span class="tfree">'witness0</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">challenge_space0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">valid_pub0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span>  <span class="main">×</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">L</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'bool</span> boolean_algebra"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="main">)</span>
    <span class="main">+</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> Σ_prot1<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ1.Σ_protocol"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> Σ_prot0<span class="main">:</span> <span class="quoted"><span class="quoted">"Σ0.Σ_protocol"</span></span>  
    <span class="keyword2"><span class="keyword">and</span></span> lossless_init<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">init0</span> <span class="free">h0</span> <span class="free">w0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">init1</span> <span class="free">h1</span> <span class="free">w1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">response0</span> <span class="free">r0</span> <span class="free">w0</span> <span class="free">e0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">response1</span> <span class="free">r1</span> <span class="free">w1</span> <span class="free">e1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_S<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">S0</span> <span class="free">h0</span> <span class="free">e0</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">S1</span> <span class="free">h1</span> <span class="free">e1</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> finite_L<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> carrier_L_not_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"carrier <span class="free">L</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_G<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="free">G</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">Rel_OR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span><span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  Rel_OR_I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span><span class="main">,</span> Inl <span class="free"><span class="bound"><span class="entity">w0</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel_OR</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w0</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">∈</span> <span class="free">valid_pub1</span>"</span></span>
<span class="main">|</span> Rel_OR_I1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span><span class="main">,</span> Inr <span class="free"><span class="bound"><span class="entity">w1</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel_OR</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w1</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="main">∈</span> <span class="free">valid_pub0</span>"</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> Rel_OR_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> Inl <span class="free">w0</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> Inr <span class="free">w1</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Domain_Rel_cases<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">∈</span> Domain Rel_OR"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span> <span class="bound">w0</span><span class="main">.</span> <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="bound">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span> <span class="main">∧</span> <span class="free">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">w1</span><span class="main">.</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span> <span class="main">∧</span> <span class="free">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> DomainE Rel_OR.cases<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> set_spmf_lists_sample <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_spmf <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> finite_L <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">challenge_space</span> <span class="main">=</span> carrier <span class="free">L</span>"</span></span>
 
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">init_OR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">+</span> <span class="tfree">'rand1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">init_OR</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">w0</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">a0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="free"><span class="bound"><span class="entity">w0</span></span></span><span class="main">;</span>
    <span class="bound">e1</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a1</span><span class="main">,</span> <span class="bound">e'1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="bound">e1</span><span class="main">;</span>
    return_spmf <span class="main">(</span>Inl <span class="main">(</span><span class="bound">r0</span><span class="main">,</span> <span class="bound">e1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span><span class="main">,</span> <span class="bound">a0</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">init_OR</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">w1</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">w1</span></span></span><span class="main">;</span>
    <span class="bound">e0</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">e'0</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="bound">e0</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span>Inr <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">e0</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span><span class="main">,</span> <span class="bound">a0</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_Σ_S<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>Σ1.S <span class="free">x1</span> <span class="free">e1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>Σ0.S <span class="free">x0</span> <span class="free">e0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> lossless_S <span class="keyword1"><span class="command">by</span></span> <span class="operator">fast</span> <span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> lossless_init_OR<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>init_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">w</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lossless_Σ_S split_def lossless_init lossless_S finite_L carrier_L_not_empty<span class="main">)</span> 

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">response_OR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'rand0</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">+</span> <span class="tfree">'rand1</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> 
                        <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">response_OR</span> <span class="main">(</span>Inl <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r0</span></span></span> <span class="main">,</span> <span class="free"><span class="bound"><span class="entity">e_1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">w0</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>  
    <span class="keyword1">let</span> <span class="bound">e0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊕</span> <span class="free"><span class="bound"><span class="entity">e_1</span></span></span><span class="main">;</span>
    <span class="bound">z0</span> <span class="main">←</span> <span class="free">response0</span> <span class="free"><span class="bound"><span class="entity">r0</span></span></span> <span class="free"><span class="bound"><span class="entity">w0</span></span></span> <span class="bound">e0</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">e0</span><span class="main">,</span><span class="bound">z0</span><span class="main">)</span><span class="main">,</span>  <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e_1</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">z1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> <span class="main">|</span>
    <span class="quoted"><span class="quoted">"<span class="free">response_OR</span>  <span class="main">(</span>Inr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">e_0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z0</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">w1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">let</span> <span class="bound">e1</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊕</span> <span class="free"><span class="bound"><span class="entity">e_0</span></span></span><span class="main">;</span>
    <span class="bound">z1</span> <span class="main">←</span> <span class="free">response1</span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span> <span class="free"><span class="bound"><span class="entity">w1</span></span></span> <span class="bound">e1</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">e_0</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">z0</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">e1</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">check_OR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'bool</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">check_OR</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">Z</span></span></span>
             <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⊕</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> 
                   <span class="main">∧</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> challenge_space <span class="main">∧</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> challenge_space 
                      <span class="main">∧</span> <span class="free">check0</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">check1</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">Z</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span>  <span class="quoted"><span class="quoted">"check_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span> <span class="free">s</span> <span class="main">(</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">)</span>
             <span class="main">=</span> <span class="main">(</span><span class="free">s</span> <span class="main">=</span> <span class="free">e0</span> <span class="main">⊕</span> <span class="free">e1</span> 
                   <span class="main">∧</span> <span class="free">e0</span> <span class="main">∈</span> challenge_space <span class="main">∧</span> <span class="free">e1</span> <span class="main">∈</span> challenge_space 
                      <span class="main">∧</span> <span class="free">check0</span> <span class="free">x0</span> <span class="free">a0</span> <span class="free">e0</span> <span class="free">z0</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="free">a1</span> <span class="free">e1</span> <span class="free">z1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> check_OR_def<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">S_OR</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">S_OR</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x0</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">e1</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a1</span><span class="main">,</span> <span class="bound">e1'</span><span class="main">,</span> <span class="bound">z1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="bound">e1</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">e0</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">⊕</span> <span class="bound">e1</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">e0'</span><span class="main">,</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free"><span class="bound"><span class="entity">x0</span></span></span> <span class="bound">e0</span><span class="main">;</span> 
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">e0'</span><span class="main">,</span><span class="bound">z0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">e1'</span><span class="main">,</span><span class="bound">z1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">a0</span><span class="main">,</span> <span class="bound">a1</span><span class="main">)</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">𝒜ss_OR'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span>
                    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">𝒜ss_OR'</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">C1</span></span></span> <span class="free"><span class="bound"><span class="entity">C2</span></span></span> <span class="main">=</span> <span class="keyword1">TRY</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main"><span class="bound">_</span></span> <span class="main">::</span> unit <span class="main">←</span> assert_spmf <span class="main">(</span><span class="main">(</span>fst <span class="main">(</span>fst  <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="bound">w0</span> <span class="main">::</span> <span class="tfree">'witness0</span> <span class="main">←</span> <span class="free">𝒜ss0</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>snd <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>snd <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span>Inl <span class="bound">w0</span><span class="main">)</span><span class="main">)</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> spmf<span class="main">}</span> <span class="keyword1">ELSE</span> <span class="keyword1">do</span> <span class="main">{</span>
     <span class="bound">w1</span> <span class="main">::</span> <span class="tfree">'witness1</span> <span class="main">←</span> <span class="free">𝒜ss1</span>  <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">,</span> fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span>return_spmf <span class="main">(</span><span class="main">(</span>Inr <span class="bound">w1</span><span class="main">)</span><span class="main">)</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> spmf<span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">𝒜ss_OR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'pub0</span> <span class="main">×</span> <span class="tfree">'pub1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span>
                    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'msg0</span> <span class="main">×</span> <span class="tfree">'msg1</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response0</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'bool</span> <span class="main">×</span> <span class="tfree">'response1</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'witness0</span> <span class="main">+</span> <span class="tfree">'witness1</span><span class="main">)</span> spmf"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">𝒜ss_OR</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">C1</span></span></span> <span class="free"><span class="bound"><span class="entity">C2</span></span></span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="main">(</span>fst <span class="main">(</span>fst  <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">≠</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> 
        <span class="main">{</span><span class="bound">w0</span> <span class="main">::</span> <span class="tfree">'witness0</span> <span class="main">←</span> <span class="free">𝒜ss0</span> <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>snd <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>fst <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>snd <span class="main">(</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> return_spmf <span class="main">(</span>Inl <span class="bound">w0</span><span class="main">)</span><span class="main">}</span> 
    <span class="keyword1">else</span>
    <span class="keyword1">do</span>  <span class="main">{</span><span class="bound">w1</span> <span class="main">::</span> <span class="tfree">'witness1</span> <span class="main">←</span> <span class="free">𝒜ss1</span>  <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">,</span>fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C1</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>snd <span class="main">(</span>fst <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">,</span> fst <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>snd <span class="free"><span class="bound"><span class="entity">C2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> return_spmf <span class="main">(</span>Inr <span class="bound">w1</span><span class="main">)</span><span class="main">}</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> 𝒜ss_OR_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span><span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span><span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="free">e0</span> <span class="main">≠</span> <span class="free">e0'</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">w0</span> <span class="main">::</span> <span class="tfree">'witness0</span> <span class="main">←</span> <span class="free">𝒜ss0</span> <span class="free">x0</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">;</span> return_spmf <span class="main">(</span>Inl <span class="bound">w0</span><span class="main">)</span><span class="main">}</span>
    <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">w1</span> <span class="main">::</span> <span class="tfree">'witness1</span> <span class="main">←</span> <span class="free">𝒜ss1</span> <span class="free">x1</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">;</span> return_spmf <span class="main">(</span>Inr <span class="bound">w1</span><span class="main">)</span><span class="main">}</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 𝒜ss_OR_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_pub_OR</span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span><span class="bound">x0</span><span class="main">,</span><span class="bound">x1</span><span class="main">)</span><span class="main">.</span> <span class="bound">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span> <span class="main">∧</span> <span class="bound">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> Σ_OR<span class="main">:</span> Σ_protocols_base <span class="quoted">init_OR</span> <span class="quoted">response_OR</span> <span class="quoted">check_OR</span> <span class="quoted">Rel_OR</span> <span class="quoted">S_OR</span> <span class="quoted">𝒜ss_OR</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub_OR</span> 
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_protocols_base_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> 
    <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> Domain Rel_OR"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x0</span></span> <span class="skolem"><span class="skolem">x1</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x0</span><span class="main">,</span><span class="skolem">x1</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> surj_pair<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> valid_pub_OR"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">w0</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x0</span><span class="main">,</span><span class="bound">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span> <span class="main">∧</span> <span class="skolem">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">using</span></span> Σ0.domain_subset_valid_pub valid_pub_OR_def x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">w1</span><span class="main">.</span> <span class="main">(</span><span class="skolem">x1</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span> <span class="main">∧</span> <span class="skolem">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> Domain_Rel_cases asm x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">using</span></span> Σ1.domain_subset_valid_pub valid_pub_OR_def x <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="command">locale</span></span> Σ_OR_proofs <span class="main">=</span> Σ_OR_base <span class="main">+</span> boolean_algebra <span class="quoted"><span class="free">L</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> G_Rel_OR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> set_spmf <span class="free">G</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lossless_response_OR<span class="main">:</span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>response_OR <span class="free">R</span> <span class="free">W</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">c</span> <span class="main">∈</span> challenge_space<span class="main">.</span> Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">w1</span><span class="main">)</span> <span class="bound">c</span> <span class="main">=</span> Σ_OR.S <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="bound">c</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> monad_normalisation
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> challenge_space"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">w1</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> Σ_OR.S <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟶</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>  
      <span class="keyword1"><span class="command">using</span></span> c challenge_space_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">w1</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">ab1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free">x1</span> <span class="free">w1</span><span class="main">;</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb'</span><span class="main">)</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb0'</span> <span class="main">)</span><span class="main">,</span>  <span class="bound">ab0'</span> <span class="main">,</span> <span class="bound">ab1</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="bound">zb1</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r</span> <span class="free">w1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb'</span><span class="main">)</span> <span class="main">,</span> <span class="main">(</span><span class="bound">eb</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> <span class="main">[</span><span class="main">[</span><span class="operator">simproc</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> monad_normalisation<span class="main">]</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_OR.R_def split_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span> <span class="main">←</span> Σ1.R <span class="free">x1</span> <span class="free">w1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span><span class="bound">ab1</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ1.R_def split_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span><span class="bound">ab1</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def Let_def Σ_prot1 Σ1.HVZK_unfold1 assms challenge_space_def  <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb</span> <span class="main">←</span> map_spmf <span class="main">(</span><span class="main">λ</span> <span class="bound">eb'</span><span class="main">.</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">)</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span><span class="bound">ab1</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_spmf o_def Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> * split_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb</span> <span class="main">←</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span><span class="bound">ab1</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms assms one_time_pad c challenge_space_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb</span> <span class="main">←</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="main">(</span><span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">c'</span><span class="main">,</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span><span class="bound">ab1</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ0.S_def Σ1.S_def bind_map_spmf o_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def map_spmf_conv_bind_spmf Σ_OR.S_def split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK0<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">c</span> <span class="main">∈</span> challenge_space<span class="main">.</span> Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">w0</span><span class="main">)</span> <span class="bound">c</span> <span class="main">=</span> Σ_OR.S <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="bound">c</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span> 
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> challenge_space"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">w0</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> Σ_OR.S <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="skolem">c</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Σ_OR.R <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">w0</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">ab0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free">x0</span> <span class="free">w0</span><span class="main">;</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb'</span><span class="main">)</span><span class="main">,</span><span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">r0</span><span class="main">,</span> <span class="bound">eb'</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span><span class="main">,</span>  <span class="bound">ab0</span><span class="main">,</span>  <span class="bound">ab1'</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="bound">zb0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r</span> <span class="free">w0</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb</span><span class="main">,</span><span class="bound">zb0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb'</span><span class="main">,</span><span class="bound">zb'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_OR.R_def split_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb0</span><span class="main">)</span> <span class="main">←</span> Σ0.R <span class="free">x0</span> <span class="free">w0</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb</span><span class="main">,</span><span class="bound">zb0</span><span class="main">)</span><span class="main">,</span>  <span class="main">(</span><span class="bound">eb'</span><span class="main">,</span><span class="bound">zb1'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0</span><span class="main">,</span>  <span class="bound">ab1'</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ0.R_def split_def Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"Σ1.S <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> <span class="main">(</span>spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0</span><span class="main">,</span> <span class="bound">c'</span><span class="main">,</span> <span class="bound">zb0</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="bound">eb</span><span class="main">,</span><span class="bound">zb0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">eb'</span><span class="main">,</span><span class="bound">zb1'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="bound">ab0</span><span class="main">,</span>  <span class="bound">ab1'</span><span class="main">)</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_prot0 Σ0.HVZK_unfold1 assms challenge_space_def split_def Let_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_OR.S_def Σ1.S_def Σ0.S_def Let_def o_def bind_map_spmf split_def map_spmf_conv_bind_spmf<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HVZK<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.HVZK"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_OR.HVZK_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> e a b w
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">w</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> HVZK0 HVZK1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_pub_OR_def Σ_OR.S_def bind_map_spmf o_def check_OR_def image_def Σ0.S_def Σ1.S_def split_def challenge_space_def local.xor_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> Σ0.HVZK_unfold2 Σ_prot0 challenge_space_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">using</span></span> Σ1.HVZK_unfold2 Σ_prot1 challenge_space_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">∈</span> Domain Rel_OR"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span> <span class="bound">w0</span><span class="main">.</span> <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="bound">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">w1</span><span class="main">.</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="bound">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms Rel_OR.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> ss<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> valid_pub_OR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">∈</span> valid_pub_OR"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> check<span class="main">:</span> <span class="quoted"><span class="quoted">"check_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span> <span class="free">s</span> <span class="main">(</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> check'<span class="main">:</span> <span class="quoted"><span class="quoted">"check_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span> <span class="free">s'</span> <span class="main">(</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≠</span> <span class="free">s'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> challenge_space<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">∈</span> challenge_space"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s'</span> <span class="main">∈</span> challenge_space"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="main">∀</span><span class="bound">w'</span><span class="main">∈</span>set_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> Rel_OR<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> e_or<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e0</span> <span class="main">≠</span> <span class="free">e0'</span> <span class="main">∨</span> <span class="free">e1</span> <span class="main">≠</span> <span class="free">e1'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">e0</span> <span class="main">≠</span> <span class="free">e0'</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> valid_pub_OR valid_pub_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check0</span> <span class="free">x0</span> <span class="free">a0</span> <span class="free">e0</span> <span class="free">z0</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> assms check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check0</span> <span class="free">x0</span> <span class="free">a0</span> <span class="free">e0'</span> <span class="free">z0'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e0</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">e0'</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> challenge_space_def check check' check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">w'</span><span class="main">∈</span>set_spmf <span class="main">(</span><span class="free">𝒜ss0</span> <span class="free">x0</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x0</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> True Σ0.Σ_protocol_def Σ0.special_soundness_def Σ_prot0 challenge_space assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span><span class="free">𝒜ss0</span> <span class="free">x0</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span> <span class="free">e0</span><span class="main">,</span> <span class="free">z0</span><span class="main">)</span> <span class="main">(</span><span class="free">a0</span><span class="main">,</span> <span class="free">e0'</span><span class="main">,</span> <span class="free">z0'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 2 3 4 𝒜ss_OR_def True Σ_prot0  Σ0.Σ_protocol_def Σ0.special_soundness_def challenge_space_def e <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">w'</span> <span class="main">∈</span> set_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span>  <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> 𝒜ss_OR_alt_def True<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def 𝒜ss_OR_def<span class="main">)</span> 
      <span class="keyword1"><span class="command">using</span></span> assms valid_pub_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 𝒜ss_OR_def<span class="main">)</span>   
      <span class="keyword1"><span class="command">using</span></span> 2 3 4 True Σ_prot0  Σ0.Σ_protocol_def Σ0.special_soundness_def challenge_space e <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> e1_neq_e1'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e1</span> <span class="main">≠</span> <span class="free">e1'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> e_or <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> valid_pub_OR valid_pub_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check1</span> <span class="free">x1</span> <span class="free">a1</span> <span class="free">e1</span> <span class="free">z1</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> assms check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> 4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">check1</span> <span class="free">x1</span> <span class="free">a1</span> <span class="free">e1'</span> <span class="free">z1'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> e<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e1</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">e1'</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> challenge_space_def check check' check_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">w'</span><span class="main">∈</span>set_spmf <span class="main">(</span><span class="free">𝒜ss1</span> <span class="free">x1</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="free">a1</span><span class="main">,</span><span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">using</span></span> False Σ1.Σ_protocol_def Σ1.special_soundness_def Σ_prot1 e1_neq_e1' challenge_space <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">w'</span> <span class="main">∈</span> set_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="bound">w'</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def 𝒜ss_OR_def<span class="main">)</span> 
      <span class="keyword1"><span class="command">using</span></span> False assms Σ1.L_def assms valid_pub_OR_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>    
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lossless_spmf <span class="main">(</span>𝒜ss_OR <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s</span><span class="main">,</span><span class="main">(</span><span class="free">e0</span><span class="main">,</span><span class="free">z0</span><span class="main">)</span><span class="main">,</span> <span class="free">e1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">a0</span><span class="main">,</span><span class="free">a1</span><span class="main">)</span><span class="main">,</span><span class="free">s'</span><span class="main">,</span><span class="main">(</span><span class="free">e0'</span><span class="main">,</span><span class="free">z0'</span><span class="main">)</span><span class="main">,</span> <span class="free">e1'</span><span class="main">,</span><span class="free">z1'</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> 𝒜ss_OR_def<span class="main">)</span>  
      <span class="keyword1"><span class="command">using</span></span> 2 3 4 Σ_prot1 Σ1.Σ_protocol_def Σ1.special_soundness_def False e1_neq_e1' challenge_space e <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> special_soundness<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.special_soundness"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_OR.special_soundness_def 
  <span class="keyword1"><span class="command">using</span></span> ss prod.collapse <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">lemma</span></span> correct0<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> e_in_carrier<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">w0</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> valid_pub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">∈</span> <span class="free">valid_pub1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">w0</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> return_spmf True"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟶</span> <span class="free">e</span> <span class="main">=</span> <span class="main">(</span><span class="free">e</span> <span class="main">⊕</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">⊕</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">using</span></span> e_in_carrier xor_assoc <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">ab0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free">x0</span> <span class="free">w0</span><span class="main">;</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="free">e</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="bound">zb0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r0</span> <span class="free">w0</span> <span class="bound">eb</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">ab0</span> <span class="bound">eb</span> <span class="bound">zb0</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="bound">ab1'</span> <span class="bound">eb'</span> <span class="bound">zb1'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_OR.completeness_game_def split_def Let_def challenge_space_def assms check_OR_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="free">e</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r0</span><span class="main">,</span><span class="bound">ab0</span><span class="main">)</span> <span class="main">←</span> <span class="free">init0</span> <span class="free">x0</span> <span class="free">w0</span><span class="main">;</span>
    <span class="bound">zb0</span> <span class="main">←</span> <span class="free">response0</span> <span class="bound">r0</span> <span class="free">w0</span> <span class="bound">eb</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">ab0</span> <span class="bound">eb</span> <span class="bound">zb0</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="bound">ab1'</span> <span class="bound">eb'</span> <span class="bound">zb1'</span><span class="main">)</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"Σ1.S <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">::</span> <span class="tfree">'e</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">check1</span> <span class="free">x1</span> <span class="bound">ab1'</span> <span class="bound">eb'</span> <span class="bound">zb1'</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> e' a e z
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">check1</span> <span class="free">x1</span> <span class="skolem">a</span> <span class="skolem">e'</span> <span class="skolem">z</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> Σ0.complete_game_return_true Σ_prot0 Σ0.completeness_game_def Σ0.Σ_protocol_def  
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms bind_spmf_const lossless_init lossless_response lossless_weight_spmfD split_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">::</span> <span class="tfree">'e</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab1'</span><span class="main">,</span> <span class="bound">eb1''</span><span class="main">,</span> <span class="bound">zb1'</span><span class="main">)</span> <span class="main">←</span> Σ1.S <span class="free">x1</span> <span class="bound">eb'</span><span class="main">;</span>
    return_spmf <span class="main">(</span>True<span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x a aa b
      <span class="keyword1"><span class="command">using</span></span>  Σ_prot1 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ1.S_def split_def image_def Σ1.HVZK_unfold2_alt<span class="main">)</span>  
      <span class="keyword1"><span class="command">using</span></span> Σ1.S_def split_def image_def Σ1.HVZK_unfold2_alt Σ_prot1 valid_pub <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> Σ1.HVZK_unfold2_alt
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const Let_def Σ1.HVZK_unfold2_alt split_def lossless_Σ_S lossless_weight_spmfD carrier_L_not_empty finite_L<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> correct1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> rel1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">w1</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Rel1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> valid_pub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x0</span> <span class="main">∈</span> <span class="free">valid_pub0</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> e_in_carrier<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">w1</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> return_spmf True"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> x1_inL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x1</span> <span class="main">∈</span> Σ1.L"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Σ1.L_def rel1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> carrier <span class="free">L</span> <span class="main">⟶</span> <span class="free">e</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">⊕</span> <span class="free">e</span> <span class="main">⊕</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> e_in_carrier xor_assoc xor_commute  local.xor_ac<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">ab1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free">x1</span> <span class="free">w1</span><span class="main">;</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="free">e</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="bound">zb1</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r1</span> <span class="free">w1</span> <span class="bound">eb</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">ab0'</span> <span class="bound">eb'</span> <span class="bound">zb0'</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="bound">ab1</span> <span class="bound">eb</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_OR.completeness_game_def split_def Let_def assms challenge_space_def check_OR_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> bind_spmf_cong_simp<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">eb</span> <span class="main">=</span> <span class="free">e</span> <span class="main">⊕</span> <span class="bound">eb'</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">r1</span><span class="main">,</span> <span class="bound">ab1</span><span class="main">)</span> <span class="main">←</span> <span class="free">init1</span> <span class="free">x1</span> <span class="free">w1</span><span class="main">;</span>
    <span class="bound">zb1</span> <span class="main">←</span> <span class="free">response1</span> <span class="bound">r1</span> <span class="free">w1</span> <span class="bound">eb</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">ab0'</span> <span class="bound">eb'</span> <span class="bound">zb0'</span> <span class="main">∧</span> <span class="free">check1</span> <span class="free">x1</span> <span class="bound">ab1</span> <span class="bound">eb</span> <span class="bound">zb1</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> bind_commute_spmf<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"Σ0.S <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    return_spmf <span class="main">(</span><span class="free">check0</span> <span class="free">x0</span> <span class="bound">ab0'</span> <span class="bound">eb'</span> <span class="bound">zb0'</span><span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> e' a e z
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">check0</span> <span class="free">x0</span> <span class="skolem">a</span> <span class="skolem">e'</span> <span class="skolem">z</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> Σ1.complete_game_return_true Σ_prot1 Σ1.completeness_game_def Σ1.Σ_protocol_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> x1_inL assms bind_spmf_const lossless_init lossless_response lossless_weight_spmfD split_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">eb'</span> <span class="main">←</span> spmf_of_set <span class="main">(</span>carrier <span class="free">L</span><span class="main">)</span><span class="main">;</span>
    <span class="main">(</span><span class="bound">ab0'</span><span class="main">,</span> <span class="bound">eb0''</span><span class="main">,</span> <span class="bound">zb0'</span><span class="main">)</span> <span class="main">←</span> Σ0.S <span class="free">x0</span> <span class="bound">eb'</span><span class="main">;</span>
    return_spmf <span class="main">(</span>True<span class="main">)</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> bind_spmf_cong<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x a aa b
      <span class="keyword1"><span class="command">using</span></span>  Σ_prot0
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valid_pub valid_pub_OR_def Σ0.S_def split_def image_def Σ0.HVZK_unfold2_alt<span class="main">)</span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ0.HVZK_unfold2 Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> Σ0.complete_game_return_true Σ_OR.completeness_game_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_spmf_const split_def lossless_Σ_S<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> lossless_weight_spmfD Let_def carrier_L_not_empty finite_L<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> completeness'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  Rel_OR_asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span><span class="main">,</span> <span class="free">w</span><span class="main">)</span> <span class="main">∈</span> Rel_OR"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">e</span> <span class="main">∈</span> carrier <span class="free">L</span><span class="main">.</span> spmf <span class="main">(</span>Σ_OR.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="free">w</span> <span class="bound">e</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span>
  <span class="keyword3"><span class="command">assume</span></span> asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> carrier <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Σ_OR.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="free">w</span> <span class="skolem">e</span><span class="main">)</span> <span class="main">=</span> return_spmf True"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">w</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> inl<span class="main">:</span> <span class="main">(</span>Inl <span class="skolem">a</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> asm correct0 assms inl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> inr<span class="main">:</span> <span class="main">(</span>Inr <span class="skolem">b</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> asm correct1 assms inr <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"spmf <span class="main">(</span>Σ_OR.completeness_game <span class="main">(</span><span class="free">x0</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span> <span class="free">w</span> <span class="skolem">e</span><span class="main">)</span> True <span class="main">=</span> <span class="main">1</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> completeness<span class="main">:</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.completeness"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Σ_OR.completeness_def
  <span class="keyword1"><span class="command">using</span></span> completeness' challenge_space_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Σ_protocol<span class="main">:</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Σ_OR.Σ_protocol"</span></span>
 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> completeness HVZK special_soundness Σ_OR.Σ_protocol_def<span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> OR_Σ_commit<span class="main">:</span> Σ_protocols_to_commitments <span class="quoted">init_OR</span> <span class="quoted">response_OR</span> <span class="quoted">check_OR</span> <span class="quoted">Rel_OR</span> <span class="quoted">S_OR</span> <span class="quoted">𝒜ss_OR</span> <span class="quoted">challenge_space</span> <span class="quoted">valid_pub_OR</span> <span class="quoted"><span class="free">G</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Σ_protocol lossless_G lossless_init_OR G_Rel_OR lossless_response_OR<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"OR_Σ_commit.abstract_com.correct"</span></span>
  <span class="keyword1"><span class="command">using</span></span> OR_Σ_commit.commit_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"OR_Σ_commit.abstract_com.perfect_hiding_ind_cpa <span class="free">𝒜</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> OR_Σ_commit.perfect_hiding <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> bind_advantage_bound_dis_log<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"OR_Σ_commit.abstract_com.bind_advantage <span class="free">𝒜</span> <span class="main">≤</span> OR_Σ_commit.rel_advantage <span class="main">(</span>OR_Σ_commit.adversary <span class="free">𝒜</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> OR_Σ_commit.bind_advantage <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>