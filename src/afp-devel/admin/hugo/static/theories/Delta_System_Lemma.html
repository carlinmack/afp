<div id="ZF_Library">
<div class="head"><h1>Theory ZF_Library</h1>
<span class="command">theory</span> <span class="name">ZF_Library</span><br/>
<span class="keyword">imports</span> <a href="../../ZF/ZF-Constructible/Normal.html"><span class="name">Normal</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Library of basic $\ZF$ results\label{sec:zf-lib}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>ZF_Library</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ZF-Constructible.Normal"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This theory gathers basic ``combinatorial'' results that can be proved
in $\ZF$ (that is, without using the Axiom of Choice $\AC$).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We begin by setting up math-friendly notation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>oadd</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹++›</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>sum</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹+›</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>oadd</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹+›</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‹ω›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>csucc</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‹_<span class="hidden">⇧</span><sup>+</sup>›</span></span></span><span> </span><span class="delimiter">[</span><span>90</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Aleph</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‹ℵ_›</span></span></span><span> </span><span class="delimiter">[</span><span>90</span><span class="delimiter">]</span><span> </span><span>90</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>Aleph</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‹ℵ<span class="hidden">⇘</span><sub>_<span class="hidden">⇙</span></sub>›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ge"</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ o"</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹≥›</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ≥ y"</span></span></span><span> </span><span class="delimiter">⇀</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ≤ x"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Some minimal arithmetic/ordinal stuff›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_leD1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∪ j ≤ k ⟹ Ord(i) ⟹ Ord(j) ⟹ Ord(k) ⟹ i ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Un_least_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_leD2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∪ j ≤ k ⟹ Ord(i) ⟹ Ord(j) ⟹ Ord(k) ⟹ j ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Un_least_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_memD1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∪ j ∈ k ⟹ Ord(i) ⟹ Ord(j) ⟹ Ord(k) ⟹ i ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ltI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>leI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Un_least_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_memD2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ∪ j ∈ k ⟹ Ord(i) ⟹ Ord(j) ⟹ Ord(k) ⟹ j ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ltI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>leI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>Un_least_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This lemma allows to apply arithmetic simprocs to ordinal addition›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_oadd_add</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈ ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n + m = n #+ m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_has_max_imp_succ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β ∈ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀α∈γ. α ≤ β"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ = succ(β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>β</span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Least_antitone</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(j)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(j)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. P(i) ⟹ Q(i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(μ i. Q(i)) ≤ (μ i. P(i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>LeastI2</span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>j</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>Least_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Least_set_antitone</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ord(j) ⟹ j∈A ⟹ A ⊆ B ⟹ (μ i. i∈B) ≤ (μ i. i∈A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Least_antitone</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_neq_imp_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x≤y ⟹ x≠y ⟹ x&lt;y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span>ltI</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>le_Ord2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Strict upper bound of a set of ordinals.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>str_bound</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i⇒i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"str_bound(A) ≡ ⋃a∈A. succ(a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>str_bound_type</span><span> </span><span class="delimiter">[</span><span>TC</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. Ord(a) ⟹ Ord(str_bound(A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>str_bound_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>str_bound_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. Ord(a) ⟹ ∀a∈A. a &lt; str_bound(A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>str_bound_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>str_bound_type</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ltI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>naturals_lt_nat</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω ⟹ n &lt; ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next two lemmas are handy when one is constructing
some object recursively. The first handles injectivity (of recursively
constructed sequences of sets), while the second is helpful for
establishing a symmetry argument.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Int_eq_zero_imp_not_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x∈D ⟹ y ∈ D ⟹ x ≠ y ⟹ A(x) ∩ A(y) = 0"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀x. x∈D ⟹ A(x) ≠ 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a≠b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A(a) ≠ A(b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_neq_symmetry</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀α β. α ∈ γ ⟹ β ∈ γ ⟹ α &lt; β ⟹ Q(α,β)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀α β. Q(α,β) ⟹ Q(β,α)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"α ∈ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β ∈ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ≠ β"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Q(α,β)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"β&lt;α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_linear_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span>α</span><span> </span><span>β</span><span> </span><span>thesis</span><span class="delimiter">]</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_succ_not_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|A| = succ(n) ⟹ A ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_eq_Collect_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;α ⟹ {j∈α. j&lt;i} = i"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹almost the same proof as @{thm nat_eq_Collect_lt}›</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ltD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ord_mem_iff_lt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ord_trans</span><span> </span><span>ltI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>lt_Ord</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lt_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span>ltD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Manipulation of function spaces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>Finite_to_one</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Finite_to_one(X,Y) ≡ {f:X→Y. ∀y∈Y. Finite({x∈X . f`x = y})}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_to_oneI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:X→Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀y. y∈Y ⟹ Finite({x∈X . f`x = y})"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Finite_to_one(X,Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_to_one_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_to_oneD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ∈ Finite_to_one(X,Y) ⟹ f:X→Y"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ∈ Finite_to_one(X,Y) ⟹ y∈Y ⟹  Finite({x∈X . f`x = y})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_to_one_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_Diff_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ A ⟹ A = (A - X) ∪ X "</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Diff_bij</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈F. X ⊆ A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λA∈F. A-X) ∈ bij(F, {A-X. A∈F})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>inj_def</span><span> </span><span>surj_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lam_type</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>subset_Diff_Un</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>function_space_nonempty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A. b) : A → B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lam_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vimage_lam</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A. f(x)) -`` B = { x∈A . f(x) ∈ B }"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_funtype</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>domain_type</span><span class="delimiter">]</span><span>
</span><span>    </span><span>lam_funtype</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>apply_equality</span><span class="delimiter">]</span><span> </span><span>lamI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>A</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_fun_subset_codomain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h:B → C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(h) ⊆ C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>range_def</span><span> </span><span>domain_def</span><span> </span><span>converse_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pi_rangeD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈Pi(A,B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ range(f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a∈A. f`a = b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>apply_equality</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>    </span><span>domain_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pi_range_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B) ⟹ range(f) = {f ` x . x ∈ A}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pi_rangeD</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span>apply_rangeI</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pi_vimage_subset</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B) ⟹ f-``C ⊆ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_in_range</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ≠0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: A → γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f`x∈γ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈A"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈A›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>   </span><span>domain_of_fun</span><span> </span><span>apply_rangeI</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∉A›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_0</span><span> </span><span>Ord_0_lt</span><span> </span><span>ltD</span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_eq_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:A→B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f) = f``A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f `` A ⊆ range(f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈range(f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈f``A"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. B"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f) ⊆ f `` A"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Image_sub_codomain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f:A→B ⟹ f``C ⊆ B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>image_subset</span><span> </span><span>fun_is_rel</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_ . B"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_to_Image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f:A→B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(A,B)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(A,f``A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>inj_inj_range</span><span> </span><span>range_eq_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_imp_surj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>inj_is_fun</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ifx(x) ≡ if x∈range(f) then converse(f)`x else b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(B,A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A. ifx(x)) ∈ surj(A,B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(f) ∈ surj(range(f),B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f) ⊆ A"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"converse(f) : range(f) → B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_converse_surj</span><span> </span><span>range_fun_subset_codomain</span><span> </span><span>surj_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈B›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A. ifx(x)) ∈ surj(A,B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>lam_type</span><span> </span><span>ballI</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>CollectE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y∈B. ∃x∈range(f). converse(f) ` x = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹range(f) ⊆ A›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈A. (λx∈A. ifx(x)) ` x = y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_Pi_disjoint_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ Pi(C,D)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"A ∩ C = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ g ∈ Pi(A ∪ C, λx. B(x) ∪ D(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Pi_iff</span><span> </span><span>extension</span><span> </span><span>Un_rls</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>function_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_restrict_decomposition</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = restrict(f, A ∩ C) ∪ restrict(f, A - C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fun_extension</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(f,A∩C) ∪ restrict(f,A-C) ∈ Pi(A∩C ∪ (A-C), λx. B(x)∪B(x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_type2</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>fun_Pi_disjoint_Un</span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ∩ C) ∪ (A - C) = A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(f, A ∩ C) ∪ restrict(f, A - C) ∈ Pi(A, B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` x = (restrict(f, A ∩ C) ∪ restrict(f, A - C)) ` x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict</span><span> </span><span>fun_disjoint_apply1</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(f,_)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>fun_disjoint_apply2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(f,_)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>domain_restrict</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>apply_0</span><span> </span><span>domain_of_fun</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈C"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrict_eq_imp_Un_into_Pi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ Pi(C,D)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(f, A ∩ C) = restrict(g, A ∩ C)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ g ∈ Pi(A ∪ C, λx. B(x) ∪ D(x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ g ⟹ x ∉ restrict(g, A ∩ C)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∩ C"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f ⟹ x ∈ restrict(f, A - C) ∨ x ∈ restrict(g, A ∩ C)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Un_restrict_decomposition</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"C"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ g = restrict(f, A - C) ∪ g"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∩ C"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Un_restrict_decomposition</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"C"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A - C ∪ C = A ∪ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_Pi_disjoint_Un</span><span class="delimiter">[</span><span>OF</span><span>
</span><span>        </span><span>restrict_type2</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="string"><span class="delete"><span class="delete">"A-C"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>g</span><span> </span><span>C</span><span> </span><span>D</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrict_eq_imp_Un_into_Pi'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(A,B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ Pi(C,D)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"restrict(f, domain(f) ∩ domain(g)) = restrict(g, domain(f) ∩ domain(g))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ g ∈ Pi(A ∪ C, λx. B(x) ∪ D(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>assms</span><span> </span><span>domain_of_fun</span><span> </span><span>restrict_eq_imp_Un_into_Pi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrict_subset_Sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ⊆ Sigma(C,B) ⟹ restrict(f,A) ⊆ Sigma(A∩C, B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>restrict_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Finite sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_sing1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (∃a. P(d,a)) ∧ (∀y y'. P(d,y) ⟶ P(d,y') ⟶ y=y') ⟧ ⟹ ∃a. {y . x ∈ {d}, P(x,y)} = {a}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment">― ‹Not really necessary›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_sing2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. ¬ P(d,a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{y . x ∈ {d}, P(x,y)} = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_sing3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c e. c ≠ e ∧ P(d,c) ∧ P(d,e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{y . x ∈ {d}, P(x,y)} = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. P(d, y) ⟶ y = z"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∉ {y . x ∈ {d}, P(x,y)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Replace_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{b . a ∈ A ∪ B, Q(a, b)} =
        {b . a ∈ A, Q(a, b)} ∪ {b . a ∈ B, Q(a, b)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Replace_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Replace_subset_sing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. {y . x ∈ {d}, P(x,y)} ⊆ {z}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>    </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃a. P(d,a)) ∧ (∀y y'. P(d,y) ⟶ P(d,y') ⟶ y=y')"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>    </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. ¬ P(d,a)"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃c e. c ≠ e ∧ P(d,c) ∧ P(d,e)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. {y . x ∈ {d}, P(x,y)} ⊆ {z}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Replace_sing1</span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Replace_sing3</span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_Replace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ Finite(Replace(A,Q))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>Finite_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>cons</span><span> </span><span>x</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b . a ∈ cons(x, B), Q(a, b)} =
        {b . a ∈ B, Q(a, b)} ∪ {b . a ∈ {x}, Q(a, b)}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Replace_Un</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cons_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{b . a ∈ {x}, Q(a, b)} ⊆ {d}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Replace_subset_sing</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite({b . a ∈ {x}, Q(a, b)})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_domain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ Finite(domain(A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Replace</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>domain_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_converse</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ Finite(converse(A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Replace</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>converse_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ Finite(range(A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_domain</span><span> </span><span>Finite_converse</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>range_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_Sigma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ ∀x. Finite(B(x)) ⟹ Finite(Sigma(A,B))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Sigma_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_RepFun</span><span> </span><span>Finite_Union</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_Pi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(A) ⟹ ∀x. Finite(B(x)) ⟹ Finite(Pi(A,B))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Sigma</span><span>
</span><span>    </span><span>Finite_Pow</span><span> </span><span>subset_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pi(A,B)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(Sigma(A,B))"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pi_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic results on equipollence, cardinality and related concepts›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepollD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≲ B ⟹ ∃f. f ∈ inj(A, B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lepoll_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepollI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(A, B) ⟹ A ≲ B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lepoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqpollD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≈ B ⟹ ∃f. f ∈ bij(A, B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>bij_imp_eqpoll</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_of_subset_eqpoll</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(X,Y)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≈ f `` S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>restrict_bij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹I thank Miguel Pagano for this proof.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>function_space_eqpoll_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A ≈ A'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≈ B'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A → B ≈ A' → B'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>eqpoll_sym</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ bij(A',A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ bij(B,B')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(g) : B' → B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(f): A → A'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_converse_bij</span><span> </span><span>bij_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>fg_imp_bijective</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span>-</span><span>2</span><span class="delimiter">]</span><span> </span><span>lam_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F: A → B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ bij(A',A)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g ∈ bij(B,B')›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g O F O f : A' → B'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_is_fun</span><span> </span><span>comp_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>F</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F: A' → B'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹converse(g) : B' → B›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹converse(f): A → A'›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(g) O F O converse(f) : A → B"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈_›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g∈_›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹converse(f)∈_›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹converse(g)∈_›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ A' → B' ⟹ converse(g) O x O converse(f) ∈ A → B)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_is_fun</span><span> </span><span>comp_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A → B. g O x O f) O (λx∈A' → B'. converse(g) O x O converse(f))
          =  (λx∈A' → B' . (g O converse(g)) O x O (converse(f) O f))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_cong</span><span> </span><span>comp_assoc</span><span> </span><span>comp_lam</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"A' → B'"</span></span></span><span> </span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (λx∈A' → B' . id(B') O x O (id(A')))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_comp_inverse</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_is_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈_›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>right_comp_inverse</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_is_surj</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g∈_›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (λx∈A' → B' . x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_comp_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_is_rel</span><span class="delimiter">]</span><span> </span><span>right_comp_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_is_rel</span><span class="delimiter">]</span><span>  </span><span>lam_cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = id(A'→B')"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A -&gt; B. g O x O f) O (λx∈A' -&gt; B'. converse(g) O x O converse(f)) = id(A' -&gt; B')"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈_›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g∈_›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. x ∈ A → B ⟹ g O x O f ∈ A' → B')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_is_fun</span><span> </span><span>comp_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A' -&gt; B'. converse(g) O x O converse(f)) O (λx∈A -&gt; B. g O x O f)
          = (λx∈A → B . (converse(g) O g) O x O (f O converse(f)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_lam</span><span> </span><span>comp_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (λx∈A → B . id(B) O x O (id(A)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>        </span><span>right_comp_inverse</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_is_surj</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈_›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>left_comp_inverse</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_is_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g∈_›</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>lam_cong</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (λx∈A → B . x)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_comp_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_is_rel</span><span class="delimiter">]</span><span> </span><span>right_comp_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_is_rel</span><span class="delimiter">]</span><span> </span><span>lam_cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = id(A→B)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A' → B'. converse(g) O x O converse(f)) O (λx∈A -&gt; B. g O x O f) = id(A -&gt; B)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>curry_eqpoll</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span>ν1</span><span> </span><span>ν2</span><span>  </span><span>κ</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν1 → ν2 → κ ≈ ν1 × ν2 → κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>lam_bijective</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>1</span><span>-</span><span>2</span><span class="delimiter">]</span><span> </span><span>lam_type</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>lam_type</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f : ν1 → ν2 → κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ ν1 × ν2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`fst(z)`snd(z) ∈ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f : ν1 × ν2 → κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈ν1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈ν2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`⟨x,y⟩ ∈ κ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> </span><span class="comment">― ‹one composition is the identity:›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f : ν1 × ν2 → κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈ν1 × ν2. (λx∈ν1. λxa∈ν2. f ` ⟨x, xa⟩) ` fst(x) ` snd(x)) = f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>fun_extension</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span> </span><span class="comment">― ‹the other composition follows automatically›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pow_eqpoll_function_space</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>d</span><span> </span><span>X</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>bool_of_o_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"d(A) ≡ (λx∈X. bool_of_o(x∈A))"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹the witnessing map for the thesis:›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(X) ≈ X → 2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>lam_bijective</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹We give explicit mutual inverses›</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A∈Pow(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d(A) : X → 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. bool_of_o(x∈A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A∈Pow(X)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{y∈X. d(A)`y = 1} = A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: X→2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d({y ∈ X . f ` y = 1}) = f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: X→2›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>fun_extension</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cantor_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ inj(Pow(A),A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_imp_surj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Pow_bottom</span><span class="delimiter">]</span><span> </span><span>cantor_surj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>cexp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_<span class="hidden">⇗</span><sup>↑_<span class="hidden">⇖</span></sup>"</span></span></span><span> </span><span class="delimiter">[</span><span>76</span><span class="delimiter">,</span><span>1</span><span class="delimiter">]</span><span> </span><span>75</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup> ≡ |ν → κ|"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Card_cexp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span> </span><span>Card_cardinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_csucc_ord</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ord(i) ⟹ i<span class="hidden">⇧</span><sup>+</sup> = |i|<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_lt_iff</span><span> </span><span>Least_cong</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>csucc_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹I thank Miguel Pagano for this proof.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lesspoll_csucc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≺ κ<span class="hidden">⇧</span><sup>+</sup> ⟷ d ≲ κ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≺ κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Card_is_Ord</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ &lt; κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cardinal_eqpoll</span><span> </span><span>csucc_basic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≺ |κ|<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(|κ|)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≈ |d|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_csucc_ord</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>lesspoll_imp_eqpoll</span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|d| &lt; |κ|<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_cardinal_lt</span><span> </span><span>csucc_basic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|d| ≲ |κ|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_lt_csucc_iff</span><span> </span><span>le_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|d| ≲ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_eq_trans</span><span> </span><span>Ord_cardinal_eqpoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≲ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq_lepoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ &lt; κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>csucc_basic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≲ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≲ κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_lepoll</span><span> </span><span>leI</span><span> </span><span>lepoll_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d ≲ κ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ<span class="hidden">⇧</span><sup>+</sup> ≲ κ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≈ κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span>eq_lepoll_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹d≲κ›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ d ≈ κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_irrefl</span><span> </span><span>lesspoll_trans1</span><span> </span><span>lt_Card_imp_lesspoll</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹κ &lt;_›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≺ κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lesspoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Infinite</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Infinite(X) ≡ ¬ Finite(X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Infinite_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X) ⟹ X ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Infinite_imp_nats_lepoll</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≲ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ∈ ω›</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinite(X)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ ω›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (x ≈ X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ≲ X›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(x,X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∉ surj(x,X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈x. f`a ≠ b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(x,X-{b})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Pi_type</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cons(⟨x, b⟩, f) ∈ inj(succ(x), cons(b, X - {b}))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_extend</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span class="string"><span class="delete"><span class="delete">"X-{b}"</span></span></span><span> </span><span>x</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>mem_irrefl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈X›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cons(b, X - {b}) = X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(x) ≲ X"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_lesspoll</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;κ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 ≺ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>eqpoll_0_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>eqpoll_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lesspoll_def</span><span> </span><span>lepoll_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepoll_nat_imp_Infinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ≲ X ⟹ Infinite(X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ≲ X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≈ n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ≲ n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_eq_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_nat_imp_Finite</span><span> </span><span>nat_not_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InfCard_imp_Infinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ) ⟹ Infinite(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_lepoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lepoll_nat_imp_Infinite</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_surj_empty_imp_Card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀α. α &lt; κ ⟹ surj(α,κ) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|κ| &lt; κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. i ≈ κ"</span></span></span><span> </span><span>κ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>eqpoll_refl</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Least_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λi. i ≈ κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|κ|"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Ord_cardinal_eqpoll</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Card_def</span><span> </span><span>cardinal_def</span><span> </span><span>eqpoll_def</span><span> </span><span>bij_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cardinal_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>not_lt_imp_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"|κ|"</span></span></span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>le_anti_sym</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Card_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Morphisms of binary relations›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The main case of interest is in the case of partial orders.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f ∈ mono_map(A,r,B,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f ∈ mono_map(A,r,C,s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ mono_map(A,_,B,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: A → B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹B⊆C›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: A → C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_weaken_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩ ∈ r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: A → B›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x ∈ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`y ∈ B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ mono_map(_,r,_,s)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨f ` x, f ` y⟩ ∈ s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordertype_zero_imp_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,r) = 0 ⟹ A = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordermap_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A=0"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_increasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"j∈mono_map(A,r,B,s) ⟹ a∈A ⟹ c∈A ⟹ ⟨a,c⟩∈r ⟹ ⟨j`a,j`c⟩∈s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>linear_mono_map_reflects</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"linear(α,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans[β](s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl(β,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈mono_map(α,r,β,s)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x∈α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨f`x,f`y⟩∈s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩∈r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈mono_map(_,_,_,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>preserves</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x∈α ⟹ y∈α ⟹ ⟨x,y⟩∈r ⟹ ⟨f`x,f`y⟩∈s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x, y⟩ ∉ r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨f`x,f`y⟩∈s›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹linear(α,r)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = x ∨ ⟨y,x⟩∈r"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>linear_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>preserves</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = x ∨ ⟨f`y, f`x⟩∈ s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈mono_map(_,_,β,_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈α›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y∈α›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x∈β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`y∈β"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨f`x,f`y⟩∈s›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹trans[β](s)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹irrefl(β,s)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_onD</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x"</span></span></span><span class="delimiter">]</span><span> </span><span>irreflE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>irrefl_Memrel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"irrefl(x, Memrel(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>irrefl_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Memrel_mono_map_reflects</span><span> </span><span class="delimiter">=</span><span> </span><span>linear_mono_map_reflects</span><span>
</span><span>  </span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_is_linear</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span> </span><span>well_ord_is_trans_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span>
</span><span>    </span><span>irrefl_Memrel</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment">― ‹Same proof as Paulson's @{thm mono_map_is_inj}›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_is_inj'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ linear(A,r);  irrefl(B,s);  f ∈ mono_map(A,r,B,s) ⟧ ⟹ f ∈ inj(A,B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>irrefl_def</span><span> </span><span>mono_map_def</span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linearE</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>linearE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>apply_type</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_imp_ord_iso_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"linear(α,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans[β](s)"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"irrefl(β,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈mono_map(α,r,β,s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f ∈ ord_iso(α,r,f``α,s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_iso_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>ballI</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">― ‹Enough to show it's bijective and preserves both ways›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(α,β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_inj'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ mono_map(_,_,_,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ surj(α, f``α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ bij(α, f``α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span> </span><span>inj_to_Image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈mono_map(_,_,_,_)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈α ⟹ y∈α ⟹ ⟨x,y⟩∈r ⟹ ⟨f`x,f`y⟩∈s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨f`x,f`y⟩∈s ⟹ x∈α ⟹ y∈α ⟹ ⟨x,y⟩∈r"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>linear_mono_map_reflects</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We introduce the following notation for strictly increasing maps
between ordinals.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>mono_map_Memrel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹→<span class="hidden">⇩</span><sub>&lt;</sub>›</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"α →<span class="hidden">⇩</span><sub>&lt;</sub> β ≡ mono_map(α,Memrel(α),β,Memrel(β))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_imp_ord_iso_Memrel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:α →<span class="hidden">⇩</span><sub>&lt;</sub> β"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f ∈ ord_iso(α,Memrel(α),f``α,Memrel(β))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mono_map_imp_ord_iso_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_is_linear</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span>
</span><span>      </span><span>well_ord_is_trans_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span> </span><span>irrefl_Memrel</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_ordertype_image'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X⊆α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ mono_map(X,Memrel(α),β,Memrel(β))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ordertype(f``X,Memrel(β)) = ordertype(X,Memrel(α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>X</span><span> </span><span>_</span><span> </span><span>β</span><span class="delimiter">]</span><span>  </span><span>ordertype_eq</span><span>
</span><span>    </span><span>mono_map_imp_ord_iso_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_is_linear</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>linear_subset</span><span class="delimiter">]</span><span>
</span><span>      </span><span>well_ord_is_trans_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span> </span><span>irrefl_Memrel</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>α</span><span> </span><span>X</span><span> </span><span>β</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>    </span><span>well_ord_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span>  </span><span>Image_sub_codomain</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>X</span><span> </span><span>β</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_ordertype_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:α →<span class="hidden">⇩</span><sub>&lt;</sub> β"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ordertype(f``α,Memrel(β)) = α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mono_map_is_fun</span><span> </span><span>ordertype_Memrel</span><span> </span><span>ordertype_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>α</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(α)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>mono_map_imp_ord_iso_Memrel</span><span> </span><span>well_ord_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span> </span><span>Image_sub_codomain</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>α</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apply_in_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f:A→B ⟹ a∈A ⟹ f`a ∈ f``A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_eq_image</span><span> </span><span>apply_rangeI</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Image_subset_Ord_imp_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h``A ⊆ α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈domain(h)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(h)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"h`x &lt; α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>domain_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imageI</span><span> </span><span>ltI</span><span> </span><span>function_apply_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordermap_le_arg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X⊆β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"x∈X ⟹ ordermap(X,Memrel(β))`x≤x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>Ord_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wf[X](Memrel(β))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_imp_wf_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_Memrel</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordermap(X,Memrel(β))`x = {ordermap(X,Memrel(β))`y . y∈{y∈X . y∈x ∧ y∈β}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordermap_unfold</span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {ordermap(X,Memrel(β))`y . y∈{y∈X . y∈x}}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ordm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ordermap(X,Memrel(β))`x = {ordermap(X,Memrel(β))`y . y∈{y∈X . y∈x}}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈x ⟹ y∈X ⟹ ordermap(X,Memrel(β))`y ≤ y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈β›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(β)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈x ⟹ y∈X ⟹ ordermap(X,Memrel(β))`y ∈ x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>lt_trans1</span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ordm</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordermap(X,Memrel(β))`x ⊆ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈X›</span></span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>Ord_ordermap</span><span>
</span><span>      </span><span>well_ord_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_imp_ordertype_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X⊆β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ordertype(X,Memrel(β))≤β"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordermap(X,Memrel(β))`x ≤ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordermap_le_arg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈X›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordermap(X,Memrel(β))`x ∈ β"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?y ∈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?y</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(x)"</span></span></span><span class="delimiter">]</span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span>  </span><span class="var">?y</span><span> </span><span>x</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(X, Memrel(β)) ⊆ β"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le</span><span> </span><span>Ord_ordertype</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_subset</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_map_imp_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f∈mono_map(α, Memrel(α),β, Memrel(β))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"α≤β"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ ⟨α, Memrel(α)⟩ ≅ ⟨f``α, Memrel(β)⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_imp_ord_iso_Memrel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(f) ∈ ⟨f``α, Memrel(β)⟩ ≅ ⟨α, Memrel(α)⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ord_iso_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α = ordertype(f``α,Memrel(β))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_eq</span><span> </span><span>well_ord_Memrel</span><span> </span><span>ordertype_Memrel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(f``α,Memrel(β)) ≤ β"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_ordertype_le</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>Image_sub_codomain</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">― ‹\&lt;^term&gt;‹Ord(A) ⟹ f ∈ mono_map(A, Memrel(A), B, Memrel(Aa)) ⟹ f ∈ inj(A, B)››</span><span> 
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Memrel_mono_map_is_inj</span><span> </span><span class="delimiter">=</span><span> </span><span>mono_map_is_inj</span><span>
</span><span>  </span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_is_linear</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span>
</span><span>    </span><span>wf_imp_wf_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_Memrel</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mapI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: A→B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. x∈A ⟹ y∈A ⟹ ⟨x,y⟩∈r ⟹ ⟨f`x,f`y⟩∈s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"f ∈ mono_map(A,r,B,s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_mapD</span><span> </span><span class="delimiter">=</span><span> </span><span>mono_map_is_fun</span><span> </span><span>mono_map_increasing</span><span>
</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>mono_map_rules</span><span> </span><span class="delimiter">=</span><span>  </span><span>mono_mapI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>mono_mapD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nats_le_InfCard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Ord_is_Transset</span><span>
</span><span>    </span><span>le_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>ω</span><span> </span><span>κ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>le_subset_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span>Transset_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_into_InfCard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  </span><span>le_imp_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Alephs are infinite cardinals›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aleph_zero_eq_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub> = ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Aleph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InfCard_Aleph</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>Aleph_zero_eq_nat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> ∈ ω)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"α=0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_irrefl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ∈ ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span>α</span><span class="delimiter">]</span><span> </span><span>ltD</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Aleph_increasing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>foundation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (|ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>| ∈ ω)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Finite(ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_Card_is_InfCard</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Limit_Aleph</span><span> </span><span class="delimiter">=</span><span> </span><span>InfCard_Aleph</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>InfCard_is_Limit</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Aleph_cont</span><span> </span><span class="delimiter">=</span><span> </span><span>Normal_imp_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Normal_Aleph</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Aleph_sup</span><span> </span><span class="delimiter">=</span><span> </span><span>Normal_Union</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>Normal_Aleph</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>Ord_dests</span><span> </span><span class="delimiter">=</span><span> </span><span>Limit_is_Ord</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>Card_is_Ord</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>Aleph_dests</span><span> </span><span class="delimiter">=</span><span> </span><span>Aleph_cont</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>Aleph_sup</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>Aleph_intros</span><span> </span><span class="delimiter">=</span><span> </span><span>Aleph_increasing</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">bundle</span></span><span> </span><span>Aleph_mem_dests</span><span> </span><span class="delimiter">=</span><span> </span><span>Aleph_increasing</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ltI</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ltD</span><span class="delimiter">,</span><span> </span><span>dest</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Cofinality">
<div class="head"><h1>Theory Cofinality</h1>
<span class="command">theory</span> <span class="name">Cofinality</span><br/>
<span class="keyword">imports</span> <a href="ZF_Library.html"><span class="name">ZF_Library</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cofinality\label{sec:cofinality}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Cofinality</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>ZF_Library</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic results and definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A set \&lt;^term&gt;‹X› is ∗‹cofinal› in \&lt;^term&gt;‹A› (with respect to the relation
    \&lt;^term&gt;‹r›) if every element of \&lt;^term&gt;‹A› is “bounded
    above” by some element of \&lt;^term&gt;‹X›. Note that \&lt;^term&gt;‹X› does not need 
    to be a subset of \&lt;^term&gt;‹A›.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>cofinal</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i,i] ⇒ o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cofinal(X,A,r) ≡ ∀a∈A. ∃x∈X. ⟨a,x⟩∈r ∨ a = x"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
(* Alternative definitions *)
definition
  cofinal_predic :: "[i,i,[i,i]⇒o] ⇒ o" where
  "cofinal_predic(X,A,r) ≡ ∀a∈A. ∃x∈X. r(a,x) ∨ a = x"

definition
  f_cofinal :: "[i⇒i,i,i,i] ⇒ o" where
  "f_cofinal(f,C,A,r) ≡ ∀a∈A. ∃x∈C. ⟨a,f(x)⟩∈r ∨ a = f(x)"

(* The next definition doesn't work if 0 is the top element of A.
   But it works for limit ordinals. *)
definition
  cofinal_fun' :: "[i,i,i] ⇒ o" where
  "cofinal_fun'(f,A,r) == f_cofinal(λx. f`x,domain(f),A, r)"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A function is cofinal if it range is.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>cofinal_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i,i] ⇒ o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,A,r) ≡ ∀a∈A. ∃x∈domain(f). ⟨a,f`x⟩∈r ∨ a = f`x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_funI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a. a∈A ⟹ ∃x∈domain(f). ⟨a,f`x⟩∈r ∨ a = f`x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,A,r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_funD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,A,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈domain(f). ⟨a,f`x⟩∈r ∨ a = f`x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_in_cofinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"trans(r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(Y,X,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(X,A,r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal(Y,A,r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(X,A,r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈A⟹∃x∈X. ⟨b,x⟩∈r ∨ b=x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,y⟩∈r ∨ a=y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(Y,X,r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c∈X⟹∃y∈Y. ⟨c,y⟩∈r ∨ c=y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨y,x⟩∈r ∨ y=x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a∈A›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y∈X›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨a,y⟩∈r ∨ a=y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans(r)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈Y. ⟨a,x⟩∈r ∨ a=x"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>codomain_is_cofinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,A,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:C → D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(D,A,r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈A ⟹ ∃x∈domain(f). ⟨a, f ` x⟩ ∈ r ∨ a = f`x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈domain(f)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨b, f ` x⟩ ∈ r ∨ b = f`x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:C → D›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈domain(f)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x∈D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span>apply_rangeI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃y∈D. ⟨b, y⟩ ∈ r ∨ b = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_range_iff_cofinal_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(f)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(range(f),A,r) ⟷ cofinal_fun(f,A,r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈A"</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(range(f),A,r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈range(f)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,y⟩ ∈ r ∨ a = y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩∈f"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>range_def</span><span> </span><span>domain_def</span><span> </span><span>converse_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹function(f)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a, f ` x⟩ ∈ r ∨ a = f ` x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>function_apply_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨x,y⟩∈f›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈domain(f). ⟨a, f ` x⟩ ∈ r ∨ a = f ` x"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. ∃x∈domain(f). ⟨a, f ` x⟩ ∈ r ∨ a = f ` x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(range(f), A, r)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>function_apply_Pair</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f∈ mono_map(C,s,D,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,D,r)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h:B → C"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(h,C,s)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"trans(r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f O h,D,r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f∈ mono_map(C,s,D,r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:C → D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:B → C›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(f) = C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(h) = B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal_fun(f,D,r)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c∈C"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨a, f ` c⟩ ∈ r ∨ a = f ` c"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal_fun(h,C,s)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(h) = B›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ B"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨c, h ` b⟩ ∈ s ∨ c = h ` b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:B → C›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h`b ∈ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ mono_map(C,s,D,r)›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹c∈C›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨f`c, f` (h ` b)⟩ ∈ r ∨ f`c = f` (h ` b)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨a, f ` c⟩ ∈ r ∨ a = f ` c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trans(r)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:B → C›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈B›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a, (f O h) ` b⟩ ∈ r ∨ a = (f O h) ` b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>transD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:B → C›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(f) = C›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(h) = B›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(f O h) = B"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_fun_subset_codomain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈B›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈domain(f O h). ⟨a, (f O h) ` x⟩ ∈ r ∨ a = (f O h) ` x"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>cf_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,α) ≡ cofinal_fun(f,α,Memrel(α))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_funI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f,α,Memrel(α)) ⟹ cf_fun(f,α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_funD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,α) ⟹ cofinal_fun(f,α,Memrel(α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_fun_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f∈ mono_map(C,s,α,Memrel(α))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,α)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"h:B → C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(h,C,s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f O h,α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cofinal_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>trans_Memrel</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>cf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i⇒i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cf(γ) ≡ μ β.  ∃A. A⊆γ ∧ cofinal(A,γ,Memrel(γ)) ∧ β = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ord_cf</span><span> </span><span class="delimiter">[</span><span>TC</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(cf(β))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_Least</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gamma_cofinal_gamma</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(γ,γ,Memrel(γ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_is_ordertype</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A. A⊆γ ∧ cofinal(A,γ,Memrel(γ)) ∧ cf(γ) = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(cf(γ))"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gamma_cofinal_gamma</span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>ordertype_Memrel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_fun_succ'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:α→succ(β)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x∈α. f`x=β) ⟷ cf_fun(f,succ(β))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x∈α. f`x=β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,succ(β))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:α→succ(β)›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_fun_def</span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,succ(β))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨β,f`x⟩ ∈ Memrel(succ(β)) ∨ β = f ` x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:α→succ(β)›</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_fun_def</span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(β)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨β,y⟩ ∉ Memrel(succ(β))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>foundation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Memrel_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈α. f ` x = β"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_fun_succ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ord(β) ⟹ f:1→succ(β) ⟹ f`0=β ⟹ cf_fun(f,succ(β))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_fun_succ'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordertype_0_not_cofinal_succ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(succ(i))) = 0"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"A⊆succ(i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬cofinal(A,succ(i),Memrel(succ(i)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(succ(i))) = ordertype(0,Memrel(0))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ordertype(A,Memrel(succ(i))) = 0›</span></span></span><span> </span><span>ordertype_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹A⊆succ(i)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(i)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ ⟨A, Memrel(succ(i))⟩ ≅ ⟨0, Memrel(0)⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>   </span><span>well_ord_Memrel</span><span> </span><span>well_ord_subset</span><span>
</span><span>      </span><span>ordertype_eq_imp_ord_iso</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>Ord_0</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A=0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>ord_iso_is_bij</span><span> </span><span>bij_imp_eqpoll</span><span> </span><span>eqpoll_0_is_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(A, succ(i), Memrel(succ(i)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(i)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_mem_empty</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹I thank Edwin Pacheco Rodríguez for the following lemma.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_succ</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(succ(α)) = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ≡ {⟨0,α⟩}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"f : 1→succ(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`0 = α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_extend3</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>0</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(α)"</span></span></span><span> </span><span>0</span><span> </span><span>α</span><span class="delimiter">]</span><span> </span><span>singleton_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,succ(α))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_fun_succ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:1→succ(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0∈domain(f)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A={f`0}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(f,succ(α))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹0∈domain(f)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f`0=α›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,succ(α),Memrel(succ(α)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹f`0=α›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A={f`0}›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ succ(α)"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>succ_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A⊆ succ(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_ord(A,Memrel(succ(α)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_succ</span><span> </span><span>well_ord_Memrel</span><span>  </span><span>well_ord_subset</span><span> </span><span>relation_Memrel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃A. A ⊆ succ(α) ∧ cofinal(A, succ(α), Memrel(succ(α))) ∧ 0 = ordertype(A, Memrel(succ(α))))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬?P(0)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_0_not_cofinal_succ</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 = ordertype(A,Memrel(succ(α)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A={f`0}›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A≈1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_eqpoll_1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹well_ord(A,Memrel(succ(α)))›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_1I</span><span> </span><span>ordertype_eq_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(succ(α)) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_1</span><span>  </span><span>Least_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cf(0) = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>    </span><span>ordertype_0</span><span> </span><span>subset_empty_iff</span><span> </span><span>Least_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>surj_is_cofinal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ surj(δ,γ) ⟹ cf_fun(f,γ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span>cofinal_fun_def</span><span> </span><span>cf_fun_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_zero_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α) ⟹ cf(α) = 0 ⟷ α = 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(α) = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_zero</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(α) = 0"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A⊆α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(α) = ordertype(A,Memrel(α))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,α,Memrel(α))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_is_ordertype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(0,α,Memrel(α))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_zero_imp_zero</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(α)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α=0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">― ‹TODO: define Succ (predicate for successor ordinals)›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_eq_one_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = 1 ⟷ (∃α. Ord(α) ∧ γ  = succ(α))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃α. Ord(α) ∧ γ  = succ(α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_succ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,γ,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_is_ordertype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(γ)) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f≡converse(ordermap(A,Memrel(γ)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ordertype(A,Memrel(γ)) = 1›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ γ›</span></span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ surj(1,A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>well_ord_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ordermap_bij</span><span class="delimiter">,</span><span>
</span><span>        </span><span>THEN</span><span> </span><span>bij_converse_bij</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>γ</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>bij_is_surj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(A,γ,Memrel(γ))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈γ. ⟨a, f`0⟩ ∈ Memrel(γ) ∨ a = f`0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span>surj_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ surj(1,A)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃α. Ord(α) ∧ γ  = succ(α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_has_max_imp_succ</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span> </span><span class="string"><span class="delete"><span class="delete">"f`0"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>surj_is_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>1</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>1</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_.A"</span></span></span><span> </span><span>0</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Ord_in_Ord</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordertype_in_cf_imp_not_cofinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(γ)) ∈ cf(γ)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A ⊆ γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ cofinal(A,γ,Memrel(γ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,γ,Memrel(γ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃B. B ⊆ γ ∧ cofinal(B, γ, Memrel(γ)) ∧  ordertype(A,Memrel(γ)) = ordertype(B, Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(ordertype(A,_))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(γ)) &lt; cf(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cf</span><span> </span><span>ltI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_LeastE</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ordertype(A,Memrel(γ))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_mono_map_cf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃j ∈ mono_map(cf(γ), Memrel(cf(γ)), γ, Memrel(γ)) . cf_fun(j,γ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,γ,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_is_ordertype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≡ converse(ordermap(A,Memrel(γ)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j :cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_ord_iso</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>ord_iso_sym</span><span class="delimiter">,</span><span>
</span><span>        </span><span>THEN</span><span> </span><span>ord_iso_is_mono_map</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>mono_map_mono</span><span class="delimiter">,</span><span>
</span><span>        </span><span>of</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(γ)"</span></span></span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>well_ord_subset</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ surj(cf(γ),A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>well_ord_Memrel</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>well_ord_subset</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ordertype_ord_iso</span><span class="delimiter">,</span><span>
</span><span>        </span><span>THEN</span><span> </span><span>ord_iso_sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>γ</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ord_iso_is_bij</span><span class="delimiter">,</span><span>
</span><span>        </span><span>THEN</span><span> </span><span>bij_is_surj</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(A,γ,Memrel(γ))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(j,γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_range_iff_cofinal_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span>γ</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(γ)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>surj_range</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ)"</span></span></span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>surj_is_fun</span><span> </span><span>fun_is_function</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ∈ mono_map(_,_,_,_)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The factorization lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In this subsection we prove a factorization lemma for cofinal functions
into ordinals, which shows that any cofinal function between ordinals can be
“decomposed” in such a way that a commutative triangle of strictly increasing
maps arises.

The factorization lemma has a kind of
fundamental character, in that the rest of the basic results on cofinality
(for, instance, idempotence) follow easily from it, in a more algebraic way.

This is a consequence that the proof encapsulates uses of transfinite
recursion in the basic theory of cofinality; indeed, only one use is needed.
In the setting of Isabelle/ZF, this is convenient since the machinery of
recursion is pretty clumsy. On the downside, this way of presenting things 
results in a longer proof of the factorization lemma. This approach was
taken by the author in the notes \cite{apunte_st} for an introductory course
in Set Theory.

To organize the use of the hypotheses of the factorization lemma,
we set up a locale containing all the relevant ingredients.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>cofinal_factor</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>j</span><span> </span><span>δ</span><span> </span><span>ξ</span><span> </span><span>γ</span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>j_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j :ξ →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>ords</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(δ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(ξ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>f_type</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f: δ → γ"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Here, \&lt;^term&gt;‹f› is cofinal function from \&lt;^term&gt;‹δ› to \&lt;^term&gt;‹γ›, and the
ordinal \&lt;^term&gt;‹ξ› is meant to be the cofinality of \&lt;^term&gt;‹γ›. Hence, there exists
an increasing map \&lt;^term&gt;‹j› from  \&lt;^term&gt;‹ξ› to  \&lt;^term&gt;‹γ› by the last lemma.

The main goal is to construct an increasing function \&lt;^term&gt;‹g:ξ→δ› such that
the composition \&lt;^term&gt;‹f O g› is still cofinal but also increasing.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>factor_body</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i,i] ⇒ o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"factor_body(β,h,x) ≡ (x∈δ ∧ j`β ≤ f`x ∧ (∀α&lt;β . f`(h`α) &lt; f`x)) ∨ x=δ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>factor_rec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"factor_rec(β,h) ≡  μ x. factor_body(β,h,x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\&lt;^term&gt;‹factor_rec› is the inductive step for the definition by transfinite
recursion of the ∗‹factor› function (called \&lt;^term&gt;‹g› above), which in
turn is obtained by minimizing the predicate \&lt;^term&gt;‹factor_body›. Next we show
that this predicate is monotonous.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_body_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"factor_body(β,λx∈β. G(x),x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"factor_body(α,λx∈α. G(x),x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α&lt;β›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈β"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈ξ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈ξ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ords</span><span> </span><span>ltD</span><span> </span><span>Ord_cf</span><span> </span><span>Ord_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`α ∈ j`β"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_mono</span><span> </span><span>mono_map_increasing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈ξ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`β∈γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_mono</span><span> </span><span>domain_of_fun</span><span> </span><span>apply_rangeI</span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(j`β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_in_Ord</span><span> </span><span>ords</span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`α ≤ j`β"</span></span></span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`β ≤ f`θ ⟹ j`α ≤ f`θ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>θ</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`((λw∈α. G(w))`y) &lt; f`z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z∈δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x&lt;β. f`((λw∈β. G(w))`x) &lt; f`z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y&lt;α"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y&lt;α›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α&lt;β›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y&lt;β"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀x&lt;β. f`((λw∈β. G(w))`x) &lt; f`z›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` ((λw∈β. G(w)) ` y) &lt; f ` z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y&lt;α›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y&lt;β›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λw∈β. G(w)) ` y = (λw∈α. G(w)) ` y"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>beta_if</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>ltD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹factor_body(β,λx∈β. G(x),x)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_body_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_body_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"factor_body(α,g,δ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_body_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_rec_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"factor_rec(α,λx∈α. G(x)) ≤ factor_rec(β,λx∈β. G(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_rec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>ords</span><span> </span><span>factor_body_mono</span><span> </span><span>Least_antitone</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We now define the factor as higher-order function.
Later it will be restricted to a set to obtain a bona fide function of
type @{typ i}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>factor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ⇒ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"factor(β) ≡ transrec(β,factor_rec)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_unfold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"factor(α) = factor_rec(α,λx∈α. factor(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def_transrec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>factor_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α)≠δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α) ≤ factor(β)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α) = factor_rec(α, λx∈α. factor(x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_unfold</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>factor_rec_mono</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ factor_rec(β, λx∈β. factor(x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor_rec(β, λx∈β. factor(x)) = factor(β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def_transrec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>factor_def</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The factor satisfies the predicate body of the minimization.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_body_factor</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"factor_body(α,λx∈α. factor(x),factor(α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ords</span><span> </span><span>factor_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span>α</span><span class="delimiter">]</span><span>
</span><span>    </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"factor_body(_,_)"</span></span></span><span> </span><span>δ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_rec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_type</span><span> </span><span class="delimiter">[</span><span>TC</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(factor(α))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ords</span><span> </span><span>factor_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span>α</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_rec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The value \&lt;^term&gt;‹δ› in \&lt;^term&gt;‹factor_body› (and therefore, in
\&lt;^term&gt;‹factor›) is meant to be a “default value”. Whenever it is not 
attained, the factor function behaves as expected: It is increasing
and its composition with \&lt;^term&gt;‹f› also is.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_factor_increasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`factor(α) &lt; f`factor(β)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` ((λx∈β. factor(x)) ` α) &lt; f ` factor(β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span>ords</span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"factor_body(β,λx∈β. factor(x))"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_rec_def</span><span> </span><span>factor_body_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>beta_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α&lt;β›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_increasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α)≠δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α)&lt;factor(β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>f_factor_increasing</span><span> </span><span>factor_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>le_neq_imp_lt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_in_delta</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β) ≠ δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β) ∈ δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>factor_body_factor</span><span> </span><span>ords</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_body_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, we define the (set) factor function as the restriction of
factor to the ordinal  \&lt;^term&gt;‹ξ›.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>fun_factor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fun_factor ≡ λβ∈ξ. factor(β)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fun_factor_is_mono_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀β. β ∈ ξ ⟹ factor(β) ≠ δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_factor ∈ mono_map(ξ, Memrel(ξ), δ, Memrel(δ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Proof that \&lt;^term&gt;‹fun_factor› respects membership *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α)≠δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_in_delta</span><span> </span><span>Ord_in_Ord</span><span> </span><span>ords</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨α, β⟩ ∈ Memrel(ξ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨fun_factor ` α, fun_factor ` β⟩ ∈ Memrel(δ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_factor_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltI</span><span> </span><span>factor_increasing</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>ltD</span><span class="delimiter">]</span><span> </span><span>factor_in_delta</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Proof of type *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_factor : ξ → δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_factor_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltI</span><span> </span><span>lam_type</span><span> </span><span>factor_in_delta</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_fun_factor_is_mono_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀β. β ∈ ξ ⟹ factor(β) ≠ δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f O fun_factor ∈ mono_map(ξ, Memrel(ξ), γ, Memrel(γ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_type</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span> </span><span>comp_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>δ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fun_factor : ξ → δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_factor_is_mono_map</span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Proof that f O ?g respects membership *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨α, β⟩ ∈ Memrel(ξ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α&lt;β"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ξ"</span></span></span><span class="delimiter">]</span><span> </span><span>ltI</span><span> </span><span>ords</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈ξ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈ξ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(α)≠δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ≠0"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ords</span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α&lt;β›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fun_factor : ξ → δ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨(f O fun_factor) ` α, (f O fun_factor) ` β⟩ ∈ Memrel(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` factor(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` factor(β)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>f_factor_increasing</span><span> </span><span>apply_in_range</span><span> </span><span>f_type</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_factor_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* cofinal_factor *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We state next the factorization lemma.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cofinal_fun_factorization</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>le_imp_subset</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span>lt_trans2</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(δ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: δ → γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃g ∈ cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> δ.  f O g : cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> γ ∧
           cofinal_fun(f O g,γ,Memrel(γ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j :cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(j,γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_mono_map_cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(j) = cf(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ∈ _›</span></span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>cofinal_factor</span><span> </span><span>j</span><span> </span><span>δ</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The core of the argument is to show that the factor function
  indeed maps into \&lt;^term&gt;‹δ›, therefore its values satisfy the first
  disjunct of \&lt;^term&gt;‹factor_body›. This holds in turn because no
  restriction of the factor composed with \&lt;^term&gt;‹f› to a proper initial
  segment of \&lt;^term&gt;‹cf(γ)› can be cofinal in \&lt;^term&gt;‹γ› by definition of
  cofinality. Hence there must be a witness that satisfies the first
  disjunct.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>factor_not_delta</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β)≠δ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β ∈ cf(γ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>β</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For this, we induct on \&lt;^term&gt;‹β› ranging over \&lt;^term&gt;‹cf(γ)›.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>β</span><span> </span><span>rule</span><span class="delimiter">:</span><span>Ord_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Ord_cf</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>β</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z∈β ⟹ factor(z)≠δ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h ≡ λx∈β. f`factor(x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z∈β ⟹ factor(z) ∈ δ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_in_delta</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:δ→γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h : β → γ"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_funtype</span><span> </span><span>lam_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h : β →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mono_map_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>CollectI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈β"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(y) ≠ δ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h ∈ β → γ›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h`x ∈ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h`y ∈ γ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈cf(γ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y∈β›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ cf(γ)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span> </span><span>Ord_cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(y)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cf</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨x,y⟩ ∈ Memrel(β)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x&lt;y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ltI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨h ` x, h ` y⟩ ∈ Memrel(γ)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_factor_increasing</span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈cf(γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(h``β,Memrel(γ)) = β"</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Maybe should use range(h) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_ordertype_image</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span>Ord_cf</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β ∈cf(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(h``β,Memrel(γ)) ∈ cf(γ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h ∈ β → γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h``β ⊆ γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span>Image_sub_codomain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ cofinal(h``β,γ,Memrel(γ))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_in_cf_imp_not_cofinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α_0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α_0∈γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈h `` β. ¬ ⟨α_0, x⟩ ∈ Memrel(γ) ∧ α_0 ≠ x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h``β ⊆ γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈h `` β. x ∈ α_0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>well_ord_Memrel</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>well_ord_is_linear</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(γ)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>linear_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α_0 ∈ γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j ∈ mono_map(_,_,γ,_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`β ∈ γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span>apply_in_range</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α_0 ∈ γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α_0 ∪ j`β ∈ γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Un_least_mem_iff</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(f,γ)›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>θ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ∈domain(f)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨α_0 ∪ j`β, f ` θ⟩ ∈ Memrel(γ) ∨  α_0 ∪ j`β = f ` θ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cofinal_fun_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:δ→γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"θ ∈ δ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:δ→γ›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹α_0 ∈ γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(f`θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_in_range</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α_0 ∈ γ›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(δ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j`β ∈ γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α_0)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(j`β)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀x∈h `` β. x ∈ α_0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α_0)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:β→γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈β ⟹ h`x &lt; α_0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_function</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span>β</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. γ"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>Image_subset_Ord_imp_lt</span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span>β</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. γ"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈β ⟹ h`x &lt; f`θ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈β"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀x∈h `` β. x ∈ α_0›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α_0)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h:β→γ›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h`x &lt; α_0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_function</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span>β</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. γ"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>Image_subset_Ord_imp_lt</span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span>β</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. γ"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨α_0 ∪ _, f ` θ⟩ ∈ Memrel(γ) ∨ α_0 ∪ _= f ` θ›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(f`θ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α_0)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(j`β)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α_0 ≤ f`θ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Un_leD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>leI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>ltI</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>Un_leD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_eqI</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h`x &lt; f`θ"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor_body(β,λx∈β. factor(x),θ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span>factor_body_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Un_memD2</span><span> </span><span>Un_leD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_eqI</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(θ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β) ≤ θ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_unfold</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span class="delimiter">]</span><span> </span><span>Least_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_rec_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹θ∈δ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(δ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"factor(β) ∈ δ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leI</span><span class="delimiter">[</span><span>of</span><span> </span><span>θ</span><span class="delimiter">]</span><span> </span><span>ltI</span><span class="delimiter">[</span><span>of</span><span> </span><span>θ</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>ltD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>mem_irrefl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f O fun_factor, γ, Memrel(γ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>cofinal_funI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(j,γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(j) = cf(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈cf(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ j`x ∨ a = j`x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cofinal_fun_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>factor_not_delta</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ domain(f O fun_factor)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_fun_factor_is_mono_map</span><span> </span><span>mono_map_is_fun</span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ (f O fun_factor) `x ∨ a = (f O fun_factor) `x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈cf(γ)›</span></span></span><span> </span><span>factor_not_delta</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ` x ≤ f ` factor(x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mem_not_refl</span><span> </span><span>factor_body_factor</span><span> </span><span>factor_in_delta</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>factor_body_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ j`x ∨ a = j`x›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ f ` factor(x) ∨ a = f ` factor(x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x∈cf(γ)›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_funtype</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ)"</span></span></span><span> </span><span>factor</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_factor_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>factor_not_delta</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(f O fun_factor) `x ∈ γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_nonzero</span><span> </span><span>apply_in_range</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f O fun_factor"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>f_fun_factor_is_mono_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x ∈ domain(f O fun_factor). ⟨a, (f O fun_factor) ` x⟩ ∈ Memrel(γ)
                                       ∨ a = (f O fun_factor) `x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_factor_is_mono_map</span><span> </span><span>f_fun_factor_is_mono_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹As a final observation in this part, we note that if the original
cofinal map was increasing, then the factor function is also cofinal.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>factor_is_cofinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(δ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f :δ →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"f O g ∈ mono_map(α,r,γ,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f O g,γ,Memrel(γ))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g: α → δ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cf_fun(g,δ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cf_fun_def</span><span> </span><span>cofinal_fun_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ mono_map(δ,_,γ,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`a ∈ γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal_fun(f O g,γ,_)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y∈α"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨f`a, (f O g) ` y⟩ ∈ Memrel(γ) ∨ f`a = (f O g) ` y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_fun_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g:α → δ›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g:α → δ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨f`a, f ` (g ` y)⟩ ∈ Memrel(γ) ∨ f`a = f ` (g ` y)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g`y ∈ δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_fun_apply</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span>α</span><span> </span><span>δ</span><span> </span><span>y</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a∈δ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a, g ` y⟩ ∈ Memrel(δ) ∨ a = g ` y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Memrel_mono_map_reflects</span><span> </span><span>Memrel_mono_map_is_inj</span><span class="delimiter">[</span><span>of</span><span> </span><span>δ</span><span> </span><span>f</span><span> </span><span>γ</span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>      </span><span>inj_apply_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>δ</span><span> </span><span>γ</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹y∈α›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈domain(g). ⟨a, g ` x⟩ ∈ Memrel(δ) ∨ a = g ` x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹g:α → δ›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Classical results on cofinalities›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now the rest of the results follow in a more algebraic way. The
next proof one invokes a case analysis on whether the argument is zero,
a successor ordinal or a limit one; the last case being the most
relevant one and is immediate from the factorization lemma.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_le_domain_cofinal_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(δ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:δ → γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cf(γ)≤δ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>Ord_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(δ)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>γ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈δ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x=γ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_fun_succ'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"δ≠0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{⟨0,f`x⟩}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f`x=γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f:1→succ(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>singleton_0</span><span> </span><span>singleton_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>singleton_subsetI</span><span> </span><span>fun_weaken_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹f`x=γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(succ(γ)) = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_succ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹δ≠0›</span></span></span><span> </span><span>succ</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_0_lt_iff</span><span> </span><span>succ_leI</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(δ)›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>limit</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g :cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> δ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_fun_factorization</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_imp_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_ordertype_cofinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A⊆γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,γ,Memrel(γ))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = cf(ordertype(A,Memrel(γ)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>le_anti_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"well_ord(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>well_ord_Memrel</span><span> </span><span>well_ord_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:⟨α, Memrel(α)⟩ ≅ ⟨A,Memrel(γ)⟩"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_ord_iso</span><span> </span><span>Ord_ordertype</span><span> </span><span>ord_iso_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: α → A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ord_iso_is_mono_map</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Memrel(α)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(f)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_function</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:⟨α, Memrel(α)⟩ ≅ ⟨A,Memrel(γ)⟩›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f) = A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ord_iso_is_bij</span><span> </span><span>bij_is_surj</span><span> </span><span>surj_range</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cofinal(A,γ,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_range_iff_cofinal_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h :cf(α) →<span class="hidden">⇩</span><sub>&lt;</sub> α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(h,α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_mono_map_cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trans(Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trans_Memrel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A⊆γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f O h,γ,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_comp</span><span> </span><span>ord_iso_is_mono_map</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:⟨α,_⟩ ≅ ⟨A,_⟩›</span></span></span><span class="delimiter">]</span><span> </span><span>mono_map_is_fun</span><span>
</span><span>      </span><span>mono_map_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:α→A›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A⊆γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹h∈mono_map(cf(α),_,α,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f O h : cf(α) → γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pi_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>comp_fun</span><span>  </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α = ordertype(A,Memrel(γ))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) ≤ cf(ordertype(A,Memrel(γ)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_le_domain_cofinal_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"f O h"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cf_fun_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(********************************************************)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:⟨α, _⟩ ≅ ⟨A,_⟩›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A⊆γ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f :α →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ord_iso_is_mono_map</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: α → γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(f,γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g :cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> α"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"f O g :cf(γ) →<span class="hidden">⇩</span><sub>&lt;</sub> γ"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"cofinal_fun(f O g,γ,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_fun_factorization</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g:cf(γ)→α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(α)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f :α →<span class="hidden">⇩</span><sub>&lt;</sub> γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(g,α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>factor_is_cofinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α = ordertype(A,Memrel(γ))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(ordertype(A,Memrel(γ))) ≤ cf(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_le_domain_cofinal_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Ord_cf</span><span> </span><span>mono_map_is_fun</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_idemp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = cf(cf(γ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A⊆γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(A,γ,Memrel(γ))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = ordertype(A,Memrel(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_is_Ord</span><span> </span><span>cf_is_ordertype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = cf(ordertype(A,Memrel(γ)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_ordertype_cofinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = cf(cf(γ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf(γ) = ordertype(A,Memrel(γ))›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) = cf(cf(γ))"</span></span></span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_le_cardinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(γ) ≤ |γ|"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ surj(|γ|,γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cardinal_eqpoll</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span>bij_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_is_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_cardinal</span><span class="delimiter">]</span><span> </span><span>surj_is_cofinal</span><span>
</span><span>      </span><span>cf_le_domain_cofinal_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>surj_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regular_is_Card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>le_imp_subset</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ = cf(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(γ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|γ| ⊆ γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_is_Ord</span><span> </span><span>Ord_cardinal_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹γ = cf(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"γ ⊆ cf(γ)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|γ| ⊆ cf(γ)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Card_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_le_cardinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Limit_cf</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(κ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(cf(κ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_cf</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Ord_cases</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="comment">― ‹\&lt;^term&gt;‹cf(κ)› being 0 or successor leads to contradiction›</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_zero_iff</span><span> </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>α</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(κ) = 1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_idemp</span><span> </span><span>cf_succ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>succ_LimitE</span><span> </span><span>cf_eq_one_iff</span><span> </span><span>Limit_is_Ord</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InfCard_cf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(κ) ⟹ InfCard(cf(κ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>regular_is_Card</span><span> </span><span>cf_idemp</span><span> </span><span>Limit_cf</span><span> </span><span>nat_le_Limit</span><span> </span><span>Limit_cf</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_le_cf_fun</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Limit_is_Ord</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(κ) ≤ ν"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f.  f:ν → κ  ∧  cf_fun(f, κ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h_cofinal_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(h,κ)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"h :cf(κ) →<span class="hidden">⇩</span><sub>&lt;</sub> κ"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"h : cf(κ) → κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cofinal_mono_map_cf</span><span> </span><span>mono_map_is_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ inj(cf(κ), ν)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>calculation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ surj(ν, cf(κ))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: ν → cf(κ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_imp_surj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Limit_has_0</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>ltD</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span>surj_is_fun</span><span> </span><span>Limit_cf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,cf(κ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_is_cofinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h_cofinal_mono</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(h O f,κ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_fun_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h O f ∈ ν -&gt; κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Limit_cofinal_fun_lt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Limit_is_Ord</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f: ν → κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈κ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃α∈ν. n &lt; f`α"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈κ›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n) ∈ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_has_succ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ltI</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ltD</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: ν → _›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(f) = ν"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(f,κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈ ν"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n) ∈ f`α ∨ succ(n) = f `α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_funD</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cofinal_funD</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n) ∈ f`α"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n) = f `α"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; f`α"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ succ(n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: ν → _›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α ∈ ν›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(f ` α)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>ν</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. κ"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` α"</span></span></span><span class="delimiter">]</span><span> </span><span>ltI</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈ f ` α"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>2</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(κ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: ν → _›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α ∈ ν›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltI</span><span>
</span><span>        </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>ν</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. κ"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Ord_dests</span><span> </span><span>Aleph_dests</span><span> </span><span>Aleph_intros</span><span> </span><span>Aleph_mem_dests</span><span> </span><span>mono_map_rules</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We end this section by calculating the cofinality of Alephs, for
the zero and limit case. The successor case depends on $\AC$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(ω) = ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_nat</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>InfCard_cf</span><span class="delimiter">]</span><span> </span><span>cf_le_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span class="delimiter">]</span><span>
</span><span>    </span><span>Card_nat</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Card_cardinal_eq</span><span class="delimiter">]</span><span> </span><span>le_anti_sym</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_Aleph_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub>) = ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub>"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_nat</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Aleph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_Aleph_Limit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>) = cf(γ)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈γ. ℵ<span class="hidden">⇘</span><sub>x<span class="hidden">⇙</span></sub>) : γ → ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f : _ → _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_funtype</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Aleph</span><span class="delimiter">]</span><span> </span><span>fun_weaken_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ y ⟹ ℵ<span class="hidden">⇘</span><sub>x<span class="hidden">⇙</span></sub> ∈ ℵ<span class="hidden">⇘</span><sub>y<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ γ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>γ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f ∈ mono_map(γ,Memrel(γ),ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>, Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?f ∈ ⟨γ, Memrel(γ)⟩ ≅ ⟨?f``γ, Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>)⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_map_imp_ord_iso_Memrel</span><span class="delimiter">[</span><span>of</span><span> </span><span>γ</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="var">?f</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>Card_Aleph</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Already an intro rule, but need it explicitly *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(?f) ∈ ⟨?f``γ, Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>)⟩ ≅ ⟨γ, Memrel(γ)⟩"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ord_iso_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ordertype(?f``γ, Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>)) = γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordertype_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>well_ord_Memrel</span><span class="delimiter">]</span><span>
</span><span>    </span><span>ordertype_Memrel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cofinal(?f``γ, ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>, Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cofinal_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub> = (⋃i&lt;γ. ℵ<span class="hidden">⇘</span><sub>i<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a∈ℵ<span class="hidden">⇘</span><sub>i<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>calculation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(i) ∈ γ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(i)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>i<span class="hidden">⇙</span></sub> &lt; ℵ<span class="hidden">⇘</span><sub>succ(i)<span class="hidden">⇙</span></sub>"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨a,ℵ<span class="hidden">⇘</span><sub>i<span class="hidden">⇙</span></sub>⟩ ∈ Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Aleph_increasing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i&lt;γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>i<span class="hidden">⇙</span></sub> ∈ ?f``γ"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span>apply_in_image</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?f : _ → _›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x∈?f `` γ. ⟨a, x⟩ ∈ Memrel(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>) ∨ a = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?f: γ → ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Limit(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(ℵ<span class="hidden">⇘</span><sub>γ<span class="hidden">⇙</span></sub>) =  cf(γ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_ordertype_cofinal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Limit_Aleph</span><span> </span><span>Image_sub_codomain</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>γ</span><span> </span><span class="var">?f</span><span> </span><span>γ</span><span> </span><span>γ</span><span> </span><span class="delimiter">]</span><span> 
</span><span>      </span><span>Limit_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* includes *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Cardinal_Library">
<div class="head"><h1>Theory Cardinal_Library</h1>
<span class="command">theory</span> <span class="name">Cardinal_Library</span><br/>
<span class="keyword">imports</span> <a href="ZF_Library.html"><span class="name">ZF_Library</span></a> <a href="../../ZF/ZF/Cardinal_AC.html"><span class="name">Cardinal_AC</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cardinal Arithmetic under Choice\label{sec:cardinal-lib}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Cardinal_Library</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>ZF_Library</span><span>
</span><span>    </span><span>ZF.Cardinal_AC</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This theory includes results on cardinalities that depend on $\AC$›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Results on cardinal exponentiation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Non trivial instances of cardinal exponentiation require that
     the relevant function spaces are well-ordered, hence this 
     implies a strong use of choice.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cexp_eqpoll_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A ≈ A'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≈ B'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"A<span class="hidden">⇗</span><sup>↑B<span class="hidden">⇖</span></sup> = A'<span class="hidden">⇗</span><sup>↑B'<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll_iff</span><span>
</span><span>    </span><span>function_space_eqpoll_cong</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cexp_cexp_cmult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(κ<span class="hidden">⇗</span><sup>↑ν1<span class="hidden">⇖</span></sup>)<span class="hidden">⇗</span><sup>↑ν2<span class="hidden">⇖</span></sup> = κ<span class="hidden">⇗</span><sup>↑ν2 ⊗ ν1<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(κ<span class="hidden">⇗</span><sup>↑ν1<span class="hidden">⇖</span></sup>)<span class="hidden">⇗</span><sup>↑ν2<span class="hidden">⇖</span></sup> = (ν1 → κ)<span class="hidden">⇗</span><sup>↑ν2<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>cexp_eqpoll_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>cexp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … = κ<span class="hidden">⇗</span><sup>↑ν2 × ν1<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>curry_eqpoll</span><span> </span><span>cardinal_cong</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" … = κ<span class="hidden">⇗</span><sup>↑ν2 ⊗ ν1<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>eqpoll_sym</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cmult_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>cexp_eqpoll_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_Pow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|Pow(X)| = 2<span class="hidden">⇗</span><sup>↑X<span class="hidden">⇖</span></sup>"</span></span></span><span> </span><span class="comment">― ‹Perhaps it's better with |X|›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Pow_eqpoll_function_space</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cantor_cexp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(ν)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν &lt; 2<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>Card_is_Ord</span><span> </span><span>Card_cexp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>not_le_iff_lt</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup> ≤ ν"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|Pow(ν)| ≤ ν"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_Pow</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(ν) ≲ ν"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll_iff</span><span> </span><span>Card_le_imp_lepoll</span><span> </span><span>Card_cardinal_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ inj(Pow(ν), ν)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cantor_inj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cexp_left_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ1 ≤ κ2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ1<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup> ≤ κ2<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ― ‹short, unreadable proof: ›
  unfolding cexp_def
  using subset_imp_lepoll[THEN lepoll_imp_Card_le]
    assms le_subset_iff[THEN iffD1, OF assms]
    Pi_weaken_type[of _ _ "λ_. κ1" "λ_. κ2"] by auto *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ1 ⊆ κ2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_subset_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν → κ1  ⊆ ν → κ2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pi_weaken_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_imp_Card_le</span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cantor_cexp'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(ν)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν &lt; κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cexp_left_mono</span><span> </span><span>assms</span><span> </span><span>cantor_cexp</span><span> </span><span>lt_trans2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>InfCard_cexp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(ν)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cantor_cexp'</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leI</span><span class="delimiter">]</span><span> </span><span>le_trans</span><span> </span><span>Card_cexp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>InfCard_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>InfCard_cexp'</span><span> </span><span class="delimiter">=</span><span> </span><span>InfCard_cexp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nats_le_InfCard</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment">― ‹\&lt;^term&gt;‹InfCard(κ) ⟹ InfCard(ν) ⟹ InfCard(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)››</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Miscellaneous›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_RepFun_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|{f(a) . a∈A}| ≤ |A|"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λx∈A. f(x)) ∈ surj(A, {f(a) . a∈A})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_funtype</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>surj_implies_cardinal_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_imp_le_cardinal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ B ⟹ |A| ≤ |B|"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lepoll_imp_Card_le</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_cardinal_imp_not_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"|A| &lt; |B| ⟹ ¬ B ⊆ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le_cardinal</span><span> </span><span>le_imp_not_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_lt_csucc_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(K) ⟹ |K'| &lt; K<span class="hidden">⇧</span><sup>+</sup> ⟷ |K'| ≤ K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Card_lt_csucc_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_UN_le_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⋀i. i∈ω ⟹ |X(i)| ≤ ω) ⟹ |⋃i∈ω. X(i)| ≤ ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cardinal_UN_le</span><span> </span><span>InfCard_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>InfCard_is_Card</span><span> </span><span>Card_is_Ord</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(K)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"J ≲ K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈J ⟹ |X(i)| ≤ K"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃i∈J. X(i)| ≤ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹J ≲ K›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ inj(J,K)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y(k) ≡ if k∈range(f) then X(converse(f)`k) else 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i∈J ⟹ f`i ∈ K"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ inj(J,K)›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃i∈J. X(i)) ⊆ (⋃i∈K. Y(i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">,</span><span> </span><span>elim</span><span> </span><span>UN_E</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i∈J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈X(i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ inj(J,K)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i∈J ⟹ f`i ∈ K›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Y(f`i)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`i ∈ K"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Y_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ inj(J,K)›</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>right_inverse</span><span> </span><span>apply_rangeI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (⋃i∈K. Y(i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃i∈J. X(i)| ≤ |⋃i∈K. Y(i)|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Y_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le_cardinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀i. i∈J ⟹ f`i ∈ K›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃i∈J. X(i)| ≤ K"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_converse_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∈ inj(J,K)›</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Y_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>cardinal_UN_le</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Ord_0_le</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_lt_csucc_iff'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Ord_dests</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ &lt; |X| ⟷ κ<span class="hidden">⇧</span><sup>+</sup> ≤ |X|"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cardinal_lt_csucc_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>    </span><span>not_le_iff_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"κ<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|X|"</span></span></span><span class="delimiter">]</span><span> </span><span>not_le_iff_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"|X|"</span></span></span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepoll_imp_subset_bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ Y ⟷ (∃Z. Z ⊆ Y ∧ Z ≈ X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ Y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"j ∈ inj(X,Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(j) ⊆ Y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ bij(X,range(j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_bij_range</span><span> </span><span>inj_is_fun</span><span> </span><span>range_fun_subset_codomain</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Z. Z ⊆ Y ∧ Z ≈ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Z. Z ⊆ Y ∧ Z ≈ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Z</span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ bij(Z,X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Z ⊆ Y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(f) ∈ inj(X,Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_is_inj</span><span> </span><span>inj_weaken_type</span><span> </span><span>bij_converse_bij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following result proves to be very useful when combining
     \&lt;^term&gt;‹cardinal› and \&lt;^term&gt;‹eqpoll› in a calculation.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_Card_eqpoll_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(κ) ⟹ |X| = κ ⟷ X ≈ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_cardinal_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>cardinal_eqpoll_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="comment">― ‹Compare @{thm "le_Card_iff"}›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepoll_imp_lepoll_cardinal</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ Y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ |Y|"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cardinal_Card_eqpoll_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y|"</span></span></span><span> </span><span>Y</span><span class="delimiter">]</span><span>
</span><span>    </span><span>lepoll_eq_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y|"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepoll_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≲ κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ≲ κ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ≲ κ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ≲ sum(A,B)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Un_lepoll_sum</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|sum(A,B)| ≤ κ ⊕ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sum_lepoll_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>κ</span><span> </span><span>B</span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>lepoll_imp_Card_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cadd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_cdouble_eq</span><span> </span><span>Card_cardinal_eq</span><span>
</span><span>      </span><span>InfCard_is_Card</span><span> </span><span>Card_le_imp_lepoll</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"sum(A,B)"</span></span></span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>      </span><span>lepoll_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"A∪B"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_Un_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|A| ≤ κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|B| ≤ κ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|A ∪ B| ≤ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lepoll_Un</span><span> </span><span>le_Card_iff</span><span> </span><span>InfCard_is_Card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This is the unconditional version under choice of 
     @{thm Cardinal.Finite_cardinal_iff}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_cardinal_iff'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(|i|) ⟷ Finite(i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll_iff</span><span> </span><span>eqpoll_imp_Finite_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_subset_of_Card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(γ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ⊆ γ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|a| &lt; γ ∨ |a| = γ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|a| &lt; |γ| ∨ |a| = |γ|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le_cardinal</span><span> </span><span>le_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Ord_dests</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(γ) ⟹ |X| &lt; γ ⟷ ¬ |X| ≥ γ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_le_iff_lt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Countable and uncountable sets›</span></span></span><span>
</span><span>
</span><span class="comment">― ‹Kunen's Definition I.10.5›</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>countable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"countable(X) ≡ X ≲ ω"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countableI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ ω ⟹ countable(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>countable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countableD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(X) ⟹ X ≲ ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>countable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countable_iff_cardinal_le_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(X) ⟷ |X| ≤ ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_Card_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>Card_nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>countable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lepoll_countable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≲ Y ⟹ countable(Y) ⟹ countable(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>Y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment">― ‹Next lemma can be proved without using AC›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>surj_countable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(X) ⟹ f ∈ surj(X,Y) ⟹ countable(Y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_implies_cardinal_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>X</span><span> </span><span>Y</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>le_trans</span><span class="delimiter">]</span><span>
</span><span>    </span><span>countable_iff_cardinal_le_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_imp_countable</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(X) ⟹ countable(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>InfCard_nat</span><span> </span><span>nats_le_InfCard</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ω</span><span class="delimiter">,</span><span>
</span><span>        </span><span>THEN</span><span> </span><span>le_imp_lepoll</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>eq_lepoll_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span> </span><span>_</span><span> </span><span>ω</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countable_imp_countable_UN</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(J)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. i∈J ⟹ countable(X(i))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(⋃i∈J. X(i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>J</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>InfCard_nat</span><span>
</span><span>    </span><span>countable_iff_cardinal_le_nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>countable_union_countable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. x ∈ C ⟹ countable(x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(C)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(⋃C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>countable_imp_countable_UN</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. x"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>uncountable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uncountable(X) ≡ ¬ countable(X)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncountable_iff_nat_lt_cardinal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"uncountable(X) ⟷ ω &lt; |X|"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>countable_iff_cardinal_le_nat</span><span> </span><span>not_le_iff_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncountable_not_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(X) ⟹ X ≠ 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncountable_imp_Infinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(X) ⟹ Infinite(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_nat_lt_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>lepoll_nat_imp_Infinite</span><span class="delimiter">[</span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cardinal_le_imp_lepoll</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>X</span><span class="delimiter">]</span><span> </span><span>leI</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncountable_not_subset_countable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(Y)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (Y ⊆ X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lepoll_trans</span><span> </span><span>subset_imp_lepoll</span><span class="delimiter">[</span><span>of</span><span> </span><span>Y</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Results on Alephs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_lt_Aleph1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Aleph_def</span><span> </span><span>lt_csucc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_lt_Aleph1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lt_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ltI</span><span> </span><span>nat_lt_Aleph1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_aleph1_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(k) ⟹ k&lt;ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ k ≤ ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Aleph_def</span><span> </span><span>Card_lt_csucc_iff</span><span> </span><span>Card_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aleph_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>succ(α)<span class="hidden">⇙</span></sub> = ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub><span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Aleph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lesspoll_aleph_plus_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ≺ ℵ<span class="hidden">⇘</span><sub>succ(α)<span class="hidden">⇙</span></sub> ⟷ d ≲ ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lesspoll_csucc</span><span> </span><span>Aleph_succ</span><span> </span><span>Card_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_Aleph</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α) ⟹ |ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>| = ℵ<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment">― ‹Could be proved without using AC›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aleph_lesspoll_increasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Aleph_intros</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a &lt; b ⟹ ℵ<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> ≺ ℵ<span class="hidden">⇘</span><sub>b<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_lt_iff_lesspoll</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>b<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span> </span><span>Card_cardinal_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>b<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>lt_Ord</span><span> </span><span>lt_Ord2</span><span> </span><span>Card_Aleph</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Card_is_Ord</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncountable_iff_subset_eqpoll_Aleph1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Ord_dests</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>Aleph_zero_eq_nat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>Card_nat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>Aleph_succ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(X) ⟷ (∃S. S ⊆ X ∧ S ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ≲ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_nat_lt_cardinal</span><span> </span><span>cardinal_lt_csucc_iff'</span><span>
</span><span>      </span><span>cardinal_le_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ X"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_imp_subset_bij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃S. S ⊆ X ∧ S ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_cong</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span class="delimiter">]</span><span> </span><span>Card_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃S. S ⊆ X ∧ S ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ≲ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>eq_lepoll_trans</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>_</span><span> </span><span>X</span><span class="delimiter">,</span><span>
</span><span>        </span><span>OF</span><span> </span><span>eqpoll_sym</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Aleph_lesspoll_increasing</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>lesspoll_trans1</span><span class="delimiter">,</span><span>
</span><span>        </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span> </span><span>lepoll_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>X</span><span> </span><span>ω</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_Aleph_imp_cardinal_UN_le_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"function(G) ⟹ domain(G) ≲ ω ⟹
   ∀n∈domain(G). |G`n|&lt;ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ |⋃n∈domain(G). G`n|≤ω"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(G)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"domain(G)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"⋃n∈domain(G). G`n"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?N ≲ ω"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n∈?N. |G`n|&lt;ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈?N"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Eq1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|G`n| ≤ ω"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_aleph1_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈?N ⟹ |G`n| ≤ ω"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹?N ≲ ω›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_nat</span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Aleph1_eq_cardinal_vimage</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→ω ⟹ ∃n∈ω. |f-``{n}| = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→ω"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(f)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(f) = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f)⊆ω"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>domain_of_fun</span><span> </span><span>fun_is_function</span><span> </span><span>range_fun_subset_codomain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?G</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λn∈range(f). f-``{n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(f) ⊆ ω"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>range_fun_subset_codomain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(?G) ≲ ω"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"function(?G)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>function_lam</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈ω ⟹ f-``{n} ⊆ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pi_vimage_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹range(f) ⊆ ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> = (⋃n∈range(f). f-``{n})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→ω›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹function(f)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(f) = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ f-``{f`x}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`x ∈ range(f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>function_apply_Pair</span><span> </span><span>vimage_iff</span><span> </span><span>apply_rangeI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ (⋃n∈range(f). f-``{n})"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n∈range(f). |f-``{n}| &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n∈domain(?G). |?G`n| &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zero_lt_Aleph1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹function(?G)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹domain(?G) ≲ ω›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃n∈domain(?G). ?G`n|≤ω"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_Aleph_imp_cardinal_UN_le_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃n∈range(f). f-``{n}|≤ω"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> = _›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>| ≤ ω"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ≤ ω"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_Aleph</span><span> </span><span>Card_cardinal_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_lt_Aleph1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span>lt_trans2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹range(f)⊆ω›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(|f -`` {n}| &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ≤ |f-``{n}|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_lt_iff_le</span><span> </span><span>Card_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈ω ⟹ f-``{n} ⊆ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le_cardinal</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>le_anti_sym</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>Card_Aleph</span><span> </span><span>Card_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">― ‹There is some asymmetry between assumptions and conclusion
    (\&lt;^term&gt;‹(≈)› versus \&lt;^term&gt;‹cardinal›)›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eqpoll_Aleph1_cardinal_vimage</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f : X → ω"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃n∈ω. |f-``{n}| = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g∈bij(ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>,X)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f : X → ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f O g : ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> → ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(g) ∈ bij(X, ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_is_fun</span><span> </span><span>comp_fun</span><span> </span><span>bij_converse_bij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|(f O g)-``{n}| = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Aleph1_eq_cardinal_vimage</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> = |converse(g) `` (f -``{n})|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>image_comp</span><span> </span><span>converse_comp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vimage_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹converse(g) ∈ bij(X, ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: X→ ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = |f -``{n}|"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>range_of_subset_eqpoll</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"converse(g)"</span></span></span><span> </span><span>X</span><span>  </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"f -``{n}"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>bij_is_inj</span><span> </span><span>cardinal_cong</span><span> </span><span>bij_is_fun</span><span> </span><span>eqpoll_sym</span><span> </span><span>Pi_vimage_subset</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈ω›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Applications of transfinite recursive constructions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>rec_constr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rec_constr(f,α) ≡ transrec(α,λa g. f`(g``a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The function \&lt;^term&gt;‹rec_constr› allows to perform ∗‹recursive
     constructions›: given a choice function on the powerset of some
     set, a transfinite sequence is created by successively choosing
     some new element.

     The next result explains its use.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rec_constr_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rec_constr(f,α) = f`({rec_constr(f,β). β∈α})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>def_transrec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rec_constr_def</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>α</span><span class="delimiter">]</span><span> </span><span>image_lam</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rec_constr_type</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:Pow(G)→ G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(α)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rec_constr(f,α) ∈ G"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>trans_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rec_constr_unfold</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(G)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. G"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next lemma is an application of recursive constructions.
     It works under the assumption that whenever the already constructed
     subsequence is small enough, another element can be added.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_cardinal_selection</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>Ord_dests</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀X. |X| &lt; γ ⟹ X ⊆ G ⟹ ∃a∈G. ∀s∈X. Q(s,a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(γ)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∃S. S : γ → G ∧ (∀α ∈ γ. ∀β ∈ γ.  α&lt;β ⟶ Q(S`α,S`β))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?cdltγ</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{X∈Pow(G) . |X|&lt;γ}"</span></span></span><span> </span><span class="comment">― ‹“cardinal less than \&lt;^term&gt;‹γ›”›</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?inQ</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λY.{a∈G. ∀s∈Y. Q(s,a)}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀Y ∈ ?cdltγ. ∃a. a ∈ ?inQ(Y)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃f. f ∈ Pi(?cdltγ,?inQ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AC_ball_Pi</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?cdltγ</span><span> </span><span class="var">?inQ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f_type</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f ∈ Pi(?cdltγ,?inQ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Cb</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cb ≡ λ_∈Pow(G)-?cdltγ. b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈G›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cb ∈ Pow(G)-?cdltγ → G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Cb_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ Cb : (∏x∈Pow(G). ?inQ(x) ∪ G)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>fun_Pi_disjoint_Un</span><span class="delimiter">[</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span class="var">?cdltγ</span><span>  </span><span class="var">?inQ</span><span> </span><span>Cb</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(G)-?cdltγ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_.G"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>Diff_partition</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{X∈Pow(G). |X|&lt;γ}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(G)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Collect_subset</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?inQ(x) ∪ G = G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ Cb : Pow(G) → G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S≡λα∈γ. rec_constr(f ∪ Cb, α)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f ∪ Cb: Pow(G) → G›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(γ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S : γ → G"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_in_Ord</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>lam_type</span><span> </span><span>rec_constr_type</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀α∈γ. ∀β∈γ. α &lt; β ⟶ Q(S ` α, S ` β)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"β∈γ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{rec_constr(f ∪ Cb, x) . x∈β} = {S`x . x ∈ β}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>Card_is_Ord</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>β</span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S : γ → G›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(γ)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{S`x . x ∈ β} ⊆ G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>Card_is_Ord</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>β</span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>        </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>γ</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. G"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(γ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈γ›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|{S`x . x ∈ β}| &lt; γ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_RepFun_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>β</span><span class="delimiter">]</span><span>  </span><span>Ord_in_Ord</span><span>
</span><span>        </span><span>lt_trans1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"|{S`x . x ∈ β}|"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|β|"</span></span></span><span> </span><span>γ</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Card_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>β</span><span> </span><span>γ</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ltI</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x∈β. Q(S`x, f ` {S`x . x ∈ β})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` {S`x . x ∈ β} ∈ {a∈G. ∀x∈β. Q(S`x,a)}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span class="var">?cdltγ</span><span> </span><span class="var">?inQ</span><span> </span><span class="string"><span class="delete"><span class="delete">"{S`x . x ∈ β}"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈γ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α &lt; β"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹β∈γ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cb ∈ Pow(G)-?cdltγ → G›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q(S ` α, S ` β)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_disjoint_apply1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{S`x . x ∈ β}"</span></span></span><span> </span><span>Cb</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>        </span><span>domain_of_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>Cb</span><span class="delimiter">]</span><span> </span><span>ltD</span><span class="delimiter">[</span><span>of</span><span> </span><span>α</span><span> </span><span>β</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>S_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>rec_constr_unfold</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following basic result can, in turn, be proved by a
     bounded-cardinal selection.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Infinite_iff_lepoll_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X) ⟷ ω ≲ X"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Infinite_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y| &lt; ω"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(Y)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_cardinal_iff'</span><span> </span><span>ltD</span><span> </span><span>nat_into_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinite(X)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ≠ Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹b∈X›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S : ω → X"</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀α∈ω. ∀β∈ω. α &lt; β ⟶ S`α ≠ S`β"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_cardinal_selection</span><span class="delimiter">[</span><span>of</span><span> </span><span>ω</span><span> </span><span>X</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. x≠y"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>Card_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈ ω ⟹ β ∈ ω ⟹ α≠β ⟹ S`α ≠ S`β"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>lt_neq_symmetry</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λα β. S`α ≠ S`β"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ω ≲ X"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lepoll_def</span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>lepoll_nat_imp_Infinite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Infinite_InfCard_cardinal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X) ⟹ InfCard(|X|)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lepoll_eq_trans</span><span> </span><span>eqpoll_sym</span><span> </span><span>lepoll_nat_imp_Infinite</span><span>
</span><span>    </span><span>Infinite_iff_lepoll_nat</span><span> </span><span>Inf_Card_is_InfCard</span><span> </span><span>cardinal_eqpoll</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Finite_to_one_surj_imp_cardinal_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ∈ Finite_to_one(X,Y) ∩ surj(X,Y)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y| = |X|"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ∈ Finite_to_one(X,Y) ∩ surj(X,Y)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X = (⋃y∈Y. {x∈X . F`x = y})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(Y)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X = (⋃y∈Y. {x∈X . F`x = y})›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_RepFun</span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>Finite_Union</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Y</span><span> </span><span class="string"><span class="delete"><span class="delete">"λy. {x∈X . F`x = y}"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ≲ |Y|"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll</span><span> </span><span>eqpoll_sym</span><span> </span><span>eqpoll_imp_lepoll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ Y ⟹ |{x∈X . F`x = y}| ≤ |Y|"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Infinite_imp_nats_lepoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lepoll_imp_Card_le</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>Y</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"|{x∈X . F`x = y}|"</span></span></span><span class="delimiter">]</span><span> </span><span>cardinal_idem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃y∈Y. {x∈X . F`x = y}| ≤ |Y|"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y|"</span></span></span><span> </span><span>Y</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Infinite_InfCard_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span>Y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ∈ Finite_to_one(X,Y) ∩ surj(X,Y)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|Y| ≤ |X|"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_implies_cardinal_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X = (⋃y∈Y. {x∈X . F`x = y})›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_anti_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cardinal_map_Un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(X)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|{a ∪ b . a ∈ X}| = |X|"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λa∈X. a ∪ b) ∈ Finite_to_one(X,{a ∪ b . a ∈ X})"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(λa∈X. a ∪ b) ∈  surj(X,{a ∪ b . a ∈ X})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>d</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite({a ∈ X . a ∪ b = d})"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(?Y(b,d))"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite(b)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>d</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{a ∈ X . a ∪ 0 = d} = (if d∈X then {d} else 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>cons</span><span> </span><span>c</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹c ∉ b›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Y(cons(c,b),d) ⊆ (if c∈d then ?Y(b,d) ∪ ?Y(b,d-{c}) else 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cons</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ∈ {x ∪ b . x ∈ X}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite({a ∈ X . (λx∈X. x ∪ b) ` a = d})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lam_funtype</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_to_one_surj_imp_cardinal_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Konig">
<div class="head"><h1>Theory Konig</h1>
<span class="command">theory</span> <span class="name">Konig</span><br/>
<span class="keyword">imports</span> <a href="Cofinality.html"><span class="name">Cofinality</span></a> <a href="Cardinal_Library.html"><span class="name">Cardinal_Library</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Konig</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Cofinality</span><span>
</span><span>    </span><span>Cardinal_Library</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now, using the Axiom of choice, we can show that all successor
cardinals are regular.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_csucc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>) = z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>) ≠ z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(z)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(z)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(z)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Limit(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Card(z)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_csucc</span><span> </span><span>Card_is_Ord</span><span> </span><span>InfCard_is_Card</span><span> </span><span>InfCard_is_Limit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>) &lt; z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_le_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>le_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Card_cardinal_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G:cf(z<span class="hidden">⇧</span><sup>+</sup>)→ z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀β∈z<span class="hidden">⇧</span><sup>+</sup>. ∃y∈cf(z<span class="hidden">⇧</span><sup>+</sup>). β &lt; G`y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_cofinal_fun_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span class="delimiter">]</span><span> </span><span>Ord_cf</span><span>
</span><span>      </span><span>cf_le_cf_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span class="delimiter">]</span><span> </span><span>le_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(z)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Card(z<span class="hidden">⇧</span><sup>+</sup>)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(z<span class="hidden">⇧</span><sup>+</sup>)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). |G`β| ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>G</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ltI</span><span class="delimiter">]</span><span> </span><span>Card_lt_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Ord_in_Ord</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Card_is_Ord</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">]</span><span> </span><span>cardinal_lt_csucc_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf(z<span class="hidden">⇧</span><sup>+</sup>) &lt; z<span class="hidden">⇧</span><sup>+</sup>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(z)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(z)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>) ≲ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_lt_csucc_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span class="delimiter">]</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>le_Card_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span class="delimiter">]</span><span> </span><span>InfCard_is_Card</span><span>
</span><span>      </span><span>Card_lt_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">]</span><span> </span><span>lt_Ord</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(z<span class="hidden">⇧</span><sup>+</sup>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf(z<span class="hidden">⇧</span><sup>+</sup>) &lt; z<span class="hidden">⇧</span><sup>+</sup>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). |G`β| ≤ _›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(z)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|⋃β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). G`β| ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span class="delimiter">]</span><span>
</span><span>      </span><span>subset_imp_lepoll</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>lepoll_imp_Card_le</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). G`β"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(z)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀β∈z<span class="hidden">⇧</span><sup>+</sup>. ∃y∈cf(z<span class="hidden">⇧</span><sup>+</sup>). β &lt; G`y›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup> ⊆ (⋃β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). G`β)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span>ltD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup> ≤ z"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_imp_le_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃β∈cf(z<span class="hidden">⇧</span><sup>+</sup>). G`β"</span></span></span><span class="delimiter">]</span><span> </span><span>le_trans</span><span>
</span><span>      </span><span>InfCard_is_Card</span><span> </span><span>Card_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>Card_cardinal_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Ord(z)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_csucc</span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>not_lt_iff_le</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>z</span><span> </span><span class="string"><span class="delete"><span class="delete">"z<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>Card_csucc</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Card_is_Ord</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹And this finishes the calculation of cofinality of Alephs.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_Aleph_succ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ord(z) ⟹ cf(ℵ<span class="hidden">⇘</span><sub>succ(z)<span class="hidden">⇙</span></sub>) = ℵ<span class="hidden">⇘</span><sub>succ(z)<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Aleph_succ</span><span> </span><span>cf_csucc</span><span> </span><span>InfCard_Aleph</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹König's Theorem\label{sec:konig}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We end this section by proving König's Theorem on the cofinality
of cardinal exponentiation. This is a strengthening of Cantor's theorem
and it is essentially the only basic way to prove strict cardinal
inequalities.

It is proved rather straightforwardly with the tools already developed.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>konigs_theorem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>InfCard_is_Card</span><span> </span><span>Card_is_Ord</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>lt_trans1</span><span> </span><span>lt_trans2</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(ν)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(κ) ≤ ν"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"κ &lt; κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>Card_cexp</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>not_le_iff_lt</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup> ≤ κ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(κ)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ν → κ ≲ κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_cardinal_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_is_Card</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Card_le_imp_lepoll</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cexp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ∈ surj(κ, ν → κ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_imp_surj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>function_space_nonempty</span><span class="delimiter">,</span><span>
</span><span>        </span><span>OF</span><span> </span><span>_</span><span> </span><span>nat_into_InfCard</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f:ν → κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf_fun(f,κ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_le_cf_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>InfCard_is_Limit</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H(α) ≡ μ x. x∈κ ∧ (∀m&lt;f`α. G`m`α ≠ x)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ≡ μ x. ?P(α,x)"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H_satisfies</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(α,H(α))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈ ν"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(α,h)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹α∈ν›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f:ν → κ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(κ)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f`α &lt; κ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>apply_type</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_ . κ"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ltI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|{G`m`α . m ∈ {x∈κ . x &lt; f`α}}| ≤ |{x∈κ . x &lt; f`α}|"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_RepFun_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f`α &lt; κ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(κ)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|{x∈κ . x &lt; f`α}| &lt; |κ|"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_lt_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lt_Ord</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f`α"</span></span></span><span> </span><span>κ</span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>          </span><span>Ord_eq_Collect_lt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f`α"</span></span></span><span> </span><span>κ</span><span class="delimiter">]</span><span> </span><span>Card_cardinal_eq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|{G`m`α . m ∈ {x∈κ . x &lt; f`α}}| &lt; |κ|"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f`α &lt; κ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(κ)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m&lt;f`α ⟹ m∈κ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ord_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"f`α"</span></span></span><span> </span><span>κ</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>ltD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃h. ?P(α,h)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_cardinal_imp_not_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(α,H(α))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LeastI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"?P(α)"</span></span></span><span> </span><span>h</span><span class="delimiter">]</span><span> </span><span>lt_Ord</span><span> </span><span>Ord_in_Ord</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λα∈ν. H(α)): ν → κ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ∈ surj(κ, ν → κ)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈κ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G`n = (λα∈ν. H(α))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(κ)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹f: ν → κ›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cf_fun(f,_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>α</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; f`α"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈ν"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Limit_cofinal_fun_lt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>InfCard_is_Limit</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G`n = (λα∈ν. H(α))›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G`n`α = H(α)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ltD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H_satisfies</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀m&lt;f`α. G`m`α ≠ H(α)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cf_cexp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Card(κ)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(ν)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2 ≤ κ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ν &lt; cf(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ν &lt; cf(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹InfCard(ν)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cf(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>) ≤ ν"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_lt_iff_le</span><span> </span><span>Ord_cf</span><span> </span><span>InfCard_is_Card</span><span> </span><span>Card_is_Ord</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"InfCard(κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_cexp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup> &lt; (κ<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>)<span class="hidden">⇗</span><sup>↑ν<span class="hidden">⇖</span></sup>"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>konigs_theorem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cexp_cexp_cmult</span><span> </span><span>InfCard_csquare_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, the next two corollaries illustrate the only possible
exceptions to the value of the cardinality of the continuum: The limit
cardinals of countable cofinality. That these are the only exceptions
is a consequence of Easton's Theorem~\cite[Thm 15.18]{Jech_Millennium}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>cf_continuum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub> &lt; cf(2<span class="hidden">⇗</span><sup>↑ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub><span class="hidden">⇖</span></sup>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_cexp</span><span> </span><span>InfCard_Aleph</span><span> </span><span>nat_into_Card</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>continuum_not_eq_Aleph_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"2<span class="hidden">⇗</span><sup>↑ℵ<span class="hidden">⇘</span><sub>0<span class="hidden">⇙</span></sub><span class="hidden">⇖</span></sup> ≠ ℵ<span class="hidden">⇘</span><sub>ω<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cf_continuum</span><span> </span><span>cf_Aleph_Limit</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Limit_nat</span><span class="delimiter">]</span><span> </span><span>cf_nat</span><span>
</span><span>    </span><span>Aleph_zero_eq_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Delta_System">
<div class="head"><h1>Theory Delta_System</h1>
<span class="command">theory</span> <span class="name">Delta_System</span><br/>
<span class="keyword">imports</span> <a href="Cardinal_Library.html"><span class="name">Cardinal_Library</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Delta System Lemma\label{sec:dsl}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Delta_System</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span>Cardinal_Library</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A ∗‹delta system› is family of sets with a common pairwise
intersection.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>delta_system</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ⇒ o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delta_system(D) ≡ ∃r. ∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = r"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_systemI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system(D)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>delta_system_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_systemD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"delta_system(D) ⟹ ∃r. ∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>delta_system_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Hence, pairwise intersections equal the intersection of the whole
family.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_system_root_eq_Inter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system(D)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = ⋂D"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>equalityI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A'</span><span> </span><span>B'</span><span> </span><span>x</span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"A'∈D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B'∈ D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A'≠B'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈A'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈B'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C∈D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>delta</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"C=A'"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>hyp</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>hyp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>delta</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = C ∩ A'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A' ∩ B' = r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x∈r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The ∗‹Delta System Lemma› (DSL) states that any uncountable family of
finite sets includes an uncountable delta system. This is the simplest
non trivial version; others, for cardinals greater than \&lt;^term&gt;‹ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›  assume
some weak versions of the generalized continuum hypothesis for the
cardinals involved.

The proof is essentially the one in \cite[III.2.6]{kunen2011set} for the
case  \&lt;^term&gt;‹ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›; another similar presentation can be found in
\cite[Chap.~16]{JW}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_system_Aleph1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈F. Finite(A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ F ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Since all members are finite,›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀A∈F. Finite(A)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λA∈F. |A|) : F → ω"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?cards : _"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>lam_type</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"?cards -`` {n} = { A∈F . |A| = n }"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vimage_lam</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹F ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹there are uncountably many have the same cardinal:›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n∈ω"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|?cards -`` {n}| = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqpoll_Aleph1_cardinal_vimage</span><span class="delimiter">[</span><span>of</span><span> </span><span>F</span><span> </span><span class="var">?cards</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>G</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ≡ ?cards -`` {n}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ F"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Therefore, without loss of generality, we can assume that all
  elements of the family have cardinality \&lt;^term&gt;‹n∈ω›.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A∈G ⟹ |A| = n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_Card_eqpoll_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈ω›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹So we prove the result by induction on this \&lt;^term&gt;‹n› and
  generalizing \&lt;^term&gt;‹G›, since the argument requires changing the
  family in order to apply the inductive hypothesis.›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ G ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>G</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="comment">― ‹This case is impossible›</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ {0}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_0_iff_0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_lt_Aleph1</span><span> </span><span>subset_imp_le_cardinal</span><span class="delimiter">[</span><span>of</span><span> </span><span>G</span><span> </span><span class="string"><span class="delete"><span class="delete">"{0}"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>lt_trans2</span><span> </span><span>cardinal_Card_eqpoll_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>succ</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈G. Finite(a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_cardinal_iff'</span><span> </span><span>nat_into_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"succ(n)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ G ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. {A∈G . p ∈ A} ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="comment">― ‹the positive case, uncountably many sets with a
                    common element›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{A∈G . p ∈ A} ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{A-{p} . A∈{X∈G. p∈X}} ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F ≈ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Diff_bij</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{A∈G . p ∈ A}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{p}"</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>comp_bij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_converse_bij</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now using the hypothesis of the successor case,›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀A. A∈G ⟹ |A|=succ(n)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀a∈G. Finite(a)›</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p∈A ⟹ A∈G ⟹ |A - {p}| = n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_imp_succ_cardinal_Diff</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈ω›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈?F. Finite(a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_cardinal_iff'</span><span> </span><span>nat_into_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹we may apply the inductive hypothesis to the new family \&lt;^term&gt;‹?F›:›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(⋀A. A ∈ ?F ⟹ |A| = n) ⟹ ?F ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹
             ∃D. D ⊆ ?F ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D⊆{A-{p} . A∈{X∈G. p∈X}}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system(D)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈D. ∀B∈D. A ≠ B ⟶ A ∩ B = r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈D.∀B∈D. A∪{p} ≠ B∪{p}⟶(A ∪ {p}) ∩ (B ∪ {p}) = r∪{p}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system({B ∪ {p} . B∈D})"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system(?D)"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|D| = ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Infinite(D)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_eqpoll_iff</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>uncountable_iff_subset_eqpoll_Aleph1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span>
</span><span>            </span><span>uncountable_imp_Infinite</span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_map_Un</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span class="string"><span class="delete"><span class="delete">"{p}"</span></span></span><span class="delimiter">]</span><span> </span><span>naturals_lt_nat</span><span>
</span><span>          </span><span>cardinal_eqpoll_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ⊆ {A-{p} . A∈{X∈G. p∈X}}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?D ⊆ G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A∈G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p∈A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = A - {p} ∪ {p}"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A -{p} ∪ {p} ∈ G"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ⊆ {A-{p} . A∈{X∈G. p∈X}}›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ G ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬ (∃p. {A ∈ G . p ∈ A} ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>)›</span></span></span><span> </span><span class="comment">― ‹the other case›</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{A ∈ G . p ∈ A} ≲ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G(p) ≲ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lepoll_eq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subset_imp_lepoll</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G(p) ≺ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lesspoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* may omit the previous step if unfolding here: *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?G(p) ≲ ω"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_aleph_plus_one</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>Aleph_zero_eq_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{A ∈ G . S ∩ A ≠ 0} = (⋃p∈S. ?G(p))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(S) ⟹ countable({A ∈ G . S ∩ A ≠ 0})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>InfCard_nat</span><span> </span><span>Card_nat</span><span>
</span><span>         </span><span>le_Card_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span> </span><span>leqpoll_imp_cardinal_UN_le</span><span class="delimiter">,</span><span>
</span><span>           </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>le_Card_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>ω</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>countable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For every countable subfamily of \&lt;^term&gt;‹G› there is another some
      element disjoint from all of them:›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A∈G. ∀S∈X. S ∩ A = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"|X| &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ⊆ G"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n∈ω›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀A. A∈G ⟹ |A| = succ(n)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A∈G ⟹ Finite(A)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_Card_eqpoll_iff</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Finite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹X⊆G›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A∈X ⟹ countable(A)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_imp_countable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹|X| &lt; ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(⋃X)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_nat</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>cardinal_lt_csucc_iff</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>X</span><span class="delimiter">]</span><span>
</span><span>            </span><span>countable_union_countable</span><span> </span><span>countable_iff_cardinal_le_nat</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Aleph_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹countable(_) ⟹ countable({A ∈ G . _  ∩ A ≠ 0})›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable({A ∈ G . (⋃X) ∩ A ≠ 0})"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B∈G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∉ {A ∈ G . (⋃X) ∩ A ≠ 0}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_lt_Aleph1</span><span> </span><span>cardinal_Card_eqpoll_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>            </span><span>uncountable_not_subset_countable</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{A ∈ G . (⋃X) ∩ A ≠ 0}"</span></span></span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>            </span><span>uncountable_iff_nat_lt_cardinal</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A∈G. ∀S∈X. S ∩ A = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b∈G"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_subset_eqpoll_Aleph1</span><span>
</span><span>          </span><span>uncountable_not_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Hence, the hypotheses to perform a bounded-cardinal selection
      are satisfied,›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S:ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>→G"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α∈ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ β∈ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ α&lt;β ⟹ S`α ∩ S`β = 0"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_cardinal_selection</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>G</span><span> </span><span class="string"><span class="delete"><span class="delete">"λs a. s ∩ a = 0"</span></span></span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"α ∈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ β ∈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> ⟹ α≠β ⟹ S`α ∩ S`β = 0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>α</span><span> </span><span>β</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lt_neq_symmetry</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λα β. S`α ∩ S`β = 0"</span></span></span><span class="delimiter">]</span><span> </span><span>Card_is_Ord</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹and a symmetry argument shows that obtained \&lt;^term&gt;‹S› is
      an injective  \&lt;^term&gt;‹ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›-sequence of disjoint elements of \&lt;^term&gt;‹G›.›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀A. A∈G ⟹ |A| = succ(n)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹S : ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub> → G›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ inj(ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>, G)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cardinal_succ_not_0</span><span> </span><span>Int_eq_zero_imp_not_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. S`x"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(S) ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_bij_range</span><span> </span><span>eqpoll_sym</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eqpoll_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range(S) ⊆ G"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span> </span><span>range_fun_subset_codomain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ G ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span> </span><span>range_eq_image</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>          </span><span>image_function</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fun_is_function</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>inj_is_fun</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>          </span><span>domain_of_fun</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inj_is_fun</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span>G</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"S``ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This finishes the successor case and hence the proof.›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹G ⊆ F›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_system_uncountable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈F. Finite(A)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(F)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D. D ⊆ F ∧ delta_system(D) ∧ D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆ F"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_subset_eqpoll_Aleph1</span><span class="delimiter">[</span><span>of</span><span> </span><span>F</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀A∈F. Finite(A)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A∈S. Finite(A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>delta_system_Aleph1</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Cohen_Posets">
<div class="head"><h1>Theory Cohen_Posets</h1>
<span class="command">theory</span> <span class="name">Cohen_Posets</span><br/>
<span class="keyword">imports</span> <a href="Delta_System.html"><span class="name">Delta_System</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Application to Cohen posets\label{sec:cohen}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Cohen_Posets</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>    </span><span>Delta_System</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We end this session by applying DSL to the combinatorics of
finite function posets. We first define some basic concepts; we take
a different approach from \cite{2020arXiv200109715G}, in that the
order relation is presented as a predicate (of type @{typ ‹[i,i] ⇒ o›}). 

Two elements of a poset are ∗‹compatible› if they have a common lower
bound.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compat_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,[i,i]⇒o,i,i]⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"compat_in(A,r,p,q) ≡ ∃d∈A . r(d,p) ∧ r(d,q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹An ∗‹antichain› is a subset of pairwise incompatible members.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,[i,i]⇒o,i]⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"antichain(P,leq,A) ≡ A⊆P ∧ (∀p∈A. ∀q∈A.
                p≠q ⟶ ¬compat_in(P,leq,p,q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A poset has the  ∗‹countable chain condition› (ccc) if all of its
antichains are countable.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>ccc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,[i,i]⇒o]⇒o"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ccc(P,leq) ≡ ∀A. antichain(P,leq,A) ⟶ countable(A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Finally, the ∗‹Cohen poset› is the set of finite partial functions
between two sets with the order of reverse inclusion.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>Fn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[i,i] ⇒ i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Fn(I,J) ≡ ⋃{(d→J) . d ∈ {x ∈ Pow(I).  Finite(x)}}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Supset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ⇒ i ⇒ o"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⊇›</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f ⊇ g ≡ g ⊆ f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FnI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p : d → J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d ⊆ I"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(d)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ Fn(I,J)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FnD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ Fn(I,J)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃d. p : d → J ∧ d ⊆ I ∧ Finite(d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fn_is_function</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ Fn(I,J) ⟹ function(p)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Fn_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_is_function</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>restrict_eq_imp_compat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Fn(I, J)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g ∈ Fn(I, J)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"restrict(f, domain(f) ∩ domain(g)) = restrict(g, domain(f) ∩ domain(g))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∪ g ∈ Fn(I, J)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>d1</span><span> </span><span>d2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f : d1 → J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d1 ∈ Pow(I)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(d1)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"g : d2 → J"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d2 ∈ Pow(I)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(d2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span>
</span><span>      </span><span>restrict_eq_imp_Un_into_Pi</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>d1</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. J"</span></span></span><span> </span><span>g</span><span> </span><span>d2</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. J"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We finally arrive to our application of DSL.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ccc_Fn_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ccc(Fn(I,2), (⊇))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ countable(A)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ Fn(I, 2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable({p∈A. domain(p) = d})"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(d) ∧ d ⊆ I"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{p ∈ A . domain(p) = d} ⊆ d → 2"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(d → 2)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Pi</span><span> </span><span>lesspoll_nat_is_Finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"d→2"</span></span></span><span> </span><span class="delimiter">]</span><span> </span><span>Finite_imp_countable</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{p ∈ A . domain(p) = d} = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>domain_of_fun</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_lepollI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable({domain(p) . p ∈ A})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A = (⋃d∈{domain(p) . p ∈ A}. {p∈A. domain(p) = d})"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable({domain(p) . p ∈ A})"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀d. countable({p∈A. domain(p) = d})›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹¬countable(A)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>countable_imp_countable_UN</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{domain(p). p∈A}"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"λd. {p ∈ A. domain(p) = d }"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ A ⟹ Finite(domain(p))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lesspoll_nat_is_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p)"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>domain_of_fun</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"delta_system(D)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ⊆ {domain(p) . p ∈ A}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>delta_system_uncountable</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{domain(p) . p ∈ A}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>delta</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀d1∈D. ∀d2∈D. d1 ≠ d2 ⟶ d1 ∩ d2 = ⋂D"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>delta_system_root_eq_Inter</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ≈ ℵ<span class="hidden">⇘</span><sub>1<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(D)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_subset_eqpoll_Aleph1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ⊆ {domain(p) . p ∈ A}›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p1 ∈ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p1) ∈ D"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_not_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹p1 ∈ A ⟹ Finite(domain(p1))›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(domain(p1))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_domain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≡ ⋂D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite(r)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subset_Finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p1)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable({restrict(p,r) . p∈A})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∈ Fn(I, 2) ⟹ restrict(f,r) ∈ Pow(r × 2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restrict_subset_Sigma</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>FnD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Pi_def</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{restrict(f,r) . f ∈ A } ⊆ Pow(r × 2)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite(r)›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Sigma</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Finite_Pow</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Finite_imp_countable</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>subset_Finite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable({p∈A. domain(p) ∈ D})"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(?X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ⊆ {domain(p) . p ∈ A}›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(λp∈?X. domain(p)) ∈ surj(?X, D)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lam_type</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>surj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(?X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹uncountable(D)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>surj_countable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D = (⋃f∈Pow(r×2) . {domain(p) . p∈{ x∈A. restrict(x,r) = f ∧ domain(x) ∈ D}})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ D"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D ⊆ _›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p) = z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p : z → 2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>domain_of_fun</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>FnD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"restrict(p,r) ⊆ r × 2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>function_restrictI</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>r</span><span class="delimiter">]</span><span> </span><span>fun_is_function</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>z</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>restrict_subset_Sigma</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>z</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. 2"</span></span></span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>Pi_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p∈A.  restrict(p,r) ∈ Pow(r×2) ∧ domain(p) = z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable({domain(p) . p∈{x∈A. restrict(x,r) = f ∧ domain(x) ∈ D}})"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"uncountable(?Y(f))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finite(r)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(Pow(r×2))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Finite_Sigma</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>Finite_Pow</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>Finite_imp_countable</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"countable(?Y(f))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹D = (⋃f∈Pow(r×2) .?Y(f))›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹uncountable(D)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>countable_imp_countable_UN</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pow(r×2)"</span></span></span><span> </span><span class="var">?Y</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j ∈ inj(nat, ?Y(f))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uncountable_iff_nat_lt_cardinal</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>leI</span><span class="delimiter">,</span><span>
</span><span>          </span><span>THEN</span><span> </span><span>cardinal_le_imp_lepoll</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>lepollD</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`0 ≠ j`1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`0 ∈ ?Y(f)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j`1 ∈ ?Y(f)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inj_is_fun</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>apply_type</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>j</span><span> </span><span>nat</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Y(f)"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inj_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p) ≠ domain(q)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∈ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q ∈ A"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"domain(p) ∈ D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(q) ∈ D"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"restrict(p,r) = restrict(q,r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>delta</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"domain(p) ∩ domain(q) = r"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A ⊆ Fn(I, 2)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>calculation</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∪ q ∈ Fn(I, 2)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>restrict_eq_imp_compat</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p∈A. ∃q∈A. p ≠ q ∧ compat_in(Fn(I, 2), (⊇), p, q)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compat_in_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ccc_def</span><span> </span><span>antichain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The fact that a poset $P$ has the ccc has useful consequences for the
theory of forcing, since it implies that cardinals from the original
model are exactly the cardinals in any generic extension by $P$
\cite[Chap.~IV]{kunen2011set}.›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>